From 66c651656f78d1c7308657717fed69faf7b08d9f Mon Sep 17 00:00:00 2001
From: CrazyCat <crazycat69@narod.ru>
Date: Sat, 16 Aug 2014 00:49:56 +0300
Subject: [PATCH] commit 86bbc04678145ab895f6129adbd119acd9590bf5

    Refrence RTL2832U driver.

diff --git a/drivers/media/usb/Kconfig b/drivers/media/usb/Kconfig
index 39d824e2..a6e2b3b3 100644
--- a/drivers/media/usb/Kconfig
+++ b/drivers/media/usb/Kconfig
@@ -45,6 +45,7 @@ source "drivers/media/usb/ttusb-budget/Kconfig"
 source "drivers/media/usb/ttusb-dec/Kconfig"
 source "drivers/media/usb/siano/Kconfig"
 source "drivers/media/usb/b2c2/Kconfig"
+source "drivers/media/usb/rtl2832u/Kconfig"
 endif
 
 if (MEDIA_CAMERA_SUPPORT || MEDIA_ANALOG_TV_SUPPORT || MEDIA_DIGITAL_TV_SUPPORT)
diff --git a/drivers/media/usb/Makefile b/drivers/media/usb/Makefile
index 7ac4b143..183f9035 100644
--- a/drivers/media/usb/Makefile
+++ b/drivers/media/usb/Makefile
@@ -4,7 +4,7 @@
 
 # DVB USB-only drivers
 obj-y += ttusb-dec/ ttusb-budget/ dvb-usb/ dvb-usb-v2/ siano/ b2c2/
-obj-y += zr364xx/ stkwebcam/ s2255/
+obj-y += zr364xx/ stkwebcam/ s2255/ rtl2832u/
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 obj-$(CONFIG_USB_GSPCA)         += gspca/
diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
index fd1312d0..8c0a0f77 100644
--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
@@ -1445,6 +1445,8 @@ static const struct usb_device_id rtl28xxu_id_table[] = {
 	/* RTL2832P devices: */
 	{ DVB_USB_DEVICE(USB_VID_HANFTEK, 0x0131,
 		&rtl2832u_props, "Astrometa DVB-T2", NULL) },
+	{ DVB_USB_DEVICE(USB_PID_GOTVIEW_CA42, 0x5654,
+		&rtl2832u_props, "GoTview MasterHD 3", NULL) },
 	{ }
 };
 MODULE_DEVICE_TABLE(usb, rtl28xxu_id_table);
diff --git a/drivers/media/usb/rtl2832u/Kconfig b/drivers/media/usb/rtl2832u/Kconfig
new file mode 100644
index 00000000..b86cf018
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/Kconfig
@@ -0,0 +1,5 @@
+config DVB_USB_RTL2832U
+	tristate "Realtek RTL2832U DVB-T USB2.0 support"
+	depends on DVB_USB_V2
+	help
+	  Realtek RTL2832U DVB-T driver.
diff --git a/drivers/media/usb/rtl2832u/Makefile b/drivers/media/usb/rtl2832u/Makefile
new file mode 100644
index 00000000..5125883d
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/Makefile
@@ -0,0 +1,8 @@
+dvb-usb-rtl2832u-objs = demod_rtl2832.o	dvbt_demod_base.o dvbt_nim_base.o foundation.o math_mpi.o nim_rtl2832_mxl5007t.o nim_rtl2832_fc2580.o nim_rtl2832_mt2266.o rtl2832u.o rtl2832u_fe.o rtl2832u_io.o tuner_mxl5007t.o tuner_fc2580.o tuner_mt2266.o tuner_tua9001.o nim_rtl2832_tua9001.o tuner_fc0012.o nim_rtl2832_fc0012.o demod_rtl2836.o dtmb_demod_base.o dtmb_nim_base.o nim_rtl2836_fc2580.o nim_rtl2836_mxl5007t.o tuner_e4000.o nim_rtl2832_e4000.o tuner_mt2063.o demod_rtl2840.o tuner_max3543.o nim_rtl2832_mt2063.o nim_rtl2832_max3543.o nim_rtl2840_mt2063.o nim_rtl2840_max3543.o qam_demod_base.o qam_nim_base.o tuner_tda18272.o nim_rtl2832_tda18272.o nim_rtl2832_fc0013.o tuner_fc0013.o rtl2832u_audio.o si2168rtl.o
+obj-$(CONFIG_DVB_USB_RTL2832U) += dvb-usb-rtl2832u.o
+
+ccflags-y += -I$(srctree)/drivers/media/dvb-core
+ccflags-y += -I$(srctree)/drivers/media/dvb-frontends
+ccflags-y += -I$(srctree)/drivers/media/tuners
+ccflags-y += -I$(srctree)/drivers/media/common
+ccflags-y += -I$(srctree)/drivers/media/usb/rtl2832u
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2832.c b/drivers/media/usb/rtl2832u/demod_rtl2832.c
new file mode 100644
index 00000000..68b18053
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2832.c
@@ -0,0 +1,2872 @@
+/**
+
+@file
+
+@brief   RTL2832 demod module definition
+
+One can manipulate RTL2832 demod through RTL2832 module.
+RTL2832 module is derived from DVB-T demod module.
+
+*/
+
+
+#include "demod_rtl2832.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 demod module builder
+
+Use BuildRtl2832Module() to build RTL2832 module, set all module function pointers with the corresponding
+functions, and initialize module private variables.
+
+
+@param [in]   ppDemod                      Pointer to RTL2832 demod module pointer
+@param [in]   pDvbtDemodModuleMemory       Pointer to an allocated DVB-T demod module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   RTL2832 I2C device address
+@param [in]   CrystalFreqHz                RTL2832 crystal frequency in Hz
+@param [in]   TsInterfaceMode              RTL2832 TS interface mode for setting
+@param [in]   AppMode                      RTL2832 application mode for setting
+@param [in]   UpdateFuncRefPeriodMs        RTL2832 update function reference period in millisecond for setting
+@param [in]   IsFunc1Enabled               RTL2832 Function 1 enabling status for setting
+
+
+@note
+	-# One should call BuildRtl2832Module() to build RTL2832 module before using it.
+
+*/
+void
+BuildRtl2832Module(
+	DVBT_DEMOD_MODULE **ppDemod,
+	DVBT_DEMOD_MODULE *pDvbtDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	int AppMode,
+	unsigned long UpdateFuncRefPeriodMs,
+	int IsFunc1Enabled
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	RTL2832_EXTRA_MODULE *pExtra;
+
+
+
+	// Set demod module pointer, 
+	*ppDemod = pDvbtDemodModuleMemory;
+
+	// Get demod module.
+	pDemod = *ppDemod;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pDemod->pBaseInterface = pBaseInterfaceModuleMemory;
+	pDemod->pI2cBridge     = pI2cBridgeModuleMemory;
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Set demod type.
+	pDemod->DemodType = DVBT_DEMOD_TYPE_RTL2832;
+
+	// Set demod I2C device address.
+	pDemod->DeviceAddr = DeviceAddr;
+
+	// Set demod crystal frequency in Hz.
+	pDemod->CrystalFreqHz = CrystalFreqHz;
+
+	// Set demod TS interface mode.
+	pDemod->TsInterfaceMode = TsInterfaceMode;
+
+
+	// Initialize demod parameter setting status
+	pDemod->IsBandwidthModeSet = NO;
+	pDemod->IsIfFreqHzSet      = NO;
+	pDemod->IsSpectrumModeSet  = NO;
+
+
+	// Initialize demod register table.
+	rtl2832_InitRegTable(pDemod);
+
+	
+	// Build I2C birdge module.
+	rtl2832_BuildI2cBridgeModule(pDemod);
+
+
+	// Set demod module I2C function pointers with default functions.
+	pDemod->SetRegPage         = dvbt_demod_default_SetRegPage;
+	pDemod->SetRegBytes        = dvbt_demod_default_SetRegBytes;
+	pDemod->GetRegBytes        = dvbt_demod_default_GetRegBytes;
+	pDemod->SetRegMaskBits     = dvbt_demod_default_SetRegMaskBits;
+	pDemod->GetRegMaskBits     = dvbt_demod_default_GetRegMaskBits;
+	pDemod->SetRegBits         = dvbt_demod_default_SetRegBits;
+	pDemod->GetRegBits         = dvbt_demod_default_GetRegBits;
+	pDemod->SetRegBitsWithPage = dvbt_demod_default_SetRegBitsWithPage;
+	pDemod->GetRegBitsWithPage = dvbt_demod_default_GetRegBitsWithPage;
+
+
+	// Set demod module manipulating function pointers with default functions.
+	pDemod->GetDemodType     = dvbt_demod_default_GetDemodType;
+	pDemod->GetDeviceAddr    = dvbt_demod_default_GetDeviceAddr;
+	pDemod->GetCrystalFreqHz = dvbt_demod_default_GetCrystalFreqHz;
+
+	pDemod->GetBandwidthMode = dvbt_demod_default_GetBandwidthMode;
+	pDemod->GetIfFreqHz      = dvbt_demod_default_GetIfFreqHz;
+	pDemod->GetSpectrumMode  = dvbt_demod_default_GetSpectrumMode;
+
+
+	// Set demod module manipulating function pointers with particular functions.
+	pDemod->IsConnectedToI2c  = rtl2832_IsConnectedToI2c;
+	pDemod->SoftwareReset     = rtl2832_SoftwareReset;
+	pDemod->Initialize        = rtl2832_Initialize;
+	pDemod->SetBandwidthMode  = rtl2832_SetBandwidthMode;
+	pDemod->SetIfFreqHz       = rtl2832_SetIfFreqHz;
+	pDemod->SetSpectrumMode   = rtl2832_SetSpectrumMode;
+
+	pDemod->IsTpsLocked       = rtl2832_IsTpsLocked;
+	pDemod->IsSignalLocked    = rtl2832_IsSignalLocked;
+
+	pDemod->GetSignalStrength = rtl2832_GetSignalStrength;
+	pDemod->GetSignalQuality  = rtl2832_GetSignalQuality;
+
+	pDemod->GetBer            = rtl2832_GetBer;
+	pDemod->GetSnrDb          = rtl2832_GetSnrDb;
+
+	pDemod->GetRfAgc          = rtl2832_GetRfAgc;
+	pDemod->GetIfAgc          = rtl2832_GetIfAgc;
+	pDemod->GetDiAgc          = rtl2832_GetDiAgc;
+
+	pDemod->GetTrOffsetPpm    = rtl2832_GetTrOffsetPpm;
+	pDemod->GetCrOffsetHz     = rtl2832_GetCrOffsetHz;
+
+	pDemod->GetConstellation  = rtl2832_GetConstellation;
+	pDemod->GetHierarchy      = rtl2832_GetHierarchy;
+	pDemod->GetCodeRateLp     = rtl2832_GetCodeRateLp;
+	pDemod->GetCodeRateHp     = rtl2832_GetCodeRateHp;
+	pDemod->GetGuardInterval  = rtl2832_GetGuardInterval;
+	pDemod->GetFftMode        = rtl2832_GetFftMode;
+
+	pDemod->UpdateFunction    = rtl2832_UpdateFunction;
+	pDemod->ResetFunction     = rtl2832_ResetFunction;
+
+
+	// Initialize demod extra module variables.
+	pExtra->AppMode = AppMode;
+
+
+	// Initialize demod Function 1 variables.
+	pExtra->Func1State = RTL2832_FUNC1_STATE_NORMAL;
+
+	pExtra->IsFunc1Enabled = IsFunc1Enabled;
+
+	pExtra->Func1WaitTimeMax        = DivideWithCeiling(RTL2832_FUNC1_WAIT_TIME_MS, UpdateFuncRefPeriodMs);
+	pExtra->Func1GettingTimeMax     = DivideWithCeiling(RTL2832_FUNC1_GETTING_TIME_MS, UpdateFuncRefPeriodMs);
+	pExtra->Func1GettingNumEachTime = DivideWithCeiling(RTL2832_FUNC1_GETTING_NUM_MIN, pExtra->Func1GettingTimeMax + 1);
+
+	pExtra->Func1QamBak  = 0xff;
+	pExtra->Func1HierBak = 0xff;
+	pExtra->Func1LpCrBak = 0xff;
+	pExtra->Func1HpCrBak = 0xff;
+	pExtra->Func1GiBak   = 0xff;
+	pExtra->Func1FftBak  = 0xff;
+
+
+	// Set demod extra module function pointers.
+	pExtra->GetAppMode = rtl2832_GetAppMode;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_IS_CONNECTED_TO_I2C
+
+*/
+void
+rtl2832_IsConnectedToI2c(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char Nothing;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Send read command.
+	// Note: The number of reading bytes must be greater than 0.
+	if(pBaseInterface->I2cRead(pBaseInterface, pDemod->DeviceAddr, &Nothing, LEN_1_BYTE) == FUNCTION_ERROR)
+		goto error_status_i2c_read;
+
+
+	// Set I2cConnectionStatus with YES.
+	*pAnswer = YES;
+
+
+	return;
+
+
+error_status_i2c_read:
+
+	// Set I2cConnectionStatus with NO.
+	*pAnswer = NO;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SOFTWARE_RESET
+
+*/
+int
+rtl2832_SoftwareReset(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	// Set SOFT_RST with 1. Then, set SOFT_RST with 0.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_SOFT_RST, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_SOFT_RST, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_INITIALIZE
+
+*/
+int
+rtl2832_Initialize(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	// Initializing table entry only used in Initialize()
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long WritingValue;
+	}
+	INIT_TABLE_ENTRY;
+
+	// TS interface initializing table entry only used in Initialize()
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long WritingValue[TS_INTERFACE_MODE_NUM];
+	}
+	TS_INTERFACE_INIT_TABLE_ENTRY;
+
+	// Application initializing table entry only used in Initialize()
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long WritingValue[RTL2832_APPLICATION_MODE_NUM];
+	}
+	APP_INIT_TABLE_ENTRY;
+
+
+
+	static const INIT_TABLE_ENTRY InitTable[RTL2832_INIT_TABLE_LEN] =
+	{
+		// RegBitName,				WritingValue
+		{DVBT_AD_EN_REG,			0x1		},
+		{DVBT_AD_EN_REG1,			0x1		},
+		{DVBT_RSD_BER_FAIL_VAL,		0x2800	},
+		{DVBT_MGD_THD0,				0x10	},
+		{DVBT_MGD_THD1,				0x20	},
+		{DVBT_MGD_THD2,				0x20	},
+		{DVBT_MGD_THD3,				0x40	},
+		{DVBT_MGD_THD4,				0x22	},
+		{DVBT_MGD_THD5,				0x32	},
+		{DVBT_MGD_THD6,				0x37	},
+		{DVBT_MGD_THD7,				0x39	},
+		{DVBT_EN_BK_TRK,			0x0		},
+		{DVBT_EN_CACQ_NOTCH,		0x0		},
+		{DVBT_AD_AV_REF,			0x2a	},
+		{DVBT_REG_PI,				0x6		},
+		{DVBT_PIP_ON,				0x0		},
+		{DVBT_CDIV_PH0,				0x8		},
+		{DVBT_CDIV_PH1,				0x8		},
+		{DVBT_SCALE1_B92,			0x4		},
+		{DVBT_SCALE1_B93,			0xb0	},
+		{DVBT_SCALE1_BA7,			0x78	},
+		{DVBT_SCALE1_BA9,			0x28	},
+		{DVBT_SCALE1_BAA,			0x59	},
+		{DVBT_SCALE1_BAB,			0x83	},
+		{DVBT_SCALE1_BAC,			0xd4	},
+		{DVBT_SCALE1_BB0,			0x65	},
+		{DVBT_SCALE1_BB1,			0x43	},
+		{DVBT_KB_P1,				0x1		},
+		{DVBT_KB_P2,				0x4		},
+		{DVBT_KB_P3,				0x7		},
+		{DVBT_K1_CR_STEP12,			0xa		},
+		{DVBT_REG_GPE,				0x1		},
+	};
+
+	static const TS_INTERFACE_INIT_TABLE_ENTRY TsInterfaceInitTable[RTL2832_TS_INTERFACE_INIT_TABLE_LEN] =
+	{
+		// RegBitName,				WritingValue for {Parallel, Serial}
+		{DVBT_SERIAL,				{0x0,	0x1}},
+		{DVBT_CDIV_PH0,				{0x9,	0x1}},
+		{DVBT_CDIV_PH1,				{0x9,	0x2}},
+		{DVBT_MPEG_IO_OPT_2_2,		{0x0,	0x0}},
+		{DVBT_MPEG_IO_OPT_1_0,		{0x0,	0x1}},
+	};
+
+	static const APP_INIT_TABLE_ENTRY AppInitTable[RTL2832_APP_INIT_TABLE_LEN] =
+	{
+		// RegBitName,				WritingValue for {Dongle, STB}
+		{DVBT_TRK_KS_P2,			{0x4,	0x4}},
+		{DVBT_TRK_KS_I2,			{0x7,	0x7}},
+		{DVBT_TR_THD_SET2,			{0x6,	0x6}},
+		{DVBT_TRK_KC_I2,			{0x5,	0x6}},
+		{DVBT_CR_THD_SET2,			{0x1,	0x1}},
+	};
+
+
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	RTL2832_EXTRA_MODULE *pExtra;
+
+	int i;
+
+	int TsInterfaceMode;
+	int AppMode;
+
+
+
+	// Get base interface and demod extra module.
+	pBaseInterface = pDemod->pBaseInterface;
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+	// Get TS interface mode.
+	TsInterfaceMode = pDemod->TsInterfaceMode;
+
+	// Get application mode.
+	pExtra->GetAppMode(pDemod, &AppMode);
+
+
+	// Initialize demod registers according to the initializing table.
+	for(i = 0; i < RTL2832_INIT_TABLE_LEN; i++)
+	{
+		if(pDemod->SetRegBitsWithPage(pDemod, InitTable[i].RegBitName, InitTable[i].WritingValue)
+			!= FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	// Initialize demod registers according to the TS interface initializing table.
+	for(i = 0; i < RTL2832_TS_INTERFACE_INIT_TABLE_LEN; i++)
+	{
+		if(pDemod->SetRegBitsWithPage(pDemod, TsInterfaceInitTable[i].RegBitName,
+			TsInterfaceInitTable[i].WritingValue[TsInterfaceMode]) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	// Initialize demod registers according to the application initializing table.
+	for(i = 0; i < RTL2832_APP_INIT_TABLE_LEN; i++)
+	{
+		if(pDemod->SetRegBitsWithPage(pDemod, AppInitTable[i].RegBitName,
+			AppInitTable[i].WritingValue[AppMode]) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_BANDWIDTH_MODE
+
+*/
+int
+rtl2832_SetBandwidthMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int BandwidthMode
+	)
+{
+	static const unsigned char HlpfxTable[DVBT_BANDWIDTH_MODE_NUM][RTL2832_H_LPF_X_LEN] =
+	{
+		// H_LPF_X writing value for 6 MHz bandwidth
+		{
+			0xf5,	0xff,	0x15,	0x38,	0x5d,	0x6d,	0x52,	0x07,	0xfa,	0x2f,
+			0x53,	0xf5,	0x3f,	0xca,	0x0b,	0x91,	0xea,	0x30,	0x63,	0xb2,
+			0x13,	0xda,	0x0b,	0xc4,	0x18,	0x7e,	0x16,	0x66,	0x08,	0x67,
+			0x19,	0xe0,
+		},
+
+		// H_LPF_X writing value for 7 MHz bandwidth
+		{
+			0xe7,	0xcc,	0xb5,	0xba,	0xe8,	0x2f,	0x67,	0x61,	0x00,	0xaf,
+			0x86,	0xf2,	0xbf,	0x59,	0x04,	0x11,	0xb6,	0x33,	0xa4,	0x30,
+			0x15,	0x10,	0x0a,	0x42,	0x18,	0xf8,	0x17,	0xd9,	0x07,	0x22,
+			0x19,	0x10,
+		},
+
+		// H_LPF_X writing value for 8 MHz bandwidth
+		{
+			0x09,	0xf6,	0xd2,	0xa7,	0x9a,	0xc9,	0x27,	0x77,	0x06,	0xbf,
+			0xec,	0xf4,	0x4f,	0x0b,	0xfc,	0x01,	0x63,	0x35,	0x54,	0xa7,
+			0x16,	0x66,	0x08,	0xb4,	0x19,	0x6e,	0x19,	0x65,	0x05,	0xc8,
+			0x19,	0xe0,
+		},
+	};
+
+
+	unsigned long CrystalFreqHz;
+
+	long ConstWithBandwidthMode;
+
+	MPI MpiCrystalFreqHz;
+	MPI MpiConst, MpiVar0, MpiVar1, MpiNone;
+
+	unsigned long RsampRatio;
+
+	long CfreqOffRatioInt;
+	unsigned long CfreqOffRatioBinary;
+
+
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Set H_LPF_X registers with HlpfxTable according to BandwidthMode.
+	if(pDemod->SetRegPage(pDemod, RTL2832_H_LPF_X_PAGE) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->SetRegBytes(pDemod, RTL2832_H_LPF_X_ADDR, HlpfxTable[BandwidthMode], RTL2832_H_LPF_X_LEN) !=
+		FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Determine constant value with bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:	ConstWithBandwidthMode = 48000000;		break;
+		case DVBT_BANDWIDTH_7MHZ:	ConstWithBandwidthMode = 56000000;		break;
+		case DVBT_BANDWIDTH_8MHZ:	ConstWithBandwidthMode = 64000000;		break;
+	}
+
+
+	// Calculate RSAMP_RATIO value.
+	// Note: RSAMP_RATIO = floor(CrystalFreqHz * 7 * pow(2, 22) / ConstWithBandwidthMode)
+	MpiSetValue(&MpiCrystalFreqHz, CrystalFreqHz);
+	MpiSetValue(&MpiVar1,          ConstWithBandwidthMode);
+	MpiSetValue(&MpiConst,         7);
+
+	MpiMul(&MpiVar0, MpiCrystalFreqHz, MpiConst);
+	MpiLeftShift(&MpiVar0, MpiVar0, 22);
+	MpiDiv(&MpiVar0, &MpiNone, MpiVar0, MpiVar1);
+
+	MpiGetValue(MpiVar0, (long *)&RsampRatio);
+
+
+	// Set RSAMP_RATIO with calculated value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_RSAMP_RATIO, RsampRatio) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Calculate CFREQ_OFF_RATIO value.
+	// Note: CFREQ_OFF_RATIO = - floor(ConstWithBandwidthMode * pow(2, 20) / (CrystalFreqHz * 7))
+	MpiSetValue(&MpiCrystalFreqHz, CrystalFreqHz);
+	MpiSetValue(&MpiVar0,          ConstWithBandwidthMode);
+	MpiSetValue(&MpiConst,         7);
+
+	MpiLeftShift(&MpiVar0, MpiVar0, 20);
+	MpiMul(&MpiVar1, MpiCrystalFreqHz, MpiConst);
+	MpiDiv(&MpiVar0, &MpiNone, MpiVar0, MpiVar1);
+
+	MpiGetValue(MpiVar0, &CfreqOffRatioInt);
+	CfreqOffRatioInt = - CfreqOffRatioInt;
+
+	CfreqOffRatioBinary = SignedIntToBin(CfreqOffRatioInt, RTL2832_CFREQ_OFF_RATIO_BIT_NUM);
+
+
+	// Set CFREQ_OFF_RATIO with calculated value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_CFREQ_OFF_RATIO, CfreqOffRatioBinary) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+
+	// Set demod bandwidth mode parameter.
+	pDemod->BandwidthMode      = BandwidthMode;
+	pDemod->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_IF_FREQ_HZ
+
+*/
+int
+rtl2832_SetIfFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	)
+{
+	unsigned long CrystalFreqHz;
+
+	unsigned long EnBbin;
+
+	MPI MpiCrystalFreqHz, MpiVar, MpiNone;
+
+	long PsetIffreqInt;
+	unsigned long PsetIffreqBinary;
+
+
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Determine and set EN_BBIN value.
+	EnBbin = (IfFreqHz == IF_FREQ_0HZ) ? 0x1 : 0x0;
+
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_EN_BBIN, EnBbin) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Calculate PSET_IFFREQ value.
+	// Note: PSET_IFFREQ = - floor((IfFreqHz % CrystalFreqHz) * pow(2, 22) / CrystalFreqHz)
+	MpiSetValue(&MpiCrystalFreqHz, CrystalFreqHz);
+
+	MpiSetValue(&MpiVar, (IfFreqHz % CrystalFreqHz));
+	MpiLeftShift(&MpiVar, MpiVar, RTL2832_PSET_IFFREQ_BIT_NUM);
+	MpiDiv(&MpiVar, &MpiNone, MpiVar, MpiCrystalFreqHz);
+
+	MpiGetValue(MpiVar, &PsetIffreqInt);
+	PsetIffreqInt = - PsetIffreqInt;
+
+	PsetIffreqBinary = SignedIntToBin(PsetIffreqInt, RTL2832_PSET_IFFREQ_BIT_NUM);
+
+
+	// Set PSET_IFFREQ with calculated value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_PSET_IFFREQ, PsetIffreqBinary) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod IF frequnecy parameter.
+	pDemod->IfFreqHz      = IfFreqHz;
+	pDemod->IsIfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_SPECTRUM_MODE
+
+*/
+int
+rtl2832_SetSpectrumMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	)
+{
+	unsigned long SpecInv;
+
+
+
+	// Determine SpecInv according to spectrum mode.
+	switch(SpectrumMode)
+	{
+		default:
+		case SPECTRUM_NORMAL:		SpecInv = 0;		break;
+		case SPECTRUM_INVERSE:		SpecInv = 1;		break;
+	}
+
+
+	// Set SPEC_INV with SpecInv.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_SPEC_INV, SpecInv) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod spectrum mode parameter.
+	pDemod->SpectrumMode      = SpectrumMode;
+	pDemod->IsSpectrumModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_IS_TPS_LOCKED
+
+*/
+int
+rtl2832_IsTpsLocked(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long FsmStage;
+
+
+
+	// Get FSM stage from FSM_STAGE.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Determine answer according to FSM stage.
+	if(FsmStage > 9)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_IS_SIGNAL_LOCKED
+
+*/
+int
+rtl2832_IsSignalLocked(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long FsmStage;
+
+
+
+	// Get FSM stage from FSM_STAGE.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Determine answer according to FSM stage.
+	if(FsmStage == 11)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+rtl2832_GetSignalStrength(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	)
+{
+	unsigned long FsmStage;
+	int IfAgc;
+
+
+
+	// Get FSM stage and IF AGC value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetIfAgc(pDemod, &IfAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	//  Determine signal strength according to FSM stage and IF AGC value.
+	if(FsmStage < 10)
+		*pSignalStrength = 0;
+	else
+		*pSignalStrength = 55 - IfAgc / 182;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+rtl2832_GetSignalQuality(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	)
+{
+	unsigned long FsmStage, RsdBerEst;
+
+	MPI MpiVar;
+	long Var;
+
+
+
+	// Get FSM_STAGE and RSD_BER_EST.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSD_BER_EST, &RsdBerEst) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// If demod is not signal-locked, set signal quality with zero.
+	if(FsmStage < 10)
+	{
+		*pSignalQuality = 0;
+		goto success_status_non_signal_lock;
+	}
+
+	// Determine signal quality according to RSD_BER_EST.
+	// Note: Map RSD_BER_EST value 8192 ~ 128 to 10 ~ 100
+	//       Original formula: SignalQuality = 205 - 15 * log2(RSD_BER_EST)
+	//       Adjusted formula: SignalQuality = ((205 << 5) - 15 * (log2(RSD_BER_EST) << 5)) >> 5
+	//       If RSD_BER_EST > 8192, signal quality is 10.
+	//       If RSD_BER_EST < 128, signal quality is 100.
+	if(RsdBerEst > 8192)
+	{
+		*pSignalQuality = 10;
+	}
+	else if(RsdBerEst < 128)
+	{
+		*pSignalQuality = 100;
+	}
+	else
+	{
+		MpiSetValue(&MpiVar, RsdBerEst);
+		MpiLog2(&MpiVar, MpiVar, RTL2832_SQ_FRAC_BIT_NUM);
+		MpiGetValue(MpiVar, &Var);
+
+		*pSignalQuality = ((205 << RTL2832_SQ_FRAC_BIT_NUM) - 15 * Var) >> RTL2832_SQ_FRAC_BIT_NUM;
+	}
+
+
+success_status_non_signal_lock:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_BER
+
+*/
+int
+rtl2832_GetBer(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	)
+{
+	unsigned long RsdBerEst;
+
+
+
+	// Get RSD_BER_EST.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSD_BER_EST, &RsdBerEst) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set BER numerator according to RSD_BER_EST.
+	*pBerNum = RsdBerEst;
+
+	// Set BER denominator.
+	*pBerDen = RTL2832_BER_DEN_VALUE;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_SNR_DB
+
+*/
+int
+rtl2832_GetSnrDb(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	unsigned long FsmStage;
+	unsigned long CeEstEvm;
+	int Constellation, Hierarchy;
+
+	static const long SnrDbNumConst[DVBT_CONSTELLATION_NUM][DVBT_HIERARCHY_NUM] =
+	{
+		{122880,	122880,		122880,		122880,		},
+		{146657,	146657,		156897,		171013,		},
+		{167857,	167857,		173127,		181810,		},
+	};
+
+	long Var;
+	MPI MpiCeEstEvm, MpiVar;
+
+
+
+	// Get FSM stage, CE_EST_EVM, constellation, and hierarchy.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_CE_EST_EVM, &CeEstEvm) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetConstellation(pDemod, &Constellation) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetHierarchy(pDemod, &Hierarchy) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+
+	// SNR dB formula
+	// Original formula: SNR_dB = 10 * log10(Norm * pow(2, 11) / CeEstEvm)
+	// Adjusted formula: SNR_dB = (SNR_DB_NUM_CONST - 10 * log2(CeEstEvm) * pow(2, SNR_FRAC_BIT_NUM)) / SNR_DB_DEN
+	//                   SNR_DB_NUM_CONST = 10 * log2(Norm * pow(2, 11)) * pow(2, SNR_FRAC_BIT_NUM)
+	//                   SNR_DB_DEN       = log2(10) * pow(2, SNR_FRAC_BIT_NUM)
+	// Norm:
+	//	                 None      Alpha=1   Alpha=2   Alpha=4
+	//        4-QAM      2         2         2         2
+	//       16-QAM      10        10        20        52
+	//       64-QAM      42        42        60        108
+
+
+	// If FSM stage < 10, set CE_EST_EVM with max value.
+	if(FsmStage < 10)
+		CeEstEvm = RTL2832_CE_EST_EVM_MAX_VALUE;
+
+
+	// Calculate SNR dB numerator.
+	MpiSetValue(&MpiCeEstEvm, CeEstEvm);
+
+	MpiLog2(&MpiVar, MpiCeEstEvm, RTL2832_SNR_FRAC_BIT_NUM);
+
+	MpiGetValue(MpiVar, &Var);
+
+	*pSnrDbNum = SnrDbNumConst[Constellation][Hierarchy] - 10 * Var;
+
+	
+	// Set SNR dB denominator.
+	*pSnrDbDen = RTL2832_SNR_DB_DEN;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_RF_AGC
+
+*/
+int
+rtl2832_GetRfAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	)
+{
+	unsigned long Value;
+
+
+
+	// Get RF_AGC_VAL to Value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RF_AGC_VAL, &Value) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Convert Value to signed integer and store the signed integer to RfAgc.
+	*pRfAgc = (int)BinToSignedInt(Value, RTL2832_RF_AGC_REG_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_IF_AGC
+
+*/
+int
+rtl2832_GetIfAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	)
+{
+	unsigned long Value;
+
+
+
+	// Get IF_AGC_VAL to Value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_IF_AGC_VAL, &Value) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Convert Value to signed integer and store the signed integer to IfAgc.
+	*pIfAgc = (int)BinToSignedInt(Value, RTL2832_IF_AGC_REG_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_DI_AGC
+
+*/
+int
+rtl2832_GetDiAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDiAgc
+	)
+{
+	unsigned long Value;
+
+
+
+	// Get DAGC_VAL to DiAgc.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_DAGC_VAL, &Value) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	*pDiAgc = (unsigned char)Value;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+rtl2832_GetTrOffsetPpm(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	)
+{
+	unsigned long SfreqOffBinary;
+	long SfreqOffInt;
+
+	MPI MpiSfreqOffInt;
+	MPI MpiConst, MpiVar;
+
+
+	// Get SfreqOff binary value from SFREQ_OFF register bits.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_SFREQ_OFF, &SfreqOffBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// Convert SfreqOff binary value to signed integer.
+	SfreqOffInt = BinToSignedInt(SfreqOffBinary, RTL2832_SFREQ_OFF_BIT_NUM);
+
+	
+	// Get TR offset in ppm.
+	// Note: Original formula:   TrOffsetPpm = (SfreqOffInt * 1000000) / pow(2, 24)
+	//       Adjusted formula:   TrOffsetPpm = (SfreqOffInt * 1000000) >> 24
+	MpiSetValue(&MpiSfreqOffInt, SfreqOffInt);
+	MpiSetValue(&MpiConst,       1000000);
+
+	MpiMul(&MpiVar, MpiSfreqOffInt, MpiConst);
+	MpiRightShift(&MpiVar, MpiVar, 24);
+
+	MpiGetValue(MpiVar, pTrOffsetPpm);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+rtl2832_GetCrOffsetHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	)
+{
+	int BandwidthMode;
+	int FftMode;
+
+	unsigned long CfreqOffBinary;
+	long CfreqOffInt;
+
+	long ConstWithBandwidthMode, ConstWithFftMode;
+
+	MPI MpiCfreqOffInt;
+	MPI MpiConstWithBandwidthMode, MpiConstWithFftMode;
+	MPI MpiConst, MpiVar0, MpiVar1, MpiNone;
+
+
+
+	// Get demod bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, &BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_bandwidth_mode;
+
+
+	// Get demod FFT mode.
+	if(pDemod->GetFftMode(pDemod, &FftMode) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Get CfreqOff binary value from CFREQ_OFF register bits.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_CFREQ_OFF, &CfreqOffBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// Convert CfreqOff binary value to signed integer.
+	CfreqOffInt = BinToSignedInt(CfreqOffBinary, RTL2832_CFREQ_OFF_BIT_NUM);
+
+
+	// Determine constant value with bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:	ConstWithBandwidthMode = 48000000;		break;
+		case DVBT_BANDWIDTH_7MHZ:	ConstWithBandwidthMode = 56000000;		break;
+		case DVBT_BANDWIDTH_8MHZ:	ConstWithBandwidthMode = 64000000;		break;
+	}
+
+
+	// Determine constant value with FFT mode.
+	switch(FftMode)
+	{
+		default:
+		case DVBT_FFT_MODE_2K:		ConstWithFftMode = 2048;		break;
+		case DVBT_FFT_MODE_8K:		ConstWithFftMode = 8192;		break;
+	}
+
+
+	// Get Cr offset in Hz.
+	// Note: Original formula:   CrOffsetHz = (CfreqOffInt * ConstWithBandwidthMode) / (ConstWithFftMode * 7 * 128)
+	//       Adjusted formula:   CrOffsetHz = (CfreqOffInt * ConstWithBandwidthMode) / ((ConstWithFftMode * 7) << 7)
+	MpiSetValue(&MpiCfreqOffInt,            CfreqOffInt);
+	MpiSetValue(&MpiConstWithBandwidthMode, ConstWithBandwidthMode);
+	MpiSetValue(&MpiConstWithFftMode,       ConstWithFftMode);
+	MpiSetValue(&MpiConst,                  7);
+
+	MpiMul(&MpiVar0, MpiCfreqOffInt, MpiConstWithBandwidthMode);
+	MpiMul(&MpiVar1, MpiConstWithFftMode, MpiConst);
+	MpiLeftShift(&MpiVar1, MpiVar1, 7);
+	MpiDiv(&MpiVar0, &MpiNone, MpiVar0, MpiVar1);
+
+	MpiGetValue(MpiVar0, pCrOffsetHz);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_get_demod_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_CONSTELLATION
+
+*/
+int
+rtl2832_GetConstellation(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pConstellation
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS constellation information from RX_CONSTEL.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RX_CONSTEL, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pConstellation = DVBT_CONSTELLATION_QPSK;			break;
+		case 1:		*pConstellation = DVBT_CONSTELLATION_16QAM;			break;
+		case 2:		*pConstellation = DVBT_CONSTELLATION_64QAM;			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_HIERARCHY
+
+*/
+int
+rtl2832_GetHierarchy(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pHierarchy
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS hierarchy infromation from RX_HIER.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RX_HIER, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pHierarchy = DVBT_HIERARCHY_NONE;				break;
+		case 1:		*pHierarchy = DVBT_HIERARCHY_ALPHA_1;			break;
+		case 2:		*pHierarchy = DVBT_HIERARCHY_ALPHA_2;			break;
+		case 3:		*pHierarchy = DVBT_HIERARCHY_ALPHA_4;			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_CODE_RATE_LP
+
+*/
+int
+rtl2832_GetCodeRateLp(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateLp
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS low-priority code rate infromation from RX_C_RATE_LP.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RX_C_RATE_LP, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pCodeRateLp = DVBT_CODE_RATE_1_OVER_2;			break;
+		case 1:		*pCodeRateLp = DVBT_CODE_RATE_2_OVER_3;			break;
+		case 2:		*pCodeRateLp = DVBT_CODE_RATE_3_OVER_4;			break;
+		case 3:		*pCodeRateLp = DVBT_CODE_RATE_5_OVER_6;			break;
+		case 4:		*pCodeRateLp = DVBT_CODE_RATE_7_OVER_8;			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_CODE_RATE_HP
+
+*/
+int
+rtl2832_GetCodeRateHp(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateHp
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS high-priority code rate infromation from RX_C_RATE_HP.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RX_C_RATE_HP, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pCodeRateHp = DVBT_CODE_RATE_1_OVER_2;			break;
+		case 1:		*pCodeRateHp = DVBT_CODE_RATE_2_OVER_3;			break;
+		case 2:		*pCodeRateHp = DVBT_CODE_RATE_3_OVER_4;			break;
+		case 3:		*pCodeRateHp = DVBT_CODE_RATE_5_OVER_6;			break;
+		case 4:		*pCodeRateHp = DVBT_CODE_RATE_7_OVER_8;			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_GUARD_INTERVAL
+
+*/
+int
+rtl2832_GetGuardInterval(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pGuardInterval
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS guard interval infromation from GI_IDX.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_GI_IDX, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pGuardInterval = DVBT_GUARD_INTERVAL_1_OVER_32;			break;
+		case 1:		*pGuardInterval = DVBT_GUARD_INTERVAL_1_OVER_16;			break;
+		case 2:		*pGuardInterval = DVBT_GUARD_INTERVAL_1_OVER_8;				break;
+		case 3:		*pGuardInterval = DVBT_GUARD_INTERVAL_1_OVER_4;				break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_FFT_MODE
+
+*/
+int
+rtl2832_GetFftMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pFftMode
+	)
+{
+	unsigned long ReadingValue;
+
+
+	// Get TPS FFT mode infromation from FFT_MODE_IDX.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FFT_MODE_IDX, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(ReadingValue)
+	{
+		default:
+		case 0:		*pFftMode = DVBT_FFT_MODE_2K;			break;
+		case 1:		*pFftMode = DVBT_FFT_MODE_8K;			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2832_UpdateFunction(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Execute Function 1 according to Function 1 enabling status
+	if(pExtra->IsFunc1Enabled == YES)
+	{
+		if(rtl2832_func1_Update(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_RESET_FUNCTION
+
+*/
+int
+rtl2832_ResetFunction(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Reset Function 1 settings according to Function 1 enabling status.
+	if(pExtra->IsFunc1Enabled == YES)
+	{
+		if(rtl2832_func1_Reset(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD
+
+*/
+int
+rtl2832_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Send I2C reading command.
+	if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_reading_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_reading_command:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD
+
+*/
+int
+rtl2832_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Send I2C writing command.
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, pWritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_writing_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_writing_command:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Initialize RTL2832 register table.
+
+Use rtl2832_InitRegTable() to initialize RTL2832 register table.
+
+
+@param [in]   pDemod   RTL2832 demod module pointer
+
+
+@note
+	-# The rtl2832_InitRegTable() function will be called by BuildRtl2832Module().
+
+*/
+void
+rtl2832_InitRegTable(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	static const DVBT_PRIMARY_REG_ENTRY PrimaryRegTable[RTL2832_REG_TABLE_LEN] =
+	{
+		// Software reset register
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_SOFT_RST,						0x1,		0x1,			2,		2},
+
+		// Tuner I2C forwording register
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_IIC_REPEAT,					0x1,		0x1,			3,		3},
+
+		// Registers for initialization
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_TR_WAIT_MIN_8K,				0x1,		0x88,			11,		2},
+		{DVBT_RSD_BER_FAIL_VAL,				0x1,		0x8f,			15,		0},
+		{DVBT_EN_BK_TRK,					0x1,		0xa6,			7,		7},
+		{DVBT_AD_EN_REG,					0x0,		0x8,			7,		7},
+		{DVBT_AD_EN_REG1,					0x0,		0x8,			6,		6},
+		{DVBT_EN_BBIN,						0x1,		0xb1,			0,		0},
+		{DVBT_MGD_THD0,						0x1,		0x95,			7,		0},
+		{DVBT_MGD_THD1,						0x1,		0x96,			7,		0},
+		{DVBT_MGD_THD2,						0x1,		0x97,			7,		0},
+		{DVBT_MGD_THD3,						0x1,		0x98,			7,		0},
+		{DVBT_MGD_THD4,						0x1,		0x99,			7,		0},
+		{DVBT_MGD_THD5,						0x1,		0x9a,			7,		0},
+		{DVBT_MGD_THD6,						0x1,		0x9b,			7,		0},
+		{DVBT_MGD_THD7,						0x1,		0x9c,			7,		0},
+		{DVBT_EN_CACQ_NOTCH,				0x1,		0x61,			4,		4},
+		{DVBT_AD_AV_REF,					0x0,		0x9,			6,		0},
+		{DVBT_REG_PI,						0x0,		0xa,			2,		0},
+		{DVBT_PIP_ON,						0x0,		0x21,			3,		3},
+		{DVBT_SCALE1_B92,					0x2,		0x92,			7,		0},
+		{DVBT_SCALE1_B93,					0x2,		0x93,			7,		0},
+		{DVBT_SCALE1_BA7,					0x2,		0xa7,			7,		0},
+		{DVBT_SCALE1_BA9,					0x2,		0xa9,			7,		0},
+		{DVBT_SCALE1_BAA,					0x2,		0xaa,			7,		0},
+		{DVBT_SCALE1_BAB,					0x2,		0xab,			7,		0},
+		{DVBT_SCALE1_BAC,					0x2,		0xac,			7,		0},
+		{DVBT_SCALE1_BB0,					0x2,		0xb0,			7,		0},
+		{DVBT_SCALE1_BB1,					0x2,		0xb1,			7,		0},
+		{DVBT_KB_P1,						0x1,		0x64,			3,		1},
+		{DVBT_KB_P2,						0x1,		0x64,			6,		4},
+		{DVBT_KB_P3,						0x1,		0x65,			2,		0},
+		{DVBT_OPT_ADC_IQ,					0x0,		0x6,			5,		4},
+		{DVBT_AD_AVI,						0x0,		0x9,			1,		0},
+		{DVBT_AD_AVQ,						0x0,		0x9,			3,		2},
+		{DVBT_K1_CR_STEP12,					0x2,		0xad,			9,		4},
+
+		// Registers for initialization according to mode
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_TRK_KS_P2,					0x1,		0x6f,			2,		0},
+		{DVBT_TRK_KS_I2,					0x1,		0x70,			5,		3},
+		{DVBT_TR_THD_SET2,					0x1,		0x72,			3,		0},
+		{DVBT_TRK_KC_P2,					0x1,		0x73,			5,		3},
+		{DVBT_TRK_KC_I2,					0x1,		0x75,			2,		0},
+		{DVBT_CR_THD_SET2,					0x1,		0x76,			7,		6},
+
+		// Registers for IF setting
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_PSET_IFFREQ,					0x1,		0x19,			21,		0},
+		{DVBT_SPEC_INV,						0x1,		0x15,			0,		0},
+
+		// Registers for bandwidth programming
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_RSAMP_RATIO,					0x1,		0x9f,			27,		2},
+		{DVBT_CFREQ_OFF_RATIO,				0x1,		0x9d,			23,		4},
+
+		// FSM stage register
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_FSM_STAGE,					0x3,		0x51,			6,		3},
+
+		// TPS content registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_RX_CONSTEL,					0x3,		0x3c,			3,		2},
+		{DVBT_RX_HIER,						0x3,		0x3c,			6,		4},
+		{DVBT_RX_C_RATE_LP,					0x3,		0x3d,			2,		0},
+		{DVBT_RX_C_RATE_HP,					0x3,		0x3d,			5,		3},
+		{DVBT_GI_IDX,						0x3,		0x51,			1,		0},
+		{DVBT_FFT_MODE_IDX,					0x3,		0x51,			2,		2},
+
+		// Performance measurement registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_RSD_BER_EST,					0x3,		0x4e,			15,		0},
+		{DVBT_CE_EST_EVM,					0x4,		0xc,			15,		0},
+
+		// AGC registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_RF_AGC_VAL,					0x3,		0x5b,			13,		0},
+		{DVBT_IF_AGC_VAL,					0x3,		0x59,			13,		0},
+		{DVBT_DAGC_VAL,						0x3,		0x5,			7,		0},
+
+		// TR offset and CR offset registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_SFREQ_OFF,					0x3,		0x18,			13,		0},
+		{DVBT_CFREQ_OFF,					0x3,		0x5f,			17,		0},
+
+		// AGC relative registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_POLAR_RF_AGC,					0x0,		0xe,			1,		1},
+		{DVBT_POLAR_IF_AGC,					0x0,		0xe,			0,		0},
+		{DVBT_AAGC_HOLD,					0x1,		0x4,			5,		5},
+		{DVBT_EN_RF_AGC,					0x1,		0x4,			6,		6},
+		{DVBT_EN_IF_AGC,					0x1,		0x4,			7,		7},
+		{DVBT_IF_AGC_MIN,					0x1,		0x8,			7,		0},
+		{DVBT_IF_AGC_MAX,					0x1,		0x9,			7,		0},
+		{DVBT_RF_AGC_MIN,					0x1,		0xa,			7,		0},
+		{DVBT_RF_AGC_MAX,					0x1,		0xb,			7,		0},
+		{DVBT_IF_AGC_MAN,					0x1,		0xc,			6,		6},
+		{DVBT_IF_AGC_MAN_VAL,				0x1,		0xc,			13,		0},
+		{DVBT_RF_AGC_MAN,					0x1,		0xe,			6,		6},
+		{DVBT_RF_AGC_MAN_VAL,				0x1,		0xe,			13,		0},
+		{DVBT_DAGC_TRG_VAL,					0x1,		0x12,			7,		0},
+		{DVBT_AGC_TARG_VAL_0,				0x1,		0x2,			0,		0},
+		{DVBT_AGC_TARG_VAL_8_1,				0x1,		0x3,			7,		0},
+		{DVBT_AAGC_LOOP_GAIN,				0x1,		0xc7,			5,		1},
+		{DVBT_LOOP_GAIN2_3_0,				0x1,		0x4,			4,		1},
+		{DVBT_LOOP_GAIN2_4,					0x1,		0x5,			7,		7},
+		{DVBT_LOOP_GAIN3,					0x1,		0xc8,			4,		0},
+		{DVBT_VTOP1,						0x1,		0x6,			5,		0},
+		{DVBT_VTOP2,						0x1,		0xc9,			5,		0},
+		{DVBT_VTOP3,						0x1,		0xca,			5,		0},
+		{DVBT_KRF1,							0x1,		0xcb,			7,		0},
+		{DVBT_KRF2,							0x1,		0x7,			7,		0},
+		{DVBT_KRF3,							0x1,		0xcd,			7,		0},
+		{DVBT_KRF4,							0x1,		0xce,			7,		0},
+		{DVBT_EN_GI_PGA,					0x1,		0xe5,			0,		0},
+		{DVBT_THD_LOCK_UP,					0x1,		0xd9,			8,		0},
+		{DVBT_THD_LOCK_DW,					0x1,		0xdb,			8,		0},
+		{DVBT_THD_UP1,						0x1,		0xdd,			7,		0},
+		{DVBT_THD_DW1,						0x1,		0xde,			7,		0},
+		{DVBT_INTER_CNT_LEN,				0x1,		0xd8,			3,		0},
+		{DVBT_GI_PGA_STATE,					0x1,		0xe6,			3,		3},
+		{DVBT_EN_AGC_PGA,					0x1,		0xd7,			0,		0},
+
+		// TS interface registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_CKOUTPAR,						0x1,		0x7b,			5,		5},
+		{DVBT_CKOUT_PWR,					0x1,		0x7b,			6,		6},
+		{DVBT_SYNC_DUR,						0x1,		0x7b,			7,		7},
+		{DVBT_ERR_DUR,						0x1,		0x7c,			0,		0},
+		{DVBT_SYNC_LVL,						0x1,		0x7c,			1,		1},
+		{DVBT_ERR_LVL,						0x1,		0x7c,			2,		2},
+		{DVBT_VAL_LVL,						0x1,		0x7c,			3,		3},
+		{DVBT_SERIAL,						0x1,		0x7c,			4,		4},
+		{DVBT_SER_LSB,						0x1,		0x7c,			5,		5},
+		{DVBT_CDIV_PH0,						0x1,		0x7d,			3,		0},
+		{DVBT_CDIV_PH1,						0x1,		0x7d,			7,		4},
+		{DVBT_MPEG_IO_OPT_2_2,				0x0,		0x6,			7,		7},
+		{DVBT_MPEG_IO_OPT_1_0,				0x0,		0x7,			7,		6},
+		{DVBT_CKOUTPAR_PIP,					0x0,		0xb7,			4,		4},
+		{DVBT_CKOUT_PWR_PIP,				0x0,		0xb7,			3,		3},
+		{DVBT_SYNC_LVL_PIP,					0x0,		0xb7,			2,		2},
+		{DVBT_ERR_LVL_PIP,					0x0,		0xb7,			1,		1},
+		{DVBT_VAL_LVL_PIP,					0x0,		0xb7,			0,		0},
+		{DVBT_CKOUTPAR_PID,					0x0,		0xb9,			4,		4},
+		{DVBT_CKOUT_PWR_PID,				0x0,		0xb9,			3,		3},
+		{DVBT_SYNC_LVL_PID,					0x0,		0xb9,			2,		2},
+		{DVBT_ERR_LVL_PID,					0x0,		0xb9,			1,		1},
+		{DVBT_VAL_LVL_PID,					0x0,		0xb9,			0,		0},
+
+		// FSM state-holding register
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_SM_PASS,						0x1,		0x93,			11,		0},
+
+		// AD7 registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_AD7_SETTING,					0x0,		0x11,			15,		0},
+		{DVBT_RSSI_R,						0x3,		0x1,			6,		0},
+
+		// ACI detection registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_ACI_DET_IND,					0x3,		0x12,			0,		0},
+
+		// Clock output registers
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DVBT_REG_MON,						0x0,		0xd,			1,		0},
+		{DVBT_REG_MONSEL,					0x0,		0xd,			2,		2},
+		{DVBT_REG_GPE,						0x0,		0xd,			7,		7},
+		{DVBT_REG_GPO,						0x0,		0x10,			0,		0},
+		{DVBT_REG_4MSEL,					0x0,		0x13,			0,		0},
+	};
+
+
+	int i;
+	int RegBitName;
+
+
+
+	// Initialize register table according to primary register table.
+	// Note: 1. Register table rows are sorted by register bit name key.
+	//       2. The default value of the IsAvailable variable is "NO".
+	for(i = 0; i < DVBT_REG_TABLE_LEN_MAX; i++)
+		pDemod->RegTable[i].IsAvailable  = NO;
+
+	for(i = 0; i < RTL2832_REG_TABLE_LEN; i++)
+	{
+		RegBitName = PrimaryRegTable[i].RegBitName;
+
+		pDemod->RegTable[RegBitName].IsAvailable  = YES;
+		pDemod->RegTable[RegBitName].PageNo       = PrimaryRegTable[i].PageNo;
+		pDemod->RegTable[RegBitName].RegStartAddr = PrimaryRegTable[i].RegStartAddr;
+		pDemod->RegTable[RegBitName].Msb          = PrimaryRegTable[i].Msb;
+		pDemod->RegTable[RegBitName].Lsb          = PrimaryRegTable[i].Lsb;
+	}
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set I2C bridge module demod arguments.
+
+RTL2832 builder will use rtl2832_BuildI2cBridgeModule() to set I2C bridge module demod arguments.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@see   BuildRtl2832Module()
+
+*/
+void
+rtl2832_BuildI2cBridgeModule(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+
+	// Get I2C bridge module.
+	pI2cBridge = pDemod->pI2cBridge;
+
+	// Set I2C bridge module demod arguments.
+	pI2cBridge->pPrivateData = (void *)pDemod;
+	pI2cBridge->ForwardI2cReadingCmd = rtl2832_ForwardI2cReadingCmd;
+	pI2cBridge->ForwardI2cWritingCmd = rtl2832_ForwardI2cWritingCmd;
+
+
+	return;
+}
+
+
+
+
+
+/*
+
+@see   RTL2832_FP_GET_APP_MODE
+
+*/
+void
+rtl2832_GetAppMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAppMode
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Get demod type from demod module.
+	*pAppMode = pExtra->AppMode;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Reset Function 1 variables and registers.
+
+One can use rtl2832_func1_Reset() to reset Function 1 variables and registers.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset Function 1 variables and registers successfully.
+@retval   FUNCTION_ERROR     Reset Function 1 variables and registers unsuccessfully.
+
+
+@note
+	-# Need to execute Function 1 reset function when change tuner RF frequency or demod parameters.
+	-# Function 1 update flow also employs Function 1 reset function.
+
+*/
+int
+rtl2832_func1_Reset(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+	// Reset demod Function 1 variables.
+	pExtra->Func1State               = RTL2832_FUNC1_STATE_NORMAL;
+	pExtra->Func1WaitTime            = 0;
+	pExtra->Func1GettingTime         = 0;
+	pExtra->Func1RsdBerEstSumNormal  = 0;
+	pExtra->Func1RsdBerEstSumConfig1 = 0;
+	pExtra->Func1RsdBerEstSumConfig2 = 0;
+	pExtra->Func1RsdBerEstSumConfig3 = 0;
+
+
+	// Reset demod Function 1 registers.
+    if(rtl2832_func1_ResetReg(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Update demod registers with Function 1.
+
+One can use rtl2832_func1_Update() to update demod registers with Function 1.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod registers with Function 1 successfully.
+@retval   FUNCTION_ERROR     Update demod registers with Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_Update(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+	int Answer;
+	int MinWeightedBerConfigMode;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Run FSM.
+	switch(pExtra->Func1State)
+	{
+		case RTL2832_FUNC1_STATE_NORMAL:
+
+			// Ask if criterion is matched.
+			if(rtl2832_func1_IsCriterionMatched(pDemod, &Answer) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			if(Answer == YES)
+			{
+				// Accumulate RSD_BER_EST for normal case.
+				if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumNormal) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset getting time counter.
+				pExtra->Func1GettingTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_NORMAL_GET_BER state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_NORMAL_GET_BER;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_NORMAL_GET_BER:
+
+			// Accumulate RSD_BER_EST for normal case.
+			if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumNormal) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			// Use getting time counter to hold RTL2832_FUNC1_STATE_NORMAL_GET_BER state several times.
+			pExtra->Func1GettingTime += 1;
+
+			if(pExtra->Func1GettingTime >= pExtra->Func1GettingTimeMax)
+			{
+				// Set common registers for configuration 1, 2, and 3 case.
+				if(rtl2832_func1_SetCommonReg(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Set registers with FFT mode for configuration 1, 2, and 3 case.
+				if(rtl2832_func1_SetRegWithFftMode(pDemod, pExtra->Func1FftBak) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Set registers for configuration 1 case.
+				if(rtl2832_func1_SetRegWithConfigMode(pDemod, RTL2832_FUNC1_CONFIG_1) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset demod by software reset.
+				if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset wait time counter.
+				pExtra->Func1WaitTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_1_WAIT state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_1_WAIT;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_1_WAIT:
+
+			// Use wait time counter to hold RTL2832_FUNC1_STATE_CONFIG_1_WAIT state several times.
+			pExtra->Func1WaitTime += 1;
+
+			if(pExtra->Func1WaitTime >= pExtra->Func1WaitTimeMax)
+			{
+				// Accumulate RSD_BER_EST for configuration 1 case.
+				if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig1) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset getting time counter.
+				pExtra->Func1GettingTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_1_GET_BER state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_1_GET_BER;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_1_GET_BER:
+
+			// Accumulate RSD_BER_EST for configuration 1 case.
+			if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig1) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			// Use getting time counter to hold RTL2832_FUNC1_STATE_CONFIG_1_GET_BER state several times.
+			pExtra->Func1GettingTime += 1;
+
+			if(pExtra->Func1GettingTime >= pExtra->Func1GettingTimeMax)
+			{
+				// Set registers for configuration 2 case.
+				if(rtl2832_func1_SetRegWithConfigMode(pDemod, RTL2832_FUNC1_CONFIG_2) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset demod by software reset.
+				if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset wait time counter.
+				pExtra->Func1WaitTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_2_WAIT state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_2_WAIT;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_2_WAIT:
+
+			// Use wait time counter to hold RTL2832_FUNC1_STATE_CONFIG_2_WAIT state several times.
+			pExtra->Func1WaitTime += 1;
+
+			if(pExtra->Func1WaitTime >= pExtra->Func1WaitTimeMax)
+			{
+				// Accumulate RSD_BER_EST for configuration 2 case.
+				if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig2) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset getting time counter.
+				pExtra->Func1GettingTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_2_GET_BER state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_2_GET_BER;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_2_GET_BER:
+
+			// Accumulate RSD_BER_EST for configuration 2 case.
+			if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig2) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			// Use getting time counter to hold RTL2832_FUNC1_STATE_CONFIG_2_GET_BER state several times.
+			pExtra->Func1GettingTime += 1;
+
+			if(pExtra->Func1GettingTime >= pExtra->Func1GettingTimeMax)
+			{
+				// Set registers for configuration 3 case.
+				if(rtl2832_func1_SetRegWithConfigMode(pDemod, RTL2832_FUNC1_CONFIG_3) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset demod by software reset.
+				if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset wait time counter.
+				pExtra->Func1WaitTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_3_WAIT state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_3_WAIT;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_3_WAIT:
+
+			// Use wait time counter to hold RTL2832_FUNC1_STATE_CONFIG_3_WAIT state several times.
+			pExtra->Func1WaitTime += 1;
+
+			if(pExtra->Func1WaitTime >= pExtra->Func1WaitTimeMax)
+			{
+				// Accumulate RSD_BER_EST for configuration 3 case.
+				if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig3) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset getting time counter.
+				pExtra->Func1GettingTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_CONFIG_3_GET_BER state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_CONFIG_3_GET_BER;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_CONFIG_3_GET_BER:
+
+			// Accumulate RSD_BER_EST for configuration 3 case.
+			if(rtl2832_func1_AccumulateRsdBerEst(pDemod, &pExtra->Func1RsdBerEstSumConfig3) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			// Use getting time counter to hold RTL2832_FUNC1_STATE_CONFIG_3_GET_BER state several times.
+			pExtra->Func1GettingTime += 1;
+
+			if(pExtra->Func1GettingTime >= pExtra->Func1GettingTimeMax)
+			{
+				// Determine minimum-weighted-BER configuration mode.
+				rtl2832_func1_GetMinWeightedBerConfigMode(pDemod, &MinWeightedBerConfigMode);
+
+				// Set registers with minimum-weighted-BER configuration mode.
+				switch(MinWeightedBerConfigMode)
+				{
+					case RTL2832_FUNC1_CONFIG_NORMAL:
+
+						// Reset registers for normal configuration.
+						if(rtl2832_func1_ResetReg(pDemod) != FUNCTION_SUCCESS)
+							goto error_status_execute_function;
+
+						break;
+
+
+					case RTL2832_FUNC1_CONFIG_1:
+					case RTL2832_FUNC1_CONFIG_2:
+					case RTL2832_FUNC1_CONFIG_3:
+
+						// Set registers for minimum-weighted-BER configuration.
+						if(rtl2832_func1_SetRegWithConfigMode(pDemod, MinWeightedBerConfigMode) != FUNCTION_SUCCESS)
+							goto error_status_execute_function;
+
+						break;
+
+
+					default:
+
+						// Get error configuration mode, reset registers.
+						if(rtl2832_func1_ResetReg(pDemod) != FUNCTION_SUCCESS)
+							goto error_status_execute_function;
+
+						break;
+				}
+
+				// Reset demod by software reset.
+				if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+
+				// Reset wait time counter.
+				pExtra->Func1WaitTime = 0;
+
+				// Go to RTL2832_FUNC1_STATE_DETERMINED_WAIT state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_DETERMINED_WAIT;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_DETERMINED_WAIT:
+
+			// Use wait time counter to hold RTL2832_FUNC1_STATE_CONFIG_3_WAIT state several times.
+			pExtra->Func1WaitTime += 1;
+
+			if(pExtra->Func1WaitTime >= pExtra->Func1WaitTimeMax)
+			{
+				// Go to RTL2832_FUNC1_STATE_DETERMINED state.
+				pExtra->Func1State = RTL2832_FUNC1_STATE_DETERMINED;
+			}
+
+			break;
+
+
+		case RTL2832_FUNC1_STATE_DETERMINED:
+
+			// Ask if criterion is matched.
+			if(rtl2832_func1_IsCriterionMatched(pDemod, &Answer) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			if(Answer == NO)
+			{
+				// Reset FSM.
+				// Note: rtl2832_func1_Reset() will set FSM state with RTL2832_FUNC1_STATE_NORMAL.
+				if(rtl2832_func1_Reset(pDemod) != FUNCTION_SUCCESS)
+					goto error_status_execute_function;
+			}
+
+			break;
+
+
+		default:
+
+			// Get error state, reset FSM.
+			// Note: rtl2832_func1_Reset() will set FSM state with RTL2832_FUNC1_STATE_NORMAL.
+			if(rtl2832_func1_Reset(pDemod) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			break;
+	}
+
+
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Ask if criterion is matched for Function 1.
+
+One can use rtl2832_func1_IsCriterionMatched() to ask if criterion is matched for Function 1.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Ask if criterion is matched for Function 1 successfully.
+@retval   FUNCTION_ERROR     Ask if criterion is matched for Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_IsCriterionMatched(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+	unsigned long FsmStage;
+
+	int Qam;
+	int Hier;
+	int LpCr;
+	int HpCr;
+	int Gi;
+	int Fft;
+
+	unsigned long Reg0, Reg1;
+
+	int BandwidthMode;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Get FSM_STAGE.
+    if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Get QAM.
+	if(pDemod->GetConstellation(pDemod, &Qam) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get hierarchy.
+	if(pDemod->GetHierarchy(pDemod, &Hier) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get low-priority code rate.
+	if(pDemod->GetCodeRateLp(pDemod, &LpCr) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get high-priority code rate.
+	if(pDemod->GetCodeRateHp(pDemod, &HpCr) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get guard interval.
+	if(pDemod->GetGuardInterval(pDemod, &Gi) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get FFT mode.
+	if(pDemod->GetFftMode(pDemod, &Fft) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Get REG_0 and REG_1.
+	if(pDemod->SetRegPage(pDemod, 0x3) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->GetRegMaskBits(pDemod, 0x22, 0, 0, &Reg0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->GetRegMaskBits(pDemod, 0x1a, 15, 3, &Reg1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Get bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, &BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Determine criterion answer.
+	*pAnswer = 
+		(FsmStage == 11) && 
+
+		(Qam  == pExtra->Func1QamBak) &&
+		(Hier == pExtra->Func1HierBak) &&
+		(LpCr == pExtra->Func1LpCrBak) &&
+		(HpCr == pExtra->Func1HpCrBak) &&
+		(Gi   == pExtra->Func1GiBak) &&
+		(Fft  == pExtra->Func1FftBak) &&
+
+		(Reg0 == 0x1) &&
+
+		((BandwidthMode == DVBT_BANDWIDTH_8MHZ) &&
+		 ( ((Fft == DVBT_FFT_MODE_2K) && (Reg1 > 1424) && (Reg1 < 1440)) ||
+		   ((Fft == DVBT_FFT_MODE_8K) && (Reg1 > 5696) && (Reg1 < 5760))    ) );
+
+
+	// Backup TPS information.
+	pExtra->Func1QamBak  = Qam;
+	pExtra->Func1HierBak = Hier;
+	pExtra->Func1LpCrBak = LpCr;
+	pExtra->Func1HpCrBak = HpCr;
+	pExtra->Func1GiBak   = Gi;
+	pExtra->Func1FftBak  = Fft;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Accumulate RSD_BER_EST value for Function 1.
+
+One can use rtl2832_func1_AccumulateRsdBerEst() to accumulate RSD_BER_EST for Function 1.
+
+
+@param [in]   pDemod               The demod module pointer
+@param [in]   pAccumulativeValue   Accumulative RSD_BER_EST value
+
+
+@retval   FUNCTION_SUCCESS   Accumulate RSD_BER_EST for Function 1 successfully.
+@retval   FUNCTION_ERROR     Accumulate RSD_BER_EST for Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_AccumulateRsdBerEst(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pAccumulativeValue
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+	int i;
+	unsigned long RsdBerEst;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Get RSD_BER_EST with assigned times.
+	for(i = 0; i < pExtra->Func1GettingNumEachTime; i++)
+	{
+		// Get RSD_BER_EST.
+		if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSD_BER_EST, &RsdBerEst) != FUNCTION_SUCCESS)
+			goto error_status_get_registers;
+
+		// Accumulate RSD_BER_EST to accumulative value.
+		*pAccumulativeValue += RsdBerEst;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Reset registers for Function 1.
+
+One can use rtl2832_func1_ResetReg() to reset registers for Function 1.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset registers for Function 1 successfully.
+@retval   FUNCTION_ERROR     Reset registers for Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_ResetReg(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	// Reset Function 1 registers.
+    if(pDemod->SetRegPage(pDemod, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x65, 2, 0, 0x7) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x68, 5, 4, 0x3) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5b, 2, 0, 0x5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5b, 5, 3, 0x5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5c, 2, 0, 0x5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5c, 5, 3, 0x5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd0, 3, 2, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd1, 14, 0, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd3, 14, 0, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd5, 14, 0, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x1, 0, 0, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xb4, 7, 6, 0x3) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd2, 1, 1, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xb5, 7, 7, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set common registers for Function 1.
+
+One can use rtl2832_func1_SetCommonReg() to set common registers for Function 1.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Set common registers for Function 1 successfully.
+@retval   FUNCTION_ERROR     Set common registers for Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_SetCommonReg(
+	DVBT_DEMOD_MODULE *pDemod
+	)
+{
+	// Set common registers for Function 1.
+    if(pDemod->SetRegPage(pDemod, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x65, 2, 0, 0x5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x68, 5, 4, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd2, 1, 1, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xb5, 7, 7, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set registers with FFT mode for Function 1.
+
+One can use rtl2832_func1_SetRegWithConfigMode() to set registers with FFT mode for Function 1.
+
+
+@param [in]   pDemod    The demod module pointer
+@param [in]   FftMode   FFT mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set registers with FFT mode for Function 1 successfully.
+@retval   FUNCTION_ERROR     Set registers with FFT mode for Function 1 unsuccessfully.
+
+*/
+int
+rtl2832_func1_SetRegWithFftMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int FftMode
+	)
+{
+	typedef struct
+	{
+		unsigned long Reg0[DVBT_FFT_MODE_NUM];
+		unsigned long Reg1[DVBT_FFT_MODE_NUM];
+	}
+	FFT_REF_ENTRY;
+
+
+
+	static const FFT_REF_ENTRY FftRefTable =
+	{
+		// 2K mode,   8K mode
+		{0x0,         0x1    },
+		{0x3,         0x0    },
+	};
+
+
+
+	// Set registers with FFT mode for Function 1.
+    if(pDemod->SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x1, 0, 0, FftRefTable.Reg0[FftMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xb4, 7, 6, FftRefTable.Reg1[FftMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set registers with configuration mode for Function 1.
+
+One can use rtl2832_func1_SetRegWithConfigMode() to set registers with configuration mode for Function 1.
+
+
+@param [in]   pDemod       The demod module pointer
+@param [in]   ConfigMode   Configuration mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set registers with configuration mode for Function 1 successfully.
+@retval   FUNCTION_ERROR     Set registers with configuration mode for Function 1 unsuccessfully.
+
+
+@note
+	-# This function can not set RTL2832_FUNC1_CONFIG_NORMAL configuration mode.
+
+*/
+int
+rtl2832_func1_SetRegWithConfigMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int ConfigMode
+	)
+{
+	typedef struct
+	{
+		unsigned long Reg0[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg1[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg2[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg3[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg4[RTL2832_FUNC1_CONFIG_MODE_NUM];
+
+		unsigned long Reg5Ref[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg6Ref[RTL2832_FUNC1_CONFIG_MODE_NUM];
+		unsigned long Reg7Ref[RTL2832_FUNC1_CONFIG_MODE_NUM];
+	}
+	CONFIG_REF_ENTRY;
+
+
+
+	static const CONFIG_REF_ENTRY ConfigRefTable =
+	{
+		// Config 1,   Config 2,   Config 3
+		{0x5,          0x4,        0x5     },
+		{0x5,          0x4,        0x7     },
+		{0x5,          0x4,        0x7     },
+		{0x7,          0x6,        0x5     },
+		{0x3,          0x3,        0x2     },
+
+		{4437,         4437,       4325    },
+		{6000,         5500,       6500    },
+		{6552,         5800,       5850    },
+	};
+
+	int BandwidthMode;
+
+	static const unsigned long Const[DVBT_BANDWIDTH_MODE_NUM] =
+	{
+		// 6Mhz, 7Mhz, 8Mhz
+		48,      56,   64,
+	};
+
+	unsigned long Reg5, Reg6, Reg7;
+
+
+
+	// Get bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, &BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Calculate REG_5, REG_6, and REG_7 with bandwidth mode and configuration mode.
+	Reg5 = (ConfigRefTable.Reg5Ref[ConfigMode] * 7 * 2048 * 8) / (1000 * Const[BandwidthMode]);
+	Reg6 = (ConfigRefTable.Reg6Ref[ConfigMode] * 7 * 2048 * 8) / (1000 * Const[BandwidthMode]);
+	Reg7 = (ConfigRefTable.Reg7Ref[ConfigMode] * 7 * 2048 * 8) / (1000 * Const[BandwidthMode]);
+
+
+	// Set registers with bandwidth mode and configuration mode.
+    if(pDemod->SetRegPage(pDemod, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5b, 2, 0, ConfigRefTable.Reg0[ConfigMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5b, 5, 3, ConfigRefTable.Reg1[ConfigMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5c, 2, 0, ConfigRefTable.Reg2[ConfigMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0x5c, 5, 3, ConfigRefTable.Reg3[ConfigMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd0, 3, 2, ConfigRefTable.Reg4[ConfigMode]) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd1, 14, 0, Reg5) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd3, 14, 0, Reg6) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+    if(pDemod->SetRegMaskBits(pDemod, 0xd5, 14, 0, Reg7) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get minimum-weighted-BER configuration mode for Function 1.
+
+One can use rtl2832_func1_GetMinWeightedBerConfigMode() to get minimum-weighted-BER configuration mode for Function 1.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pConfigMode   Pointer to an allocated memory for storing configuration mode answer
+
+
+@retval   FUNCTION_SUCCESS   Get minimum-weighted-BER configuration mode for Function 1 successfully.
+@retval   FUNCTION_ERROR     Get minimum-weighted-BER configuration mode for Function 1 unsuccessfully.
+
+*/
+void
+rtl2832_func1_GetMinWeightedBerConfigMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pConfigMode
+	)
+{
+	RTL2832_EXTRA_MODULE *pExtra;
+
+	unsigned long WeightedBerNormal;
+	unsigned long WeightedBerConfig1;
+	unsigned long WeightedBerConfig2;
+	unsigned long WeightedBerConfig3;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2832);
+
+
+	// Calculate weighted BER for all configuration mode
+	WeightedBerNormal  = pExtra->Func1RsdBerEstSumNormal * 2;
+	WeightedBerConfig1 = pExtra->Func1RsdBerEstSumConfig1;
+	WeightedBerConfig2 = pExtra->Func1RsdBerEstSumConfig2;
+	WeightedBerConfig3 = pExtra->Func1RsdBerEstSumConfig3;
+
+
+	// Determine minimum-weighted-BER configuration mode.
+	if(WeightedBerNormal <= WeightedBerConfig1 &&
+		WeightedBerNormal <= WeightedBerConfig2 &&
+		WeightedBerNormal <= WeightedBerConfig3)
+	{
+		*pConfigMode = RTL2832_FUNC1_CONFIG_NORMAL;
+	}
+	else if(WeightedBerConfig1 <= WeightedBerNormal &&
+		WeightedBerConfig1 <= WeightedBerConfig2 &&
+		WeightedBerConfig1 <= WeightedBerConfig3)
+	{
+		*pConfigMode = RTL2832_FUNC1_CONFIG_1;
+	}
+	else if(WeightedBerConfig2 <= WeightedBerNormal &&
+		WeightedBerConfig2 <= WeightedBerConfig1 &&
+		WeightedBerConfig2 <= WeightedBerConfig3)
+	{
+		*pConfigMode = RTL2832_FUNC1_CONFIG_2;
+	}
+	else if(WeightedBerConfig3 <= WeightedBerNormal &&
+		WeightedBerConfig3 <= WeightedBerConfig1 &&
+		WeightedBerConfig3 <= WeightedBerConfig2)
+	{
+		*pConfigMode = RTL2832_FUNC1_CONFIG_3;
+	}
+
+
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2832.h b/drivers/media/usb/rtl2832u/demod_rtl2832.h
new file mode 100644
index 00000000..d9fd4f1f
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2832.h
@@ -0,0 +1,466 @@
+#ifndef __DEMOD_RTL2832_H
+#define __DEMOD_RTL2832_H
+
+/**
+
+@file
+
+@brief   RTL2832 demod module declaration
+
+One can manipulate RTL2832 demod through RTL2832 module.
+RTL2832 module is derived from DVB-T demod module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the DVB-T demod example in dvbt_demod_base.h except the listed lines.
+
+
+
+#include "demod_rtl2832.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+	DVBT_DEMOD_MODULE     DvbtDemodModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+
+	...
+
+
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pDemod,
+		&DvbtDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x20,								// I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,			// Crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,				// TS interface mode is serial.
+		RTL2832_APPLICATION_STB,			// Application mode is STB.
+		200,								// Update function reference period is 200 millisecond
+		YES									// Function 1 enabling status is YES.
+		);
+
+
+
+	// See the example for other DVB-T demod functions in dvbt_demod_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "dvbt_demod_base.h"
+
+
+
+
+
+// Definitions
+
+// Initializing
+#define RTL2832_INIT_TABLE_LEN						32
+#define RTL2832_TS_INTERFACE_INIT_TABLE_LEN			5
+#define RTL2832_APP_INIT_TABLE_LEN					5
+
+
+// Bandwidth setting
+#define RTL2832_H_LPF_X_PAGE		1
+#define RTL2832_H_LPF_X_ADDR		0x1c
+#define RTL2832_H_LPF_X_LEN			32
+#define RTL2832_RATIO_PAGE			1
+#define RTL2832_RATIO_ADDR			0x9d
+#define RTL2832_RATIO_LEN			6
+
+
+// Bandwidth setting
+#define RTL2832_CFREQ_OFF_RATIO_BIT_NUM		20
+
+
+// IF frequency setting
+#define RTL2832_PSET_IFFREQ_BIT_NUM		22
+
+
+// Signal quality
+#define RTL2832_SQ_FRAC_BIT_NUM			5
+
+
+// BER
+#define RTL2832_BER_DEN_VALUE				1000000
+
+
+// SNR
+#define RTL2832_CE_EST_EVM_MAX_VALUE		65535
+#define RTL2832_SNR_FRAC_BIT_NUM			10
+#define RTL2832_SNR_DB_DEN					3402
+
+
+// AGC
+#define RTL2832_RF_AGC_REG_BIT_NUM		14
+#define RTL2832_IF_AGC_REG_BIT_NUM		14
+
+
+// TR offset and CR offset
+#define RTL2832_SFREQ_OFF_BIT_NUM		14
+#define RTL2832_CFREQ_OFF_BIT_NUM		18
+
+
+// Register table length
+#define RTL2832_REG_TABLE_LEN			127
+
+
+// Function 1
+#define RTL2832_FUNC1_WAIT_TIME_MS			500
+#define RTL2832_FUNC1_GETTING_TIME_MS		200
+#define RTL2832_FUNC1_GETTING_NUM_MIN		20
+
+
+
+/// Demod application modes
+enum RTL2832_APPLICATION_MODE
+{
+	RTL2832_APPLICATION_DONGLE,
+	RTL2832_APPLICATION_STB,
+};
+#define RTL2832_APPLICATION_MODE_NUM		2
+
+
+// Function 1
+enum RTL2832_FUNC1_CONFIG_MODE
+{
+	RTL2832_FUNC1_CONFIG_1,
+	RTL2832_FUNC1_CONFIG_2,
+	RTL2832_FUNC1_CONFIG_3,
+};
+#define RTL2832_FUNC1_CONFIG_MODE_NUM		3
+#define RTL2832_FUNC1_CONFIG_NORMAL			-1
+
+
+enum RTL2832_FUNC1_STATE
+{
+	RTL2832_FUNC1_STATE_NORMAL,
+	RTL2832_FUNC1_STATE_NORMAL_GET_BER,
+	RTL2832_FUNC1_STATE_CONFIG_1_WAIT,
+	RTL2832_FUNC1_STATE_CONFIG_1_GET_BER,
+	RTL2832_FUNC1_STATE_CONFIG_2_WAIT,
+	RTL2832_FUNC1_STATE_CONFIG_2_GET_BER,
+	RTL2832_FUNC1_STATE_CONFIG_3_WAIT,
+	RTL2832_FUNC1_STATE_CONFIG_3_GET_BER,
+	RTL2832_FUNC1_STATE_DETERMINED_WAIT,
+	RTL2832_FUNC1_STATE_DETERMINED,
+};
+
+
+
+
+
+// Demod module builder
+void
+BuildRtl2832Module(
+	DVBT_DEMOD_MODULE **ppDemod,
+	DVBT_DEMOD_MODULE *pDvbtDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	int AppMode,
+	unsigned long UpdateFuncRefPeriodMs,
+	int IsFunc1Enabled
+	);
+
+
+
+
+
+// Manipulating functions
+void
+rtl2832_IsConnectedToI2c(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+);
+
+int
+rtl2832_SoftwareReset(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_Initialize(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_SetBandwidthMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int BandwidthMode
+	);
+
+int
+rtl2832_SetIfFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+int
+rtl2832_SetSpectrumMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+int
+rtl2832_IsTpsLocked(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2832_IsSignalLocked(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2832_GetSignalStrength(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+int
+rtl2832_GetSignalQuality(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+int
+rtl2832_GetBer(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+int
+rtl2832_GetSnrDb(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+rtl2832_GetRfAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+int
+rtl2832_GetIfAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+int
+rtl2832_GetDiAgc(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDiAgc
+	);
+
+int
+rtl2832_GetTrOffsetPpm(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+int
+rtl2832_GetCrOffsetHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+int
+rtl2832_GetConstellation(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pConstellation
+	);
+
+int
+rtl2832_GetHierarchy(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pHierarchy
+	);
+
+int
+rtl2832_GetCodeRateLp(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateLp
+	);
+
+int
+rtl2832_GetCodeRateHp(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateHp
+	);
+
+int
+rtl2832_GetGuardInterval(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pGuardInterval
+	);
+
+int
+rtl2832_GetFftMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pFftMode
+	);
+
+int
+rtl2832_UpdateFunction(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_ResetFunction(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// I2C command forwarding functions
+int
+rtl2832_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+rtl2832_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+// Register table initializing
+void
+rtl2832_InitRegTable(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// I2C birdge module builder
+void
+rtl2832_BuildI2cBridgeModule(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// RTL2832 extra functions
+void
+rtl2832_GetAppMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAppMode
+	);
+
+
+
+
+
+// RTL2832 dependence
+int
+rtl2832_func1_Reset(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_func1_Update(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_func1_IsCriterionMatched(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2832_func1_AccumulateRsdBerEst(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pAccumulativeValue
+	);
+
+int
+rtl2832_func1_ResetReg(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_func1_SetCommonReg(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2832_func1_SetRegWithFftMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int FftMode
+	);
+
+int
+rtl2832_func1_SetRegWithConfigMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int ConfigMode
+	);
+
+void
+rtl2832_func1_GetMinWeightedBerConfigMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pConfigMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2836.c b/drivers/media/usb/rtl2832u/demod_rtl2836.c
new file mode 100644
index 00000000..90fae89d
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2836.c
@@ -0,0 +1,2049 @@
+/**
+
+@file
+
+@brief   RTL2836 demod module definition
+
+One can manipulate RTL2836 demod through RTL2836 module.
+RTL2836 module is derived from DTMB demod module.
+
+*/
+
+
+#include "demod_rtl2836.h"
+
+
+
+
+
+/**
+
+@brief   RTL2836 demod module builder
+
+Use BuildRtl2836Module() to build RTL2836 module, set all module function pointers with the corresponding
+functions, and initialize module private variables.
+
+
+@param [in]   ppDemod                      Pointer to RTL2836 demod module pointer
+@param [in]   pDtmbDemodModuleMemory       Pointer to an allocated DTMB demod module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   RTL2836 I2C device address
+@param [in]   CrystalFreqHz                RTL2836 crystal frequency in Hz
+@param [in]   TsInterfaceMode              RTL2836 TS interface mode for setting
+@param [in]   UpdateFuncRefPeriodMs        RTL2836 update function reference period in millisecond
+@param [in]   IsFunc1Enabled               RTL2836 Function 1 enabling status for setting
+@param [in]   IsFunc2Enabled               RTL2836 Function 2 enabling status for setting
+
+
+@note
+	-# One should call BuildRtl2836Module() to build RTL2836 module before using it.
+
+*/
+void
+BuildRtl2836Module(
+	DTMB_DEMOD_MODULE **ppDemod,
+	DTMB_DEMOD_MODULE *pDtmbDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	unsigned long UpdateFuncRefPeriodMs,
+	int IsFunc1Enabled,
+	int IsFunc2Enabled
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	RTL2836_EXTRA_MODULE *pExtra;
+
+
+
+	// Set demod module pointer, 
+	*ppDemod = pDtmbDemodModuleMemory;
+
+	// Get demod module.
+	pDemod = *ppDemod;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pDemod->pBaseInterface = pBaseInterfaceModuleMemory;
+	pDemod->pI2cBridge     = pI2cBridgeModuleMemory;
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+
+	// Set demod type.
+	pDemod->DemodType = DTMB_DEMOD_TYPE_RTL2836;
+
+	// Set demod I2C device address.
+	pDemod->DeviceAddr = DeviceAddr;
+
+	// Set demod crystal frequency in Hz.
+	pDemod->CrystalFreqHz = CrystalFreqHz;
+
+	// Set demod TS interface mode.
+	pDemod->TsInterfaceMode = TsInterfaceMode;
+
+
+	// Initialize demod parameter setting status
+	pDemod->IsIfFreqHzSet      = NO;
+	pDemod->IsSpectrumModeSet  = NO;
+
+
+	// Initialize demod register table.
+	rtl2836_InitRegTable(pDemod);
+
+	
+	// Build I2C birdge module.
+	rtl2836_BuildI2cBridgeModule(pDemod);
+
+
+	// Set demod module I2C function pointers with 8-bit address default functions.
+	pDemod->RegAccess.Addr8Bit.SetRegPage         = dtmb_demod_addr_8bit_default_SetRegPage;
+	pDemod->RegAccess.Addr8Bit.SetRegBytes        = dtmb_demod_addr_8bit_default_SetRegBytes;
+	pDemod->RegAccess.Addr8Bit.GetRegBytes        = dtmb_demod_addr_8bit_default_GetRegBytes;
+	pDemod->RegAccess.Addr8Bit.SetRegMaskBits     = dtmb_demod_addr_8bit_default_SetRegMaskBits;
+	pDemod->RegAccess.Addr8Bit.GetRegMaskBits     = dtmb_demod_addr_8bit_default_GetRegMaskBits;
+	pDemod->RegAccess.Addr8Bit.SetRegBits         = dtmb_demod_addr_8bit_default_SetRegBits;
+	pDemod->RegAccess.Addr8Bit.GetRegBits         = dtmb_demod_addr_8bit_default_GetRegBits;
+	pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage = dtmb_demod_addr_8bit_default_SetRegBitsWithPage;
+	pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage = dtmb_demod_addr_8bit_default_GetRegBitsWithPage;
+
+
+	// Set demod module manipulating function pointers with default functions.
+	pDemod->GetDemodType     = dtmb_demod_default_GetDemodType;
+	pDemod->GetDeviceAddr    = dtmb_demod_default_GetDeviceAddr;
+	pDemod->GetCrystalFreqHz = dtmb_demod_default_GetCrystalFreqHz;
+
+	pDemod->GetIfFreqHz      = dtmb_demod_default_GetIfFreqHz;
+	pDemod->GetSpectrumMode  = dtmb_demod_default_GetSpectrumMode;
+
+
+	// Set demod module manipulating function pointers with particular functions.
+	pDemod->IsConnectedToI2c       = rtl2836_IsConnectedToI2c;
+	pDemod->SoftwareReset          = rtl2836_SoftwareReset;
+	pDemod->Initialize             = rtl2836_Initialize;
+	pDemod->SetIfFreqHz            = rtl2836_SetIfFreqHz;
+	pDemod->SetSpectrumMode        = rtl2836_SetSpectrumMode;
+
+	pDemod->IsSignalLocked         = rtl2836_IsSignalLocked;
+
+	pDemod->GetSignalStrength      = rtl2836_GetSignalStrength;
+	pDemod->GetSignalQuality       = rtl2836_GetSignalQuality;
+
+	pDemod->GetBer                 = rtl2836_GetBer;
+	pDemod->GetPer                 = rtl2836_GetPer;
+	pDemod->GetSnrDb               = rtl2836_GetSnrDb;
+
+	pDemod->GetRfAgc               = rtl2836_GetRfAgc;
+	pDemod->GetIfAgc               = rtl2836_GetIfAgc;
+	pDemod->GetDiAgc               = rtl2836_GetDiAgc;
+
+	pDemod->GetTrOffsetPpm         = rtl2836_GetTrOffsetPpm;
+	pDemod->GetCrOffsetHz          = rtl2836_GetCrOffsetHz;
+
+	pDemod->GetCarrierMode         = rtl2836_GetCarrierMode;
+	pDemod->GetPnMode              = rtl2836_GetPnMode;
+	pDemod->GetQamMode             = rtl2836_GetQamMode;
+	pDemod->GetCodeRateMode        = rtl2836_GetCodeRateMode;
+	pDemod->GetTimeInterleaverMode = rtl2836_GetTimeInterleaverMode;
+
+	pDemod->UpdateFunction         = rtl2836_UpdateFunction;
+	pDemod->ResetFunction          = rtl2836_ResetFunction;
+
+
+	// Initialize demod Function 1 variables.
+	pExtra->IsFunc1Enabled = IsFunc1Enabled;
+	pExtra->Func1CntThd = DivideWithCeiling(RTL2836_FUNC1_CHECK_TIME_MS, UpdateFuncRefPeriodMs);
+	pExtra->Func1Cnt = 0;
+
+	// Initialize demod Function 2 variables.
+	pExtra->IsFunc2Enabled = IsFunc2Enabled;
+	pExtra->Func2SignalModePrevious = RTL2836_FUNC2_SIGNAL_NORMAL;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_IS_CONNECTED_TO_I2C
+
+*/
+void
+rtl2836_IsConnectedToI2c(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long ChipId;
+
+
+
+	// Get CHIP_ID.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_CHIP_ID, &ChipId) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Check chip ID value.
+	if(ChipId != RTL2836_CHIP_ID_VALUE)
+		goto error_status_check_value;
+
+
+	// Set I2cConnectionStatus with YES.
+	*pAnswer = YES;
+
+
+	return;
+
+
+error_status_check_value:
+error_status_get_registers:
+
+	// Set I2cConnectionStatus with NO.
+	*pAnswer = NO;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SOFTWARE_RESET
+
+*/
+int
+rtl2836_SoftwareReset(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	// Set SOFT_RST with 0x0. Then, set SOFT_RST with 0x1.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_SOFT_RST_N, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_SOFT_RST_N, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_INITIALIZE
+
+*/
+int
+rtl2836_Initialize(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	// Initializing table entry only used in Initialize()
+	typedef struct
+	{
+		unsigned char PageNo;
+		unsigned char RegStartAddr;
+		unsigned char Msb;
+		unsigned char Lsb;
+		unsigned long WritingValue;
+	}
+	INIT_TABLE_ENTRY;
+
+	// TS interface initializing table entry only used in Initialize()
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long WritingValue[TS_INTERFACE_MODE_NUM];
+	}
+	TS_INTERFACE_INIT_TABLE_ENTRY;
+
+
+
+	static const INIT_TABLE_ENTRY InitRegTable[RTL2836_INIT_REG_TABLE_LEN] =
+	{
+		// PageNo,	RegStartAddr,	Msb,	Lsb,	WritingValue
+		{0x0,		0x1,			0,		0,		0x1			},
+		{0x0,		0x2,			4,		4,		0x0			},
+		{0x0,		0x3,			2,		0,		0x0			},
+		{0x0,		0xe,			5,		5,		0x1			},
+		{0x0,		0x11,			3,		3,		0x0			},
+		{0x0,		0x12,			1,		0,		0x1			},
+		{0x0,		0x16,			2,		0,		0x3			},
+		{0x0,		0x19,			7,		0,		0x19		},
+		{0x0,		0x1b,			7,		0,		0xcc		},
+		{0x0,		0x1f,			7,		0,		0x5			},
+		{0x0,		0x20,			2,		2,		0x1			},
+		{0x0,		0x20,			3,		3,		0x0			},
+		{0x1,		0x3,			7,		0,		0x38		},
+		{0x1,		0x31,			1,		1,		0x0			},
+		{0x1,		0x67,			7,		0,		0x30		},
+		{0x1,		0x68,			7,		0,		0x10		},
+		{0x1,		0x7f,			3,		2,		0x1			},
+		{0x1,		0xda,			7,		7,		0x1			},
+		{0x1,		0xdb,			7,		0,		0x5			},
+		{0x2,		0x9,			7,		0,		0xa			},
+		{0x2,		0x10,			7,		0,		0x31		},
+		{0x2,		0x11,			7,		0,		0x31		},
+		{0x2,		0x1b,			7,		0,		0x1e		},
+		{0x2,		0x1e,			7,		0,		0x3a		},
+		{0x2,		0x1f,			5,		3,		0x3			},
+		{0x2,		0x21,			7,		0,		0x3f		},
+		{0x2,		0x24,			6,		5,		0x0			},
+		{0x2,		0x27,			7,		0,		0x17		},
+		{0x2,		0x31,			7,		0,		0x35		},
+		{0x2,		0x32,			7,		0,		0x3f		},
+		{0x2,		0x4f,			3,		2,		0x2			},
+		{0x2,		0x5a,			7,		0,		0x5			},
+		{0x2,		0x5b,			7,		0,		0x8			},
+		{0x2,		0x5c,			7,		0,		0x8			},
+		{0x2,		0x5e,			7,		5,		0x5			},
+		{0x2,		0x70,			0,		0,		0x0			},
+		{0x2,		0x77,			0,		0,		0x1			},
+		{0x2,		0x7a,			7,		0,		0x2f		},
+		{0x2,		0x81,			3,		2,		0x2			},
+		{0x2,		0x8d,			7,		0,		0x77		},
+		{0x2,		0x8e,			7,		4,		0x8			},
+		{0x2,		0x93,			7,		0,		0xff		},
+		{0x2,		0x94,			7,		0,		0x3			},
+		{0x2,		0x9d,			7,		0,		0xff		},
+		{0x2,		0x9e,			7,		0,		0x3			},
+		{0x2,		0xa8,			7,		0,		0xff		},
+		{0x2,		0xa9,			7,		0,		0x3			},
+		{0x2,		0xa3,			2,		2,		0x1			},
+		{0x3,		0x1,			7,		0,		0x0			},
+		{0x3,		0x4,			7,		0,		0x20		},
+		{0x3,		0x9,			7,		0,		0x10		},
+		{0x3,		0x14,			7,		0,		0xe4		},
+		{0x3,		0x15,			7,		0,		0x62		},
+		{0x3,		0x16,			7,		0,		0x8c		},
+		{0x3,		0x17,			7,		0,		0x11		},
+		{0x3,		0x1b,			7,		0,		0x40		},
+		{0x3,		0x1c,			7,		0,		0x14		},
+		{0x3,		0x23,			7,		0,		0x40		},
+		{0x3,		0x24,			7,		0,		0xd6		},
+		{0x3,		0x2b,			7,		0,		0x60		},
+		{0x3,		0x2c,			7,		0,		0x16		},
+		{0x3,		0x33,			7,		0,		0x40		},
+		{0x3,		0x3b,			7,		0,		0x44		},
+		{0x3,		0x43,			7,		0,		0x41		},
+		{0x3,		0x4b,			7,		0,		0x40		},
+		{0x3,		0x53,			7,		0,		0x4a		},
+		{0x3,		0x58,			7,		0,		0x1c		},
+		{0x3,		0x5b,			7,		0,		0x5a		},
+		{0x3,		0x5f,			7,		0,		0xe0		},
+		{0x4,		0x2,			7,		0,		0x7			},
+		{0x4,		0x3,			5,		0,		0x9			},
+		{0x4,		0x4,			5,		0,		0xb			},
+		{0x4,		0x5,			5,		0,		0xd			},
+		{0x4,		0x7,			2,		1,		0x3			},
+		{0x4,		0x7,			4,		3,		0x3			},
+		{0x4,		0xe,			4,		0,		0x18		},
+		{0x4,		0x10,			4,		0,		0x1c		},
+		{0x4,		0x12,			4,		0,		0x1c		},
+		{0x4,		0x2f,			7,		0,		0x0			},
+		{0x4,		0x30,			7,		0,		0x20		},
+		{0x4,		0x31,			7,		0,		0x40		},
+		{0x4,		0x3e,			0,		0,		0x0			},
+		{0x4,		0x3e,			1,		1,		0x1			},
+		{0x4,		0x3e,			5,		2,		0x0			},
+		{0x4,		0x3f,			5,		0,		0x10		},
+		{0x4,		0x4a,			0,		0,		0x1			},
+	};
+
+	static const TS_INTERFACE_INIT_TABLE_ENTRY TsInterfaceInitTable[RTL2836_TS_INTERFACE_INIT_TABLE_LEN] =
+	{
+		// RegBitName,				WritingValue for {Parallel, Serial}
+		{DTMB_SERIAL,				{0x0,	0x1}},
+		{DTMB_CDIV_PH0,				{0xf,	0x1}},
+		{DTMB_CDIV_PH1,				{0xf,	0x1}},
+	};
+
+	int i;
+
+	int TsInterfaceMode;
+
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+	unsigned long WritingValue;
+
+
+
+	// Get TS interface mode.
+	TsInterfaceMode = pDemod->TsInterfaceMode;
+
+	// Initialize demod registers according to the initializing table.
+	for(i = 0; i < RTL2836_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get all information from each register initializing entry.
+		PageNo       = InitRegTable[i].PageNo;
+		RegStartAddr = InitRegTable[i].RegStartAddr;
+		Msb          = InitRegTable[i].Msb;
+		Lsb          = InitRegTable[i].Lsb;
+		WritingValue = InitRegTable[i].WritingValue;
+
+		// Set register page number.
+		if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+
+		// Set register mask bits.
+		if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+	// Initialize demod registers according to the TS interface initializing table.
+	for(i = 0; i < RTL2836_TS_INTERFACE_INIT_TABLE_LEN; i++)
+	{
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, TsInterfaceInitTable[i].RegBitName,
+			TsInterfaceInitTable[i].WritingValue[TsInterfaceMode]) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_IF_FREQ_HZ
+
+*/
+int
+rtl2836_SetIfFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	)
+{
+
+	unsigned long BbinEn, EnDcr;
+
+	unsigned long IfFreqHzAdj;
+
+	MPI MpiVar, MpiNone, MpiConst;
+
+	long IffreqInt;
+	unsigned long IffreqBinary;
+
+
+
+	// Determine and set BBIN_EN and EN_DCR value.
+	BbinEn = (IfFreqHz == IF_FREQ_0HZ) ? 0x1 : 0x0;
+	EnDcr  = (IfFreqHz == IF_FREQ_0HZ) ? 0x1 : 0x0;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_BBIN_EN, BbinEn) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_EN_DCR, EnDcr) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Calculate IFFREQ value.
+	// Note: Case 1: IfFreqHz < 24000000,  IfFreqHzAdj = IfFreqHz;
+	//       Case 2: IfFreqHz >= 24000000, IfFreqHzAdj = 48000000 - IfFreqHz; 
+	//       IFFREQ = - round( IfFreqHzAdj * pow(2, 10) / 48000000 )
+	//              = - floor( (IfFreqHzAdj * pow(2, 10) + 24000000) / 48000000 )
+	//       RTL2836_ADC_FREQ_HZ = 48 MHz
+	//       IFFREQ_BIT_NUM = 10
+	IfFreqHzAdj = (IfFreqHz < (RTL2836_ADC_FREQ_HZ / 2)) ? IfFreqHz : (RTL2836_ADC_FREQ_HZ - IfFreqHz);
+
+	MpiSetValue(&MpiVar, IfFreqHzAdj);
+	MpiLeftShift(&MpiVar, MpiVar, RTL2836_IFFREQ_BIT_NUM);
+
+	MpiSetValue(&MpiConst, (RTL2836_ADC_FREQ_HZ / 2));
+	MpiAdd(&MpiVar, MpiVar, MpiConst);
+
+	MpiSetValue(&MpiConst, RTL2836_ADC_FREQ_HZ);
+	MpiDiv(&MpiVar, &MpiNone, MpiVar, MpiConst);
+
+	MpiGetValue(MpiVar, &IffreqInt);
+	IffreqInt = - IffreqInt;
+
+	IffreqBinary = SignedIntToBin(IffreqInt, RTL2836_IFFREQ_BIT_NUM);
+
+
+	// Set IFFREQ with calculated value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_IFFREQ, IffreqBinary) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod IF frequnecy parameter.
+	pDemod->IfFreqHz      = IfFreqHz;
+	pDemod->IsIfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_SPECTRUM_MODE
+
+*/
+int
+rtl2836_SetSpectrumMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	)
+{
+	unsigned long EnSpInv;
+
+
+
+	// Determine SpecInv according to spectrum mode.
+	switch(SpectrumMode)
+	{
+		case SPECTRUM_NORMAL:		EnSpInv = 0;		break;
+		case SPECTRUM_INVERSE:		EnSpInv = 1;		break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	// Set SPEC_INV with SpecInv.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_EN_SP_INV, EnSpInv) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod spectrum mode parameter.
+	pDemod->SpectrumMode      = SpectrumMode;
+	pDemod->IsSpectrumModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_IS_SIGNAL_LOCKED
+
+*/
+int
+rtl2836_IsSignalLocked(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	long SnrDbNum;
+	long SnrDbDen;
+	long SnrDbInt;
+
+	unsigned long PerNum;
+	unsigned long PerDen;
+
+
+
+	// Get SNR integer part.
+	if(pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	SnrDbInt = SnrDbNum / SnrDbDen;
+
+
+	// Get PER.
+	if(pDemod->GetPer(pDemod, &PerNum, &PerDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Determine answer according to SNR and PER.
+	// Note: The criterion is "(0 < SNR_in_Db < 40) && (PER < 1)"
+	if((SnrDbInt > 0) && (SnrDbInt < 40) && (PerNum < PerDen))
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+rtl2836_GetSignalStrength(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	)
+{
+	int SignalLockStatus;
+	long IfAgc;
+
+
+
+	// Get signal lock status.
+	if(pDemod->IsSignalLocked(pDemod, &SignalLockStatus) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Get IF AGC value.
+	if(pDemod->GetIfAgc(pDemod, &IfAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// If demod is not signal-locked, set signal strength with zero.
+	if(SignalLockStatus != YES)
+	{
+		*pSignalStrength = 0;
+		goto success_status_signal_is_not_locked;
+	}
+
+	//  Determine signal strength according to signal lock status and IF AGC value.
+	// Note: Map IfAgc value 8191 ~ -8192 to 10 ~ 99
+	//       Formula: SignalStrength = 54 - IfAgc / 183
+	*pSignalStrength = 54 - IfAgc / 183;
+
+
+success_status_signal_is_not_locked:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+rtl2836_GetSignalQuality(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	)
+{
+	int SignalLockStatus;
+	long SnrDbNum, SnrDbDen;
+
+
+
+	// Get signal lock status.
+	if(pDemod->IsSignalLocked(pDemod, &SignalLockStatus) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// If demod is not signal-locked, set signal quality with zero.
+	if(SignalLockStatus != YES)
+	{
+		*pSignalQuality = 0;
+		goto success_status_signal_is_not_locked;
+	}
+
+	// Determine signal quality according to SnrDbNum.
+	// Note: Map SnrDbNum value 12 ~ 100 to 12 ~ 100
+	//       Formula: SignalQuality = SnrDbNum
+	//       If SnrDbNum < 12, signal quality is 10.
+	//       If SnrDbNum > 100, signal quality is 100.
+	if(SnrDbNum < 12)
+	{
+		*pSignalQuality = 10;
+	}
+	else if(SnrDbNum > 100)
+	{
+		*pSignalQuality = 100;
+	}
+	else
+	{
+		*pSignalQuality = SnrDbNum;
+	}
+
+
+success_status_signal_is_not_locked:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_BER
+
+*/
+int
+rtl2836_GetBer(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	)
+{
+/*
+	unsigned long RsdBerEst;
+
+
+
+	// Get RSD_BER_EST.
+	if(pDemod->GetRegBitsWithPage(pDemod, DTMB_RSD_BER_EST, &RsdBerEst) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set BER numerator according to RSD_BER_EST.
+	*pBerNum = RsdBerEst;
+
+	// Set BER denominator.
+	*pBerDen = RTL2836_BER_DEN_VALUE;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+*/
+	return FUNCTION_SUCCESS;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_PER
+
+*/
+int
+rtl2836_GetPer(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	)
+{
+	unsigned long RoPktErrRate;
+
+
+
+	// Get RO_PKT_ERR_RATE.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_RO_PKT_ERR_RATE, &RoPktErrRate) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set PER numerator according to RO_PKT_ERR_RATE.
+	*pPerNum = RoPktErrRate;
+
+	// Set PER denominator.
+	*pPerDen = RTL2836_PER_DEN_VALUE;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_SNR_DB
+
+*/
+int
+rtl2836_GetSnrDb(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	unsigned long EstSnr;
+
+
+
+	// Get EST_SNR.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_EST_SNR, &EstSnr) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set SNR dB numerator according to EST_SNR.
+	*pSnrDbNum = BinToSignedInt(EstSnr, RTL2836_EST_SNR_BIT_NUM);
+
+	// Set SNR dB denominator.
+	*pSnrDbDen = RTL2836_SNR_DB_DEN_VALUE;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_RF_AGC
+
+*/
+int
+rtl2836_GetRfAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	)
+{
+	unsigned long RfAgcVal;
+
+
+
+	// Get RF AGC binary value from RF_AGC_VAL.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_RF_AGC_VAL, &RfAgcVal) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Convert RF AGC binary value to signed integer.
+	*pRfAgc = (long)BinToSignedInt(RfAgcVal, RTL2836_RF_AGC_REG_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_IF_AGC
+
+*/
+int
+rtl2836_GetIfAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	)
+{
+	unsigned long IfAgcVal;
+
+
+
+	// Get IF AGC binary value from IF_AGC_VAL.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_IF_AGC_VAL, &IfAgcVal) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Convert IF AGC binary value to signed integer.
+	*pIfAgc = (long)BinToSignedInt(IfAgcVal, RTL2836_IF_AGC_REG_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_DI_AGC
+
+*/
+int
+rtl2836_GetDiAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	)
+{
+	unsigned long GainOutR;
+
+
+
+	// Get GAIN_OUT_R to DiAgc.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_GAIN_OUT_R, &GainOutR) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	*pDiAgc = GainOutR;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+rtl2836_GetTrOffsetPpm(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	)
+{
+	unsigned long TrOutRBinary;
+	long TrOutRInt;
+	unsigned long SfoaqOutRBinary;
+	long SfoaqOutRInt;
+
+	MPI MpiVar, MpiNone, MpiConst;
+
+
+	// Get TR_OUT_R and SFOAQ_OUT_R binary value.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_TR_OUT_R, &TrOutRBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_SFOAQ_OUT_R, &SfoaqOutRBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Convert TR_OUT_R and SFOAQ_OUT_R binary value to signed integer.
+	TrOutRInt = BinToSignedInt(TrOutRBinary, RTL2836_TR_OUT_R_BIT_NUM);
+	SfoaqOutRInt = BinToSignedInt(SfoaqOutRBinary, RTL2836_SFOAQ_OUT_R_BIT_NUM);
+
+	
+	// Get TR offset in ppm.
+	// Note: Original formula:   TrOffsetPpm = ((TrOutRInt + SfoaqOutRInt * 8) * 15.12 * pow(10, 6)) / (48 * pow(2, 23))
+	//       Adjusted formula:   TrOffsetPpm = ((TrOutRInt + SfoaqOutRInt * 8) * 15120000) / 402653184
+	MpiSetValue(&MpiVar, (TrOutRInt + SfoaqOutRInt * 8));
+
+	MpiSetValue(&MpiConst, 15120000);
+	MpiMul(&MpiVar, MpiVar, MpiConst);
+
+	MpiSetValue(&MpiConst, 402653184);
+	MpiDiv(&MpiVar, &MpiNone, MpiVar, MpiConst);
+
+	MpiGetValue(MpiVar, pTrOffsetPpm);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+rtl2836_GetCrOffsetHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	)
+{
+	unsigned long CfoEstRBinary;
+	long CfoEstRInt;
+
+	MPI MpiVar, MpiConst;
+
+
+	// Get CFO_EST_R binary value.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_CFO_EST_R, &CfoEstRBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// Convert CFO_EST_R binary value to signed integer.
+	CfoEstRInt = BinToSignedInt(CfoEstRBinary, RTL2836_CFO_EST_R_BIT_NUM);
+
+	
+	// Get CR offset in Hz.
+	// Note: Original formula:   CrOffsetHz = (CfoEstRInt * 15.12 * pow(10, 6)) / pow(2, 26)
+	//       Adjusted formula:   CrOffsetHz = (CfoEstRInt * 15120000) >> 26
+	MpiSetValue(&MpiVar, CfoEstRInt);
+
+	MpiSetValue(&MpiConst, 15120000);
+	MpiMul(&MpiVar, MpiVar, MpiConst);
+
+	MpiRightShift(&MpiVar, MpiVar, 26);
+
+	MpiGetValue(MpiVar, pCrOffsetHz);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_CARRIER_MODE
+
+*/
+int
+rtl2836_GetCarrierMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCarrierMode
+	)
+{
+	unsigned long EstCarrier;
+
+
+	// Get carrier mode from EST_CARRIER.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_EST_CARRIER, &EstCarrier) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(EstCarrier)
+	{
+		case 0:		*pCarrierMode = DTMB_CARRIER_SINGLE;		break;
+		case 1:		*pCarrierMode = DTMB_CARRIER_MULTI;			break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_PN_MODE
+
+*/
+int
+rtl2836_GetPnMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pPnMode
+	)
+{
+	unsigned long RxModeR;
+
+
+	// Get PN mode from RX_MODE_R.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_RX_MODE_R, &RxModeR) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(RxModeR)
+	{
+		case 0:		*pPnMode = DTMB_PN_420;		break;
+		case 1:		*pPnMode = DTMB_PN_595;		break;
+		case 2:		*pPnMode = DTMB_PN_945;		break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_QAM_MODE
+
+*/
+int
+rtl2836_GetQamMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	)
+{
+	unsigned long UseTps;
+
+
+	// Get QAM mode from USE_TPS.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_USE_TPS, &UseTps) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(UseTps)
+	{
+		case 0:		*pQamMode = DTMB_QAM_UNKNOWN;		break;
+
+		case 2:
+		case 3:		*pQamMode = DTMB_QAM_4QAM_NR;		break;
+
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+		case 9:		*pQamMode = DTMB_QAM_4QAM;			break;
+
+		case 10:
+		case 11:
+		case 12:
+		case 13:
+		case 14:
+		case 15:	*pQamMode = DTMB_QAM_16QAM;			break;
+
+		case 16:
+		case 17:	*pQamMode = DTMB_QAM_32QAM;			break;
+
+		case 18:
+		case 19:
+		case 20:
+		case 21:
+		case 22:
+		case 23:	*pQamMode = DTMB_QAM_64QAM;			break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_CODE_RATE_MODE
+
+*/
+int
+rtl2836_GetCodeRateMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCodeRateMode
+	)
+{
+	unsigned long UseTps;
+
+
+	// Get QAM mode from USE_TPS.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_USE_TPS, &UseTps) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(UseTps)
+	{
+		case 0:		*pCodeRateMode = DTMB_CODE_RATE_UNKNOWN;		break;
+
+		case 4:
+		case 5:
+		case 10:
+		case 11:
+		case 18:
+		case 19:	*pCodeRateMode = DTMB_CODE_RATE_0P4;			break;
+
+		case 6:
+		case 7:
+		case 12:
+		case 13:
+		case 20:
+		case 21:	*pCodeRateMode = DTMB_CODE_RATE_0P6;			break;
+
+		case 2:
+		case 3:
+		case 8:
+		case 9:
+		case 14:
+		case 15:
+		case 16:
+		case 17:
+		case 22:
+		case 23:	*pCodeRateMode = DTMB_CODE_RATE_0P8;			break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_TIME_INTERLEAVER_MODE
+
+*/
+int
+rtl2836_GetTimeInterleaverMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pTimeInterleaverMode
+	)
+{
+	unsigned long UseTps;
+
+
+	// Get QAM mode from USE_TPS.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_USE_TPS, &UseTps) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	switch(UseTps)
+	{
+		case 0:		*pTimeInterleaverMode = DTMB_TIME_INTERLEAVER_UNKNOWN;		break;
+
+		case 2:
+		case 4:
+		case 6:
+		case 8:
+		case 10:
+		case 12:
+		case 14:
+		case 16:
+		case 18:
+		case 20:
+		case 22:	*pTimeInterleaverMode = DTMB_TIME_INTERLEAVER_240;			break;
+
+		case 3:
+		case 5:
+		case 7:
+		case 9:
+		case 11:
+		case 13:
+		case 15:
+		case 17:
+		case 19:
+		case 21:
+		case 23:	*pTimeInterleaverMode = DTMB_TIME_INTERLEAVER_720;			break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2836_UpdateFunction(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2836_EXTRA_MODULE *pExtra;
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+
+	// Execute Function 1 according to Function 1 enabling status
+	if(pExtra->IsFunc1Enabled == YES)
+	{
+		if(rtl2836_func1_Update(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+	// Execute Function 2 according to Function 2 enabling status
+	if(pExtra->IsFunc2Enabled == YES)
+	{
+		if(rtl2836_func2_Update(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_RESET_FUNCTION
+
+*/
+int
+rtl2836_ResetFunction(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2836_EXTRA_MODULE *pExtra;
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+
+	// Reset Function 1 settings according to Function 1 enabling status.
+	if(pExtra->IsFunc1Enabled == YES)
+	{
+		if(rtl2836_func1_Reset(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+	// Reset Function 2 settings according to Function 2 enabling status.
+	if(pExtra->IsFunc2Enabled == YES)
+	{
+		if(rtl2836_func2_Reset(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD
+
+*/
+int
+rtl2836_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module.
+	pDemod = (DTMB_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Send I2C reading command.
+	if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_reading_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_reading_command:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD
+
+*/
+int
+rtl2836_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module.
+	pDemod = (DTMB_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Send I2C writing command.
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, pWritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_writing_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_writing_command:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Initialize RTL2836 register table.
+
+Use rtl2836_InitRegTable() to initialize RTL2836 register table.
+
+
+@param [in]   pDemod   RTL2836 demod module pointer
+
+
+@note
+	-# The rtl2836_InitRegTable() function will be called by BuildRtl2836Module().
+
+*/
+void
+rtl2836_InitRegTable(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	static const DTMB_PRIMARY_REG_ENTRY_ADDR_8BIT PrimaryRegTable[RTL2836_REG_TABLE_LEN] =
+	{
+		// Software reset
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_SOFT_RST_N,					0x0,		0x4,			0,		0	},
+
+		// Tuner I2C forwording
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_I2CT_EN_CTRL,					0x0,		0x6,			0,		0	},
+
+		// Chip ID
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_CHIP_ID,						0x5,		0x10,			15,		0	},
+
+		// IF setting
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_EN_SP_INV,					0x1,		0x31,			1,		1	},
+		{DTMB_EN_DCR,						0x1,		0x31,			0,		0	},
+		{DTMB_BBIN_EN,						0x1,		0x6a,			0,		0	},
+		{DTMB_IFFREQ,						0x1,		0x32,			9,		0	},
+
+		// AGC setting
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_TARGET_VAL,					0x1,		0x3,			7,		0	},
+
+		// IF setting
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_SERIAL,						0x4,		0x50,			7,		7	},
+		{DTMB_CDIV_PH0,						0x4,		0x51,			4,		0	},
+		{DTMB_CDIV_PH1,						0x4,		0x52,			4,		0	},
+
+		// Signal lock status
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_TPS_LOCK,						0x8,		0x2a,			6,		6	},
+		{DTMB_PN_PEAK_EXIST,				0x6,		0x53,			0,		0	},
+
+		// FSM
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_FSM_STATE_R,					0x6,		0xc0,			4,		0	},
+
+		// Performance measurement
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_RO_PKT_ERR_RATE,				0x9,		0x2d,			15,		0	},
+		{DTMB_EST_SNR,						0x8,		0x3e,			8,		0	},
+
+		// AGC
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_GAIN_OUT_R,					0x6,		0xb4,			12,		1	},
+		{DTMB_RF_AGC_VAL,					0x6,		0x16,			13,		0	},
+		{DTMB_IF_AGC_VAL,					0x6,		0x14,			13,		0	},
+
+		// TR and CR
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_TR_OUT_R,						0x7,		0x7c,			16,		0	},
+		{DTMB_SFOAQ_OUT_R,					0x7,		0x21,			13,		0	},
+		{DTMB_CFO_EST_R,					0x6,		0x94,			22,		0	},
+
+		// Signal information
+		// RegBitName,						PageNo,		RegStartAddr,	MSB,	LSB
+		{DTMB_EST_CARRIER,					0x8,		0x2a,			0,		0	},
+		{DTMB_RX_MODE_R,					0x7,		0x17,			1,		0	},
+		{DTMB_USE_TPS,						0x8,		0x2a,			5,		1	},
+	};
+
+
+	int i;
+	int RegBitName;
+
+
+
+	// Initialize register table according to primary register table.
+	// Note: 1. Register table rows are sorted by register bit name key.
+	//       2. The default value of the IsAvailable variable is "NO".
+	for(i = 0; i < DTMB_REG_TABLE_LEN_MAX; i++)
+		pDemod->RegTable.Addr8Bit[i].IsAvailable  = NO;
+
+	for(i = 0; i < RTL2836_REG_TABLE_LEN; i++)
+	{
+		RegBitName = PrimaryRegTable[i].RegBitName;
+
+		pDemod->RegTable.Addr8Bit[RegBitName].IsAvailable  = YES;
+		pDemod->RegTable.Addr8Bit[RegBitName].PageNo       = PrimaryRegTable[i].PageNo;
+		pDemod->RegTable.Addr8Bit[RegBitName].RegStartAddr = PrimaryRegTable[i].RegStartAddr;
+		pDemod->RegTable.Addr8Bit[RegBitName].Msb          = PrimaryRegTable[i].Msb;
+		pDemod->RegTable.Addr8Bit[RegBitName].Lsb          = PrimaryRegTable[i].Lsb;
+	}
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set I2C bridge module demod arguments.
+
+RTL2836 builder will use rtl2836_BuildI2cBridgeModule() to set I2C bridge module demod arguments.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@see   BuildRtl2836Module()
+
+*/
+void
+rtl2836_BuildI2cBridgeModule(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+
+	// Get I2C bridge module.
+	pI2cBridge = pDemod->pI2cBridge;
+
+	// Set I2C bridge module demod arguments.
+	pI2cBridge->pPrivateData = (void *)pDemod;
+	pI2cBridge->ForwardI2cReadingCmd = rtl2836_ForwardI2cReadingCmd;
+	pI2cBridge->ForwardI2cWritingCmd = rtl2836_ForwardI2cWritingCmd;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Reset Function 1 variables and registers.
+
+One can use rtl2836_func1_Reset() to reset Function 1 variables and registers.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset Function 1 variables and registers successfully.
+@retval   FUNCTION_ERROR     Reset Function 1 variables and registers unsuccessfully.
+
+
+@note
+	-# Need to execute Function 1 reset function when change tuner RF frequency or demod parameters.
+	-# Function 1 update flow also employs Function 1 reset function.
+
+*/
+int
+rtl2836_func1_Reset(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2836_EXTRA_MODULE *pExtra;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+	// Reset demod Function 1 variables.
+	pExtra->Func1Cnt = 0;
+
+
+	return FUNCTION_SUCCESS;
+}
+
+
+
+
+
+/**
+
+@brief   Update demod registers with Function 1.
+
+One can use rtl2836_func1_Update() to update demod registers with Function 1.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod registers with Function 1 successfully.
+@retval   FUNCTION_ERROR     Update demod registers with Function 1 unsuccessfully.
+
+
+@note
+	-# Recommended update period is 50 ~ 200 ms for Function 1.
+	-# Need to execute Function 1 reset function when change tuner RF frequency or demod parameters.
+	-# Function 1 update flow also employs Function 1 reset function.
+
+*/
+int
+rtl2836_func1_Update(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2836_EXTRA_MODULE *pExtra;
+
+	unsigned long Reg0;
+	unsigned long Reg1;
+	unsigned long PnPeakExist;
+	unsigned long FsmStateR;
+	unsigned long TpsLock;
+
+	long SnrDbNum;
+	long SnrDbDen;
+	long SnrDbInt;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+
+	// Update Function 1 counter.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x9) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegMaskBits(pDemod, 0x1e, 9, 0, &Reg0) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if((Reg0 & 0x3fb) == 0)
+	{
+		pExtra->Func1Cnt += 1;
+	}
+	else
+	{
+		pExtra->Func1Cnt = 0;
+	}
+
+
+	// Get PN_PEAK_EXIST and FSM_STATE_R value.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x6) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, DTMB_PN_PEAK_EXIST, &PnPeakExist) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, DTMB_FSM_STATE_R, &FsmStateR) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Get Reg1 and TPS_LOCK value.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x8) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegMaskBits(pDemod, 0x28, 3, 0, &Reg1) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, DTMB_TPS_LOCK, &TpsLock) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Get SNR integer part.
+	if(pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	SnrDbInt = SnrDbNum / SnrDbDen;
+
+
+	// Determine if reset demod by software reset.
+	// Note: Need to reset Function 2 when reset demod.
+	if((pExtra->Func1Cnt > pExtra->Func1CntThd) || ((PnPeakExist == 0) && (FsmStateR > 9)) ||
+		((Reg1 >= 6) && (TpsLock == 0)) || (SnrDbInt == -64))
+	{
+		pExtra->Func1Cnt = 0;
+
+		if(pExtra->IsFunc2Enabled == ON)
+		{
+			if(rtl2836_func2_Reset(pDemod) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+		}
+
+		if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_get_registers:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Reset Function 2 variables and registers.
+
+One can use rtl2836_func2_Reset() to reset Function 1 variables and registers.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset Function 2 variables and registers successfully.
+@retval   FUNCTION_ERROR     Reset Function 2 variables and registers unsuccessfully.
+
+
+@note
+	-# Need to execute Function 2 reset function when change tuner RF frequency or demod parameters.
+	-# Function 2 update flow also employs Function 2 reset function.
+
+*/
+int
+rtl2836_func2_Reset(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	RTL2836_EXTRA_MODULE *pExtra;
+
+
+
+	// Get demod extra module.
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+	// Reset demod Function 2 variables and registers to signal normal mode.
+	pExtra->Func2SignalModePrevious = RTL2836_FUNC2_SIGNAL_NORMAL;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x15, 7, 0, 0xf) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1e, 6, 0, 0x3a) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1f, 5, 0, 0x19) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x23, 4, 0, 0x1e) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Update demod registers with Function 2.
+
+One can use rtl2836_func2_Update() to update demod registers with Function 2.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod registers with Function 2 successfully.
+@retval   FUNCTION_ERROR     Update demod registers with Function 2 unsuccessfully.
+
+
+@note
+	-# Recommended update period is 50 ~ 200 ms for Function 2.
+	-# Need to execute Function 2 reset function when change tuner RF frequency or demod parameters.
+	-# Function 2 update flow also employs Function 2 reset function.
+
+*/
+int
+rtl2836_func2_Update(
+	DTMB_DEMOD_MODULE *pDemod
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	RTL2836_EXTRA_MODULE *pExtra;
+
+	int i;
+
+	unsigned long TpsLock;
+	unsigned long PnPeakExist;
+
+	int PnMode;
+	int QamMode;
+	int CodeRateMode;
+
+	int SignalLockStatus;
+
+	int SignalMode;
+
+
+
+	// Get base interface and demod extra module.
+	pBaseInterface = pDemod->pBaseInterface;
+	pExtra = &(pDemod->Extra.Rtl2836);
+
+
+	// Get TPS_LOCK value.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_TPS_LOCK, &TpsLock) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Get PN_PEAK_EXIST value.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, DTMB_PN_PEAK_EXIST, &PnPeakExist) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Get PN mode.
+	if(pDemod->GetPnMode(pDemod, &PnMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get QAM mode.
+	if(pDemod->GetQamMode(pDemod, &QamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get code rate mode.
+	if(pDemod->GetCodeRateMode(pDemod, &CodeRateMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// If TPS is not locked or PN peak doesn't exist, do nothing.
+	if((TpsLock != 0x1) || (PnPeakExist != 0x1))
+		goto success_status_tps_is_not_locked;
+
+	// Determine signal mode.
+	if((PnMode == DTMB_PN_945) && (QamMode == DTMB_QAM_64QAM) && (CodeRateMode == DTMB_CODE_RATE_0P6))
+	{
+		SignalMode = RTL2836_FUNC2_SIGNAL_PARTICULAR;
+	}
+	else
+	{
+		SignalMode = RTL2836_FUNC2_SIGNAL_NORMAL;
+	}
+
+	// If signal mode is the same as previous one, do nothing.
+	if(SignalMode == pExtra->Func2SignalModePrevious)
+		goto success_status_signal_mode_is_the_same;
+
+
+	// Set demod registers according to signal mode
+	switch(SignalMode)
+	{
+		default:
+		case RTL2836_FUNC2_SIGNAL_NORMAL:
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x15, 7, 0, 0xf) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1e, 6, 0, 0x3a) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1f, 5, 0, 0x19) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x23, 4, 0, 0x1e) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			break;
+
+
+		case RTL2836_FUNC2_SIGNAL_PARTICULAR:
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0x2) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x15, 7, 0, 0x4) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1e, 6, 0, 0xa) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x1f, 5, 0, 0x3f) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, 0x23, 4, 0, 0x1f) != FUNCTION_SUCCESS)
+				goto error_status_set_registers;
+
+			break;
+	}
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Wait 1000 ms for signal lock check.
+	for(i = 0; i < 10; i++)
+	{
+		// Wait 100 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 100);
+
+		// Check signal lock status on demod.
+		// Note: If signal is locked, stop signal lock check.
+		if(pDemod->IsSignalLocked(pDemod, &SignalLockStatus) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(SignalLockStatus == YES)
+			break;
+	}
+
+
+	// Update previous signal mode.
+	pExtra->Func2SignalModePrevious = SignalMode;
+
+
+success_status_signal_mode_is_the_same:
+success_status_tps_is_not_locked:
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2836.h b/drivers/media/usb/rtl2832u/demod_rtl2836.h
new file mode 100644
index 00000000..af3c79ee
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2836.h
@@ -0,0 +1,376 @@
+#ifndef __DEMOD_RTL2836_H
+#define __DEMOD_RTL2836_H
+
+/**
+
+@file
+
+@brief   RTL2836 demod module declaration
+
+One can manipulate RTL2836 demod through RTL2836 module.
+RTL2836 module is derived from DTMB demod module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the DTMB demod example in dtmb_demod_base.h except the listed lines.
+
+
+
+#include "demod_rtl2836.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+	DTMB_DEMOD_MODULE     DtmbDemodModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+
+	...
+
+
+
+	// Build RTL2836 demod module.
+	BuildRtl2836Module(
+		&pDemod,
+		&DtmbDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x3e,								// I2C device address is 0x3e in 8-bit format.
+		CRYSTAL_FREQ_27000000HZ,			// Crystal frequency is 27.0 MHz.
+		TS_INTERFACE_SERIAL,				// TS interface mode is serial.
+		50,									// Update function reference period is 50 millisecond
+		YES,								// Function 1 enabling status is on.
+		YES									// Function 2 enabling status is on.
+		);
+
+
+
+	// See the example for other DTMB demod functions in dtmb_demod_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "dtmb_demod_base.h"
+
+
+
+
+
+// Definitions
+
+// Initializing
+#define RTL2836_INIT_REG_TABLE_LEN					86
+#define RTL2836_TS_INTERFACE_INIT_TABLE_LEN			3
+
+
+// Chip ID
+#define RTL2836_CHIP_ID_VALUE			0x4
+
+
+// IF frequency setting
+#define RTL2836_ADC_FREQ_HZ			48000000
+#define RTL2836_IFFREQ_BIT_NUM		10
+
+
+// BER
+#define RTL2836_BER_DEN_VALUE				1000000
+
+
+// PER
+#define RTL2836_PER_DEN_VALUE				32768
+
+
+// SNR
+#define RTL2836_EST_SNR_BIT_NUM				9
+#define RTL2836_SNR_DB_DEN_VALUE			4
+
+
+// AGC
+#define RTL2836_RF_AGC_REG_BIT_NUM		14
+#define RTL2836_IF_AGC_REG_BIT_NUM		14
+
+
+// TR offset and CR offset
+#define RTL2836_TR_OUT_R_BIT_NUM			17
+#define RTL2836_SFOAQ_OUT_R_BIT_NUM			14
+#define RTL2836_CFO_EST_R_BIT_NUM			23
+
+
+// Register table length
+#define RTL2836_REG_TABLE_LEN			25
+
+
+// Function 1
+#define RTL2836_FUNC1_CHECK_TIME_MS			500
+
+
+// Function 2
+enum RTL2836_FUNC2_SIGNAL_MODE
+{
+	RTL2836_FUNC2_SIGNAL_NORMAL,
+	RTL2836_FUNC2_SIGNAL_PARTICULAR,
+};
+
+
+
+
+
+// Demod module builder
+void
+BuildRtl2836Module(
+	DTMB_DEMOD_MODULE **ppDemod,
+	DTMB_DEMOD_MODULE *pDtmbDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	unsigned long UpdateFuncRefPeriodMs,
+	int IsFunc1Enabled,
+	int IsFunc2Enabled
+	);
+
+
+
+
+
+// Manipulating functions
+void
+rtl2836_IsConnectedToI2c(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+);
+
+int
+rtl2836_SoftwareReset(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_Initialize(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_SetIfFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+int
+rtl2836_SetSpectrumMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+int
+rtl2836_IsSignalLocked(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2836_GetSignalStrength(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+int
+rtl2836_GetSignalQuality(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+int
+rtl2836_GetBer(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+int
+rtl2836_GetPer(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+int
+rtl2836_GetSnrDb(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+rtl2836_GetRfAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+int
+rtl2836_GetIfAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+int
+rtl2836_GetDiAgc(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	);
+
+int
+rtl2836_GetTrOffsetPpm(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+int
+rtl2836_GetCrOffsetHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+int
+rtl2836_GetCarrierMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCarrierMode
+	);
+
+int
+rtl2836_GetPnMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pPnMode
+	);
+
+int
+rtl2836_GetQamMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	);
+
+int
+rtl2836_GetCodeRateMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCodeRateMode
+	);
+
+int
+rtl2836_GetTimeInterleaverMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pTimeInterleaverMode
+	);
+
+int
+rtl2836_UpdateFunction(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_ResetFunction(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// I2C command forwarding functions
+int
+rtl2836_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+rtl2836_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+// Register table initializing
+void
+rtl2836_InitRegTable(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// I2C birdge module builder
+void
+rtl2836_BuildI2cBridgeModule(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// RTL2836 dependence
+int
+rtl2836_func1_Reset(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_func1_Update(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_func2_Reset(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2836_func2_Update(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2840.c b/drivers/media/usb/rtl2832u/demod_rtl2840.c
new file mode 100644
index 00000000..226caf90
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2840.c
@@ -0,0 +1,2437 @@
+/**
+
+@file
+
+@brief   RTL2840 QAM demod module definition
+
+One can manipulate RTL2840 QAM demod through RTL2840 module.
+RTL2840 module is derived from QAM demod module.
+
+*/
+
+
+#include "demod_rtl2840.h"
+
+
+
+
+
+/**
+
+@brief   RTL2840 demod module builder
+
+Use BuildRtl2840Module() to build RTL2840 module, set all module function pointers with the corresponding functions, and
+initialize module private variables.
+
+
+@param [in]   ppDemod                      Pointer to RTL2840 demod module pointer
+@param [in]   pQamDemodModuleMemory        Pointer to an allocated QAM demod module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   RTL2840 I2C device address
+@param [in]   CrystalFreqHz                RTL2840 crystal frequency in Hz
+@param [in]   TsInterfaceMode              RTL2840 TS interface mode for setting
+@param [in]   EnhancementMode              RTL2840 enhancement mode for setting
+
+
+@note
+	-# One should call BuildRtl2840Module() to build RTL2840 module before using it.
+
+*/
+void
+BuildRtl2840Module(
+	QAM_DEMOD_MODULE **ppDemod,
+	QAM_DEMOD_MODULE *pQamDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	int EnhancementMode
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+
+	// Set demod module pointer.
+	*ppDemod = pQamDemodModuleMemory;
+
+	// Get demod module.
+	pDemod = *ppDemod;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pDemod->pBaseInterface = pBaseInterfaceModuleMemory;
+	pDemod->pI2cBridge     = pI2cBridgeModuleMemory;
+
+
+	// Set demod type.
+	pDemod->DemodType = QAM_DEMOD_TYPE_RTL2840;
+
+	// Set demod I2C device address.
+	pDemod->DeviceAddr = DeviceAddr;
+
+	// Set demod crystal frequency in Hz.
+	pDemod->CrystalFreqHz = CrystalFreqHz;
+
+	// Set demod TS interface mode.
+	pDemod->TsInterfaceMode = TsInterfaceMode;
+
+
+	// Initialize demod parameter setting status
+	pDemod->IsQamModeSet       = NO;
+	pDemod->IsSymbolRateHzSet  = NO;
+	pDemod->IsAlphaModeSet     = NO;
+	pDemod->IsIfFreqHzSet      = NO;
+	pDemod->IsSpectrumModeSet  = NO;
+
+
+	// Initialize register tables in demod extra module.
+	rtl2840_InitBaseRegTable(pDemod);
+	rtl2840_InitMonitorRegTable(pDemod);
+
+
+	// Build I2C birdge module.
+	rtl2840_BuildI2cBridgeModule(pDemod);
+
+
+	// Set demod module I2C function pointers with default functions.
+	pDemod->RegAccess.Addr8Bit.SetRegPage         = qam_demod_addr_8bit_default_SetRegPage;
+	pDemod->RegAccess.Addr8Bit.SetRegBytes        = qam_demod_addr_8bit_default_SetRegBytes;
+	pDemod->RegAccess.Addr8Bit.GetRegBytes        = qam_demod_addr_8bit_default_GetRegBytes;
+	pDemod->RegAccess.Addr8Bit.SetRegMaskBits     = qam_demod_addr_8bit_default_SetRegMaskBits;
+	pDemod->RegAccess.Addr8Bit.GetRegMaskBits     = qam_demod_addr_8bit_default_GetRegMaskBits;
+	pDemod->RegAccess.Addr8Bit.SetRegBits         = qam_demod_addr_8bit_default_SetRegBits;
+	pDemod->RegAccess.Addr8Bit.GetRegBits         = qam_demod_addr_8bit_default_GetRegBits;
+	pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage = qam_demod_addr_8bit_default_SetRegBitsWithPage;
+	pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage = qam_demod_addr_8bit_default_GetRegBitsWithPage;
+
+
+	// Set demod module manipulating function pointers with default functions.
+	pDemod->GetDemodType     = qam_demod_default_GetDemodType;
+	pDemod->GetDeviceAddr    = qam_demod_default_GetDeviceAddr;
+	pDemod->GetCrystalFreqHz = qam_demod_default_GetCrystalFreqHz;
+
+	pDemod->GetQamMode       = qam_demod_default_GetQamMode;
+	pDemod->GetSymbolRateHz  = qam_demod_default_GetSymbolRateHz;
+	pDemod->GetAlphaMode     = qam_demod_default_GetAlphaMode;
+	pDemod->GetIfFreqHz      = qam_demod_default_GetIfFreqHz;
+	pDemod->GetSpectrumMode  = qam_demod_default_GetSpectrumMode;
+
+
+	// Set demod module manipulating function pointers with particular functions.
+	// Note: Need to assign manipulating function pointers according to enhancement mode.
+	pDemod->IsConnectedToI2c  = rtl2840_IsConnectedToI2c;
+	pDemod->SoftwareReset     = rtl2840_SoftwareReset;
+
+	pDemod->Initialize        = rtl2840_Initialize;
+	pDemod->SetSymbolRateHz   = rtl2840_SetSymbolRateHz;
+	pDemod->SetAlphaMode      = rtl2840_SetAlphaMode;
+	pDemod->SetIfFreqHz       = rtl2840_SetIfFreqHz;
+	pDemod->SetSpectrumMode   = rtl2840_SetSpectrumMode;
+
+	pDemod->GetRfAgc          = rtl2840_GetRfAgc;
+	pDemod->GetIfAgc          = rtl2840_GetIfAgc;
+	pDemod->GetDiAgc          = rtl2840_GetDiAgc;
+	pDemod->GetTrOffsetPpm    = rtl2840_GetTrOffsetPpm;
+	pDemod->GetCrOffsetHz     = rtl2840_GetCrOffsetHz;
+
+	pDemod->IsAagcLocked      = rtl2840_IsAagcLocked;
+	pDemod->IsEqLocked        = rtl2840_IsEqLocked;
+	pDemod->IsFrameLocked     = rtl2840_IsFrameLocked;
+
+	pDemod->GetErrorRate      = rtl2840_GetErrorRate;
+	pDemod->GetSnrDb          = rtl2840_GetSnrDb;
+
+	pDemod->GetSignalStrength = rtl2840_GetSignalStrength;
+	pDemod->GetSignalQuality  = rtl2840_GetSignalQuality;
+
+	pDemod->UpdateFunction    = rtl2840_UpdateFunction;
+	pDemod->ResetFunction     = rtl2840_ResetFunction;
+
+	switch(EnhancementMode)
+	{
+		case QAM_DEMOD_EN_NONE:
+			pDemod->SetQamMode = rtl2840_SetQamMode;
+			break;
+
+		case QAM_DEMOD_EN_AM_HUM:
+			pDemod->SetQamMode = rtl2840_am_hum_en_SetQamMode;
+			break;
+	}
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_IS_CONNECTED_TO_I2C
+
+*/
+void
+rtl2840_IsConnectedToI2c(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long ReadingValue;
+
+
+
+	// Set reading value to zero, and get SYS_VERSION value.
+	// Note: Use GetRegBitsWithPage() to get register bits with page setting.
+	ReadingValue = 0;
+
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_SYS_VERSION, &ReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Compare SYS_VERSION value with RTL2840_SYS_VERSION_VALUE.
+	if(ReadingValue == RTL2840_SYS_VERSION_VALUE)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return;
+
+
+error_status_get_demod_registers:
+
+	*pAnswer = NO;
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SOFTWARE_RESET
+
+*/
+int
+rtl2840_SoftwareReset(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	// Set register page number with system page number for software resetting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 0) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set and clear SOFT_RESET register bit.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SOFT_RESET, ON) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SOFT_RESET, OFF) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_INITIALIZE
+
+*/
+int
+rtl2840_Initialize(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	typedef struct
+	{
+		unsigned char PageNo;
+		unsigned char RegStartAddr;
+		unsigned char Msb;
+		unsigned char Lsb;
+		unsigned long WritingValue;
+	}
+	INIT_REG_ENTRY;
+
+
+	typedef struct
+	{
+		unsigned char SpecReg0Sel;
+		unsigned char SpecReg0ValueTable[RTL2840_SPEC_REG_0_VALUE_TABLE_LEN];
+	}
+	INIT_SPEC_REG_0_ENTRY;
+
+
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long WritingValue[TS_INTERFACE_MODE_NUM];
+	}
+	TS_INTERFACE_INIT_TABLE_ENTRY;
+
+
+
+	static const INIT_REG_ENTRY InitRegTable[RTL2840_INIT_REG_TABLE_LEN] =
+	{
+		// PageNo,	RegStartAddr,	Msb,	Lsb,	WritingValue
+		{0,			0x04,			2,		0,		0x5			},
+		{0,			0x04,			4,		3,		0x0			},
+		{0,			0x04,			5,		5,		0x1			},
+		{0,			0x06,			0,		0,		0x0			},
+		{0,			0x07,			2,		2,		0x0			},
+		{1,			0x04,			0,		0,		0x0			},
+		{1,			0x04,			1,		1,		0x0			},
+		{1,			0x04,			2,		2,		0x0			},
+		{1,			0x04,			3,		3,		0x0			},
+		{1,			0x0c,			2,		0,		0x7			},
+		{1,			0x19,			5,		5,		0x0			},
+		{1,			0x19,			6,		6,		0x1			},
+		{1,			0x19,			7,		7,		0x1			},
+		{1,			0x1a,			0,		0,		0x0			},
+		{1,			0x1a,			1,		1,		0x1			},
+		{1,			0x1a,			2,		2,		0x0			},
+		{1,			0x1a,			3,		3,		0x1			},
+		{1,			0x1a,			4,		4,		0x0			},
+		{1,			0x1a,			5,		5,		0x1			},
+		{1,			0x1a,			6,		6,		0x1			},
+		{1,			0x1b,			3,		0,		0x7			},
+		{1,			0x1b,			7,		4,		0xc			},
+		{1,			0x1c,			2,		0,		0x4			},
+		{1,			0x1c,			5,		3,		0x3			},
+		{1,			0x1d,			5,		0,		0x7			},
+		{1,			0x27,			9,		0,		0x6d		},
+		{1,			0x2b,			7,		0,		0x26		},
+		{1,			0x2c,			7,		0,		0x1e		},
+		{1,			0x2e,			7,		6,		0x3			},
+		{1,			0x32,			2,		0,		0x7			},
+		{1,			0x32,			5,		3,		0x0			},
+		{1,			0x32,			6,		6,		0x1			},
+		{1,			0x32,			7,		7,		0x0			},
+		{1,			0x33,			6,		0,		0xf			},
+		{1,			0x33,			7,		7,		0x1			},
+		{1,			0x39,			7,		0,		0x88		},
+		{1,			0x3a,			7,		0,		0x36		},
+		{1,			0x3e,			7,		0,		0x26		},
+		{1,			0x3f,			7,		0,		0x15		},
+		{1,			0x4b,			8,		0,		0x166		},
+		{1,			0x4d,			8,		0,		0x166		},
+		{2,			0x11,			0,		0,		0x0			},
+		{2,			0x02,			7,		0,		0x7e		},
+		{2,			0x12,			3,		0,		0x7			},
+		{2,			0x12,			7,		4,		0x7			},
+	};
+
+
+	static const INIT_SPEC_REG_0_ENTRY InitSpecReg0Table[RTL2840_INIT_SPEC_REG_0_TABLE_LEN] =
+	{
+		// SpecReg0Sel,		{SpecReg0ValueTable																	}
+		{0,					{0x00,	0xd0,	0x49,	0x8e,	0xf2,	0x01,	0x00,	0xc0,	0x62,	0x62,	0x00}	},
+		{1,					{0x11,	0x21,	0x89,	0x8e,	0xf2,	0x01,	0x80,	0x8b,	0x62,	0xe2,	0x00}	},
+		{2,					{0x22,	0x32,	0x89,	0x8e,	0x72,	0x00,	0xc0,	0x86,	0xe2,	0xe3,	0x00}	},
+		{3,					{0x43,	0x44,	0x8b,	0x0e,	0xf2,	0xdd,	0xb5,	0x84,	0xe2,	0xcb,	0x00}	},
+		{4,					{0x54,	0x55,	0xcb,	0x1e,	0xf3,	0x4d,	0xb5,	0x84,	0xe2,	0xcb,	0x00}	},
+		{5,					{0x65,	0x66,	0xcb,	0x1e,	0xf5,	0x4b,	0xb4,	0x84,	0xe2,	0xcb,	0x00}	},
+		{6,					{0x76,	0x77,	0xcb,	0x9e,	0xf7,	0xc7,	0x73,	0x80,	0xe2,	0xcb,	0x00}	},
+		{7,					{0x87,	0x88,	0xcb,	0x2e,	0x48,	0x41,	0x72,	0x80,	0xe2,	0xcb,	0x00}	},
+		{8,					{0x98,	0x99,	0xcc,	0x3e,	0x48,	0x21,	0x71,	0x80,	0xea,	0xcb,	0x00}	},
+		{11,				{0xbb,	0xc8,	0xcb,	0x6e,	0x24,	0x18,	0x73,	0xa0,	0xfa,	0xcf,	0x01}	},
+		{13,				{0x1d,	0x1e,	0x4f,	0x8e,	0xf2,	0x01,	0x00,	0x80,	0x62,	0x62,	0x00}	},
+		{14,				{0x1e,	0x1f,	0x4f,	0x8e,	0xf2,	0x01,	0x00,	0x80,	0x62,	0x62,	0x00}	},
+		{15,				{0x1f,	0x11,	0x4f,	0x8e,	0xf2,	0x01,	0x00,	0x80,	0x62,	0x62,	0x00}	},
+	};
+
+
+	static const TS_INTERFACE_INIT_TABLE_ENTRY TsInterfaceInitTable[RTL2840_TS_INTERFACE_INIT_TABLE_LEN] =
+	{
+		// RegBitName,				WritingValue for {Parallel, Serial}
+		{QAM_SERIAL,				{0x0,	0x1}},
+		{QAM_CDIV_PH0,				{0x7,	0x0}},
+		{QAM_CDIV_PH1,				{0x7,	0x0}},
+	};
+
+
+	int i;
+
+	int TsInterfaceMode;
+
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+	unsigned long WritingValue;
+
+	unsigned char SpecReg0Sel;
+	const unsigned char *pSpecReg0ValueTable;
+
+	unsigned long QamSpecInitA2Backup;
+	unsigned long RegValue, RegValueComparison;
+	int AreAllValueEqual;
+
+
+
+	// Get TS interface mode.
+	TsInterfaceMode = pDemod->TsInterfaceMode;
+
+	// Initialize demod with register initializing table.
+	for(i = 0; i < RTL2840_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get all information from each register initializing entry.
+		PageNo       = InitRegTable[i].PageNo;
+		RegStartAddr = InitRegTable[i].RegStartAddr;
+		Msb          = InitRegTable[i].Msb;
+		Lsb          = InitRegTable[i].Lsb;
+		WritingValue = InitRegTable[i].WritingValue;
+
+		// Set register page number.
+		if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set register mask bits.
+		if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set register page number with inner page number for specific register 0 initializing.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Initialize demod with specific register 0 initializing table.
+	for(i = 0; i < RTL2840_INIT_SPEC_REG_0_TABLE_LEN; i++)
+	{
+		// Get all information from each specific register 0 initializing entry.
+		SpecReg0Sel         = InitSpecReg0Table[i].SpecReg0Sel;
+		pSpecReg0ValueTable = InitSpecReg0Table[i].SpecReg0ValueTable;
+
+		// Set specific register 0 selection.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_SEL, SpecReg0Sel) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 values.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, RTL2840_SPEC_REG_0_VAL_START_ADDR, pSpecReg0ValueTable, LEN_11_BYTE) !=
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Initialize demod registers according to the TS interface initializing table.
+	for(i = 0; i < RTL2840_TS_INTERFACE_INIT_TABLE_LEN; i++)
+	{
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, TsInterfaceInitTable[i].RegBitName,
+			TsInterfaceInitTable[i].WritingValue[TsInterfaceMode]) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Backup SPEC_INIT_A2 value.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_SPEC_INIT_A2, &QamSpecInitA2Backup)!= FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// Set SPEC_INIT_A2 with 0.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_SPEC_INIT_A2, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Get SPEC_MONITER_INIT_0 several times.
+	// If all SPEC_MONITER_INIT_0 getting values are the same, set SPEC_INIT_A1 with 0.
+	// Note: 1. Need to set SPEC_INIT_A2 with 0 when get SPEC_MONITER_INIT_0.
+	//       2. The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_SPEC_MONITER_INIT_0, &RegValueComparison) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	for(i = 0, AreAllValueEqual = YES; i < RTL2840_SPEC_MONITOR_INIT_0_COMPARISON_TIMES; i++)
+	{
+		if(rtl2840_GetMonitorRegBits(pDemod, QAM_SPEC_MONITER_INIT_0, &RegValue) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+
+		if(RegValue != RegValueComparison)
+		{
+			AreAllValueEqual = NO;
+
+			break;
+		}
+	}
+
+	if(AreAllValueEqual == YES)
+	{
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_SPEC_INIT_A1, 0x0) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+	// Restore SPEC_INIT_A2 value.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_SPEC_INIT_A2, QamSpecInitA2Backup) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_QAM_MODE
+
+*/
+int
+rtl2840_SetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int QamMode
+	)
+{
+	typedef struct
+	{
+		unsigned char PageNo;
+		unsigned char RegStartAddr;
+		unsigned char Msb;
+		unsigned char Lsb;
+		unsigned long WritingValue[QAM_QAM_MODE_NUM];
+	}
+	QAM_MODE_REG_ENTRY;
+
+
+	typedef struct
+	{
+		unsigned char SpecReg0Sel;
+		unsigned char SpecReg0ValueTable[QAM_QAM_MODE_NUM][RTL2840_SPEC_REG_0_VALUE_TABLE_LEN];
+	}
+	QAM_MODE_SPEC_REG_0_ENTRY;
+
+
+
+	static const QAM_MODE_REG_ENTRY QamModeRegTable[RTL2840_QAM_MODE_REG_TABLE_LEN] =
+	{
+		// Reg,									WritingValue according to QAM mode
+		// PageNo,	StartAddr,	Msb,	Lsb,	{4-Q,   16-Q,  32-Q,  64-Q,  128-Q, 256-Q, 512-Q, 1024-Q}
+		{1,			0x02,		2,		0,		{0x7,   0x0,   0x1,   0x2,   0x3,   0x4,   0x5,   0x6	}},
+		{1,			0x05,		7,		0,		{0x6b,  0x6b,  0x6b,  0x6b,  0x6b,  0x6b,  0x6b,  0x6b  }},
+		{1,			0x2f,		15,		5,		{0x37,  0x82,  0xb9,  0x10e, 0x177, 0x21c, 0x2ee, 0x451	}},
+		{1,			0x31,		5,		0,		{0x1,   0x3,   0x4,   0x5,   0x8,   0xa,   0xf,   0x14	}},
+		{1,			0x2e,		5,		0,		{0x2,   0x4,   0x6,   0x8,   0xc,   0x10,  0x18,  0x20	}},
+		{1,			0x18,		7,		0,		{0x0,   0xdb,  0x79,  0x0,   0x8a,  0x0,   0x8c,  0x0	}},
+		{1,			0x19,		4,		0,		{0x14,  0x14,  0xf,   0x14,  0xf,   0x14,  0xf,   0x14  }},
+		{1,			0x3b,		2,		0,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3b,		5,		3,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3c,		2,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3c,		4,		3,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3c,		6,		5,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		1,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		3,		2,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3d,		5,		4,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		7,		6,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x40,		2,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x40,		5,		3,		{0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x3,   0x3	}},
+		{1,			0x41,		2,		0,		{0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x4,   0x4	}},
+		{1,			0x41,		4,		3,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1	}},
+		{1,			0x41,		6,		5,		{0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2	}},
+		{1,			0x42,		1,		0,		{0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3	}},
+		{1,			0x42,		3,		2,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1	}},
+		{1,			0x42,		5,		4,		{0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2	}},
+		{1,			0x42,		7,		6,		{0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3	}},
+	};
+
+
+	static const QAM_MODE_SPEC_REG_0_ENTRY QamModeSpecReg0Table[RTL2840_QAM_MODE_SPEC_REG_0_TABLE_LEN] =
+	{
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{9,				{	{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 4-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 16-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 32-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 64-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 128-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 256-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 512-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},	}	// 1024-QAM
+		},
+
+
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{10,			{	{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 4-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 16-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 32-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 64-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 128-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 256-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 512-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},	}	// 1024-QAM
+		},
+
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{12,			{	{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 4-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 16-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 32-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 64-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 128-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 256-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 512-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},	}	// 1024-QAM
+		},
+	};
+
+
+	int i;
+
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+	unsigned long WritingValue;
+
+	unsigned char SpecReg0Sel;
+	const unsigned char *pSpecReg0ValueTable;
+
+
+
+	// Set demod QAM mode with QAM mode register setting table.
+	for(i = 0; i < RTL2840_QAM_MODE_REG_TABLE_LEN; i++)
+	{
+		// Get all information from each register setting entry according to QAM mode.
+		PageNo       = QamModeRegTable[i].PageNo;
+		RegStartAddr = QamModeRegTable[i].RegStartAddr;
+		Msb          = QamModeRegTable[i].Msb;
+		Lsb          = QamModeRegTable[i].Lsb;
+		WritingValue = QamModeRegTable[i].WritingValue[QamMode];
+
+		// Set register page number.
+		if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set register mask bits.
+		if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set register page number with inner page number for QAM mode specific register 0 setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Set demod QAM mode with QAM mode specific register 0 setting table.
+	for(i = 0; i < RTL2840_QAM_MODE_SPEC_REG_0_TABLE_LEN; i++)
+	{
+		// Get all information from each specific register 0 setting entry according to QAM mode.
+		SpecReg0Sel         = QamModeSpecReg0Table[i].SpecReg0Sel;
+		pSpecReg0ValueTable = QamModeSpecReg0Table[i].SpecReg0ValueTable[QamMode];
+
+		// Set specific register 0 selection.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_SEL, SpecReg0Sel) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 values.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, RTL2840_SPEC_REG_0_VAL_START_ADDR, pSpecReg0ValueTable, LEN_11_BYTE) != 
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set demod QAM mode parameter.
+	pDemod->QamMode      = QamMode;
+	pDemod->IsQamModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_SYMBOL_RATE_HZ
+
+*/
+int
+rtl2840_SetSymbolRateHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long SymbolRateHz
+	)
+{
+	typedef struct
+	{
+		unsigned long TrDeciRatioRangeMin;
+		unsigned char SymbolRateReg0;
+		unsigned long SymbolRateValue[RTL2840_SYMBOL_RATE_VALUE_TABLE_LEN];
+	}
+	SYMBOL_RATE_ENTRY;
+
+
+
+	static const SYMBOL_RATE_ENTRY SymbolRateTable[RTL2840_SYMBOL_RATE_TABLE_LEN] =
+	{
+		// TrDeciRatioRangeMin,	SymbolRateReg0,	{SymbolRateValue                              }
+		{0x1a0000,				0x4,			{10,   14,   1,  988,  955, 977, 68,  257, 438}	},
+		{0x160000,				0x5,			{2,    15,   19, 1017, 967, 950, 12,  208, 420}	},
+		{0x0,					0x6,			{1019, 1017, 9,  29,   3,   957, 956, 105, 377}	},
+	};
+
+
+	int i;
+
+	unsigned long CrystalFreqHz;
+	const SYMBOL_RATE_ENTRY *pSymbolRateEntry;
+
+	MPI MpiCrystalFreqHz, MpiSymbolRateHz, MpiConst, MpiVar, MpiNone;
+
+	unsigned long TrDeciRatio;
+	unsigned char SymbolRateReg0;
+	unsigned long SymbolRateValue;
+
+
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+	
+	// Calculate TR_DECI_RATIO value.
+	// Note: Original formula:   TR_DECI_RATIO = round( (CrystalFreqHz * pow(2, 18)) / SymbolRateHz )
+	//       Adjusted formula:   TR_DECI_RATIO = floor( ((CrystalFreqHz << 19) / SymbolRateHz + 1) >> 1 )
+	MpiSetValue(&MpiCrystalFreqHz, CrystalFreqHz);
+	MpiSetValue(&MpiSymbolRateHz, SymbolRateHz);
+	MpiSetValue(&MpiConst, 1);
+
+	MpiLeftShift(&MpiVar, MpiCrystalFreqHz, 19);
+	MpiDiv(&MpiVar, &MpiNone, MpiVar, MpiSymbolRateHz);
+	MpiAdd(&MpiVar, MpiVar, MpiConst);
+	MpiRightShift(&MpiVar, MpiVar, 1);
+
+	MpiGetValue(MpiVar, (long *)&TrDeciRatio);
+
+
+	// Determine symbol rate entry according to TR_DECI_RATIO value and minimum of TR_DECI_RATIO range.
+	for(i = 0; i < RTL2840_SYMBOL_RATE_TABLE_LEN; i++)
+	{
+		if(TrDeciRatio >= SymbolRateTable[i].TrDeciRatioRangeMin)
+		{
+			pSymbolRateEntry = &SymbolRateTable[i];
+
+			break;
+		}
+	}
+
+
+	// Set register page number with inner page number for symbol rate setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Set TR_DECI_RATIO with calculated value.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_TR_DECI_RATIO, TrDeciRatio) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set SPEC_SYMBOL_RATE_REG_0 value with determined symbol rate entry.
+	SymbolRateReg0 = pSymbolRateEntry->SymbolRateReg0;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_SYMBOL_RATE_REG_0, SymbolRateReg0) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set symbol rate value with determined symbol rate entry.
+	for(i = 0; i < RTL2840_SYMBOL_RATE_VALUE_TABLE_LEN; i++)
+	{
+		// Get symbol rate value.
+		SymbolRateValue = pSymbolRateEntry->SymbolRateValue[i];
+
+		// Set symbol rate register selection.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_SYMBOL_RATE_SEL, i) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set symbol rate register value.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_SYMBOL_RATE_VAL, SymbolRateValue) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set symbol rate register strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_SYMBOL_RATE_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set demod symbol rate parameter.
+	pDemod->SymbolRateHz      = SymbolRateHz;
+	pDemod->IsSymbolRateHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_ALPHA_MODE
+
+*/
+int
+rtl2840_SetAlphaMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int AlphaMode
+	)
+{
+	static const unsigned long AlphaValueTable[QAM_ALPHA_MODE_NUM][RTL2840_ALPHA_VALUE_TABLE_LEN] =
+	{
+		{258,  94,   156,  517,  6,  1015,  1016,  17,  11,  994,   1011,  51,  15,  926,  1008,  313},	// alpha = 0.12
+		{258,  31,   28,   3,    6,  1016,  1016,  16,  11,  996,   1010,  50,  16,  927,  1007,  312},	// alpha = 0.13
+		{131,  257,  27,   2,    8,  1017,  1013,  16,  14,  996,   1008,  50,  18,  927,  1004,  310},	// alpha = 0.15
+		{0,    195,  30,   30,   6,  1022,  1014,  10,  14,  1002,  1006,  45,  21,  931,  1001,  307},	// alpha = 0.18
+		{415,  68,   31,   29,   4,  1,     1016,  6,   13,  1006,  1006,  41,  23,  934,  998,   304},	// alpha = 0.20
+	};
+
+
+	int i;
+	unsigned long AlphaValue;
+
+
+
+	// Set register page number with inner page number for alpha value setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Set demod alpha mode with alpha value table.
+	for(i = 0; i < RTL2840_ALPHA_VALUE_TABLE_LEN; i++)
+	{
+		// Get alpha value from alpha value entry according to alpha mode.
+		AlphaValue = AlphaValueTable[AlphaMode][i];
+
+		// Set alpha register selection.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_ALPHA_SEL, i) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set alpha register value.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_ALPHA_VAL, AlphaValue) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set alpha register strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_ALPHA_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set demod alpha mode parameter.
+	pDemod->AlphaMode      = AlphaMode;
+	pDemod->IsAlphaModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_IF_FREQ_HZ
+
+*/
+int
+rtl2840_SetIfFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	)
+{
+	unsigned long CrystalFreqHz;
+	unsigned long DdcFreq;
+
+	MPI MpiIfFreqHz, MpiCrystalFreqHz, MpiConst, MpiVar, MpiNone;
+
+
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Calculate DDC_FREQ value.
+	// Note: Original formula:   DDC_FREQ = round( (CrystalFreqHz - (IfFreqHz % CrystalFreqHz)) * pow(2, 15) /
+	//                                             CrystalFreqHz )
+	//       Adjusted formula:   DDC_FREQ = floor( ( ((CrystalFreqHz - (IfFreqHz % CrystalFreqHz)) << 16) /
+	//                                               CrystalFreqHz + 1 ) >> 1)
+	MpiSetValue(&MpiIfFreqHz, IfFreqHz);
+	MpiSetValue(&MpiCrystalFreqHz, CrystalFreqHz);
+	MpiSetValue(&MpiConst, 1);
+
+	MpiSetValue(&MpiVar, CrystalFreqHz - (IfFreqHz % CrystalFreqHz));
+	MpiLeftShift(&MpiVar, MpiVar, 16);
+	MpiDiv(&MpiVar, &MpiNone, MpiVar, MpiCrystalFreqHz);
+	MpiAdd(&MpiVar, MpiVar, MpiConst);
+	MpiRightShift(&MpiVar, MpiVar, 1);
+
+	MpiGetValue(MpiVar, (long *)&DdcFreq);
+
+
+	// Set DDC_FREQ with calculated value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_DDC_FREQ, DdcFreq) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set demod IF frequnecy parameter.
+	pDemod->IfFreqHz      = IfFreqHz;
+	pDemod->IsIfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_SPECTRUM_MODE
+
+*/
+int
+rtl2840_SetSpectrumMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	)
+{
+	static const char SpecInvValueTable[SPECTRUM_MODE_NUM] =
+	{
+		// SpecInv
+		0,				// Normal spectrum
+		1,				// Inverse spectrum
+	};
+
+
+	unsigned long SpecInv;
+
+
+
+	// Get SPEC_INV value from spectrum inverse value table according to spectrum mode.
+	SpecInv = SpecInvValueTable[SpectrumMode];
+
+
+	// Set SPEC_INV with gotten value.
+	// Note: Use SetRegBitsWithPage() to set register bits with page setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_SPEC_INV, SpecInv) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set demod spectrum mode parameter.
+	pDemod->SpectrumMode      = SpectrumMode;
+	pDemod->IsSpectrumModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_RF_AGC
+
+*/
+int
+rtl2840_GetRfAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	)
+{
+	unsigned long RfAgcBinary;
+
+
+	// Get RF AGC binary value from RF_AGC_VALUE monitor register bits.
+	// Note: The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_RF_AGC_VALUE, &RfAgcBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Convert RF AGC binary value to signed integer.
+	*pRfAgc = BinToSignedInt(RfAgcBinary, RTL2840_RF_AGC_VALUE_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_IF_AGC
+
+*/
+int
+rtl2840_GetIfAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	)
+{
+	unsigned long IfAgcBinary;
+
+
+	// Get IF AGC binary value from IF_AGC_VALUE monitor register bits.
+	// Note: The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_IF_AGC_VALUE, &IfAgcBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Convert IF AGC binary value to signed integer.
+	*pIfAgc = BinToSignedInt(IfAgcBinary, RTL2840_IF_AGC_VALUE_BIT_NUM);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_DI_AGC
+
+*/
+int
+rtl2840_GetDiAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	)
+{
+	// Get digital AGC value from DAGC_VALUE monitor register bits.
+	// Note: The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_DAGC_VALUE, pDiAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+rtl2840_GetTrOffsetPpm(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	)
+{
+	unsigned long SymbolRateHz;
+	unsigned long CrystalFreqHz;
+
+	unsigned long TrOffsetBinary;
+	long          TrOffsetInt;
+
+	MPI MpiTrOffsetInt, MpiSymbolRateHz, MpiCrystalFreqHz, MpiVar0, MpiVar1;
+
+
+
+	// Get demod symbol rate in Hz.
+	if(pDemod->GetSymbolRateHz(pDemod, &SymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_symbol_rate;
+
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Get TR offset binary value from TR_OFFSET monitor register bits.
+	// Note: The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_TR_OFFSET, &TrOffsetBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Convert TR offset binary value to signed integer.
+	TrOffsetInt = BinToSignedInt(TrOffsetBinary, RTL2840_TR_OFFSET_BIT_NUM);
+
+
+	// Get TR offset in ppm.
+	// Note: (TR offset in ppm) = ((TR offset integer) * (symbol rate in Hz) * 1000000) /
+	//                            ((pow(2, 35) * (crystal frequency in Hz))
+	//       TR offset integer is 31 bit value.
+	MpiSetValue(&MpiTrOffsetInt,   TrOffsetInt);
+	MpiSetValue(&MpiSymbolRateHz,  (long)SymbolRateHz);
+	MpiSetValue(&MpiCrystalFreqHz, (long)CrystalFreqHz);
+	MpiSetValue(&MpiVar0,          1000000);
+
+	MpiMul(&MpiVar0, MpiVar0, MpiTrOffsetInt);
+	MpiMul(&MpiVar0, MpiVar0, MpiSymbolRateHz);
+	MpiLeftShift(&MpiVar1, MpiCrystalFreqHz, 35);
+	MpiDiv(&MpiVar0, &MpiVar1, MpiVar0, MpiVar1);
+
+	MpiGetValue(MpiVar0, pTrOffsetPpm);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_get_demod_symbol_rate:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+rtl2840_GetCrOffsetHz(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	)
+{
+	unsigned long SymbolRateHz;
+
+	unsigned long CrOffsetBinary;
+	long          CrOffsetInt;
+
+	MPI MpiCrOffsetInt, MpiSymbolRateHz, MpiMiddleResult;
+
+
+
+	// Get demod symbol rate in Hz.
+	if(pDemod->GetSymbolRateHz(pDemod, &SymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_symbol_rate;
+
+
+	// Get CR offset binary value from CR_OFFSET monitor register bits.
+	// Note: The function rtl2840_GetMonitorRegBits() will set register page automatically.
+	if(rtl2840_GetMonitorRegBits(pDemod, QAM_CR_OFFSET, &CrOffsetBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Convert CR offset binary value to signed integer.
+	CrOffsetInt = BinToSignedInt(CrOffsetBinary, RTL2840_CR_OFFSET_BIT_NUM);
+
+
+	// Get CR offset in Hz.
+	// Note: (CR offset in Hz) = (CR offset integer) * (symbol rate in Hz) / pow(2, 34)
+	//       CR offset integer is 32 bit value.
+	MpiSetValue(&MpiCrOffsetInt,  CrOffsetInt);
+	MpiSetValue(&MpiSymbolRateHz, (long)SymbolRateHz);
+
+	MpiMul(&MpiMiddleResult, MpiCrOffsetInt, MpiSymbolRateHz);
+	MpiRightShift(&MpiMiddleResult, MpiMiddleResult, 34);
+
+	MpiGetValue(MpiMiddleResult, pCrOffsetHz);
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_get_demod_symbol_rate:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_IS_AAGC_LOCKED
+
+*/
+int
+rtl2840_IsAagcLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long LockStatus;
+
+
+
+	// Get AAGC lock status from AAGC_LD inner strobe register bits.
+	// Note: The function rtl2840_GetInnerStrobeRegBits() will set register page automatically.
+	if(rtl2840_GetInnerStrobeRegBits(pDemod, QAM_AAGC_LD, &LockStatus) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Determine answer according to AAGC lock status.
+	if(LockStatus == LOCKED)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_IS_EQ_LOCKED
+
+*/
+int
+rtl2840_IsEqLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long LockStatus;
+
+
+
+	// Get EQ lock status from EQ_LD inner strobe register bits.
+	// Note: The function rtl2840_GetInnerStrobeRegBits() will set register page automatically.
+	if(rtl2840_GetInnerStrobeRegBits(pDemod, QAM_EQ_LD, &LockStatus) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Determine answer according to EQ lock status.
+	if(LockStatus == LOCKED)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_IS_FRAME_LOCKED
+
+*/
+int
+rtl2840_IsFrameLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	)
+{
+	unsigned long LossStatus;
+
+
+
+	// Get frame loss status from SYNCLOST register bits.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_SYNCLOST, &LossStatus) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Determine answer according to frame loss status.
+	if(LossStatus == NOT_LOST)
+		*pAnswer = YES;
+	else
+		*pAnswer = NO;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_ERROR_RATE
+
+*/
+int
+rtl2840_GetErrorRate(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i;
+	unsigned long TestPacketNum;
+	unsigned int  WaitCnt;
+	int FrameLock;
+	unsigned long BerReg2, BerReg2Msb, BerReg2Lsb;
+	unsigned long BerReg0, BerReg1;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Calculate test packet number and wait counter value.
+	TestPacketNum = 0x1 << (TestVolume * 2 + 4);
+	WaitCnt = WaitTimeMsMax / RTL2840_BER_WAIT_TIME_MS;
+
+
+	// Set TEST_VOLUME with test volume.
+	// Note: The function SetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_TEST_VOLUME, TestVolume) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Clear and enable error counter.
+	// Note: The function SetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_BERT_EN, OFF) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_BERT_EN, ON) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Check if error test is finished.
+	for(i = 0; i < WaitCnt; i++)
+	{
+		// Check if demod is frame-locked.
+		if(pDemod->IsFrameLocked(pDemod, &FrameLock) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+
+		if(FrameLock == NO)
+			goto error_status_frame_lock;
+
+
+		// Wait a minute.
+		// Note: The input unit of WaitMs() is ms.
+		pBaseInterface->WaitMs(pBaseInterface, RTL2840_BER_WAIT_TIME_MS);
+
+
+		// Set error counter strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		//       The function SetRegBitsWithPage() will set register page automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_BER_RD_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+
+		// Check if error test is finished.
+		// Note: The function GetRegBitsWithPage() will set register page automatically.
+		if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_BER_REG2_15_0, &BerReg2Lsb) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+
+		if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_BER_REG2_18_16, &BerReg2Msb) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+
+		BerReg2 = (BerReg2Msb << RTL2840_BER_REG2_MSB_SHIFT) | BerReg2Lsb;
+
+		if(BerReg2 == TestPacketNum)
+			break;
+	}
+
+
+	// Check time-out status.
+	if(i == WaitCnt)
+		goto error_status_time_out;
+
+
+	// Get BER register 0 from BER_REG0.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_BER_REG0, &BerReg0) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Get BER register 1 from BER_REG1.
+	// Note: The function GetRegBitsWithPage() will set register page automatically.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBitsWithPage(pDemod, QAM_BER_REG1, &BerReg1) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Set BER numerator and denominator.
+	*pBerNum = 27 * BerReg0 + BerReg1;
+	*pBerDen = 1632 * TestPacketNum;
+
+
+	// Set PER numerator and denominator.
+	*pPerNum = BerReg0;
+	*pPerDen = TestPacketNum;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+error_status_frame_lock:
+error_status_time_out:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_SNR_DB
+
+*/
+int
+rtl2840_GetSnrDb(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	static const unsigned long SnrConstTable[QAM_QAM_MODE_NUM] =
+	{
+		26880,		// for    4-QAM mode
+		29852,		// for   16-QAM mode
+		31132,		// for   32-QAM mode
+		32502,		// for   64-QAM mode
+		33738,		// for  128-QAM mode
+		35084,		// for  256-QAM mode
+		36298,		// for  512-QAM mode
+		37649,		// for 1024-QAM mode
+	};
+
+	int QamMode;
+
+	unsigned long Mse;
+	long MiddleResult;
+	MPI MpiMse, MpiResult;
+
+
+
+	// Get demod QAM mode.
+	if(pDemod->GetQamMode(pDemod, &QamMode) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_qam_mode;
+
+
+	// Get mean-square error from MSE.
+	// Note: The function rtl2840_GetInnerStrobeRegBits() will set register page automatically.
+	if(rtl2840_GetInnerStrobeRegBits(pDemod, QAM_MSE, &Mse) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Calculate SNR dB numerator.
+	MpiSetValue(&MpiMse, Mse);
+	MpiLog2(&MpiResult, MpiMse, RTL2840_SNR_FRAC_BIT_NUM);
+	MpiGetValue(MpiResult, &MiddleResult);
+
+	*pSnrDbNum = SnrConstTable[QamMode] - 10 * MiddleResult;
+
+	
+	// Set SNR dB denominator.
+	*pSnrDbDen = RTL2840_SNR_DB_DEN;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_get_demod_qam_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+rtl2840_GetSignalStrength(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	)
+{
+	int FrameLock;
+	long IfAgcValue;
+
+
+
+	// Get demod frame lock status.
+	if(pDemod->IsFrameLocked(pDemod, &FrameLock) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// If demod is not frame-locked, set signal strength with zero.
+	if(FrameLock == NO)
+	{
+		*pSignalStrength = 0;
+		goto success_status_non_frame_lock;
+	}
+
+
+	// Get IF AGC value.
+	if(pDemod->GetIfAgc(pDemod, &IfAgcValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Determine signal strength according to IF AGC value.
+	// Note: Map IF AGC value (1023 ~ -1024) to signal strength (0 ~ 100).
+	*pSignalStrength = (102300 - IfAgcValue * 100) / 2047;
+
+
+success_status_non_frame_lock:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+rtl2840_GetSignalQuality(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	)
+{
+	int FrameLock;
+
+	unsigned long Mse;
+	long MiddleResult;
+	MPI MpiMse, MpiResult;
+
+
+
+	// Get demod frame lock status.
+	if(pDemod->IsFrameLocked(pDemod, &FrameLock) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+	// If demod is not frame-locked, set signal quality with zero.
+	if(FrameLock == NO)
+	{
+		*pSignalQuality = 0;
+		goto success_status_non_frame_lock;
+	}
+
+
+	// Get mean-square error from MSE.
+	// Note: The function rtl2840_GetInnerStrobeRegBits() will set register page automatically.
+	if(rtl2840_GetInnerStrobeRegBits(pDemod, QAM_MSE, &Mse) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Determine signal quality according to MSE value.
+	// Note: Map MSE value (pow(2, 19) ~ pow(2, 17)) to signal quality (0 ~ 100).
+	//       If MSE value < pow(2, 17), signal quality is 100.
+	//       If MSE value > pow(2, 19), signal quality is 0.
+	if(Mse > 524288)
+	{
+		*pSignalQuality = 0;
+	}
+	else if(Mse < 131072)
+	{
+		*pSignalQuality = 100;
+	}
+	else
+	{
+		MpiSetValue(&MpiMse, Mse);
+		MpiLog2(&MpiResult, MpiMse, RTL2840_SIGNAL_QUALITY_FRAC_BIT_NUM);
+		MpiGetValue(MpiResult, &MiddleResult);
+
+		*pSignalQuality = (243200 - MiddleResult * 100) / 256;
+	}
+
+
+success_status_non_frame_lock:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2840_UpdateFunction(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	// RTL2840 does not use UpdateFunction(), so we just return FUNCTION_SUCCESS.
+	return FUNCTION_SUCCESS;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_RESET_FUNCTION
+
+*/
+int
+rtl2840_ResetFunction(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	// RTL2840 does not use UpdateFunction(), so we just return FUNCTION_SUCCESS.
+	return FUNCTION_SUCCESS;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_QAM_MODE
+
+*/
+int
+rtl2840_am_hum_en_SetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int QamMode
+	)
+{
+	typedef struct
+	{
+		unsigned char PageNo;
+		unsigned char RegStartAddr;
+		unsigned char Msb;
+		unsigned char Lsb;
+		unsigned long WritingValue[QAM_QAM_MODE_NUM];
+	}
+	QAM_MODE_REG_ENTRY;
+
+
+	typedef struct
+	{
+		unsigned char SpecReg0Sel;
+		unsigned char SpecReg0ValueTable[QAM_QAM_MODE_NUM][RTL2840_SPEC_REG_0_VALUE_TABLE_LEN];
+	}
+	QAM_MODE_SPEC_REG_0_ENTRY;
+
+
+
+	static const QAM_MODE_REG_ENTRY QamModeRegTable[RTL2840_QAM_MODE_REG_TABLE_LEN] =
+	{
+		// Reg,									WritingValue according to QAM mode
+		// PageNo,	StartAddr,	Msb,	Lsb,	{4-Q,   16-Q,  32-Q,  64-Q,  128-Q, 256-Q, 512-Q, 1024-Q}
+		{1,			0x02,		2,		0,		{0x7,   0x0,   0x1,   0x2,   0x3,   0x4,   0x5,   0x6	}},
+		{1,			0x2f,		15,		5,		{0x37,  0x82,  0xb9,  0x10e, 0x177, 0x21c, 0x2ee, 0x451	}},
+		{1,			0x31,		5,		0,		{0x1,   0x3,   0x4,   0x5,   0x8,   0xa,   0xf,   0x14	}},
+		{1,			0x2e,		5,		0,		{0x2,   0x4,   0x6,   0x8,   0xc,   0x10,  0x18,  0x20	}},
+		{1,			0x18,		7,		0,		{0x0,   0xdb,  0x79,  0x0,   0x8a,  0x0,   0x8c,  0x0	}},
+		{1,			0x19,		4,		0,		{0x14,  0x14,  0xf,   0x14,  0xf,   0x14,  0xf,   0x14  }},
+		{1,			0x3b,		2,		0,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3b,		5,		3,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3c,		2,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3c,		4,		3,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3c,		6,		5,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		1,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		3,		2,		{0x0,   0x0,   0x0,   0x0,   0x0,   0x0,   0x1,   0x1	}},
+		{1,			0x3d,		5,		4,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x3d,		7,		6,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x41,		4,		3,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1	}},
+		{1,			0x41,		6,		5,		{0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2	}},
+		{1,			0x42,		1,		0,		{0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3	}},
+		{1,			0x42,		3,		2,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x1	}},
+		{1,			0x42,		5,		4,		{0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2,   0x2	}},
+		{1,			0x42,		7,		6,		{0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3,   0x3	}},
+
+
+		// For AM-hum enhancement
+		// Reg,									WritingValue according to QAM mode
+		// PageNo,	StartAddr,	Msb,	Lsb,	{4-Q,   16-Q,  32-Q,  64-Q,  128-Q, 256-Q, 512-Q, 1024-Q}
+		{1,			0x05,		7,		0,		{0x64,  0x64,  0x64,  0x64,  0x6b,  0x6b,  0x6b,  0x6b  }},
+		{1,			0x40,		2,		0,		{0x1,   0x1,   0x1,   0x1,   0x1,   0x1,   0x2,   0x2	}},
+		{1,			0x40,		5,		3,		{0x1,   0x1,   0x1,   0x1,   0x2,   0x2,   0x3,   0x3	}},
+		{1,			0x41,		2,		0,		{0x0,   0x0,   0x0,   0x0,   0x3,   0x3,   0x4,   0x4	}},
+	};
+
+
+	static const QAM_MODE_SPEC_REG_0_ENTRY QamModeSpecReg0Table[RTL2840_QAM_MODE_SPEC_REG_0_TABLE_LEN] =
+	{
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{9,				{	{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 4-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 16-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 32-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 64-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 128-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},		// 256-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x10, 0x70, 0x80, 0xfa, 0xcb, 0x00},		// 512-QAM
+							{0x99, 0xa9, 0xc9, 0x4e, 0x48, 0x20, 0x71, 0x80, 0xfa, 0xcb, 0x00},	}	// 1024-QAM
+		},
+
+
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{10,			{	{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 4-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 16-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 32-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 64-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 128-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x20, 0x71, 0xa0, 0xfa, 0xcb, 0x00},		// 256-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},		// 512-QAM
+							{0xaa, 0xbb, 0xee, 0x5e, 0x48, 0x10, 0x70, 0xa0, 0xfa, 0xcb, 0x00},	}	// 1024-QAM
+		},
+
+
+
+		// For AM-hum enhancement
+		// SpecReg0Sel,		{SpecReg0ValueTable                                              }		   QAM mode
+		{12,			{	{0xc8, 0xcc, 0x40, 0x7e, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 4-QAM
+							{0xc8, 0xcc, 0x40, 0x7e, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 16-QAM
+							{0xc8, 0xcc, 0x40, 0x7e, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 32-QAM
+							{0xc8, 0xcc, 0x40, 0x7e, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 64-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 128-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 256-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},		// 512-QAM
+							{0xc8, 0xcc, 0x00, 0x7f, 0x28, 0xda, 0x4b, 0xa0, 0xfe, 0xcd, 0x01},	}	// 1024-QAM
+		},
+	};
+
+
+	int i;
+
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+	unsigned long WritingValue;
+
+	unsigned char SpecReg0Sel;
+	const unsigned char *pSpecReg0ValueTable;
+
+
+
+	// Set demod QAM mode with QAM mode register setting table.
+	for(i = 0; i < RTL2840_QAM_MODE_REG_TABLE_LEN; i++)
+	{
+		// Get all information from each register setting entry according to QAM mode.
+		PageNo       = QamModeRegTable[i].PageNo;
+		RegStartAddr = QamModeRegTable[i].RegStartAddr;
+		Msb          = QamModeRegTable[i].Msb;
+		Lsb          = QamModeRegTable[i].Lsb;
+		WritingValue = QamModeRegTable[i].WritingValue[QamMode];
+
+		// Set register page number.
+		if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set register mask bits.
+		if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set register page number with inner page number for QAM mode specific register 0 setting.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// Set demod QAM mode with QAM mode specific register 0 setting table.
+	for(i = 0; i < RTL2840_QAM_MODE_SPEC_REG_0_TABLE_LEN; i++)
+	{
+		// Get all information from each specific register 0 setting entry according to QAM mode.
+		SpecReg0Sel         = QamModeSpecReg0Table[i].SpecReg0Sel;
+		pSpecReg0ValueTable = QamModeSpecReg0Table[i].SpecReg0ValueTable[QamMode];
+
+		// Set specific register 0 selection.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_SEL, SpecReg0Sel) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 values.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, RTL2840_SPEC_REG_0_VAL_START_ADDR, pSpecReg0ValueTable, LEN_11_BYTE) != 
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+
+		// Set specific register 0 strobe.
+		// Note: RTL2840 hardware will clear strobe automatically.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_SPEC_REG_0_STROBE, ON) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set demod QAM mode parameter.
+	pDemod->QamMode      = QamMode;
+	pDemod->IsQamModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD
+
+*/
+int
+rtl2840_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module and tuner device address.
+	pDemod = (QAM_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+	
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Enable demod I2C relay.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_OPT_I2C_RELAY, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Send I2C reading command.
+	if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_reading_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_reading_command:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD
+
+*/
+int
+rtl2840_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get demod module and tuner device address.
+	pDemod = (QAM_DEMOD_MODULE *)pI2cBridge->pPrivateData;
+
+	
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Enable demod I2C relay.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_OPT_I2C_RELAY, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Send I2C writing command.
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, pWritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_send_i2c_writing_command;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_send_i2c_writing_command:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Initialize base register table
+
+RTL2840 builder will use rtl2840_InitBaseRegTable() to initialize base register table.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@see   BuildRtl2840Module()
+
+*/
+void
+rtl2840_InitBaseRegTable(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	static const QAM_PRIMARY_BASE_REG_ENTRY_ADDR_8BIT PrimaryBaseRegTable[RTL2840_BASE_REG_TABLE_LEN] =
+	{
+		// Generality
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_SYS_VERSION,					0,			0x01,			7,		0	},
+		{QAM_OPT_I2C_RELAY,					0,			0x03,			5,		5	},
+		{QAM_SOFT_RESET,					0,			0x09,			0,		0	},
+
+		// Miscellany
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_OPT_I2C_DRIVE_CURRENT,			0,			0x07,			7,		7	},
+		{QAM_GPIO2_OEN,						0,			0x05,			6,		6	},
+		{QAM_GPIO3_OEN,						0,			0x05,			7,		7	},
+		{QAM_GPIO2_O,						0,			0x0a,			2,		2	},
+		{QAM_GPIO3_O,						0,			0x0a,			3,		3	},
+		{QAM_GPIO2_I,						0,			0x0a,			6,		6	},
+		{QAM_GPIO3_I,						0,			0x0a,			7,		7	},
+		{QAM_INNER_DATA_STROBE,				1,			0x69,			0,		0	},
+		{QAM_INNER_DATA_SEL1,				1,			0x48,			7,		0	},
+		{QAM_INNER_DATA_SEL2,				1,			0x49,			7,		0	},
+		{QAM_INNER_DATA1,					1,			0x6a,			15,		0	},
+		{QAM_INNER_DATA2,					1,			0x6c,			15,		0	},
+
+		// QAM mode
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_QAM_MODE,						1,			0x02,			2,		0	},
+
+		// AD
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_AD_AV,							0,			0x0b,			2,		0	},
+
+		// AAGC
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_OPT_RF_AAGC_DRIVE_CURRENT,		0,			0x07,			0,		0	},
+		{QAM_OPT_IF_AAGC_DRIVE_CURRENT,		0,			0x07,			1,		1	},
+		{QAM_OPT_RF_AAGC_DRIVE,				0,			0x04,			3,		3	},
+		{QAM_OPT_IF_AAGC_DRIVE,				0,			0x04,			4,		4	},
+		{QAM_OPT_RF_AAGC_OEN,				0,			0x04,			6,		6	},
+		{QAM_OPT_IF_AAGC_OEN,				0,			0x04,			7,		7	},
+		{QAM_PAR_RF_SD_IB,					0,			0x03,			0,		0	},
+		{QAM_PAR_IF_SD_IB,					0,			0x03,			1,		1	},
+		{QAM_AAGC_FZ_OPTION,				1,			0x04,			5,		4	},
+		{QAM_AAGC_TARGET,					1,			0x05,			7,		0	},
+		{QAM_RF_AAGC_MAX,					1,			0x06,			7,		0	},
+		{QAM_RF_AAGC_MIN,					1,			0x07,			7,		0	},
+		{QAM_IF_AAGC_MAX,					1,			0x08,			7,		0	},
+		{QAM_IF_AAGC_MIN,					1,			0x09,			7,		0	},
+		{QAM_VTOP,							1,			0x0b,			7,		0	},
+		{QAM_KRF_MSB,						1,			0x0c,			6,		3	},
+		{QAM_KRF_LSB,						1,			0x04,			7,		6	},
+		{QAM_AAGC_MODE_SEL,					1,			0x0c,			7,		7	},
+		{QAM_AAGC_LD,						1,			0x72,			0,		0	},
+		{QAM_AAGC_INIT_LEVEL,				1,			0x0a,			7,		0	},
+
+		// DDC
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_DDC_FREQ,						1,			0x0d,			14,		0	},
+		{QAM_SPEC_INV,						1,			0x0e,			7,		7	},
+
+		// Timing recovery
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_TR_DECI_RATIO,					1,			0x1f,			23,		0	},
+
+		// Carrier recovery
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_CR_LD,							1,			0x74,			5,		0	},
+
+		// Equalizer
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_EQ_LD,							1,			0x72,			1,		1	},
+		{QAM_MSE,							1,			0x76,			21,		0	},
+
+		// Frame sync. indicator
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_SYNCLOST,						2,			0x02,			7,		7	},
+
+		// BER
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_BER_RD_STROBE,					2,			0x05,			7,		7	},
+		{QAM_BERT_EN,						2,			0x06,			0,		0	},
+		{QAM_BERT_HOLD,						2,			0x06,			1,		1	},
+		{QAM_DIS_AUTO_MODE,					2,			0x06,			2,		2	},
+		{QAM_TEST_VOLUME,					2,			0x06,			5,		3	},
+		{QAM_BER_REG0,						2,			0x0e,			15,		0	},
+		{QAM_BER_REG1,						2,			0x07,			20,		0	},
+		{QAM_BER_REG2_15_0,					2,			0x0a,			15,		0	},
+		{QAM_BER_REG2_18_16,				2,			0x09,			7,		5	},
+
+		// MPEG TS output interface
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_CKOUTPAR,						2,			0x11,			0,		0	},
+		{QAM_CKOUT_PWR,						2,			0x11,			1,		1	},
+		{QAM_CDIV_PH0,						2,			0x12,			3,		0	},
+		{QAM_CDIV_PH1,						2,			0x12,			7,		4	},
+		{QAM_MPEG_OUT_EN,					0,			0x04,			5,		5	},
+		{QAM_OPT_MPEG_DRIVE_CURRENT,		0,			0x07,			2,		2	},
+		{QAM_NO_REINVERT,					2,			0x10,			2,		2	},
+		{QAM_FIX_TEI,						2,			0x10,			3,		3	},
+		{QAM_SERIAL,						2,			0x11,			2,		2	},
+
+		// Monitor
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_ADC_CLIP_CNT_REC,				1,			0x6a,			15,		4	},
+		{QAM_DAGC_LEVEL_26_11,				1,			0x6a,			15,		0	},
+		{QAM_DAGC_LEVEL_10_0,				1,			0x6c,			15,		5	},
+		{QAM_RF_AAGC_SD_IN,					1,			0x6a,			15,		5	},
+		{QAM_IF_AAGC_SD_IN,					1,			0x6c,			15,		5	},
+		{QAM_KI_TR_OUT_30_15,				1,			0x6a,			15,		0	},
+		{QAM_KI_TR_OUT_14_0,				1,			0x6c,			15,		1	},
+		{QAM_KI_CR_OUT_15_0,				1,			0x6a,			15,		0	},
+		{QAM_KI_CR_OUT_31_16,				1,			0x6c,			15,		0	},
+
+		// Specific register
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_SPEC_SIGNAL_INDICATOR,			1,			0x73,			5,		3	},
+		{QAM_SPEC_ALPHA_STROBE,				1,			0x57,			0,		0	},
+		{QAM_SPEC_ALPHA_SEL,				1,			0x57,			4,		1	},
+		{QAM_SPEC_ALPHA_VAL,				1,			0x57,			14,		5	},
+		{QAM_SPEC_SYMBOL_RATE_REG_0,		1,			0x0f,			2,		0	},
+		{QAM_SPEC_SYMBOL_RATE_STROBE,		1,			0x5b,			0,		0	},
+		{QAM_SPEC_SYMBOL_RATE_SEL,			1,			0x5b,			4,		1	},
+		{QAM_SPEC_SYMBOL_RATE_VAL,			1,			0x5b,			14,		5	},
+		{QAM_SPEC_REG_0_STROBE,				1,			0x5d,			0,		0	},
+		{QAM_SPEC_REG_0_SEL,				1,			0x5d,			4,		1	},
+
+		// Specific register for initialization
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_SPEC_INIT_A0,					1,			0x6a,			15,		6	},
+		{QAM_SPEC_INIT_A1,					0,			0x0f,			0,		0	},
+		{QAM_SPEC_INIT_A2,					1,			0x2b,			1,		1	},
+
+		// Pseudo register for test only
+		// RegBitName,						PageNo,		RegStartAddr,	Msb,	Lsb
+		{QAM_TEST_REG_0,					1,			0x17,			6,		2	},
+		{QAM_TEST_REG_1,					1,			0x17,			14,		1	},
+		{QAM_TEST_REG_2,					1,			0x17,			21,		3	},
+		{QAM_TEST_REG_3,					1,			0x17,			30,		2	},
+	};
+
+
+	int i;
+	int RegBitName;
+
+
+
+	// Initialize base register table according to primary base register table.
+	// Note: 1. Base register table rows are sorted by register bit name key.
+	//       2. The default value of the IsAvailable variable is "NO".
+	for(i = 0; i < QAM_BASE_REG_TABLE_LEN_MAX; i++)
+		pDemod->BaseRegTable.Addr8Bit[i].IsAvailable  = NO;
+
+	for(i = 0; i < RTL2840_BASE_REG_TABLE_LEN; i++)
+	{
+		RegBitName = PrimaryBaseRegTable[i].RegBitName;
+
+		pDemod->BaseRegTable.Addr8Bit[RegBitName].IsAvailable  = YES;
+		pDemod->BaseRegTable.Addr8Bit[RegBitName].PageNo       = PrimaryBaseRegTable[i].PageNo;
+		pDemod->BaseRegTable.Addr8Bit[RegBitName].RegStartAddr = PrimaryBaseRegTable[i].RegStartAddr;
+		pDemod->BaseRegTable.Addr8Bit[RegBitName].Msb          = PrimaryBaseRegTable[i].Msb;
+		pDemod->BaseRegTable.Addr8Bit[RegBitName].Lsb          = PrimaryBaseRegTable[i].Lsb;
+	}
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Initialize monitor register table
+
+RTL2840 builder will use rtl2840_InitMonitorRegTable() to initialize monitor register table.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@see   BuildRtl2840Module()
+
+*/
+void
+rtl2840_InitMonitorRegTable(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	static const QAM_PRIMARY_MONITOR_REG_ENTRY_ADDR_8BIT PrimaryMonitorRegTable[RTL2840_MONITOR_REG_TABLE_LEN] =
+	{
+		// Generality
+		// MonitorRegBitName,		InfoNum,		{SelRegAddr,	SelValue,	RegBitName,				Shift	}
+		{QAM_ADC_CLIP_CNT,			1,			{	{0x48,			0x01,		QAM_ADC_CLIP_CNT_REC,	0		},
+													{NO_USE,		NO_USE,		NO_USE,					NO_USE	},	}},
+
+		{QAM_DAGC_VALUE,			2,			{	{0x48,			0x20,		QAM_DAGC_LEVEL_26_11,	11		},
+													{0x49,			0x20,		QAM_DAGC_LEVEL_10_0,	0		},	}},
+
+		{QAM_RF_AGC_VALUE,			1,			{	{0x48,			0x80,		QAM_RF_AAGC_SD_IN,		0		},
+													{NO_USE,		NO_USE,		NO_USE,					NO_USE	},	}},
+
+		{QAM_IF_AGC_VALUE,			1,			{	{0x49,			0x80,		QAM_IF_AAGC_SD_IN,		0		},
+													{NO_USE,		NO_USE,		NO_USE,					NO_USE	},	}},
+
+		{QAM_TR_OFFSET,				2,			{	{0x48,			0xc2,		QAM_KI_TR_OUT_30_15,	15		},
+													{0x49,			0xc2,		QAM_KI_TR_OUT_14_0,		0		},	}},
+
+		{QAM_CR_OFFSET,				2,			{	{0x48,			0xc3,		QAM_KI_CR_OUT_15_0,		0		},
+													{0x49,			0xc3,		QAM_KI_CR_OUT_31_16,	16		},	}},
+
+		// Specific monitor register for initialization
+		// MonitorRegBitName,		InfoNum,		{SelRegAddr,	SelValue,	RegBitName,				Shift	}
+		{QAM_SPEC_MONITER_INIT_0,	1,			{	{0x48,			0x00,		QAM_SPEC_INIT_A0,		0		},
+													{NO_USE,		NO_USE,		NO_USE,					NO_USE	},	}},
+	};
+
+
+	int i, j;
+	int MonitorRegBitName;
+
+
+
+	// Initialize monitor register table according to primary monitor register table.
+	// Note: 1. Monitor register table rows are sorted by monitor register name key.
+	//       2. The default value of the IsAvailable variable is "NO".
+	for(i = 0; i < QAM_MONITOR_REG_TABLE_LEN_MAX; i++)
+		pDemod->MonitorRegTable.Addr8Bit[i].IsAvailable  = NO;
+
+	for(i = 0; i < RTL2840_MONITOR_REG_TABLE_LEN; i++)
+	{
+		MonitorRegBitName = PrimaryMonitorRegTable[i].MonitorRegBitName;
+
+		pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].IsAvailable = YES;
+		pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoNum = PrimaryMonitorRegTable[i].InfoNum;
+
+		for(j = 0; j < QAM_MONITOR_REG_INFO_TABLE_LEN; j++)
+		{
+			pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[j].SelRegAddr =
+				PrimaryMonitorRegTable[i].InfoTable[j].SelRegAddr;
+			pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[j].SelValue =
+				PrimaryMonitorRegTable[i].InfoTable[j].SelValue;
+			pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[j].RegBitName =
+				PrimaryMonitorRegTable[i].InfoTable[j].RegBitName;
+			pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[j].Shift =
+				PrimaryMonitorRegTable[i].InfoTable[j].Shift;
+		}
+	}
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Get inner strobe register bits.
+
+RTL2840 upper level functions will use rtl2840_GetInnerStrobeRegBits() to get register bits with inner strobe.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name and inner strobe.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Don't need to set register page before using rtl2840_GetInnerStrobeRegBits().
+
+*/
+int
+rtl2840_GetInnerStrobeRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	// Set register page number with inner page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set inner data strobe.
+	// Note: RTL2840 hardware will clear strobe automatically.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_INNER_DATA_STROBE, ON) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get the inner strobe register bits.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, RegBitName, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get monitor register bits.
+
+RTL2840 upper level functions will use rtl2840_GetMonitorRegBits() to get monitor register bits.
+
+
+@param [in]    pDemod              The demod module pointer
+@param [in]    MonitorRegBitName   Pre-defined demod monitor register bit name
+@param [out]   pReadingValue       Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod monitor register bits successfully with monitor bit name.
+@retval   FUNCTION_ERROR     Get demod monitor register bits unsuccessfully.
+
+
+@note
+	-# Don't need to set register page before using rtl2840_GetMonitorRegBits().
+
+*/
+int
+rtl2840_GetMonitorRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int MonitorRegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char InfoNum;
+	unsigned char SelRegAddr;
+	unsigned char SelValue;
+	int RegBitName;
+	unsigned char Shift;
+	
+	unsigned long Buffer[QAM_MONITOR_REG_INFO_TABLE_LEN];
+
+
+
+	// Check if register bit name is available.
+	if(pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].IsAvailable == NO)
+		goto error_status_monitor_register_bit_name;
+
+
+	// Get information entry number from monitor register table by monitor register name key.
+	InfoNum = pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoNum;
+
+
+	// Set register page number with inner page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, 1) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set selection register with selection value for each information entry.
+	for(i = 0; i < InfoNum; i++)
+	{
+		// Get selection register address and value from information entry by monitor register name key.
+		SelRegAddr = pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[i].SelRegAddr;
+		SelValue   = pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[i].SelValue;
+
+		// Set selection register with selection value.
+		if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, SelRegAddr, &SelValue, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	// Set inner data strobe.
+	// Note: RTL2840 hardware will clear strobe automatically.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, QAM_INNER_DATA_STROBE, ON) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get register bits to buffer according to register bit names for each information entry.
+	for(i = 0; i < InfoNum; i++)
+	{
+		// Get register bit name from information entry by monitor register name key.
+		RegBitName = pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[i].RegBitName;
+
+		// Get register bits and store it to buffer.
+		if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, RegBitName, &Buffer[i]) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	// Combine the buffer values into reading value.
+	*pReadingValue = 0;
+
+	for(i = 0; i < InfoNum; i++)
+	{
+		// Get shift from information entry by monitor register name key.
+		Shift = pDemod->MonitorRegTable.Addr8Bit[MonitorRegBitName].InfoTable[i].Shift;
+
+		// Combine the buffer values into reading value with shift.
+		*pReadingValue |= Buffer[i] << Shift;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+error_status_monitor_register_bit_name:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set I2C bridge module demod arguments.
+
+RTL2840 builder will use rtl2840_BuildI2cBridgeModule() to set I2C bridge module demod arguments.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@see   BuildRtl2840Module()
+
+*/
+void
+rtl2840_BuildI2cBridgeModule(
+	QAM_DEMOD_MODULE *pDemod
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+
+	// Get I2C bridge module.
+	pI2cBridge = pDemod->pI2cBridge;
+
+	// Set I2C bridge module demod arguments.
+	pI2cBridge->pPrivateData = (void *)pDemod;
+	pI2cBridge->ForwardI2cReadingCmd = rtl2840_ForwardI2cReadingCmd;
+	pI2cBridge->ForwardI2cWritingCmd = rtl2840_ForwardI2cWritingCmd;
+
+
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/demod_rtl2840.h b/drivers/media/usb/rtl2832u/demod_rtl2840.h
new file mode 100644
index 00000000..16f4723a
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/demod_rtl2840.h
@@ -0,0 +1,386 @@
+#ifndef __DEMOD_RTL2840_H
+#define __DEMOD_RTL2840_H
+
+/**
+
+@file
+
+@brief   RTL2840 QAM demod module declaration
+
+One can manipulate RTL2840 QAM demod through RTL2840 module.
+RTL2840 module is derived from QAM demod module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the QAM demod example in qam_demod_base.h except the listed lines.
+
+
+
+#include "demod_rtl2840.h"
+
+
+...
+
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+	QAM_DEMOD_MODULE      QamDemodModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+
+	...
+
+
+
+	// Build RTL2840 demod module.
+	BuildRtl2840Module(
+		&pDemod,
+		&QamDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x44,								// I2C device address is 0x44 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,			// Crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,				// TS interface mode is serial.
+		QAM_DEMOD_EN_AM_HUM					// Enhancement mode is AM-hum.
+		);
+
+
+
+	// See the example for other QAM demod functions in qam_demod_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "qam_demod_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2840_BASE_REG_TABLE_LEN				88
+#define RTL2840_MONITOR_REG_TABLE_LEN			7
+
+#define RTL2840_PAGE_REG_ADDR					0x0
+#define RTL2840_SYS_VERSION_VALUE				0xa3
+
+
+
+// Specific register
+#define RTL2840_SPEC_REG_0_VAL_START_ADDR		0x5e
+
+
+
+// Initialization
+#define RTL2840_SPEC_MONITOR_INIT_0_COMPARISON_TIMES		30
+
+// RF_AGC_VALUE register
+#define RTL2840_RF_AGC_VALUE_BIT_NUM		11
+
+// IF_AGC_VALUE register
+#define RTL2840_IF_AGC_VALUE_BIT_NUM		11
+
+// CR_OFFSET register
+#define RTL2840_CR_OFFSET_BIT_NUM			32
+
+// TR_OFFSET register
+#define RTL2840_TR_OFFSET_BIT_NUM			31
+
+
+
+// BER and UPER
+#define RTL2840_BER_WAIT_TIME_MS			10
+#define RTL2840_BER_REG2_MSB_SHIFT			16
+
+// SNR
+// Note: RTL2840_SNR_DB_DEN = round(log2(10) * pow(2, RTL2840_SNR_FRAC_BIT_NUM))
+#define RTL2840_SNR_FRAC_BIT_NUM			7
+#define RTL2840_SNR_DB_DEN					425
+
+
+
+// Singal strength and signal quality
+#define RTL2840_SIGNAL_QUALITY_FRAC_BIT_NUM			7
+
+
+
+
+
+// Table length
+#define RTL2840_SPEC_REG_0_VALUE_TABLE_LEN						11
+#define RTL2840_SYMBOL_RATE_VALUE_TABLE_LEN						9
+
+#define RTL2840_INIT_REG_TABLE_LEN								45
+#define RTL2840_INIT_SPEC_REG_0_TABLE_LEN						13
+#define RTL2840_TS_INTERFACE_INIT_TABLE_LEN						3
+
+#define RTL2840_QAM_MODE_REG_TABLE_LEN							25
+#define RTL2840_QAM_MODE_SPEC_REG_0_TABLE_LEN					3
+
+#define RTL2840_ALPHA_VALUE_TABLE_LEN							16
+
+#define RTL2840_SYMBOL_RATE_TABLE_LEN							3
+
+
+
+
+
+// Builder
+void
+BuildRtl2840Module(
+	QAM_DEMOD_MODULE **ppDemod,
+	QAM_DEMOD_MODULE *pQamDemodModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int TsInterfaceMode,
+	int EnhancementMode
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+rtl2840_IsConnectedToI2c(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2840_SoftwareReset(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2840_Initialize(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2840_SetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int QamMode
+	);
+
+int
+rtl2840_SetSymbolRateHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long SymbolRateHz
+	);
+
+int
+rtl2840_SetAlphaMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int AlphaMode
+	);
+
+int
+rtl2840_SetIfFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+int
+rtl2840_SetSpectrumMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+int
+rtl2840_GetRfAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+int
+rtl2840_GetIfAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+int
+rtl2840_GetDiAgc(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	);
+
+int
+rtl2840_GetTrOffsetPpm(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+int
+rtl2840_GetCrOffsetHz(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+int
+rtl2840_IsAagcLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2840_IsEqLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2840_IsFrameLocked(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+int
+rtl2840_GetErrorRate(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+int
+rtl2840_GetSnrDb(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+rtl2840_GetSignalStrength(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+int
+rtl2840_GetSignalQuality(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+int
+rtl2840_UpdateFunction(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+int
+rtl2840_ResetFunction(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// Demod AM-hum enhancement functions
+int
+rtl2840_am_hum_en_SetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int QamMode
+	);
+
+
+
+
+
+// I2C command forwarding functions
+int
+rtl2840_ForwardI2cReadingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+rtl2840_ForwardI2cWritingCmd(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+// Register table initialization
+void
+rtl2840_InitBaseRegTable(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+void
+rtl2840_InitMonitorRegTable(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+// Register getting methods	
+int
+rtl2840_GetInnerStrobeRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+int
+rtl2840_GetMonitorRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int MonitorRegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// I2C birdge module builder
+void
+rtl2840_BuildI2cBridgeModule(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/dtmb_demod_base.c b/drivers/media/usb/rtl2832u/dtmb_demod_base.c
new file mode 100644
index 00000000..b0de54a8
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dtmb_demod_base.c
@@ -0,0 +1,1566 @@
+/**
+
+@file
+
+@brief   DTMB demod default function definition
+
+DTMB demod default functions.
+
+*/
+#include "rtl2832u_io.h"
+#include "dtmb_demod_base.h"
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE
+
+*/
+int
+dtmb_demod_addr_8bit_default_SetRegPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBytes[LEN_2_BYTE];
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Set demod register page with page number.
+	// Note: The I2C format of demod register page setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + DTMB_DEMOD_PAGE_REG_ADDR + PageNo + stop_bit
+	WritingBytes[0] = DTMB_DEMOD_PAGE_REG_ADDR;
+	WritingBytes[1] = (unsigned char)PageNo;
+
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBytes, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+	// temp, because page register is write-only.
+	pDemod->CurrentPageNo = PageNo;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Set register bytes separately.
+int
+internal_dtmb_demod_addr_8bit_SetRegBytesSeparately(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes one by one.
+	for(i = 0; i < ByteNum; i++)
+	{
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) + stop_bit
+		WritingBuffer[0] = (unsigned char)(RegStartAddr + i);
+		WritingBuffer[1] = pWritingBytes[i];
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+        struct dvb_usb_device	*d;
+	unsigned int i;
+	unsigned char DeviceAddr;
+	//unsigned char WritingBuffer[LEN_2_BYTE];
+	
+	unsigned long PageNo = pDemod->CurrentPageNo;
+		
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get user defined data pointer of base interface structure for context.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);
+	
+	
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes one by one.
+	for(i = 0; i < ByteNum; i++)
+	{
+
+		// Set demod register bytes with writing buffer.
+			if(write_demod_register(d, DeviceAddr, PageNo,  RegStartAddr+i,  (unsigned char*)pWritingBytes+i, LEN_1_BYTE))
+			goto error_status_set_demod_registers;	
+	
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Set register bytes continuously.
+int
+internal_dtmb_demod_addr_8bit_SetRegBytesContinuously(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = (unsigned char)(RegStartAddr + i);
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) + stop_bit
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, WritingByteNum + LEN_1_BYTE) !=
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_BYTES
+
+*/
+int
+dtmb_demod_addr_8bit_default_SetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	unsigned long CurrentPageNo;		// temp, because page register is write-only.
+
+
+
+	// Get page register number.
+	CurrentPageNo = pDemod->CurrentPageNo;		// temp, because page register is write-only.
+
+
+	// Set register bytes according to page register number.
+	switch(CurrentPageNo)
+	{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+
+			if(internal_dtmb_demod_addr_8bit_SetRegBytesSeparately(pDemod, RegStartAddr, pWritingBytes, ByteNum) != FUNCTION_SUCCESS)
+				goto error_status_set_demod_registers;
+
+			break;
+
+
+		default:
+			
+			goto error_status_set_demod_registers;
+			
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Get register bytes separately.
+int
+internal_dtmb_demod_addr_8bit_GetRegBytesSeparately(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+
+	unsigned char DeviceAddr;
+	unsigned char RegAddr;
+	unsigned char RegByte;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes one by one.
+	for(i = 0; i < ByteNum; i++)
+	{
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		RegAddr = (unsigned char)(RegStartAddr + i);
+
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, &RegAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &RegByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+
+		// Copy register byte to reading bytes.
+		pReadingBytes[i] = RegByte;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+        struct dvb_usb_device	*d;
+	unsigned int i;
+
+	unsigned char DeviceAddr;
+
+	unsigned long PageNo = pDemod->CurrentPageNo;
+		
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get user defined data pointer of base interface structure for context.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes one by one.
+	for(i = 0; i < ByteNum; i++)
+	{
+
+		// Get demod register bytes.
+		if(read_demod_register(d, DeviceAddr, PageNo,  RegStartAddr+i,  pReadingBytes+i, LEN_1_BYTE))
+			goto error_status_get_demod_registers;	
+
+
+
+		
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+//error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Get register bytes continuously.
+int
+internal_dtmb_demod_addr_8bit_GetRegBytesContinuously(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+	unsigned char DeviceAddr;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = (unsigned char)(RegStartAddr + i);
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, &RegReadingAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+        struct dvb_usb_device	*d;
+	
+	unsigned char DeviceAddr;
+	
+	unsigned long PageNo = pDemod->CurrentPageNo;
+		
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get user defined data pointer of base interface structure for context.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);
+
+
+	// Get demod register bytes.
+	if(read_demod_register(d, DeviceAddr, PageNo,  RegStartAddr,  pReadingBytes, ByteNum))
+		goto error_status_get_demod_registers;	
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_BYTES
+
+*/
+int
+dtmb_demod_addr_8bit_default_GetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	unsigned long CurrentPageNo;		// temp, because page register is write-only.
+
+
+
+	// Get page register number.
+	CurrentPageNo = pDemod->CurrentPageNo;		// temp, because page register is write-only.
+
+
+	// Get register bytes according to page register number.
+	switch(CurrentPageNo)
+	{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+
+			if(internal_dtmb_demod_addr_8bit_GetRegBytesSeparately(pDemod, RegStartAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+				goto error_status_get_demod_registers;
+
+			break;
+
+
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+		case 9:
+
+			if(internal_dtmb_demod_addr_8bit_GetRegBytesContinuously(pDemod, RegStartAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+				goto error_status_get_demod_registers;
+
+			break;
+
+
+		default:
+			
+			goto error_status_get_demod_registers;
+			
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_MASK_BITS
+
+*/
+int
+dtmb_demod_addr_8bit_default_SetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+	unsigned char WritingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Reserve unsigned integer value unmask bit with mask and inlay writing value into it.
+	Value &= ~Mask;
+	Value |= (WritingValue << Shift) & Mask;
+
+
+	// Separate unsigned integer value into writing bytes.
+	// Note: Pick up lower address byte from value LSB.
+	//       Pick up upper address byte from value MSB.
+	for(i = 0; i < ByteNum; i++)
+		WritingBytes[i] = (unsigned char)((Value >> (BYTE_SHIFT * i)) & BYTE_MASK);
+
+
+	// Write demod register bytes with writing bytes.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, RegStartAddr, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_MASK_BITS
+
+*/
+int
+dtmb_demod_addr_8bit_default_GetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Get register bits from unsigned integaer value with mask and shift
+	*pReadingValue = (Value & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_BITS
+
+*/
+int
+dtmb_demod_addr_8bit_default_SetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable.Addr8Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable.Addr8Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable.Addr8Bit[RegBitName].Msb;
+	Lsb          = pDemod->RegTable.Addr8Bit[RegBitName].Lsb;
+
+
+	// Set register mask bits.
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_BITS
+
+*/
+int
+dtmb_demod_addr_8bit_default_GetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable.Addr8Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable.Addr8Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable.Addr8Bit[RegBitName].Msb;
+	Lsb          = pDemod->RegTable.Addr8Bit[RegBitName].Lsb;
+
+
+	// Get register mask bits.
+	if(pDemod->RegAccess.Addr8Bit.GetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+*/
+int
+dtmb_demod_addr_8bit_default_SetRegBitsWithPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned long PageNo;
+
+
+	// Get register page number from register table with register bit name key.
+	PageNo = pDemod->RegTable.Addr8Bit[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set register mask bits with register bit name key.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, RegBitName, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+*/
+int
+dtmb_demod_addr_8bit_default_GetRegBitsWithPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned long PageNo;
+
+
+	// Get register page number from register table with register bit name key.
+	PageNo = pDemod->RegTable.Addr8Bit[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get register mask bits with register bit name key.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, RegBitName, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_BYTES
+
+*/
+int
+dtmb_demod_addr_16bit_default_SetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned short RegWritingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_2_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = (unsigned short)(RegStartAddr + i);
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddrMsb + RegWritingAddrLsb +
+		//       writing_bytes (WritingByteNum bytes) + stop_bit
+		WritingBuffer[0] = (RegWritingAddr >> BYTE_SHIFT) & BYTE_MASK;
+		WritingBuffer[1] = RegWritingAddr & BYTE_MASK;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_2_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, WritingByteNum + LEN_2_BYTE) !=
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Get register bytes normally.
+int
+internal_dtmb_demod_addr_16bit_GetRegBytesNormally(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+	unsigned char DeviceAddr;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned short RegReadingAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = (unsigned short)(RegStartAddr + i);
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddrMsb + RegReadingAddrLsb + stop_bit
+		WritingBuffer[0] = (RegReadingAddr >> BYTE_SHIFT) & BYTE_MASK;
+		WritingBuffer[1] = RegReadingAddr & BYTE_MASK;
+
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Internal function:
+// Get register bytes with freeze.
+
+#define DTMB_I2C_REG_DEBUG_PAGE_ADDR		0xc708
+#define DTMB_I2C_REG_DEBUG_ADDR_ADDR		0xc709
+#define DTMB_I2C_REG_DEBUG_FREEZE_ADDR		0xc70a
+#define DTMB_I2C_REG_DEBUG_BYTE_ADDR		0xc70b
+
+int
+internal_dtmb_demod_addr_16bit_GetRegBytesWithFreeze(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+	unsigned char DeviceAddr;
+
+	unsigned char WritingBuffer[LEN_4_BYTE];
+	unsigned char ReadingBuffer[LEN_4_BYTE];
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+
+	// Note: The I2C format of demod register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddrMsb + RegWritingAddrLsb + writing_bytes (WritingByteNum bytes) + stop_bit
+
+	// Note: The I2C format of demod register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+
+	// Set I2C_REG_DEBUG_PAGE and I2C_REG_DEBUG_ADDR with register start address.
+	// Note: 1. Set I2C_REG_DEBUG_PAGE with register start address [11:8].
+	//       2. Set I2C_REG_DEBUG_ADDR with register start address [7:0].
+	WritingBuffer[0] = (DTMB_I2C_REG_DEBUG_PAGE_ADDR >> BYTE_SHIFT) & BYTE_MASK;
+	WritingBuffer[1] = DTMB_I2C_REG_DEBUG_PAGE_ADDR & BYTE_MASK;
+	WritingBuffer[2] = (RegStartAddr >> BYTE_SHIFT) & HEX_DIGIT_MASK;
+	WritingBuffer[3] = RegStartAddr & BYTE_MASK;
+
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, LEN_4_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set I2C_REG_DEBUG_FREEZE with 0x1.
+	WritingBuffer[0] = (DTMB_I2C_REG_DEBUG_FREEZE_ADDR >> BYTE_SHIFT) & BYTE_MASK;
+	WritingBuffer[1] = DTMB_I2C_REG_DEBUG_FREEZE_ADDR & BYTE_MASK;
+	WritingBuffer[2] = 0x1;
+
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, LEN_3_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get I2C_REG_DEBUG_BYTE 4 bytes.
+	if(internal_dtmb_demod_addr_16bit_GetRegBytesNormally(pDemod, DTMB_I2C_REG_DEBUG_BYTE_ADDR, ReadingBuffer, LEN_4_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Arrange reading bytes from big-endian to little-endian.
+	// Note: 1. The bytes format reading from I2C_REG_DEBUG_BYTE is big-endian.
+	//       2. The bytes format we needs is little-endian.
+	for(i = 0; i < ByteNum; i++)
+	{
+		// Set reading bytes.
+		pReadingBytes[i] = ReadingBuffer[LEN_3_BYTE - i];
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_BYTES
+
+*/
+int
+dtmb_demod_addr_16bit_default_GetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	unsigned char RegStartAddrMsb;
+
+
+
+	// Get regiser start address MSB.
+	RegStartAddrMsb = (RegStartAddr >> BYTE_SHIFT) & BYTE_MASK;
+
+
+	// Get register bytes according to page register number.
+	switch(RegStartAddrMsb)
+	{
+		case 0xc0:
+		case 0xc1:
+		case 0xc2:
+		case 0xc3:
+		case 0xc4:
+		case 0xc5:
+		case 0xc6:
+		case 0xc7:
+		case 0xe0:
+		case 0xe1:
+		case 0xe2:
+		case 0xe3:
+		case 0xe4:
+		case 0xf0:
+
+			if(internal_dtmb_demod_addr_16bit_GetRegBytesNormally(pDemod, RegStartAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+				goto error_status_get_demod_registers;
+
+			break;
+
+
+		case 0xc8:
+		case 0xc9:
+		case 0xca:
+		case 0xcb:
+		case 0xcc:
+		case 0xcd:
+
+			if(internal_dtmb_demod_addr_16bit_GetRegBytesWithFreeze(pDemod, RegStartAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+				goto error_status_get_demod_registers;
+
+			break;
+
+
+		default:
+			
+			goto error_status_get_demod_registers;
+			
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_MASK_BITS
+
+*/
+int
+dtmb_demod_addr_16bit_default_SetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+	unsigned char WritingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr16Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Reserve unsigned integer value unmask bit with mask and inlay writing value into it.
+	Value &= ~Mask;
+	Value |= (WritingValue << Shift) & Mask;
+
+
+	// Separate unsigned integer value into writing bytes.
+	// Note: Pick up lower address byte from value LSB.
+	//       Pick up upper address byte from value MSB.
+	for(i = 0; i < ByteNum; i++)
+		WritingBytes[i] = (unsigned char)((Value >> (BYTE_SHIFT * i)) & BYTE_MASK);
+
+
+	// Write demod register bytes with writing bytes.
+	if(pDemod->RegAccess.Addr16Bit.SetRegBytes(pDemod, RegStartAddr, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_MASK_BITS
+
+*/
+int
+dtmb_demod_addr_16bit_default_GetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr16Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Get register bits from unsigned integaer value with mask and shift
+	*pReadingValue = (Value & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_SET_REG_BITS
+
+*/
+int
+dtmb_demod_addr_16bit_default_SetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable.Addr16Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable.Addr16Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable.Addr16Bit[RegBitName].Msb;
+	Lsb          = pDemod->RegTable.Addr16Bit[RegBitName].Lsb;
+
+
+	// Set register mask bits.
+	if(pDemod->RegAccess.Addr16Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_REG_BITS
+
+*/
+int
+dtmb_demod_addr_16bit_default_GetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable.Addr16Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable.Addr16Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable.Addr16Bit[RegBitName].Msb;
+	Lsb          = pDemod->RegTable.Addr16Bit[RegBitName].Lsb;
+
+
+	// Get register mask bits.
+	if(pDemod->RegAccess.Addr16Bit.GetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_DEMOD_TYPE
+
+*/
+void
+dtmb_demod_default_GetDemodType(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	)
+{
+	// Get demod type from demod module.
+	*pDemodType = pDemod->DemodType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_DEVICE_ADDR
+
+*/
+void
+dtmb_demod_default_GetDeviceAddr(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get demod I2C device address from demod module.
+	*pDeviceAddr = pDemod->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_CRYSTAL_FREQ_HZ
+
+*/
+void
+dtmb_demod_default_GetCrystalFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	)
+{
+	// Get demod crystal frequency in Hz from demod module.
+	*pCrystalFreqHz = pDemod->CrystalFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_IF_FREQ_HZ
+
+*/
+int
+dtmb_demod_default_GetIfFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	)
+{
+	// Get demod IF frequency in Hz from demod module.
+	if(pDemod->IsIfFreqHzSet != YES)
+		goto error_status_get_demod_if_frequency;
+
+	*pIfFreqHz = pDemod->IfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_if_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_DEMOD_FP_GET_SPECTRUM_MODE
+
+*/
+int
+dtmb_demod_default_GetSpectrumMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	)
+{
+	// Get demod spectrum mode from demod module.
+	if(pDemod->IsSpectrumModeSet != YES)
+		goto error_status_get_demod_spectrum_mode;
+
+	*pSpectrumMode = pDemod->SpectrumMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_spectrum_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/dtmb_demod_base.h b/drivers/media/usb/rtl2832u/dtmb_demod_base.h
new file mode 100644
index 00000000..38e8ed95
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dtmb_demod_base.h
@@ -0,0 +1,2501 @@
+#ifndef __DTMB_DEMOD_BASE_H
+#define __DTMB_DEMOD_BASE_H
+
+/**
+
+@file
+
+@brief   DTMB demod base module definition
+
+DTMB demod base module definitions contains demod module structure, demod funciton pointers, and demod definitions.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_xxx.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;
+
+	unsigned long IfFreqHz;
+	int SpectrumMode;
+
+	int DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+
+	long RfAgc, IfAgc;
+	unsigned long DiAgc;
+
+	int Answer;
+	long TrOffsetPpm, CrOffsetHz;
+	unsigned long BerNum, BerDen;
+	double Ber;
+	unsigned long PerNum, PerDen;
+	double Per;
+	long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	unsigned long SignalStrength, SignalQuality;
+
+	int CarrierMode;
+	int PnMode;
+	int QamMode;
+	int CodeRateMode;
+	int TimeInterleaverMode;
+
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pBaseInterface,
+		&BaseInterfaceModuleMemory,
+		9,								// Set maximum I2C reading byte number with 9.
+		8,								// Set maximum I2C writing byte number with 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs					// Employ CustomWaitMs() as basic waiting function.
+		);
+
+
+	// Build DTMB demod XXX module.
+	BuildXxxModule(
+		&pDemod,
+		&DtmbDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x3e,							// Demod I2C device address is 0x3e in 8-bit format.
+		CRYSTAL_FREQ_27000000HZ,		// Demod crystal frequency is 27.0 MHz.
+		TS_INTERFACE_SERIAL,			// Demod TS interface mode is serial.
+		DIVERSITY_PIP_OFF				// Demod diversity and PIP both are disabled.
+		...								// Other arguments by each demod module
+		);
+
+
+
+
+
+	// ==== Initialize DTMB demod and set its parameters =====
+
+	// Initialize demod.
+	pDemod->Initialize(pDemod);
+
+
+	// Set demod parameters. (IF frequency and spectrum mode)
+	// Note: In the example:
+	//       1. IF frequency is 36.125 MHz.
+	//       2. Spectrum mode is SPECTRUM_INVERSE.
+	IfFreqHz      = IF_FREQ_36125000HZ;
+	SpectrumMode  = SPECTRUM_INVERSE;
+
+	pDemod->SetIfFreqHz(pDemod,      IfFreqHz);
+	pDemod->SetSpectrumMode(pDemod,  SpectrumMode);
+
+
+	// Need to set tuner before demod software reset.
+	// The order to set demod and tuner is not important.
+	// Note: One can use "pDemod->SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x1);"
+	//       for tuner I2C command forwarding.
+
+
+	// Reset demod by software reset.
+	pDemod->SoftwareReset(pDemod);
+
+
+	// Wait maximum 1000 ms for demod converge.
+	for(i = 0; i < 25; i++)
+	{
+		// Wait 40 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 40);
+
+		// Check signal lock status.
+		// Note: If Answer is YES, signal is locked.
+		//       If Answer is NO, signal is not locked.
+		pDemod->IsSignalLocked(pDemod, &Answer);
+
+		if(Answer == YES)
+		{
+			// Signal is locked.
+			break;
+		}
+	}
+
+
+
+
+
+	// ==== Get DTMB demod information =====
+
+	// Get demod type.
+	// Note: One can find demod type in MODULE_TYPE enumeration.
+	pDemod->GetDemodType(pDemod, &DemodType);
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Ask demod if it is connected to I2C bus.
+	// Note: If Answer is YES, demod is connected to I2C bus.
+	//       If Answer is NO, demod is not connected to I2C bus.
+	pDemod->IsConnectedToI2c(pDemod, &Answer);
+
+
+	// Get demod parameters. (IF frequency and spectrum mode)
+	pDemod->GetIfFreqHz(pDemod,      &IfFreqHz);
+	pDemod->GetSpectrumMode(pDemod,  &SpectrumMode);
+
+
+	// Get demod AGC value.
+	// Note: The range of RF AGC and IF AGC value is -8192 ~ 8191.
+	//       The range of digital AGC value is 0 ~ 255.
+	pDemod->GetRfAgc(pDemod, &RfAgc);
+	pDemod->GetIfAgc(pDemod, &IfAgc);
+	pDemod->GetDiAgc(pDemod, &DiAgc);
+
+
+	// Get demod lock status.
+	// Note: If Answer is YES, it is locked.
+	//       If Answer is NO, it is not locked.
+	pDemod->IsSignalLocked(pDemod, &Answer);
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pDemod->GetTrOffsetPpm(pDemod, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pDemod->GetCrOffsetHz(pDemod, &CrOffsetHz);
+
+
+	// Get BER.
+	pDemod->GetBer(pDemod, &BerNum, &BerDen);
+	Ber = (double)BerNum / (double)BerDen;
+
+	// Get PER.
+	pDemod->GetPer(pDemod, &PerNum, &PerDen);
+	Per = (double)PerNum / (double)PerDen;
+
+	// Get SNR in dB.
+	pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pDemod->GetSignalStrength(pDemod, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pDemod->GetSignalQuality(pDemod, &SignalQuality);
+
+
+	// Get signal information.
+	// Note: One can find signal information definitions in the enumerations as follows:
+	//       1. DTMB_CARRIER_MODE
+	//       2. DTMB_PN_MODE
+	//       3. DTMB_QAM_MODE
+	//       4. DTMB_CODE_RATE_MODE
+	//       5. DTMB_TIME_INTERLEAVER_MODE
+	pDemod->GetCarrierMode(pDemod, &CarrierMode);
+	pDemod->GetPnMode(pDemod, &PnMode);
+	pDemod->GetQamMode(pDemod, &QamMode);
+	pDemod->GetCodeRateMode(pDemod, &CodeRateMode);
+	pDemod->GetTimeInterleaverMode(pDemod, &TimeInterleaverMode);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+
+
+
+
+
+// Definitions
+
+// Page register address
+#define DTMB_DEMOD_PAGE_REG_ADDR		0x0
+
+
+// Carrier mode
+enum DTMB_CARRIER_MODE
+{
+	DTMB_CARRIER_SINGLE,
+	DTMB_CARRIER_MULTI,
+};
+
+
+// PN mode
+enum DTMB_PN_MODE
+{
+	DTMB_PN_420,
+	DTMB_PN_595,
+	DTMB_PN_945,
+};
+
+
+// QAM mode
+enum DTMB_QAM_MODE
+{
+	DTMB_QAM_4QAM_NR,
+	DTMB_QAM_4QAM,
+	DTMB_QAM_16QAM,
+	DTMB_QAM_32QAM,
+	DTMB_QAM_64QAM,
+};
+#define DTMB_QAM_UNKNOWN		-1
+
+
+// Code rate mode
+enum DTMB_CODE_RATE_MODE
+{
+	DTMB_CODE_RATE_0P4,
+	DTMB_CODE_RATE_0P6,
+	DTMB_CODE_RATE_0P8,
+};
+#define DTMB_CODE_RATE_UNKNOWN		-1
+
+
+// Time interleaver mode
+enum DTMB_TIME_INTERLEAVER_MODE
+{
+	DTMB_TIME_INTERLEAVER_240,
+	DTMB_TIME_INTERLEAVER_720,
+};
+#define DTMB_TIME_INTERLEAVER_UNKNOWN		-1
+
+
+
+
+
+// Register entry definitions
+
+// Register entry for 8-bit address
+typedef struct
+{
+	int IsAvailable;
+	unsigned long PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DTMB_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Primary register entry for 8-bit address
+typedef struct
+{
+	int RegBitName;
+	unsigned long PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DTMB_PRIMARY_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Register entry for 16-bit address
+typedef struct
+{
+	int IsAvailable;
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DTMB_REG_ENTRY_ADDR_16BIT;
+
+
+
+// Primary register entry for 16-bit address
+typedef struct
+{
+	int RegBitName;
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DTMB_PRIMARY_REG_ENTRY_ADDR_16BIT;
+
+
+
+
+
+// Register table dependence
+
+// Demod register bit names
+enum DTMB_REG_BIT_NAME
+{
+	// Software reset
+	DTMB_SOFT_RST_N,
+
+	// Tuner I2C forwording
+	DTMB_I2CT_EN_CTRL,
+
+	// Chip ID
+	DTMB_CHIP_ID,
+
+
+	// IF setting
+	DTMB_EN_SP_INV,
+	DTMB_EN_DCR,
+	DTMB_BBIN_EN,
+	DTMB_IFFREQ,
+
+	// AGC setting
+	DTMB_AGC_DRIVE_LV,						// for RTL2836B DTMB only
+	DTMB_Z_AGC,								// for RTL2836B DTMB only
+	DTMB_EN_PGA_MODE,						// for RTL2836B DTMB only
+	DTMB_TARGET_VAL,
+	DTMB_AAGC_LOOPGAIN1,					// for RTL2836B DTMB only
+	DTMB_POLAR_IFAGC,						// for RTL2836B DTMB only
+	DTMB_POLAR_RFAGC,						// for RTL2836B DTMB only
+	DTMB_INTEGRAL_CNT_LEN,					// for RTL2836B DTMB only
+	DTMB_AAGC_LOCK_PGA_HIT_LEN,				// for RTL2836B DTMB only
+	DTMB_THD_LOCK_UP,						// for RTL2836B DTMB only
+	DTMB_THD_LOCK_DW,						// for RTL2836B DTMB only
+	DTMB_THD_UP1,							// for RTL2836B DTMB only
+	DTMB_THD_DW1,							// for RTL2836B DTMB only
+	DTMB_THD_UP2,							// for RTL2836B DTMB only
+	DTMB_THD_DW2,							// for RTL2836B DTMB only
+	DTMB_GAIN_PULSE_SPACE_LEN,				// for RTL2836B DTMB only
+	DTMB_GAIN_PULSE_HOLD_LEN,				// for RTL2836B DTMB only
+	DTMB_GAIN_STEP_SUM_UP_THD,				// for RTL2836B DTMB only
+	DTMB_GAIN_STEP_SUM_DW_THD,				// for RTL2836B DTMB only
+
+
+	// TS interface
+	DTMB_SERIAL,
+	DTMB_CDIV_PH0,
+	DTMB_CDIV_PH1,
+	DTMB_SER_LSB,
+	DTMB_SYNC_DUR,
+	DTMB_ERR_DUR,
+	DTMB_FIX_TEI,
+
+	// Signal lock status
+	DTMB_TPS_LOCK,
+	DTMB_PN_PEAK_EXIST,
+
+	// FSM
+	DTMB_FSM_STATE_R,
+
+	// Performance measurement
+	DTMB_RO_PKT_ERR_RATE,
+	DTMB_EST_SNR,
+	DTMB_RO_LDPC_BER,
+
+	// AGC
+	DTMB_GAIN_OUT_R,
+	DTMB_RF_AGC_VAL,
+	DTMB_IF_AGC_VAL,
+
+	// TR and CR
+	DTMB_TR_OUT_R,
+	DTMB_SFOAQ_OUT_R,
+	DTMB_CFO_EST_R,
+
+	// Signal information
+	DTMB_EST_CARRIER,
+	DTMB_RX_MODE_R,
+	DTMB_USE_TPS,
+
+	// GPIO
+	DTMB_DMBT_GPIOA_OE,			// For RTL2836B only
+	DTMB_DMBT_GPIOB_OE,			// For RTL2836B only
+	DTMB_DMBT_OPT_GPIOA_SEL,	// For RTL2836B only
+	DTMB_DMBT_OPT_GPIOB_SEL,	// For RTL2836B only
+	DTMB_GPIOA_SEL,				// For RTL2836B only
+	DTMB_GPIOB_SEL,				// For RTL2836B only
+
+	// AD7
+	DTMB_RSSI_R,				// For RTL2836B only
+	DTMB_AV_SET7,				// For RTL2836B only
+	DTMB_IBX,					// For RTL2836B only
+	DTMB_POW_AD7,				// For RTL2836B only
+	DTMB_VICM_SET,				// For RTL2836B only
+	DTMB_VRC,					// For RTL2836B only
+	DTMB_ATT_AD7,				// For RTL2836B only
+
+	// Diversity
+	DTMB_DIV_EN,				// For RTL2836B DTMB only
+	DTMB_DIV_MODE,				// For RTL2836B DTMB only
+	DTMB_DIV_RX_CLK_XOR,		// For RTL2836B DTMB only
+	DTMB_DIV_THD_ERR_CMP0,		// For RTL2836B DTMB only
+	DTMB_FSM_10L_MSB_3Byte,		// For RTL2836B DTMB only
+
+	// Item terminator
+	DTMB_REG_BIT_NAME_ITEM_TERMINATOR,
+};
+
+
+
+// Register table length definitions
+#define DTMB_REG_TABLE_LEN_MAX			DTMB_REG_BIT_NAME_ITEM_TERMINATOR
+
+
+
+
+
+// DTMB demod module pre-definition
+typedef struct DTMB_DEMOD_MODULE_TAG DTMB_DEMOD_MODULE;
+
+
+
+
+
+/**
+
+@brief   DTMB demod register page setting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_SET_REG_PAGE() to set demod register page.
+
+
+@param [in]   pDemod   The demod module pointer
+@param [in]   PageNo   Page number
+
+
+@retval   FUNCTION_SUCCESS   Set register page successfully with page number.
+@retval   FUNCTION_ERROR     Set register page unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_REG_PAGE() with the corresponding function.
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register page with page number 2.
+	pDemod->SetRegPage(pDemod, 2);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_PAGE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register byte setting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_SET_REG_BYTES() to set demod register bytes.
+
+
+@param [in]   pDemod          The demod module pointer
+@param [in]   RegStartAddr    Demod register start address
+@param [in]   pWritingBytes   Pointer to writing bytes
+@param [in]   ByteNum         Writing byte number
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bytes successfully with writing bytes.
+@retval   FUNCTION_ERROR     Set demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by DTMB_DEMOD_FP_SET_REG_PAGE() before using DTMB_DEMOD_FP_SET_REG_BYTES().
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_GET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char WritingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bytes (page 1, address 0x17 ~ 0x1b) with 5 writing bytes.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBytes(pDemod, 0x17, WritingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BYTES)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_BYTES)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register byte getting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_GET_REG_BYTES() to get demod register bytes.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [out]   pReadingBytes   Pointer to an allocated memory for storing reading bytes
+@param [in]    ByteNum         Reading byte number
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bytes successfully with reading byte number.
+@retval   FUNCTION_ERROR     Get demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by DTMB_DEMOD_FP_SET_REG_PAGE() before using DTMB_DEMOD_FP_GET_REG_BYTES().
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_SET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char ReadingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bytes (page 1, address 0x17 ~ 0x1b) with reading byte number 5.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBytes(pDemod, 0x17, ReadingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BYTES)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_BYTES)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register mask bits setting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_SET_REG_MASK_BITS() to set demod register mask bits.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegStartAddr   Demod register start address
+@param [in]   Msb            Mask MSB with 0-based index
+@param [in]   Lsb            Mask LSB with 0-based index
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register mask bits successfully with writing value.
+@retval   FUNCTION_ERROR     Set demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by DTMB_DEMOD_FP_SET_REG_PAGE() before using DTMB_DEMOD_FP_SET_REG_MASK_BITS().
+	-# The constraints of DTMB_DEMOD_FP_SET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_GET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits (page 1, address {0x18, 0x17} [12:5]) with writing value 0x1d.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegMaskBits(pDemod, 0x17, 12, 5, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x17          0x18
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_MASK_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_MASK_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register mask bits getting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_GET_REG_MASK_BITS() to get demod register mask bits.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [in]    Msb             Mask MSB with 0-based index
+@param [in]    Lsb             Mask LSB with 0-based index
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register mask bits successfully.
+@retval   FUNCTION_ERROR     Get demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by DTMB_DEMOD_FP_SET_REG_PAGE() before using DTMB_DEMOD_FP_GET_REG_MASK_BITS().
+	-# The constraints of DTMB_DEMOD_FP_GET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_SET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits (page 1, address {0x18, 0x17} [12:5]).
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegMaskBits(pDemod, 0x17, 12, 5, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_MASK_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_MASK_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register bits setting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_SET_REG_BITS() to set demod register bits with bit name.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using DTMB_DEMOD_FP_SET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_GET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBits(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register bits getting function pointer
+
+Demod upper level functions will use DTMB_DEMOD_FP_GET_REG_BITS() to get demod register bits with bit name.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using DTMB_DEMOD_FP_GET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DTMB_DEMOD_FP_SET_REG_PAGE, DTMB_DEMOD_FP_SET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBits(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+typedef int
+(*DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_BITS)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register bits setting function pointer (with page setting)
+
+Demod upper level functions will use DTMB_DEMOD_FP_SET_REG_BITS_WITH_PAGE() to set demod register bits with bit name and
+page setting.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name, page setting, and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using DTMB_DEMOD_FP_SET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DTMB_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BITS_WITH_PAGE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod register bits getting function pointer (with page setting)
+
+Demod upper level functions will use DTMB_DEMOD_FPT_GET_REG_BITS_WITH_PAGE() to get demod register bits with bit name and
+page setting.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name and page setting.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using DTMB_DEMOD_FP_GET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DTMB_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->GetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BITS_WITH_PAGE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// Demod register access for 8-bit address
+typedef struct
+{
+	DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_PAGE             SetRegPage;
+	DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BYTES            SetRegBytes;
+	DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BYTES            GetRegBytes;
+	DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_MASK_BITS        SetRegMaskBits;
+	DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_MASK_BITS        GetRegMaskBits;
+	DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BITS             SetRegBits;
+	DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BITS             GetRegBits;
+	DTMB_DEMOD_FP_ADDR_8BIT_SET_REG_BITS_WITH_PAGE   SetRegBitsWithPage;
+	DTMB_DEMOD_FP_ADDR_8BIT_GET_REG_BITS_WITH_PAGE   GetRegBitsWithPage;
+}
+DTMB_DEMOD_REG_ACCESS_ADDR_8BIT;
+
+
+
+
+
+// Demod register access for 16-bit address
+typedef struct
+{
+	DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_BYTES       SetRegBytes;
+	DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_BYTES       GetRegBytes;
+	DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_MASK_BITS   SetRegMaskBits;
+	DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_MASK_BITS   GetRegMaskBits;
+	DTMB_DEMOD_FP_ADDR_16BIT_SET_REG_BITS        SetRegBits;
+	DTMB_DEMOD_FP_ADDR_16BIT_GET_REG_BITS        GetRegBits;
+}
+DTMB_DEMOD_REG_ACCESS_ADDR_16BIT;
+
+
+
+
+
+/**
+
+@brief   DTMB demod type getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_DEMOD_TYPE() to get DTMB demod type.
+
+
+@param [in]    pDemod       The demod module pointer
+@param [out]   pDemodType   Pointer to an allocated memory for storing demod type
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_DEMOD_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*DTMB_DEMOD_FP_GET_DEMOD_TYPE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod I2C device address getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_DEVICE_ADDR() to get DTMB demod I2C device address.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pDeviceAddr   Pointer to an allocated memory for storing demod I2C device address
+
+
+@retval   FUNCTION_SUCCESS   Get demod device address successfully.
+@retval   FUNCTION_ERROR     Get demod device address unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_DEVICE_ADDR() with the corresponding function.
+
+*/
+typedef void
+(*DTMB_DEMOD_FP_GET_DEVICE_ADDR)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod crystal frequency getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() to get DTMB demod crystal frequency in Hz.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pCrystalFreqHz   Pointer to an allocated memory for storing demod crystal frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod crystal frequency successfully.
+@retval   FUNCTION_ERROR     Get demod crystal frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() with the corresponding function.
+
+*/
+typedef void
+(*DTMB_DEMOD_FP_GET_CRYSTAL_FREQ_HZ)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod I2C bus connection asking function pointer
+
+One can use DTMB_DEMOD_FP_IS_CONNECTED_TO_I2C() to ask DTMB demod if it is connected to I2C bus.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_IS_CONNECTED_TO_I2C() with the corresponding function.
+
+*/
+typedef void
+(*DTMB_DEMOD_FP_IS_CONNECTED_TO_I2C)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod software resetting function pointer
+
+One can use DTMB_DEMOD_FP_SOFTWARE_RESET() to reset DTMB demod by software reset.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod by software reset successfully.
+@retval   FUNCTION_ERROR     Reset demod by software reset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SOFTWARE_RESET() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_SOFTWARE_RESET)(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod initializing function pointer
+
+One can use DTMB_DEMOD_FP_INITIALIZE() to initialie DTMB demod.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize demod successfully.
+@retval   FUNCTION_ERROR     Initialize demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_INITIALIZE)(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod IF frequency setting function pointer
+
+One can use DTMB_DEMOD_FP_SET_IF_FREQ_HZ() to set DTMB demod IF frequency in Hz.
+
+
+@param [in]   pDemod     The demod module pointer
+@param [in]   IfFreqHz   IF frequency in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Set demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_SET_IF_FREQ_HZ)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod spectrum mode setting function pointer
+
+One can use DTMB_DEMOD_FP_SET_SPECTRUM_MODE() to set DTMB demod spectrum mode.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   SpectrumMode   Spectrum mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Set demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_SET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_SET_SPECTRUM_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod IF frequency getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_IF_FREQ_HZ() to get DTMB demod IF frequency in Hz.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pIfFreqHz   Pointer to an allocated memory for storing demod IF frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Get demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_IF_FREQ_HZ)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod spectrum mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_SPECTRUM_MODE() to get DTMB demod spectrum mode.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pSpectrumMode   Pointer to an allocated memory for storing demod spectrum mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Get demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_SPECTRUM_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod signal lock asking function pointer
+
+One can use DTMB_DEMOD_FP_IS_SIGNAL_LOCKED() to ask DTMB demod if it is signal-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform signal lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_IS_SIGNAL_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_IS_SIGNAL_LOCKED)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod signal strength getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pDemod            The demod module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal strength successfully.
+@retval   FUNCTION_ERROR     Get demod signal strength unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_SIGNAL_STRENGTH)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod signal quality getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal quality successfully.
+@retval   FUNCTION_ERROR     Get demod signal quality unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_SIGNAL_QUALITY)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod BER getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_BER() to get BER.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pBerNum         Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen         Pointer to an allocated memory for storing BER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod error rate value successfully.
+@retval   FUNCTION_ERROR     Get demod error rate value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_BER() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_BER)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod PER getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_PER() to get PER.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pPerNum         Pointer to an allocated memory for storing PER numerator
+@param [out]   pPerDen         Pointer to an allocated memory for storing PER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod error rate value successfully.
+@retval   FUNCTION_ERROR     Get demod error rate value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_PER() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_PER)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod SNR getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod SNR successfully.
+@retval   FUNCTION_ERROR     Get demod SNR unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_SNR_DB)(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod RF AGC getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_RF_AGC() to get DTMB demod RF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pRfAgc   Pointer to an allocated memory for storing RF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod RF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod RF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_RF_AGC() with the corresponding function.
+	-# The range of RF AGC value is 0 ~ (pow(2, 14) - 1).
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_RF_AGC)(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod IF AGC getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_IF_AGC() to get DTMB demod IF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pIfAgc   Pointer to an allocated memory for storing IF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod IF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_IF_AGC() with the corresponding function.
+	-# The range of IF AGC value is 0 ~ (pow(2, 14) - 1).
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_IF_AGC)(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod digital AGC getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_DI_AGC() to get DTMB demod digital AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pDiAgc   Pointer to an allocated memory for storing digital AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod digital AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod digital AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_DI_AGC() with the corresponding function.
+	-# The range of digital AGC value is 0 ~ (pow(2, 12) - 1).
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_DI_AGC)(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod TR offset getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pDemod         The demod module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get demod TR offset successfully.
+@retval   FUNCTION_ERROR     Get demod TR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_TR_OFFSET_PPM)(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod CR offset getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod CR offset successfully.
+@retval   FUNCTION_ERROR     Get demod CR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_CR_OFFSET_HZ)(
+	DTMB_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod carrier mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_CARRIER_MODE() to get DTMB demod carrier mode.
+
+
+@param [in]    pDemod         The demod module pointer
+@param [out]   pCarrierMode   Pointer to an allocated memory for storing demod carrier mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod carrier mode successfully.
+@retval   FUNCTION_ERROR     Get demod carrier mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_CARRIER_MODE() with the corresponding function.
+
+
+@see   DTMB_CARRIER_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_CARRIER_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCarrierMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod PN mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_PN_MODE() to get DTMB demod PN mode.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pPnMode   Pointer to an allocated memory for storing demod PN mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod PN mode successfully.
+@retval   FUNCTION_ERROR     Get demod PN mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_PN_MODE() with the corresponding function.
+
+
+@see   DTMB_PN_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_PN_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pPnMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod QAM mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_QAM_MODE() to get DTMB demod QAM mode.
+
+
+@param [in]    pDemod     The demod module pointer
+@param [out]   pQamMode   Pointer to an allocated memory for storing demod QAM mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod QAM mode successfully.
+@retval   FUNCTION_ERROR     Get demod QAM mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_QAM_MODE() with the corresponding function.
+
+
+@see   DTMB_QAM_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_QAM_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod code rate mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_CODE_RATE_MODE() to get DTMB demod code rate mode.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pCodeRateMode   Pointer to an allocated memory for storing demod code rate mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod code rate mode successfully.
+@retval   FUNCTION_ERROR     Get demod code rate mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_CODE_RATE_MODE() with the corresponding function.
+
+
+@see   DTMB_CODE_RATE_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_CODE_RATE_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pCodeRateMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod time interleaver mode getting function pointer
+
+One can use DTMB_DEMOD_FP_GET_TIME_INTERLEAVER_MODE() to get DTMB demod time interleaver mode.
+
+
+@param [in]    pDemod                 The demod module pointer
+@param [out]   pTimeInterleaverMode   Pointer to an allocated memory for storing demod time interleaver mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod time interleaver mode successfully.
+@retval   FUNCTION_ERROR     Get demod time interleaver mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_GET_TIME_INTERLEAVER_MODE() with the corresponding function.
+
+
+@see   DTMB_TIME_INTERLEAVER_MODE
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_GET_TIME_INTERLEAVER_MODE)(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pTimeInterleaverMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod updating function pointer
+
+One can use DTMB_DEMOD_FP_UPDATE_FUNCTION() to update demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod setting successfully.
+@retval   FUNCTION_ERROR     Update demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_UPDATE_FUNCTION)(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB demod reseting function pointer
+
+One can use DTMB_DEMOD_FP_RESET_FUNCTION() to reset demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod setting successfully.
+@retval   FUNCTION_ERROR     Reset demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set DTMB_DEMOD_FP_RESET_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DtmbDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_DEMOD_FP_RESET_FUNCTION)(
+	DTMB_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/// RTL2836 extra module
+typedef struct RTL2836_EXTRA_MODULE_TAG RTL2836_EXTRA_MODULE;
+struct RTL2836_EXTRA_MODULE_TAG
+{
+	// RTL2836 update procedure enabling status
+	int IsFunc1Enabled;
+	int IsFunc2Enabled;
+
+	// RTL2836 update Function 1 variables
+	int Func1CntThd;
+	int Func1Cnt;
+
+	// RTL2836 update Function 2 variables
+	int Func2SignalModePrevious;
+};
+
+
+
+
+
+/// DTMB demod module structure
+struct DTMB_DEMOD_MODULE_TAG
+{
+	// Private variables
+	int           DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+	int           TsInterfaceMode;
+	int           DiversityPipMode;
+
+	unsigned long IfFreqHz;
+	int           SpectrumMode;
+
+	int IsIfFreqHzSet;
+	int IsSpectrumModeSet;
+
+	unsigned long CurrentPageNo;		// temp, because page register is write-only.
+
+	union											///<   Demod extra module used by driving module
+	{
+		RTL2836_EXTRA_MODULE Rtl2836;
+	}
+	Extra;
+
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+	// Demod register table
+	union
+	{
+		DTMB_REG_ENTRY_ADDR_8BIT  Addr8Bit[DTMB_REG_TABLE_LEN_MAX];
+		DTMB_REG_ENTRY_ADDR_16BIT Addr16Bit[DTMB_REG_TABLE_LEN_MAX];
+	}
+	RegTable;
+
+
+	// Demod I2C function pointers
+	union
+	{
+		DTMB_DEMOD_REG_ACCESS_ADDR_8BIT  Addr8Bit;
+		DTMB_DEMOD_REG_ACCESS_ADDR_16BIT Addr16Bit;
+	}
+	RegAccess;
+
+
+	// Demod manipulating function pointers
+	DTMB_DEMOD_FP_GET_DEMOD_TYPE              GetDemodType;
+	DTMB_DEMOD_FP_GET_DEVICE_ADDR             GetDeviceAddr;
+	DTMB_DEMOD_FP_GET_CRYSTAL_FREQ_HZ         GetCrystalFreqHz;
+
+	DTMB_DEMOD_FP_IS_CONNECTED_TO_I2C         IsConnectedToI2c;
+
+	DTMB_DEMOD_FP_SOFTWARE_RESET              SoftwareReset;
+
+	DTMB_DEMOD_FP_INITIALIZE                  Initialize;
+	DTMB_DEMOD_FP_SET_IF_FREQ_HZ              SetIfFreqHz;
+	DTMB_DEMOD_FP_SET_SPECTRUM_MODE           SetSpectrumMode;
+	DTMB_DEMOD_FP_GET_IF_FREQ_HZ              GetIfFreqHz;
+	DTMB_DEMOD_FP_GET_SPECTRUM_MODE           GetSpectrumMode;
+
+	DTMB_DEMOD_FP_IS_SIGNAL_LOCKED            IsSignalLocked;
+
+	DTMB_DEMOD_FP_GET_SIGNAL_STRENGTH         GetSignalStrength;
+	DTMB_DEMOD_FP_GET_SIGNAL_QUALITY          GetSignalQuality;
+
+	DTMB_DEMOD_FP_GET_BER                     GetBer;
+	DTMB_DEMOD_FP_GET_PER                     GetPer;
+	DTMB_DEMOD_FP_GET_SNR_DB                  GetSnrDb;
+
+	DTMB_DEMOD_FP_GET_RF_AGC                  GetRfAgc;
+	DTMB_DEMOD_FP_GET_IF_AGC                  GetIfAgc;
+	DTMB_DEMOD_FP_GET_DI_AGC                  GetDiAgc;
+
+	DTMB_DEMOD_FP_GET_TR_OFFSET_PPM           GetTrOffsetPpm;
+	DTMB_DEMOD_FP_GET_CR_OFFSET_HZ            GetCrOffsetHz;
+
+	DTMB_DEMOD_FP_GET_CARRIER_MODE            GetCarrierMode;
+	DTMB_DEMOD_FP_GET_PN_MODE                 GetPnMode;
+	DTMB_DEMOD_FP_GET_QAM_MODE                GetQamMode;
+	DTMB_DEMOD_FP_GET_CODE_RATE_MODE          GetCodeRateMode;
+	DTMB_DEMOD_FP_GET_TIME_INTERLEAVER_MODE   GetTimeInterleaverMode;
+
+	DTMB_DEMOD_FP_UPDATE_FUNCTION             UpdateFunction;
+	DTMB_DEMOD_FP_RESET_FUNCTION              ResetFunction;
+};
+
+
+
+
+
+
+
+// DTMB demod default I2C functions for 8-bit address
+int
+dtmb_demod_addr_8bit_default_SetRegPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+int
+dtmb_demod_addr_8bit_default_SetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+int
+dtmb_demod_addr_8bit_default_GetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+dtmb_demod_addr_8bit_default_SetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+int
+dtmb_demod_addr_8bit_default_GetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+int
+dtmb_demod_addr_8bit_default_SetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+dtmb_demod_addr_8bit_default_GetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+int
+dtmb_demod_addr_8bit_default_SetRegBitsWithPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+dtmb_demod_addr_8bit_default_GetRegBitsWithPage(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// DTMB demod default I2C functions for 16-bit address
+int
+dtmb_demod_addr_16bit_default_SetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+int
+dtmb_demod_addr_16bit_default_GetRegBytes(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+dtmb_demod_addr_16bit_default_SetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+int
+dtmb_demod_addr_16bit_default_GetRegMaskBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+int
+dtmb_demod_addr_16bit_default_SetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+dtmb_demod_addr_16bit_default_GetRegBits(
+	DTMB_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// DTMB demod default manipulating functions
+void
+dtmb_demod_default_GetDemodType(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+void
+dtmb_demod_default_GetDeviceAddr(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+void
+dtmb_demod_default_GetCrystalFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+int
+dtmb_demod_default_GetBandwidthMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pBandwidthMode
+	);
+
+int
+dtmb_demod_default_GetIfFreqHz(
+	DTMB_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+int
+dtmb_demod_default_GetSpectrumMode(
+	DTMB_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/dtmb_nim_base.c b/drivers/media/usb/rtl2832u/dtmb_nim_base.c
new file mode 100644
index 00000000..541bd486
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dtmb_nim_base.c
@@ -0,0 +1,545 @@
+/**
+
+@file
+
+@brief   DTMB NIM base module definition
+
+DTMB NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+*/
+
+
+#include "dtmb_nim_base.h"
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_NIM_TYPE
+
+*/
+void
+dtmb_nim_default_GetNimType(
+	DTMB_NIM_MODULE *pNim,
+	int *pNimType
+	)
+{
+	// Get NIM type from NIM module.
+	*pNimType = pNim->NimType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_SET_PARAMETERS
+
+*/
+int
+dtmb_nim_default_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_PARAMETERS
+
+*/
+int
+dtmb_nim_default_GetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+
+
+	// Get tuner module.
+	pTuner = pNim->pTuner;
+
+
+	// Get tuner RF frequency in Hz.
+	if(pTuner->GetRfFreqHz(pTuner, pRfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_IS_SIGNAL_PRESENT
+
+*/
+int
+dtmb_nim_default_IsSignalPresent(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	DTMB_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait for signal present check.
+	for(i = 0; i < DTMB_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX_DEFAULT; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check signal lock status on demod.
+		// Note: If signal is locked, stop signal lock check.
+		if(pDemod->IsSignalLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_IS_SIGNAL_LOCKED
+
+*/
+int
+dtmb_nim_default_IsSignalLocked(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	DTMB_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait for signal lock check.
+	for(i = 0; i < DTMB_NIM_SINGAL_LOCK_CHECK_TIMES_MAX_DEFAULT; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check signal lock status on demod.
+		// Note: If signal is locked, stop signal lock check.
+		if(pDemod->IsSignalLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+dtmb_nim_default_GetSignalStrength(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal strength from demod.
+	if(pDemod->GetSignalStrength(pDemod, pSignalStrength) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+dtmb_nim_default_GetSignalQuality(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal quality from demod.
+	if(pDemod->GetSignalQuality(pDemod, pSignalQuality) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_BER
+
+*/
+int
+dtmb_nim_default_GetBer(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get BER from demod.
+	if(pDemod->GetBer(pDemod, pBerNum, pBerDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_PER
+
+*/
+int
+dtmb_nim_default_GetPer(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get PER from demod.
+	if(pDemod->GetPer(pDemod, pPerNum, pPerDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_SNR_DB
+
+*/
+int
+dtmb_nim_default_GetSnrDb(
+	DTMB_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get SNR in dB from demod.
+	if(pDemod->GetSnrDb(pDemod, pSnrDbNum, pSnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+dtmb_nim_default_GetTrOffsetPpm(
+	DTMB_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get TR offset in ppm from demod.
+	if(pDemod->GetTrOffsetPpm(pDemod, pTrOffsetPpm) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+dtmb_nim_default_GetCrOffsetHz(
+	DTMB_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get CR offset in Hz from demod.
+	if(pDemod->GetCrOffsetHz(pDemod, pCrOffsetHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_GET_SIGNAL_INFO
+
+*/
+int
+dtmb_nim_default_GetSignalInfo(
+	DTMB_NIM_MODULE *pNim,
+	int *pCarrierMode,
+	int *pPnMode,
+	int *pQamMode,
+	int *pCodeRateMode,
+	int *pTimeInterleaverMode
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal information from demod.
+	if(pDemod->GetCarrierMode(pDemod, pCarrierMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	if(pDemod->GetPnMode(pDemod, pPnMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	if(pDemod->GetQamMode(pDemod, pQamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	if(pDemod->GetCodeRateMode(pDemod, pCodeRateMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	if(pDemod->GetTimeInterleaverMode(pDemod, pTimeInterleaverMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+dtmb_nim_default_UpdateFunction(
+	DTMB_NIM_MODULE *pNim
+	)
+{
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/dtmb_nim_base.h b/drivers/media/usb/rtl2832u/dtmb_nim_base.h
new file mode 100644
index 00000000..fcbe3c14
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dtmb_nim_base.h
@@ -0,0 +1,951 @@
+#ifndef __DTMB_NIM_BASE_H
+#define __DTMB_NIM_BASE_H
+
+/**
+
+@file
+
+@brief   DTMB NIM base module definition
+
+DTMB NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	DTMB_NIM_MODULE *pNim;
+	DTMB_NIM_MODULE DtmbNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+	unsigned long RfFreqHz;
+
+	int Answer;
+	unsigned long SignalStrength, SignalQuality;
+	unsigned long BerNum, BerDen;
+	double Ber;
+	unsigned long PerNum, PerDen;
+	double Per;
+	unsigned long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	long TrOffsetPpm, CrOffsetHz;
+
+	int CarrierMode;
+	int PnMode;
+	int QamMode;
+	int CodeRateMode;
+	int TimeInterleaverMode;
+
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		&pNim,
+		&DtmbNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs					// Employ CustomWaitMs() as basic waiting function.
+
+		&DemodxExtraModuleMemory,		// Employ Demod-X extra module.
+		0x3e,							// The Demod-X I2C device address is 0x3e in 8-bit format.
+		CRYSTAL_FREQ_27000000HZ,		// The Demod-X crystal frequency is 27.0 MHz.
+		...								// Other arguments for Demod-X
+
+		&TunerxExtraModuleMemory,		// Employ Tuner-Y extra module.
+		0xc0,							// The Tuner-Y I2C device address is 0xc0 in 8-bit format.
+		...								// Other arguments for Tuner-Y
+		);
+
+
+
+	// Get NIM type.
+	// Note: NIM types are defined in the MODULE_TYPE enumeration.
+	pNim->GetNimType(pNim, &NimType);
+
+
+
+
+
+
+
+	// ==== Initialize NIM and set its parameters =====
+
+	// Initialize NIM.
+	pNim->Initialize(pNim);
+
+	// Set NIM parameters. (RF frequency)
+	// Note: In the example: RF frequency is 666 MHz.
+	RfFreqHz = 666000000;
+	pNim->SetParameters(pNim, RfFreqHz);
+
+
+
+	// Wait 1 second for demod convergence.
+
+
+
+
+
+	// ==== Get NIM information =====
+
+	// Get NIM parameters. (RF frequency)
+	pNim->GetParameters(pNim, &RfFreqHz);
+
+
+	// Get signal present status.
+	// Note: 1. The argument Answer is YES when the NIM module has found DTMB signal in the RF channel.
+	//       2. The argument Answer is NO when the NIM module does not find DTMB signal in the RF channel.
+	// Recommendation: Use the IsSignalPresent() function for channel scan.
+	pNim->IsSignalPresent(pNim, &Answer);
+
+	// Get signal lock status.
+	// Note: 1. The argument Answer is YES when the NIM module has locked DTMB signal in the RF channel.
+	//          At the same time, the NIM module sends TS packets through TS interface hardware pins.
+	//       2. The argument Answer is NO when the NIM module does not lock DTMB signal in the RF channel.
+	// Recommendation: Use the IsSignalLocked() function for signal lock check.
+	pNim->IsSignalLocked(pNim, &Answer);
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pNim->GetSignalStrength(pNim, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pNim->GetSignalQuality(pNim, &SignalQuality);
+
+
+	// Get BER.
+	pNim->GetBer(pNim, &BerNum, &BerDen);
+	Ber = (double)BerNum / (double)BerDen;
+
+	// Get PER.
+	pNim->GetPer(pNim, &PerNum, &PerDen);
+	Per = (double)PerNum / (double)PerDen;
+
+	// Get SNR in dB.
+	pNim->GetSnrDb(pNim, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pNim->GetTrOffsetPpm(pNim, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pNim->GetCrOffsetHz(pNim, &CrOffsetHz);
+
+
+	// Get signal information.
+	// Note: One can find signal information definitions in the enumerations as follows:
+	//       1. DTMB_CARRIER_MODE
+	//       2. DTMB_PN_MODE
+	//       3. DTMB_QAM_MODE
+	//       4. DTMB_CODE_RATE_MODE
+	//       5. DTMB_TIME_INTERLEAVER_MODE
+	pNim->GetSignalInfo(pNim, &CarrierMode, &PnMode, &QamMode, &CodeRateMode, &TimeInterleaverMode);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+#include "tuner_base.h"
+#include "dtmb_demod_base.h"
+
+
+
+
+
+// Definitions
+#define DTMB_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX_DEFAULT			1
+#define DTMB_NIM_SINGAL_LOCK_CHECK_TIMES_MAX_DEFAULT			1
+
+
+
+
+
+/// DTMB NIM module pre-definition
+typedef struct DTMB_NIM_MODULE_TAG DTMB_NIM_MODULE;
+
+
+
+
+
+/**
+
+@brief   DTMB demod type getting function pointer
+
+One can use DTMB_NIM_FP_GET_NIM_TYPE() to get DTMB NIM type.
+
+
+@param [in]    pNim       The NIM module pointer
+@param [out]   pNimType   Pointer to an allocated memory for storing NIM type
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_NIM_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*DTMB_NIM_FP_GET_NIM_TYPE)(
+	DTMB_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM initializing function pointer
+
+One can use DTMB_NIM_FP_INITIALIZE() to initialie DTMB NIM.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize NIM successfully.
+@retval   FUNCTION_ERROR     Initialize NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_INITIALIZE)(
+	DTMB_NIM_MODULE *pNim
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM parameter setting function pointer
+
+One can use DTMB_NIM_FP_SET_PARAMETERS() to set DTMB NIM parameters.
+
+
+@param [in]   pNim            The NIM module pointer
+@param [in]   RfFreqHz        RF frequency in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set NIM parameters successfully.
+@retval   FUNCTION_ERROR     Set NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_SET_PARAMETERS() with the corresponding function.
+
+
+@see   DTMB_BANDWIDTH_MODE
+
+*/
+typedef int
+(*DTMB_NIM_FP_SET_PARAMETERS)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM parameter getting function pointer
+
+One can use DTMB_NIM_FP_GET_PARAMETERS() to get DTMB NIM parameters.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pRfFreqHz        Pointer to an allocated memory for storing NIM RF frequency in Hz
+@param [out]   pBandwidthMode   Pointer to an allocated memory for storing NIM bandwidth mode
+
+
+@retval   FUNCTION_SUCCESS   Get NIM parameters successfully.
+@retval   FUNCTION_ERROR     Get NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_PARAMETERS() with the corresponding function.
+
+
+@see   DTMB_BANDWIDTH_MODE
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_PARAMETERS)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM signal present asking function pointer
+
+One can use DTMB_NIM_FP_IS_SIGNAL_PRESENT() to ask DTMB NIM if signal is present.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal present asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal present asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_IS_SIGNAL_PRESENT() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_IS_SIGNAL_PRESENT)(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM signal lock asking function pointer
+
+One can use DTMB_NIM_FP_IS_SIGNAL_LOCKED() to ask DTMB NIM if signal is locked.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal lock asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal lock asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_IS_SIGNAL_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_IS_SIGNAL_LOCKED)(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM signal strength getting function pointer
+
+One can use DTMB_NIM_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pNim              The NIM module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal strength successfully.
+@retval   FUNCTION_ERROR     Get NIM signal strength unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_SIGNAL_STRENGTH)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM signal quality getting function pointer
+
+One can use DTMB_NIM_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal quality successfully.
+@retval   FUNCTION_ERROR     Get NIM signal quality unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_SIGNAL_QUALITY)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM BER value getting function pointer
+
+One can use DTMB_NIM_FP_GET_BER() to get BER.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pBerNum   Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen   Pointer to an allocated memory for storing BER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM BER value successfully.
+@retval   FUNCTION_ERROR     Get NIM BER value unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_BER() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_BER)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM PER value getting function pointer
+
+One can use DTMB_NIM_FP_GET_PER() to get PER.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pPerNum   Pointer to an allocated memory for storing PER numerator
+@param [out]   pPerDen   Pointer to an allocated memory for storing PER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM PER value successfully.
+@retval   FUNCTION_ERROR     Get NIM PER value unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_PER() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_PER)(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM SNR getting function pointer
+
+One can use DTMB_NIM_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pNim        The NIM module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM SNR successfully.
+@retval   FUNCTION_ERROR     Get NIM SNR unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_SNR_DB)(
+	DTMB_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM TR offset getting function pointer
+
+One can use DTMB_NIM_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pNim           The NIM module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get NIM TR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM TR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_TR_OFFSET_PPM)(
+	DTMB_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM CR offset getting function pointer
+
+One can use DTMB_NIM_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pNim          The NIM module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get NIM CR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM CR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_CR_OFFSET_HZ)(
+	DTMB_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM signal information getting function pointer
+
+One can use DTMB_NIM_FP_GET_SIGNAL_INFO() to get signal information.
+
+
+@param [in]    pNim                   The NIM module pointer
+@param [out]   pCarrierMode           Pointer to an allocated memory for storing demod carrier mode
+@param [out]   pPnMode                Pointer to an allocated memory for storing demod PN mode
+@param [out]   pQamMode               Pointer to an allocated memory for storing demod QAM mode
+@param [out]   pCodeRateMode          Pointer to an allocated memory for storing demod code rate mode
+@param [out]   pTimeInterleaverMode   Pointer to an allocated memory for storing demod time interleaver mode
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal information successfully.
+@retval   FUNCTION_ERROR     Get NIM signal information unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_GET_SIGNAL_INFO() with the corresponding function.
+
+
+@see   DTMB_CARRIER_MODE, DTMB_PN_MODE, DTMB_QAM_MODE, DTMB_CODE_RATE_MODE, DTMB_TIME_INTERLEAVER_MODE
+
+*/
+typedef int
+(*DTMB_NIM_FP_GET_SIGNAL_INFO)(
+	DTMB_NIM_MODULE *pNim,
+	int *pCarrierMode,
+	int *pPnMode,
+	int *pQamMode,
+	int *pCodeRateMode,
+	int *pTimeInterleaverMode
+	);
+
+
+
+
+
+/**
+
+@brief   DTMB NIM updating function pointer
+
+One can use DTMB_NIM_FP_UPDATE_FUNCTION() to update NIM register setting.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update NIM setting successfully.
+@retval   FUNCTION_ERROR     Update NIM setting unsuccessfully.
+
+
+@note
+	-# NIM building function will set DTMB_NIM_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+int main(void)
+{
+	DTMB_NIM_MODULE *pNim;
+	DTMB_NIM_MODULE DtmbNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		...
+		);
+
+	...
+
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pNim->UpdateFunction(pNim);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DTMB_NIM_FP_UPDATE_FUNCTION)(
+	DTMB_NIM_MODULE *pNim
+	);
+
+
+
+
+
+// RTL2836 E4000 extra module
+typedef struct RTL2836_E4000_EXTRA_MODULE_TAG RTL2836_E4000_EXTRA_MODULE;
+struct RTL2836_E4000_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long TunerModeUpdateWaitTimeMax;
+	unsigned long TunerModeUpdateWaitTime;
+	unsigned char TunerGainMode;
+};
+
+
+
+
+
+// RTL2836B DTMB E4000 extra module
+typedef struct RTL2836B_DTMB_E4000_EXTRA_MODULE_TAG RTL2836B_DTMB_E4000_EXTRA_MODULE;
+struct RTL2836B_DTMB_E4000_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long TunerModeUpdateWaitTimeMax;
+	unsigned long TunerModeUpdateWaitTime;
+	unsigned char TunerGainMode;
+};
+
+
+
+
+
+// RTL2836B DTMB FC0012 extra module
+typedef struct RTL2836B_DTMB_FC0012_EXTRA_MODULE_TAG RTL2836B_DTMB_FC0012_EXTRA_MODULE;
+struct RTL2836B_DTMB_FC0012_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long LnaUpdateWaitTimeMax;
+	unsigned long LnaUpdateWaitTime;
+	unsigned long RssiRCalOn;
+};
+
+
+
+
+
+// RTL2836B DTMB FC0013B extra module
+typedef struct RTL2836B_DTMB_FC0013B_EXTRA_MODULE_TAG RTL2836B_DTMB_FC0013B_EXTRA_MODULE;
+struct RTL2836B_DTMB_FC0013B_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long LnaUpdateWaitTimeMax;
+	unsigned long LnaUpdateWaitTime;
+	unsigned long RssiRCalOn;
+};
+
+
+
+
+
+/// DTMB NIM module structure
+struct DTMB_NIM_MODULE_TAG
+{
+	// Private variables
+	int NimType;
+
+	union														///<   NIM extra module used by driving module
+	{
+		RTL2836_E4000_EXTRA_MODULE        Rtl2836E4000;
+		RTL2836B_DTMB_E4000_EXTRA_MODULE  Rtl2836bDtmbE4000;
+		RTL2836B_DTMB_FC0012_EXTRA_MODULE Rtl2836bDtmbFc0012;
+		RTL2836B_DTMB_FC0013B_EXTRA_MODULE Rtl2836bDtmbFc0013b;
+	}
+	Extra;
+
+
+	// Modules
+	BASE_INTERFACE_MODULE *pBaseInterface;						///<   Base interface module pointer
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;			///<   Base interface module memory
+
+	I2C_BRIDGE_MODULE *pI2cBridge;								///<   I2C bridge module pointer
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;					///<   I2C bridge module memory
+
+	TUNER_MODULE *pTuner;										///<   Tuner module pointer
+	TUNER_MODULE TunerModuleMemory;								///<   Tuner module memory
+
+	DTMB_DEMOD_MODULE *pDemod;									///<   DTMB demod module pointer
+	DTMB_DEMOD_MODULE DtmbDemodModuleMemory;					///<   DTMB demod module memory
+
+
+	// NIM manipulating functions
+	DTMB_NIM_FP_GET_NIM_TYPE          GetNimType;
+	DTMB_NIM_FP_INITIALIZE            Initialize;
+	DTMB_NIM_FP_SET_PARAMETERS        SetParameters;
+	DTMB_NIM_FP_GET_PARAMETERS        GetParameters;
+	DTMB_NIM_FP_IS_SIGNAL_PRESENT     IsSignalPresent;
+	DTMB_NIM_FP_IS_SIGNAL_LOCKED      IsSignalLocked;
+	DTMB_NIM_FP_GET_SIGNAL_STRENGTH   GetSignalStrength;
+	DTMB_NIM_FP_GET_SIGNAL_QUALITY    GetSignalQuality;
+	DTMB_NIM_FP_GET_BER               GetBer;
+	DTMB_NIM_FP_GET_PER               GetPer;
+	DTMB_NIM_FP_GET_SNR_DB            GetSnrDb;
+	DTMB_NIM_FP_GET_TR_OFFSET_PPM     GetTrOffsetPpm;
+	DTMB_NIM_FP_GET_CR_OFFSET_HZ      GetCrOffsetHz;
+	DTMB_NIM_FP_GET_SIGNAL_INFO       GetSignalInfo;
+	DTMB_NIM_FP_UPDATE_FUNCTION       UpdateFunction;
+};
+
+
+
+
+
+
+
+// DTMB NIM default manipulaing functions
+void
+dtmb_nim_default_GetNimType(
+	DTMB_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+int
+dtmb_nim_default_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	);
+
+int
+dtmb_nim_default_GetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz
+	);
+
+int
+dtmb_nim_default_IsSignalPresent(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+dtmb_nim_default_IsSignalLocked(
+	DTMB_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+dtmb_nim_default_GetSignalStrength(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+int
+dtmb_nim_default_GetSignalQuality(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+int
+dtmb_nim_default_GetBer(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+int
+dtmb_nim_default_GetPer(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+int
+dtmb_nim_default_GetSnrDb(
+	DTMB_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+dtmb_nim_default_GetTrOffsetPpm(
+	DTMB_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+int
+dtmb_nim_default_GetCrOffsetHz(
+	DTMB_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+int
+dtmb_nim_default_GetSignalInfo(
+	DTMB_NIM_MODULE *pNim,
+	int *pCarrierMode,
+	int *pPnMode,
+	int *pQamMode,
+	int *pCodeRateMode,
+	int *pTimeInterleaverMode
+	);
+
+int
+dtmb_nim_default_UpdateFunction(
+	DTMB_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/dvb-usb.h b/drivers/media/usb/rtl2832u/dvb-usb.h
new file mode 100644
index 00000000..ce4c4e3b
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dvb-usb.h
@@ -0,0 +1,483 @@
+/* dvb-usb.h is part of the DVB USB library.
+ *
+ * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@desy.de)
+ * see dvb-usb-init.c for copyright information.
+ *
+ * the headerfile, all dvb-usb-drivers have to include.
+ *
+ * TODO: clean-up the structures for unused fields and update the comments
+ */
+#ifndef __DVB_USB_H__
+#define __DVB_USB_H__
+
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/firmware.h>
+#include <linux/mutex.h>
+#include <media/rc-core.h>
+
+#include "dvb_frontend.h"
+#include "dvb_demux.h"
+#include "dvb_net.h"
+#include "dmxdev.h"
+
+#include "dvb-pll.h"
+
+#include "dvb-usb-ids.h"
+
+/* debug */
+#ifdef CONFIG_DVB_USB_DEBUG
+#define dprintk(var,level,args...) \
+	    do { if ((var & level)) { printk(args); } } while (0)
+
+#define debug_dump(b,l,func) {\
+	int loop_; \
+	for (loop_ = 0; loop_ < l; loop_++) func("%02x ", b[loop_]); \
+	func("\n");\
+}
+#define DVB_USB_DEBUG_STATUS
+#else
+#define dprintk(args...)
+#define debug_dump(b,l,func)
+
+#define DVB_USB_DEBUG_STATUS " (debugging is not enabled)"
+
+#endif
+
+/* generic log methods - taken from usb.h */
+#ifndef DVB_USB_LOG_PREFIX
+ #define DVB_USB_LOG_PREFIX "dvb-usb (please define a log prefix)"
+#endif
+
+#undef err
+#define err(format, arg...)  printk(KERN_ERR     DVB_USB_LOG_PREFIX ": " format "\n" , ## arg)
+#undef info
+#define info(format, arg...) printk(KERN_INFO    DVB_USB_LOG_PREFIX ": " format "\n" , ## arg)
+#undef warn
+#define warn(format, arg...) printk(KERN_WARNING DVB_USB_LOG_PREFIX ": " format "\n" , ## arg)
+
+/**
+ * struct dvb_usb_device_description - name and its according USB IDs
+ * @name: real name of the box, regardless which DVB USB device class is in use
+ * @cold_ids: array of struct usb_device_id which describe the device in
+ *  pre-firmware state
+ * @warm_ids: array of struct usb_device_id which describe the device in
+ *  post-firmware state
+ *
+ * Each DVB USB device class can have one or more actual devices, this struct
+ * assigns a name to it.
+ */
+struct dvb_usb_device_description {
+	const char *name;
+
+#define DVB_USB_ID_MAX_NUM 15
+	struct usb_device_id *cold_ids[DVB_USB_ID_MAX_NUM];
+	struct usb_device_id *warm_ids[DVB_USB_ID_MAX_NUM];
+};
+
+static inline u8 rc5_custom(struct rc_map_table *key)
+{
+	return (key->scancode >> 8) & 0xff;
+}
+
+static inline u8 rc5_data(struct rc_map_table *key)
+{
+	return key->scancode & 0xff;
+}
+
+static inline u16 rc5_scan(struct rc_map_table *key)
+{
+	return key->scancode & 0xffff;
+}
+
+struct dvb_usb_device;
+struct dvb_usb_adapter;
+struct usb_data_stream;
+
+/**
+ * Properties of USB streaming - TODO this structure should be somewhere else
+ * describes the kind of USB transfer used for data-streaming.
+ *  (BULK or ISOC)
+ */
+struct usb_data_stream_properties {
+#define USB_BULK  1
+#define USB_ISOC  2
+	int type;
+	int count;
+	int endpoint;
+
+	union {
+		struct {
+			int buffersize; /* per URB */
+		} bulk;
+		struct {
+			int framesperurb;
+			int framesize;
+			int interval;
+		} isoc;
+	} u;
+};
+
+/**
+ * struct dvb_usb_adapter_properties - properties of a dvb-usb-adapter.
+ *    A DVB-USB-Adapter is basically a dvb_adapter which is present on a USB-device.
+ * @caps: capabilities of the DVB USB device.
+ * @pid_filter_count: number of PID filter position in the optional hardware
+ *  PID-filter.
+ * @num_frontends: number of frontends of the DVB USB adapter.
+ * @frontend_ctrl: called to power on/off active frontend.
+ * @streaming_ctrl: called to start and stop the MPEG2-TS streaming of the
+ *  device (not URB submitting/killing).
+ * @pid_filter_ctrl: called to en/disable the PID filter, if any.
+ * @pid_filter: called to set/unset a PID for filtering.
+ * @frontend_attach: called to attach the possible frontends (fill fe-field
+ *  of struct dvb_usb_device).
+ * @tuner_attach: called to attach the correct tuner and to fill pll_addr,
+ *  pll_desc and pll_init_buf of struct dvb_usb_device).
+ * @stream: configuration of the USB streaming
+ */
+struct dvb_usb_adapter_fe_properties {
+#define DVB_USB_ADAP_HAS_PID_FILTER               0x01
+#define DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF 0x02
+#define DVB_USB_ADAP_NEED_PID_FILTERING           0x04
+#define DVB_USB_ADAP_RECEIVES_204_BYTE_TS         0x08
+#define DVB_USB_ADAP_RECEIVES_RAW_PAYLOAD         0x10
+	int caps;
+	int pid_filter_count;
+
+	int (*streaming_ctrl)  (struct dvb_usb_adapter *, int);
+	int (*pid_filter_ctrl) (struct dvb_usb_adapter *, int);
+	int (*pid_filter)      (struct dvb_usb_adapter *, int, u16, int);
+
+	int (*frontend_attach) (struct dvb_usb_adapter *);
+	int (*tuner_attach)    (struct dvb_usb_adapter *);
+
+	struct usb_data_stream_properties stream;
+
+	int size_of_priv;
+};
+
+#define MAX_NO_OF_FE_PER_ADAP 3
+struct dvb_usb_adapter_properties {
+	int size_of_priv;
+
+	int (*frontend_ctrl)   (struct dvb_frontend *, int);
+
+	int num_frontends;
+	struct dvb_usb_adapter_fe_properties fe[MAX_NO_OF_FE_PER_ADAP];
+};
+
+/**
+ * struct dvb_rc_legacy - old properties of remote controller
+ * @rc_map_table: a hard-wired array of struct rc_map_table (NULL to disable
+ *  remote control handling).
+ * @rc_map_size: number of items in @rc_map_table.
+ * @rc_query: called to query an event event.
+ * @rc_interval: time in ms between two queries.
+ */
+struct dvb_rc_legacy {
+/* remote control properties */
+#define REMOTE_NO_KEY_PRESSED      0x00
+#define REMOTE_KEY_PRESSED         0x01
+#define REMOTE_KEY_REPEAT          0x02
+	struct rc_map_table  *rc_map_table;
+	int rc_map_size;
+	int (*rc_query) (struct dvb_usb_device *, u32 *, int *);
+	int rc_interval;
+};
+
+/**
+ * struct dvb_rc properties of remote controller, using rc-core
+ * @rc_codes: name of rc codes table
+ * @protocol: type of protocol(s) currently used by the driver
+ * @allowed_protos: protocol(s) supported by the driver
+ * @driver_type: Used to point if a device supports raw mode
+ * @change_protocol: callback to change protocol
+ * @rc_query: called to query an event event.
+ * @rc_interval: time in ms between two queries.
+ * @bulk_mode: device supports bulk mode for RC (disable polling mode)
+ */
+struct dvb_rc {
+	char *rc_codes;
+	u64 protocol;
+	u64 allowed_protos;
+	enum rc_driver_type driver_type;
+	int (*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	char *module_name;
+	int (*rc_query) (struct dvb_usb_device *d);
+	int rc_interval;
+	bool bulk_mode;				/* uses bulk mode */
+};
+
+/**
+ * enum dvb_usb_mode - Specifies if it is using a legacy driver or a new one
+ *		       based on rc-core
+ * This is initialized/used only inside dvb-usb-remote.c.
+ * It shouldn't be set by the drivers.
+ */
+enum dvb_usb_mode {
+	DVB_RC_LEGACY,
+	DVB_RC_CORE,
+};
+
+/**
+ * struct dvb_usb_device_properties - properties of a dvb-usb-device
+ * @usb_ctrl: which USB device-side controller is in use. Needed for firmware
+ *  download.
+ * @firmware: name of the firmware file.
+ * @download_firmware: called to download the firmware when the usb_ctrl is
+ *  DEVICE_SPECIFIC.
+ * @no_reconnect: device doesn't do a reconnect after downloading the firmware,
+ *  so do the warm initialization right after it
+ *
+ * @size_of_priv: how many bytes shall be allocated for the private field
+ *  of struct dvb_usb_device.
+ *
+ * @power_ctrl: called to enable/disable power of the device.
+ * @read_mac_address: called to read the MAC address of the device.
+ * @identify_state: called to determine the state (cold or warm), when it
+ *  is not distinguishable by the USB IDs.
+ *
+ * @rc: remote controller properties
+ *
+ * @i2c_algo: i2c_algorithm if the device has I2CoverUSB.
+ *
+ * @generic_bulk_ctrl_endpoint: most of the DVB USB devices have a generic
+ *  endpoint which received control messages with bulk transfers. When this
+ *  is non-zero, one can use dvb_usb_generic_rw and dvb_usb_generic_write-
+ *  helper functions.
+ *
+ * @generic_bulk_ctrl_endpoint_response: some DVB USB devices use a separate
+ *  endpoint for responses to control messages sent with bulk transfers via
+ *  the generic_bulk_ctrl_endpoint. When this is non-zero, this will be used
+ *  instead of the generic_bulk_ctrl_endpoint when reading usb responses in
+ *  the dvb_usb_generic_rw helper function.
+ *
+ * @num_device_descs: number of struct dvb_usb_device_description in @devices
+ * @devices: array of struct dvb_usb_device_description compatibles with these
+ *  properties.
+ */
+#define MAX_NO_OF_ADAPTER_PER_DEVICE 2
+struct dvb_usb_device_properties {
+
+#define DVB_USB_IS_AN_I2C_ADAPTER            0x01
+	int caps;
+
+#define DEVICE_SPECIFIC 0
+#define CYPRESS_AN2135  1
+#define CYPRESS_AN2235  2
+#define CYPRESS_FX2     3
+	int        usb_ctrl;
+	int        (*download_firmware) (struct usb_device *, const struct firmware *);
+	const char *firmware;
+	int        no_reconnect;
+
+	int size_of_priv;
+
+	int num_adapters;
+	struct dvb_usb_adapter_properties adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];
+
+	int (*power_ctrl)       (struct dvb_usb_device *, int);
+	int (*read_mac_address) (struct dvb_usb_device *, u8 []);
+	int (*identify_state)   (struct usb_device *, struct dvb_usb_device_properties *,
+			struct dvb_usb_device_description **, int *);
+
+	struct {
+		enum dvb_usb_mode mode;	/* Drivers shouldn't touch on it */
+		struct dvb_rc_legacy legacy;
+		struct dvb_rc core;
+	} rc;
+
+	struct i2c_algorithm *i2c_algo;
+
+	int generic_bulk_ctrl_endpoint;
+	int generic_bulk_ctrl_endpoint_response;
+
+	int num_device_descs;
+	struct dvb_usb_device_description devices[12];
+};
+
+/**
+ * struct usb_data_stream - generic object of an USB stream
+ * @buf_num: number of buffer allocated.
+ * @buf_size: size of each buffer in buf_list.
+ * @buf_list: array containing all allocate buffers for streaming.
+ * @dma_addr: list of dma_addr_t for each buffer in buf_list.
+ *
+ * @urbs_initialized: number of URBs initialized.
+ * @urbs_submitted: number of URBs submitted.
+ */
+#define MAX_NO_URBS_FOR_DATA_STREAM 10
+struct usb_data_stream {
+	struct usb_device                 *udev;
+	struct usb_data_stream_properties  props;
+
+#define USB_STATE_INIT    0x00
+#define USB_STATE_URB_BUF 0x01
+	int state;
+
+	void (*complete) (struct usb_data_stream *, u8 *, size_t);
+
+	struct urb    *urb_list[MAX_NO_URBS_FOR_DATA_STREAM];
+	int            buf_num;
+	unsigned long  buf_size;
+	u8            *buf_list[MAX_NO_URBS_FOR_DATA_STREAM];
+	dma_addr_t     dma_addr[MAX_NO_URBS_FOR_DATA_STREAM];
+
+	int urbs_initialized;
+	int urbs_submitted;
+
+	void *user_priv;
+};
+
+/**
+ * struct dvb_usb_adapter - a DVB adapter on a USB device
+ * @id: index of this adapter (starting with 0).
+ *
+ * @feedcount: number of reqested feeds (used for streaming-activation)
+ * @pid_filtering: is hardware pid_filtering used or not.
+ *
+ * @pll_addr: I2C address of the tuner for programming
+ * @pll_init: array containing the initialization buffer
+ * @pll_desc: pointer to the appropriate struct dvb_pll_desc
+ * @tuner_pass_ctrl: called to (de)activate tuner passthru of the demod or the board
+ *
+ * @dvb_adap: device's dvb_adapter.
+ * @dmxdev: device's dmxdev.
+ * @demux: device's software demuxer.
+ * @dvb_net: device's dvb_net interfaces.
+ * @dvb_frontend: device's frontend.
+ * @max_feed_count: how many feeds can be handled simultaneously by this
+ *  device
+ *
+ * @fe_init:  rerouted frontend-init (wakeup) function.
+ * @fe_sleep: rerouted frontend-sleep function.
+ *
+ * @stream: the usb data stream.
+ */
+struct dvb_usb_fe_adapter {
+	struct dvb_frontend *fe;
+
+	int (*fe_init)  (struct dvb_frontend *);
+	int (*fe_sleep) (struct dvb_frontend *);
+
+	struct usb_data_stream stream;
+
+	int pid_filtering;
+	int max_feed_count;
+
+	void *priv;
+};
+
+struct dvb_usb_adapter {
+	struct dvb_usb_device *dev;
+	struct dvb_usb_adapter_properties props;
+
+#define DVB_USB_ADAP_STATE_INIT 0x000
+#define DVB_USB_ADAP_STATE_DVB  0x001
+	int state;
+
+	u8  id;
+
+	int feedcount;
+
+	/* dvb */
+	struct dvb_adapter   dvb_adap;
+	struct dmxdev        dmxdev;
+	struct dvb_demux     demux;
+	struct dvb_net       dvb_net;
+
+	struct dvb_usb_fe_adapter fe_adap[MAX_NO_OF_FE_PER_ADAP];
+	int active_fe;
+	int num_frontends_initialized;
+
+	void *priv;
+};
+
+/**
+ * struct dvb_usb_device - object of a DVB USB device
+ * @props: copy of the struct dvb_usb_properties this device belongs to.
+ * @desc: pointer to the device's struct dvb_usb_device_description.
+ * @state: initialization and runtime state of the device.
+ *
+ * @powered: indicated whether the device is power or not.
+ *  Powered is in/decremented for each call to modify the state.
+ * @udev: pointer to the device's struct usb_device.
+ *
+ * @usb_mutex: semaphore of USB control messages (reading needs two messages)
+ * @i2c_mutex: semaphore for i2c-transfers
+ *
+ * @i2c_adap: device's i2c_adapter if it uses I2CoverUSB
+ *
+ * @rc_dev: rc device for the remote control (rc-core mode)
+ * @input_dev: input device for the remote control (legacy mode)
+ * @rc_query_work: struct work_struct frequent rc queries
+ * @last_event: last triggered event
+ * @last_state: last state (no, pressed, repeat)
+ * @owner: owner of the dvb_adapter
+ * @priv: private data of the actual driver (allocate by dvb-usb, size defined
+ *  in size_of_priv of dvb_usb_properties).
+ */
+struct dvb_usb_device {
+	struct dvb_usb_device_properties props;
+	struct dvb_usb_device_description *desc;
+
+	struct usb_device *udev;
+
+#define DVB_USB_STATE_INIT        0x000
+#define DVB_USB_STATE_I2C         0x001
+#define DVB_USB_STATE_DVB         0x002
+#define DVB_USB_STATE_REMOTE      0x004
+	int state;
+
+	int powered;
+
+	/* locking */
+	struct mutex usb_mutex;
+
+	/* i2c */
+	struct mutex i2c_mutex;
+	struct i2c_adapter i2c_adap;
+
+	int                    num_adapters_initialized;
+	struct dvb_usb_adapter adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];
+
+	/* remote control */
+	struct rc_dev *rc_dev;
+	struct input_dev *input_dev;
+	char rc_phys[64];
+	struct delayed_work rc_query_work;
+	u32 last_event;
+	int last_state;
+
+	struct module *owner;
+
+	void *priv;
+};
+
+extern int dvb_usb_device_init(struct usb_interface *,
+			       struct dvb_usb_device_properties *,
+			       struct module *, struct dvb_usb_device **,
+			       short *adapter_nums);
+extern void dvb_usb_device_exit(struct usb_interface *);
+
+/* the generic read/write method for device control */
+extern int dvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16,int);
+extern int dvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);
+
+/* commonly used remote control parsing */
+extern int dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *, u8[], u32 *, int *);
+
+/* commonly used firmware download types and function */
+struct hexline {
+	u8 len;
+	u32 addr;
+	u8 type;
+	u8 data[255];
+	u8 chk;
+};
+extern int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type);
+extern int dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx, int *pos);
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/dvbt_demod_base.c b/drivers/media/usb/rtl2832u/dvbt_demod_base.c
new file mode 100644
index 00000000..d1bd1f65
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dvbt_demod_base.c
@@ -0,0 +1,816 @@
+/**
+
+@file
+
+@brief   DVB-T demod default function definition
+
+DVB-T demod default functions.
+
+*/
+
+#include "dvbt_demod_base.h"
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE
+
+*/
+int
+dvbt_demod_default_SetRegPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBytes[LEN_2_BYTE];
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Set demod register page with page number.
+	// Note: The I2C format of demod register page setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + DVBT_DEMOD_PAGE_REG_ADDR + PageNo + stop_bit
+	WritingBytes[0] = DVBT_DEMOD_PAGE_REG_ADDR;
+	WritingBytes[1] = (unsigned char)PageNo;
+
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBytes, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+	if( mutex_lock_interruptible(&d->usb_mutex) )	goto error;
+
+	 pDemod->CurrentPageNo = PageNo;
+
+	mutex_unlock(&d->usb_mutex);
+	
+	return FUNCTION_SUCCESS;
+
+error:
+	return FUNCTION_ERROR;
+
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_REG_BYTES
+
+*/
+int
+dvbt_demod_default_SetRegBytes(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned char ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+	
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = RegStartAddr + i;
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) + stop_bit
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, WritingByteNum + LEN_1_BYTE) !=
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned char WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+	
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = RegStartAddr + i;
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[j] = pWritingBytes[i + j];
+
+		// Set demod register bytes with writing buffer.
+		if(write_demod_register( d, DeviceAddr, pDemod->CurrentPageNo, RegWritingAddr, WritingBuffer, WritingByteNum )) goto error;
+
+		
+	}
+
+
+	return FUNCTION_SUCCESS;
+error:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_REG_BYTES
+
+*/
+int
+dvbt_demod_default_GetRegBytes(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i;
+	unsigned char DeviceAddr;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = RegStartAddr + i;
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, &RegReadingAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i;
+	unsigned char DeviceAddr;
+	unsigned char ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = RegStartAddr + i;
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Get demod register bytes.
+		if(read_demod_register(d, DeviceAddr, pDemod->CurrentPageNo, RegReadingAddr, &pReadingBytes[i], ReadingByteNum)) goto error;
+
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+error:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_REG_MASK_BITS
+
+*/
+int
+dvbt_demod_default_SetRegMaskBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+	unsigned char WritingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value MSB.
+	//       Put upper address byte on value LSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * (ByteNum - i -1));
+
+
+	// Reserve unsigned integer value unmask bit with mask and inlay writing value into it.
+	Value &= ~Mask;
+	Value |= (WritingValue << Shift) & Mask;
+
+
+	// Separate unsigned integer value into writing bytes.
+	// Note: Pick up lower address byte from value MSB.
+	//       Pick up upper address byte from value LSB.
+	for(i = 0; i < ByteNum; i++)
+		WritingBytes[i] = (unsigned char)((Value >> (BYTE_SHIFT * (ByteNum - i -1))) & BYTE_MASK);
+
+
+	// Write demod register bytes with writing bytes.
+	if(pDemod->SetRegBytes(pDemod, RegStartAddr, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_REG_MASK_BITS
+
+*/
+int
+dvbt_demod_default_GetRegMaskBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value MSB.
+	//       Put upper address byte on value LSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * (ByteNum - i -1));
+
+
+	// Get register bits from unsigned integaer value with mask and shift
+	*pReadingValue = (Value & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_REG_BITS
+
+*/
+int
+dvbt_demod_default_SetRegBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable[RegBitName].Msb;
+	Lsb          = pDemod->RegTable[RegBitName].Lsb;
+
+
+	// Set register mask bits.
+	if(pDemod->SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_REG_BITS
+
+*/
+int
+dvbt_demod_default_GetRegBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->RegTable[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from register table with register bit name key.
+	RegStartAddr = pDemod->RegTable[RegBitName].RegStartAddr;
+	Msb          = pDemod->RegTable[RegBitName].Msb;
+	Lsb          = pDemod->RegTable[RegBitName].Lsb;
+
+
+	// Get register mask bits.
+	if(pDemod->GetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+*/
+int
+dvbt_demod_default_SetRegBitsWithPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned long PageNo;
+
+
+	// Get register page number from register table with register bit name key.
+	PageNo = pDemod->RegTable[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set register mask bits with register bit name key.
+	if(pDemod->SetRegBits(pDemod, RegBitName, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+*/
+int
+dvbt_demod_default_GetRegBitsWithPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned long PageNo;
+
+
+	// Get register page number from register table with register bit name key.
+	PageNo = pDemod->RegTable[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get register mask bits with register bit name key.
+	if(pDemod->GetRegBits(pDemod, RegBitName, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_DEMOD_TYPE
+
+*/
+void
+dvbt_demod_default_GetDemodType(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	)
+{
+	// Get demod type from demod module.
+	*pDemodType = pDemod->DemodType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_DEVICE_ADDR
+
+*/
+void
+dvbt_demod_default_GetDeviceAddr(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get demod I2C device address from demod module.
+	*pDeviceAddr = pDemod->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_CRYSTAL_FREQ_HZ
+
+*/
+void
+dvbt_demod_default_GetCrystalFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	)
+{
+	// Get demod crystal frequency in Hz from demod module.
+	*pCrystalFreqHz = pDemod->CrystalFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_BANDWIDTH_MODE
+
+*/
+int
+dvbt_demod_default_GetBandwidthMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pBandwidthMode
+	)
+{
+	// Get demod bandwidth mode from demod module.
+	if(pDemod->IsBandwidthModeSet != YES)
+		goto error_status_get_demod_bandwidth_mode;
+
+	*pBandwidthMode = pDemod->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_IF_FREQ_HZ
+
+*/
+int
+dvbt_demod_default_GetIfFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	)
+{
+	// Get demod IF frequency in Hz from demod module.
+	if(pDemod->IsIfFreqHzSet != YES)
+		goto error_status_get_demod_if_frequency;
+
+	*pIfFreqHz = pDemod->IfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_if_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_DEMOD_FP_GET_SPECTRUM_MODE
+
+*/
+int
+dvbt_demod_default_GetSpectrumMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	)
+{
+	// Get demod spectrum mode from demod module.
+	if(pDemod->IsSpectrumModeSet != YES)
+		goto error_status_get_demod_spectrum_mode;
+
+	*pSpectrumMode = pDemod->SpectrumMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_spectrum_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/dvbt_demod_base.h b/drivers/media/usb/rtl2832u/dvbt_demod_base.h
new file mode 100644
index 00000000..edf7f192
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dvbt_demod_base.h
@@ -0,0 +1,2722 @@
+#ifndef __DVBT_DEMOD_BASE_H
+#define __DVBT_DEMOD_BASE_H
+
+/**
+
+@file
+
+@brief   DVB-T demod base module definition
+
+DVB-T demod base module definitions contains demod module structure, demod funciton pointers, and demod definitions.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_xxx.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;
+
+	int BandwidthMode;
+	unsigned long IfFreqHz;
+	int SpectrumMode;
+
+	int DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+
+	long RfAgc, IfAgc;
+	unsigned char DiAgc;
+
+	int Answer;
+	long TrOffsetPpm, CrOffsetHz;
+	unsigned long BerNum, BerDen;
+	double Ber;
+	long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	unsigned long SignalStrength, SignalQuality;
+
+	int Constellation;
+	int Hierarchy;
+	int CodeRateLp;
+	int CodeRateHp;
+	int GuardInterval;
+	int FftMode;
+
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pBaseInterface,
+		&BaseInterfaceModuleMemory,
+		9,								// Set maximum I2C reading byte number with 9.
+		8,								// Set maximum I2C writing byte number with 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs					// Employ CustomWaitMs() as basic waiting function.
+		);
+
+
+	// Build DVB-T demod XXX module.
+	BuildXxxModule(
+		&pDemod,
+		&DvbtDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x20,							// Demod I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// Demod crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// Demod TS interface mode is serial.
+		...								// Other arguments by each demod module
+		);
+
+
+
+
+
+	// ==== Initialize DVB-T demod and set its parameters =====
+
+	// Initialize demod.
+	pDemod->Initialize(pDemod);
+
+
+	// Set demod parameters. (bandwidth mode, IF frequency, spectrum mode)
+	// Note: In the example:
+	//       1. Bandwidth mode is 8 MHz.
+	//       2. IF frequency is 36.125 MHz.
+	//       3. Spectrum mode is SPECTRUM_INVERSE.
+	BandwidthMode = DVBT_BANDWIDTH_8MHZ;
+	IfFreqHz      = IF_FREQ_36125000HZ;
+	SpectrumMode  = SPECTRUM_INVERSE;
+
+	pDemod->SetBandwidthMode(pDemod, BandwidthMode);
+	pDemod->SetIfFreqHz(pDemod,      IfFreqHz);
+	pDemod->SetSpectrumMode(pDemod,  SpectrumMode);
+
+
+	// Need to set tuner before demod software reset.
+	// The order to set demod and tuner is not important.
+	// Note: One can use "pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1);"
+	//       for tuner I2C command forwarding.
+
+
+	// Reset demod by software reset.
+	pDemod->SoftwareReset(pDemod);
+
+
+	// Wait maximum 1000 ms for demod converge.
+	for(i = 0; i < 25; i++)
+	{
+		// Wait 40 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 40);
+
+		// Check signal lock status.
+		// Note: If Answer is YES, signal is locked.
+		//       If Answer is NO, signal is not locked.
+		pDemod->IsSignalLocked(pDemod, &Answer);
+
+		if(Answer == YES)
+		{
+			// Signal is locked.
+			break;
+		}
+	}
+
+
+
+
+
+	// ==== Get DVB-T demod information =====
+
+	// Get demod type.
+	// Note: One can find demod type in MODULE_TYPE enumeration.
+	pDemod->GetDemodType(pDemod, &DemodType);
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Ask demod if it is connected to I2C bus.
+	// Note: If Answer is YES, demod is connected to I2C bus.
+	//       If Answer is NO, demod is not connected to I2C bus.
+	pDemod->IsConnectedToI2c(pDemod, &Answer);
+
+
+	// Get demod parameters. (bandwidth mode, IF frequency, spectrum mode)
+	pDemod->GetBandwidthMode(pDemod, &BandwidthMode);
+	pDemod->GetIfFreqHz(pDemod,      &IfFreqHz);
+	pDemod->GetSpectrumMode(pDemod,  &SpectrumMode);
+
+
+	// Get demod AGC value.
+	// Note: The range of RF AGC and IF AGC value is -8192 ~ 8191.
+	//       The range of digital AGC value is 0 ~ 255.
+	pDemod->GetRfAgc(pDemod, &RfAgc);
+	pDemod->GetIfAgc(pDemod, &IfAgc);
+	pDemod->GetDiAgc(pDemod, &DiAgc);
+
+
+	// Get demod lock status.
+	// Note: If Answer is YES, it is locked.
+	//       If Answer is NO, it is not locked.
+	pDemod->IsTpsLocked(pDemod,    &Answer);
+	pDemod->IsSignalLocked(pDemod, &Answer);
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pDemod->GetTrOffsetPpm(pDemod, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pDemod->GetCrOffsetHz(pDemod, &CrOffsetHz);
+
+
+	// Get BER.
+	pDemod->GetBer(pDemod, &BerNum, &BerDen);
+	Ber = (double)BerNum / (double)BerDen;
+
+	// Get SNR in dB.
+	pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pDemod->GetSignalStrength(pDemod, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pDemod->GetSignalQuality(pDemod, &SignalQuality);
+
+
+	// Get TPS information.
+	// Note: One can find TPS information definitions in the enumerations as follows:
+	//       1. DVBT_CONSTELLATION_MODE
+	//       2. DVBT_HIERARCHY_MODE
+	//       3. DVBT_CODE_RATE_MODE (for low-priority and high-priority code rate)
+	//       4. DVBT_GUARD_INTERVAL_MODE
+	//       5. DVBT_FFT_MODE_MODE
+	pDemod->GetConstellation(pDemod, &Constellation);
+	pDemod->GetHierarchy(pDemod,     &Hierarchy);
+	pDemod->GetCodeRateLp(pDemod,    &CodeRateLp);
+	pDemod->GetCodeRateHp(pDemod,    &CodeRateHp);
+	pDemod->GetGuardInterval(pDemod, &GuardInterval);
+	pDemod->GetFftMode(pDemod,       &FftMode);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+
+
+
+
+
+// Definitions
+
+// Page register address
+#define DVBT_DEMOD_PAGE_REG_ADDR		0x00
+
+
+// Bandwidth modes
+#define DVBT_BANDWIDTH_NONE			-1
+enum DVBT_BANDWIDTH_MODE
+{
+	DVBT_BANDWIDTH_6MHZ,
+	DVBT_BANDWIDTH_7MHZ,
+	DVBT_BANDWIDTH_8MHZ,
+};
+#define DVBT_BANDWIDTH_MODE_NUM		3
+
+
+// Constellation
+enum DVBT_CONSTELLATION_MODE
+{
+	DVBT_CONSTELLATION_QPSK,
+	DVBT_CONSTELLATION_16QAM,
+	DVBT_CONSTELLATION_64QAM,
+};
+#define DVBT_CONSTELLATION_NUM		3
+
+
+// Hierarchy
+enum DVBT_HIERARCHY_MODE
+{
+	DVBT_HIERARCHY_NONE,
+	DVBT_HIERARCHY_ALPHA_1,
+	DVBT_HIERARCHY_ALPHA_2,
+	DVBT_HIERARCHY_ALPHA_4,
+};
+#define DVBT_HIERARCHY_NUM			4
+
+
+// Code rate
+enum DVBT_CODE_RATE_MODE
+{
+	DVBT_CODE_RATE_1_OVER_2,
+	DVBT_CODE_RATE_2_OVER_3,
+	DVBT_CODE_RATE_3_OVER_4,
+	DVBT_CODE_RATE_5_OVER_6,
+	DVBT_CODE_RATE_7_OVER_8,
+};
+#define DVBT_CODE_RATE_NUM			5
+
+
+// Guard interval
+enum DVBT_GUARD_INTERVAL_MODE
+{
+	DVBT_GUARD_INTERVAL_1_OVER_32,
+	DVBT_GUARD_INTERVAL_1_OVER_16,
+	DVBT_GUARD_INTERVAL_1_OVER_8,
+	DVBT_GUARD_INTERVAL_1_OVER_4,
+};
+#define DVBT_GUARD_INTERVAL_NUM		4
+
+
+// FFT mode
+enum DVBT_FFT_MODE_MODE
+{
+	DVBT_FFT_MODE_2K,
+	DVBT_FFT_MODE_8K,
+};
+#define DVBT_FFT_MODE_NUM			2
+
+
+
+
+
+// Register entry definitions
+
+// Register entry
+typedef struct
+{
+	int IsAvailable;
+	unsigned long PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DVBT_REG_ENTRY;
+
+
+
+// Primary register entry
+typedef struct
+{
+	int RegBitName;
+	unsigned long PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+DVBT_PRIMARY_REG_ENTRY;
+
+
+
+
+
+// Register table dependence
+
+// Demod register bit names
+enum DVBT_REG_BIT_NAME
+{
+	// Software reset register
+	DVBT_SOFT_RST,
+
+	// Tuner I2C forwording register
+	DVBT_IIC_REPEAT,
+
+
+	// Registers for initializing
+	DVBT_TR_WAIT_MIN_8K,
+	DVBT_RSD_BER_FAIL_VAL,
+	DVBT_EN_BK_TRK,
+	DVBT_REG_PI,
+
+	DVBT_REG_PFREQ_1_0,				// For RTL2830 only
+	DVBT_PD_DA8,					// For RTL2830 only
+	DVBT_LOCK_TH,					// For RTL2830 only
+	DVBT_BER_PASS_SCAL,				// For RTL2830 only
+	DVBT_CE_FFSM_BYPASS,			// For RTL2830 only
+	DVBT_ALPHAIIR_N,				// For RTL2830 only
+	DVBT_ALPHAIIR_DIF,				// For RTL2830 only
+	DVBT_EN_TRK_SPAN,				// For RTL2830 only
+	DVBT_LOCK_TH_LEN,				// For RTL2830 only
+	DVBT_CCI_THRE,					// For RTL2830 only
+	DVBT_CCI_MON_SCAL,				// For RTL2830 only
+	DVBT_CCI_M0,					// For RTL2830 only
+	DVBT_CCI_M1,					// For RTL2830 only
+	DVBT_CCI_M2,					// For RTL2830 only
+	DVBT_CCI_M3,					// For RTL2830 only
+	DVBT_SPEC_INIT_0,				// For RTL2830 only
+	DVBT_SPEC_INIT_1,				// For RTL2830 only
+	DVBT_SPEC_INIT_2,				// For RTL2830 only
+
+	DVBT_AD_EN_REG,					// For RTL2832 only
+	DVBT_AD_EN_REG1,				// For RTL2832 only
+	DVBT_EN_BBIN,					// For RTL2832 only
+	DVBT_MGD_THD0,					// For RTL2832 only
+	DVBT_MGD_THD1,					// For RTL2832 only
+	DVBT_MGD_THD2,					// For RTL2832 only
+	DVBT_MGD_THD3,					// For RTL2832 only
+	DVBT_MGD_THD4,					// For RTL2832 only
+	DVBT_MGD_THD5,					// For RTL2832 only
+	DVBT_MGD_THD6,					// For RTL2832 only
+	DVBT_MGD_THD7,					// For RTL2832 only
+	DVBT_EN_CACQ_NOTCH,				// For RTL2832 only
+	DVBT_AD_AV_REF,					// For RTL2832 only
+	DVBT_PIP_ON,					// For RTL2832 only
+	DVBT_SCALE1_B92,				// For RTL2832 only
+	DVBT_SCALE1_B93,				// For RTL2832 only
+	DVBT_SCALE1_BA7,				// For RTL2832 only
+	DVBT_SCALE1_BA9,				// For RTL2832 only
+	DVBT_SCALE1_BAA,				// For RTL2832 only
+	DVBT_SCALE1_BAB,				// For RTL2832 only
+	DVBT_SCALE1_BAC,				// For RTL2832 only
+	DVBT_SCALE1_BB0,				// For RTL2832 only
+	DVBT_SCALE1_BB1,				// For RTL2832 only
+	DVBT_KB_P1,						// For RTL2832 only
+	DVBT_KB_P2,						// For RTL2832 only
+	DVBT_KB_P3,						// For RTL2832 only
+	DVBT_OPT_ADC_IQ,				// For RTL2832 only
+	DVBT_AD_AVI,					// For RTL2832 only
+	DVBT_AD_AVQ,					// For RTL2832 only
+	DVBT_K1_CR_STEP12,				// For RTL2832 only
+
+	// Registers for initializing according to mode
+	DVBT_TRK_KS_P2,
+	DVBT_TRK_KS_I2,
+	DVBT_TR_THD_SET2,
+	DVBT_TRK_KC_P2,
+	DVBT_TRK_KC_I2,
+	DVBT_CR_THD_SET2,
+
+	// Registers for IF setting
+	DVBT_PSET_IFFREQ,
+	DVBT_SPEC_INV,
+
+
+	// Registers for bandwidth programming
+	DVBT_BW_INDEX,					// For RTL2830 only
+
+	DVBT_RSAMP_RATIO,				// For RTL2832 only
+	DVBT_CFREQ_OFF_RATIO,			// For RTL2832 only
+
+
+	// FSM stage register
+	DVBT_FSM_STAGE,
+
+	// TPS content registers
+	DVBT_RX_CONSTEL,
+	DVBT_RX_HIER,
+	DVBT_RX_C_RATE_LP,
+	DVBT_RX_C_RATE_HP,
+	DVBT_GI_IDX,
+	DVBT_FFT_MODE_IDX,
+	
+	// Performance measurement registers
+	DVBT_RSD_BER_EST,
+	DVBT_CE_EST_EVM,
+
+	// AGC registers
+	DVBT_RF_AGC_VAL,
+	DVBT_IF_AGC_VAL,
+	DVBT_DAGC_VAL,
+
+	// TR offset and CR offset registers
+	DVBT_SFREQ_OFF,
+	DVBT_CFREQ_OFF,
+
+
+	// AGC relative registers
+	DVBT_POLAR_RF_AGC,
+	DVBT_POLAR_IF_AGC,
+	DVBT_AAGC_HOLD,
+	DVBT_EN_RF_AGC,
+	DVBT_EN_IF_AGC,
+	DVBT_IF_AGC_MIN,
+	DVBT_IF_AGC_MAX,
+	DVBT_RF_AGC_MIN,
+	DVBT_RF_AGC_MAX,
+	DVBT_IF_AGC_MAN,
+	DVBT_IF_AGC_MAN_VAL,
+	DVBT_RF_AGC_MAN,
+	DVBT_RF_AGC_MAN_VAL,
+	DVBT_DAGC_TRG_VAL,
+
+	DVBT_AGC_TARG_VAL,				// For RTL2830 only
+	DVBT_LOOP_GAIN_3_0,				// For RTL2830 only
+	DVBT_LOOP_GAIN_4,				// For RTL2830 only
+	DVBT_VTOP,						// For RTL2830 only
+	DVBT_KRF,						// For RTL2830 only
+
+	DVBT_AGC_TARG_VAL_0,			// For RTL2832 only
+	DVBT_AGC_TARG_VAL_8_1,			// For RTL2832 only
+	DVBT_AAGC_LOOP_GAIN,			// For RTL2832 only
+	DVBT_LOOP_GAIN2_3_0,			// For RTL2832 only
+	DVBT_LOOP_GAIN2_4,				// For RTL2832 only
+	DVBT_LOOP_GAIN3,				// For RTL2832 only
+	DVBT_VTOP1,						// For RTL2832 only
+	DVBT_VTOP2,						// For RTL2832 only
+	DVBT_VTOP3,						// For RTL2832 only
+	DVBT_KRF1,						// For RTL2832 only
+	DVBT_KRF2,						// For RTL2832 only
+	DVBT_KRF3,						// For RTL2832 only
+	DVBT_KRF4,						// For RTL2832 only
+	DVBT_EN_GI_PGA,					// For RTL2832 only
+	DVBT_THD_LOCK_UP,				// For RTL2832 only
+	DVBT_THD_LOCK_DW,				// For RTL2832 only
+	DVBT_THD_UP1,					// For RTL2832 only
+	DVBT_THD_DW1,					// For RTL2832 only
+	DVBT_INTER_CNT_LEN,				// For RTL2832 only
+	DVBT_GI_PGA_STATE,				// For RTL2832 only
+	DVBT_EN_AGC_PGA,				// For RTL2832 only
+
+
+	// TS interface registers
+	DVBT_CKOUTPAR,
+	DVBT_CKOUT_PWR,
+	DVBT_SYNC_DUR,
+	DVBT_ERR_DUR,
+	DVBT_SYNC_LVL,
+	DVBT_ERR_LVL,
+	DVBT_VAL_LVL,
+	DVBT_SERIAL,
+	DVBT_SER_LSB,
+	DVBT_CDIV_PH0,
+	DVBT_CDIV_PH1,
+
+	DVBT_MPEG_IO_OPT_2_2,			// For RTL2832 only
+	DVBT_MPEG_IO_OPT_1_0,			// For RTL2832 only
+	DVBT_CKOUTPAR_PIP,				// For RTL2832 only
+	DVBT_CKOUT_PWR_PIP,				// For RTL2832 only
+	DVBT_SYNC_LVL_PIP,				// For RTL2832 only
+	DVBT_ERR_LVL_PIP,				// For RTL2832 only
+	DVBT_VAL_LVL_PIP,				// For RTL2832 only
+	DVBT_CKOUTPAR_PID,				// For RTL2832 only
+	DVBT_CKOUT_PWR_PID,				// For RTL2832 only
+	DVBT_SYNC_LVL_PID,				// For RTL2832 only
+	DVBT_ERR_LVL_PID,				// For RTL2832 only
+	DVBT_VAL_LVL_PID,				// For RTL2832 only
+
+
+	// FSM state-holding register
+	DVBT_SM_PASS,
+
+	// Registers for function 2 (for RTL2830 only)
+	DVBT_UPDATE_REG_2,
+
+	// Registers for function 3 (for RTL2830 only)
+	DVBT_BTHD_P3,
+	DVBT_BTHD_D3,
+
+	// Registers for function 4 (for RTL2830 only)
+	DVBT_FUNC4_REG0,
+	DVBT_FUNC4_REG1,
+	DVBT_FUNC4_REG2,
+	DVBT_FUNC4_REG3,
+	DVBT_FUNC4_REG4,
+	DVBT_FUNC4_REG5,
+	DVBT_FUNC4_REG6,
+	DVBT_FUNC4_REG7,
+	DVBT_FUNC4_REG8,
+	DVBT_FUNC4_REG9,
+	DVBT_FUNC4_REG10,
+
+	// Registers for functin 5 (for RTL2830 only)
+	DVBT_FUNC5_REG0,
+	DVBT_FUNC5_REG1,
+	DVBT_FUNC5_REG2,
+	DVBT_FUNC5_REG3,
+	DVBT_FUNC5_REG4,
+	DVBT_FUNC5_REG5,
+	DVBT_FUNC5_REG6,
+	DVBT_FUNC5_REG7,
+	DVBT_FUNC5_REG8,
+	DVBT_FUNC5_REG9,
+	DVBT_FUNC5_REG10,
+	DVBT_FUNC5_REG11,
+	DVBT_FUNC5_REG12,
+	DVBT_FUNC5_REG13,
+	DVBT_FUNC5_REG14,
+	DVBT_FUNC5_REG15,
+	DVBT_FUNC5_REG16,
+	DVBT_FUNC5_REG17,
+	DVBT_FUNC5_REG18,
+
+
+	// AD7 registers (for RTL2832 only)
+	DVBT_AD7_SETTING,
+	DVBT_RSSI_R,
+
+	// ACI detection registers (for RTL2832 only)
+	DVBT_ACI_DET_IND,
+
+	// Clock output registers (for RTL2832 only)
+	DVBT_REG_MON,
+	DVBT_REG_MONSEL,
+	DVBT_REG_GPE,
+	DVBT_REG_GPO,
+	DVBT_REG_4MSEL,
+
+
+	// Test registers for test only
+	DVBT_TEST_REG_1,
+	DVBT_TEST_REG_2,
+	DVBT_TEST_REG_3,
+	DVBT_TEST_REG_4,
+
+	// Item terminator
+	DVBT_REG_BIT_NAME_ITEM_TERMINATOR,
+};
+
+
+
+// Register table length definitions
+#define DVBT_REG_TABLE_LEN_MAX			DVBT_REG_BIT_NAME_ITEM_TERMINATOR
+
+
+
+
+
+// DVB-T demod module pre-definition
+typedef struct DVBT_DEMOD_MODULE_TAG DVBT_DEMOD_MODULE;
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register page setting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_SET_REG_PAGE() to set demod register page.
+
+
+@param [in]   pDemod   The demod module pointer
+@param [in]   PageNo   Page number
+
+
+@retval   FUNCTION_SUCCESS   Set register page successfully with page number.
+@retval   FUNCTION_ERROR     Set register page unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_REG_PAGE() with the corresponding function.
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register page with page number 2.
+	pDemod->SetRegPage(pDemod, 2);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_REG_PAGE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register byte setting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_SET_REG_BYTES() to set demod register bytes.
+
+
+@param [in]   pDemod          The demod module pointer
+@param [in]   RegStartAddr    Demod register start address
+@param [in]   pWritingBytes   Pointer to writing bytes
+@param [in]   ByteNum         Writing byte number
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bytes successfully with writing bytes.
+@retval   FUNCTION_ERROR     Set demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by DVBT_DEMOD_FP_SET_REG_PAGE() before using DVBT_DEMOD_FP_SET_REG_BYTES().
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_GET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char WritingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bytes (page 1, address 0x17 ~ 0x1b) with 5 writing bytes.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBytes(pDemod, 0x17, WritingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_REG_BYTES)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned char ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register byte getting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_GET_REG_BYTES() to get demod register bytes.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [out]   pReadingBytes   Pointer to an allocated memory for storing reading bytes
+@param [in]    ByteNum         Reading byte number
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bytes successfully with reading byte number.
+@retval   FUNCTION_ERROR     Get demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by DVBT_DEMOD_FP_SET_REG_PAGE() before using DVBT_DEMOD_FP_GET_REG_BYTES().
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_SET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char ReadingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bytes (page 1, address 0x17 ~ 0x1b) with reading byte number 5.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBytes(pDemod, 0x17, ReadingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_REG_BYTES)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register mask bits setting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_SET_REG_MASK_BITS() to set demod register mask bits.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegStartAddr   Demod register start address
+@param [in]   Msb            Mask MSB with 0-based index
+@param [in]   Lsb            Mask LSB with 0-based index
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register mask bits successfully with writing value.
+@retval   FUNCTION_ERROR     Set demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by DVBT_DEMOD_FP_SET_REG_PAGE() before using DVBT_DEMOD_FP_SET_REG_MASK_BITS().
+	-# The constraints of DVBT_DEMOD_FP_SET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_GET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits (page 1, address {0x18, 0x17} [12:5]) with writing value 0x1d.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegMaskBits(pDemod, 0x17, 12, 5, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x17          0x18
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_REG_MASK_BITS)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register mask bits getting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_GET_REG_MASK_BITS() to get demod register mask bits.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [in]    Msb             Mask MSB with 0-based index
+@param [in]    Lsb             Mask LSB with 0-based index
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register mask bits successfully.
+@retval   FUNCTION_ERROR     Get demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by DVBT_DEMOD_FP_SET_REG_PAGE() before using DVBT_DEMOD_FP_GET_REG_MASK_BITS().
+	-# The constraints of DVBT_DEMOD_FP_GET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_SET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits (page 1, address {0x18, 0x17} [12:5]).
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegMaskBits(pDemod, 0x17, 12, 5, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_REG_MASK_BITS)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register bits setting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_SET_REG_BITS() to set demod register bits with bit name.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using DVBT_DEMOD_FP_SET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_GET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBits(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_REG_BITS)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register bits getting function pointer
+
+Demod upper level functions will use DVBT_DEMOD_FP_GET_REG_BITS() to get demod register bits with bit name.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using DVBT_DEMOD_FP_GET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DVBT_DEMOD_FP_SET_REG_PAGE, DVBT_DEMOD_FP_SET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBits(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_REG_BITS)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register bits setting function pointer (with page setting)
+
+Demod upper level functions will use DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE() to set demod register bits with bit name and
+page setting.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name, page setting, and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod register bits getting function pointer (with page setting)
+
+Demod upper level functions will use DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE() to get demod register bits with bit name and
+page setting.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name and page setting.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->GetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod type getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_DEMOD_TYPE() to get DVB-T demod type.
+
+
+@param [in]    pDemod       The demod module pointer
+@param [out]   pDemodType   Pointer to an allocated memory for storing demod type
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_DEMOD_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*DVBT_DEMOD_FP_GET_DEMOD_TYPE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod I2C device address getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_DEVICE_ADDR() to get DVB-T demod I2C device address.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pDeviceAddr   Pointer to an allocated memory for storing demod I2C device address
+
+
+@retval   FUNCTION_SUCCESS   Get demod device address successfully.
+@retval   FUNCTION_ERROR     Get demod device address unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_DEVICE_ADDR() with the corresponding function.
+
+*/
+typedef void
+(*DVBT_DEMOD_FP_GET_DEVICE_ADDR)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod crystal frequency getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() to get DVB-T demod crystal frequency in Hz.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pCrystalFreqHz   Pointer to an allocated memory for storing demod crystal frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod crystal frequency successfully.
+@retval   FUNCTION_ERROR     Get demod crystal frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() with the corresponding function.
+
+*/
+typedef void
+(*DVBT_DEMOD_FP_GET_CRYSTAL_FREQ_HZ)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod I2C bus connection asking function pointer
+
+One can use DVBT_DEMOD_FP_IS_CONNECTED_TO_I2C() to ask DVB-T demod if it is connected to I2C bus.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_IS_CONNECTED_TO_I2C() with the corresponding function.
+
+*/
+typedef void
+(*DVBT_DEMOD_FP_IS_CONNECTED_TO_I2C)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod software resetting function pointer
+
+One can use DVBT_DEMOD_FP_SOFTWARE_RESET() to reset DVB-T demod by software reset.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod by software reset successfully.
+@retval   FUNCTION_ERROR     Reset demod by software reset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SOFTWARE_RESET() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SOFTWARE_RESET)(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod initializing function pointer
+
+One can use DVBT_DEMOD_FP_INITIALIZE() to initialie DVB-T demod.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize demod successfully.
+@retval   FUNCTION_ERROR     Initialize demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_INITIALIZE)(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod bandwidth mode setting function pointer
+
+One can use DVBT_DEMOD_FP_SET_DVBT_MODE() to set DVB-T demod bandwidth mode.
+
+
+@param [in]   pDemod	      The demod module pointer
+@param [in]   BandwidthMode   Bandwidth mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod bandwidth mode successfully.
+@retval   FUNCTION_ERROR     Set demod bandwidth mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_DVBT_MODE() with the corresponding function.
+
+
+@see   DVBT_BANDWIDTH_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_BANDWIDTH_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int BandwidthMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod IF frequency setting function pointer
+
+One can use DVBT_DEMOD_FP_SET_IF_FREQ_HZ() to set DVB-T demod IF frequency in Hz.
+
+
+@param [in]   pDemod     The demod module pointer
+@param [in]   IfFreqHz   IF frequency in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Set demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_IF_FREQ_HZ)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod spectrum mode setting function pointer
+
+One can use DVBT_DEMOD_FP_SET_SPECTRUM_MODE() to set DVB-T demod spectrum mode.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   SpectrumMode   Spectrum mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Set demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_SET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_SET_SPECTRUM_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod bandwidth mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_DVBT_MODE() to get DVB-T demod bandwidth mode.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pBandwidthMode   Pointer to an allocated memory for storing demod bandwidth mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod bandwidth mode successfully.
+@retval   FUNCTION_ERROR     Get demod bandwidth mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_DVBT_MODE() with the corresponding function.
+
+
+@see   DVBT_DVBT_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_BANDWIDTH_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod IF frequency getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_IF_FREQ_HZ() to get DVB-T demod IF frequency in Hz.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pIfFreqHz   Pointer to an allocated memory for storing demod IF frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Get demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_IF_FREQ_HZ)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod spectrum mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_SPECTRUM_MODE() to get DVB-T demod spectrum mode.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pSpectrumMode   Pointer to an allocated memory for storing demod spectrum mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Get demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_SPECTRUM_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod TPS lock asking function pointer
+
+One can use DVBT_DEMOD_FP_IS_TPS_LOCKED() to ask DVB-T demod if it is TPS-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform TPS lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform TPS lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_IS_TPS_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_IS_TPS_LOCKED)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod signal lock asking function pointer
+
+One can use DVBT_DEMOD_FP_IS_SIGNAL_LOCKED() to ask DVB-T demod if it is signal-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform signal lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_IS_SIGNAL_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_IS_SIGNAL_LOCKED)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod signal strength getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pDemod            The demod module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal strength successfully.
+@retval   FUNCTION_ERROR     Get demod signal strength unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_SIGNAL_STRENGTH)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod signal quality getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal quality successfully.
+@retval   FUNCTION_ERROR     Get demod signal quality unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_SIGNAL_QUALITY)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod BER getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_BER() to get BER.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pBerNum         Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen         Pointer to an allocated memory for storing BER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod error rate value successfully.
+@retval   FUNCTION_ERROR     Get demod error rate value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_BER() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_BER)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod SNR getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod SNR successfully.
+@retval   FUNCTION_ERROR     Get demod SNR unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_SNR_DB)(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod RF AGC getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_RF_AGC() to get DVB-T demod RF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pRfAgc   Pointer to an allocated memory for storing RF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod RF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod RF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_RF_AGC() with the corresponding function.
+	-# The range of RF AGC value is (-pow(2, 13)) ~ (pow(2, 13) - 1).
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_RF_AGC)(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod IF AGC getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_IF_AGC() to get DVB-T demod IF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pIfAgc   Pointer to an allocated memory for storing IF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod IF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_IF_AGC() with the corresponding function.
+	-# The range of IF AGC value is (-pow(2, 13)) ~ (pow(2, 13) - 1).
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_IF_AGC)(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod digital AGC getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_DI_AGC() to get DVB-T demod digital AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pDiAgc   Pointer to an allocated memory for storing digital AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod digital AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod digital AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_DI_AGC() with the corresponding function.
+	-# The range of digital AGC value is 0 ~ (pow(2, 8) - 1).
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_DI_AGC)(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDiAgc
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod TR offset getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pDemod         The demod module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get demod TR offset successfully.
+@retval   FUNCTION_ERROR     Get demod TR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_TR_OFFSET_PPM)(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod CR offset getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod CR offset successfully.
+@retval   FUNCTION_ERROR     Get demod CR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_CR_OFFSET_HZ)(
+	DVBT_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod constellation mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_CONSTELLATION() to get DVB-T demod constellation mode.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pConstellation   Pointer to an allocated memory for storing demod constellation mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod constellation mode successfully.
+@retval   FUNCTION_ERROR     Get demod constellation mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_CONSTELLATION() with the corresponding function.
+
+
+@see   DVBT_CONSTELLATION_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_CONSTELLATION)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pConstellation
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod hierarchy mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_HIERARCHY() to get DVB-T demod hierarchy mode.
+
+
+@param [in]    pDemod       The demod module pointer
+@param [out]   pHierarchy   Pointer to an allocated memory for storing demod hierarchy mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod hierarchy mode successfully.
+@retval   FUNCTION_ERROR     Get demod hierarchy mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_HIERARCHY() with the corresponding function.
+
+
+@see   DVBT_HIERARCHY_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_HIERARCHY)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pHierarchy
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod low-priority code rate mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_CODE_RATE_LP() to get DVB-T demod low-priority code rate mode.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pCodeRateLp   Pointer to an allocated memory for storing demod low-priority code rate mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod low-priority code rate mode successfully.
+@retval   FUNCTION_ERROR     Get demod low-priority code rate mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_CODE_RATE_LP() with the corresponding function.
+
+
+@see   DVBT_CODE_RATE_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_CODE_RATE_LP)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateLp
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod high-priority code rate mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_CODE_RATE_HP() to get DVB-T demod high-priority code rate mode.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pCodeRateHp   Pointer to an allocated memory for storing demod high-priority code rate mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod high-priority code rate mode successfully.
+@retval   FUNCTION_ERROR     Get demod high-priority code rate mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_CODE_RATE_HP() with the corresponding function.
+
+
+@see   DVBT_CODE_RATE_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_CODE_RATE_HP)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pCodeRateHp
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod guard interval mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_GUARD_INTERVAL() to get DVB-T demod guard interval mode.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pGuardInterval   Pointer to an allocated memory for storing demod guard interval mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod guard interval mode successfully.
+@retval   FUNCTION_ERROR     Get demod guard interval mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_GUARD_INTERVAL() with the corresponding function.
+
+
+@see   DVBT_GUARD_INTERVAL_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_GUARD_INTERVAL)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pGuardInterval
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod FFT mode getting function pointer
+
+One can use DVBT_DEMOD_FP_GET_FFT_MODE() to get DVB-T demod FFT mode.
+
+
+@param [in]    pDemod     The demod module pointer
+@param [out]   pFftMode   Pointer to an allocated memory for storing demod FFT mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod FFT mode successfully.
+@retval   FUNCTION_ERROR     Get demod FFT mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_GET_FFT_MODE() with the corresponding function.
+
+
+@see   DVBT_FFT_MODE_MODE
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_GET_FFT_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pFftMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod updating function pointer
+
+One can use DVBT_DEMOD_FP_UPDATE_FUNCTION() to update demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod setting successfully.
+@retval   FUNCTION_ERROR     Update demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_UPDATE_FUNCTION)(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T demod reseting function pointer
+
+One can use DVBT_DEMOD_FP_RESET_FUNCTION() to reset demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod setting successfully.
+@retval   FUNCTION_ERROR     Reset demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set DVBT_DEMOD_FP_RESET_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbtDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_DEMOD_FP_RESET_FUNCTION)(
+	DVBT_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/// RTL2830 extra module
+
+// Definitions for Function 4
+#define DVBT_FUNC4_REG_VALUE_NUM		5
+
+typedef struct RTL2830_EXTRA_MODULE_TAG RTL2830_EXTRA_MODULE;
+
+/*
+
+@brief   RTL2830 application mode getting function pointer
+
+One can use RTL2830_FP_GET_APP_MODE() to get RTL2830 application mode.
+
+
+@param [in]    pDemod     The demod module pointer
+@param [out]   pAppMode   Pointer to an allocated memory for storing demod application mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod application mode successfully.
+@retval   FUNCTION_ERROR     Get demod application mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set RTL2830_FP_GET_APP_MODE() with the corresponding function.
+
+
+@see   RTL2830_APPLICATION_MODE
+
+*/
+typedef void
+(*RTL2830_FP_GET_APP_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAppMode
+	);
+
+struct RTL2830_EXTRA_MODULE_TAG
+{
+	// RTL2830 variables
+	int AppMode;
+
+	// RTL2830 update procedure enabling status
+	int IsFunction2Enabled;
+	int IsFunction3Enabled;
+	int IsFunction4Enabled;
+	int IsFunction5Enabled;
+
+	// RTL2830 update procedure variables
+	unsigned char Func2Executing;
+	unsigned char Func3State;
+	unsigned char Func3Executing;
+	unsigned char Func4State;
+	unsigned long Func4DelayCnt;
+	unsigned long Func4DelayCntMax;
+	unsigned char Func4ParamSetting;
+	unsigned long Func4RegValue[DVBT_FUNC4_REG_VALUE_NUM];
+	unsigned char Func5State;
+	unsigned char Func5QamBak;
+	unsigned char Func5HierBak;
+	unsigned char Func5LpCrBak;
+	unsigned char Func5HpCrBak;
+	unsigned char Func5GiBak;
+	unsigned char Func5FftBak;
+
+	// RTL2830 extra function pointers
+	RTL2830_FP_GET_APP_MODE GetAppMode;
+};
+
+
+
+
+
+/// RTL2832 extra module
+typedef struct RTL2832_EXTRA_MODULE_TAG RTL2832_EXTRA_MODULE;
+
+/*
+
+@brief   RTL2832 application mode getting function pointer
+
+One can use RTL2832_FP_GET_APP_MODE() to get RTL2832 application mode.
+
+
+@param [in]    pDemod     The demod module pointer
+@param [out]   pAppMode   Pointer to an allocated memory for storing demod application mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod application mode successfully.
+@retval   FUNCTION_ERROR     Get demod application mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set RTL2832_FP_GET_APP_MODE() with the corresponding function.
+
+
+@see   RTL2832_APPLICATION_MODE
+
+*/
+typedef void
+(*RTL2832_FP_GET_APP_MODE)(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pAppMode
+	);
+
+struct RTL2832_EXTRA_MODULE_TAG
+{
+	// RTL2832 extra variables
+	int AppMode;
+
+	// RTL2832 update procedure enabling status
+	int IsFunc1Enabled;
+
+	// RTL2832 update Function 1 variables
+	int Func1State;
+
+	int Func1WaitTimeMax;
+	int Func1GettingTimeMax;
+	int Func1GettingNumEachTime;
+
+	int Func1WaitTime;
+	int Func1GettingTime;
+
+	unsigned long Func1RsdBerEstSumNormal;
+	unsigned long Func1RsdBerEstSumConfig1;
+	unsigned long Func1RsdBerEstSumConfig2;
+	unsigned long Func1RsdBerEstSumConfig3;
+
+	int Func1QamBak;
+	int Func1HierBak;
+	int Func1LpCrBak;
+	int Func1HpCrBak;
+	int Func1GiBak;
+	int Func1FftBak;
+
+	// RTL2832 extra function pointers
+	RTL2832_FP_GET_APP_MODE GetAppMode;
+};
+
+
+
+
+
+/// DVB-T demod module structure
+struct DVBT_DEMOD_MODULE_TAG
+{
+	unsigned long CurrentPageNo;
+	// Private variables
+	int           DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+	int           TsInterfaceMode;
+
+	int           BandwidthMode;
+	unsigned long IfFreqHz;
+	int           SpectrumMode;
+
+	int IsBandwidthModeSet;
+	int IsIfFreqHzSet;
+	int IsSpectrumModeSet;
+
+	union											///<   Demod extra module used by driving module
+	{
+		RTL2830_EXTRA_MODULE Rtl2830;
+		RTL2832_EXTRA_MODULE Rtl2832;
+	}
+	Extra;
+
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+	// Demod register table
+	DVBT_REG_ENTRY RegTable[DVBT_REG_TABLE_LEN_MAX];
+
+
+	// Demod I2C function pointers
+	DVBT_DEMOD_FP_SET_REG_PAGE             SetRegPage;
+	DVBT_DEMOD_FP_SET_REG_BYTES            SetRegBytes;
+	DVBT_DEMOD_FP_GET_REG_BYTES            GetRegBytes;
+	DVBT_DEMOD_FP_SET_REG_MASK_BITS        SetRegMaskBits;
+	DVBT_DEMOD_FP_GET_REG_MASK_BITS        GetRegMaskBits;
+	DVBT_DEMOD_FP_SET_REG_BITS             SetRegBits;
+	DVBT_DEMOD_FP_GET_REG_BITS             GetRegBits;
+	DVBT_DEMOD_FP_SET_REG_BITS_WITH_PAGE   SetRegBitsWithPage;
+	DVBT_DEMOD_FP_GET_REG_BITS_WITH_PAGE   GetRegBitsWithPage;
+
+
+	// Demod manipulating function pointers
+	DVBT_DEMOD_FP_GET_DEMOD_TYPE        GetDemodType;
+	DVBT_DEMOD_FP_GET_DEVICE_ADDR       GetDeviceAddr;
+	DVBT_DEMOD_FP_GET_CRYSTAL_FREQ_HZ   GetCrystalFreqHz;
+
+	DVBT_DEMOD_FP_IS_CONNECTED_TO_I2C   IsConnectedToI2c;
+
+	DVBT_DEMOD_FP_SOFTWARE_RESET        SoftwareReset;
+
+	DVBT_DEMOD_FP_INITIALIZE            Initialize;
+	DVBT_DEMOD_FP_SET_BANDWIDTH_MODE    SetBandwidthMode;
+	DVBT_DEMOD_FP_SET_IF_FREQ_HZ        SetIfFreqHz;
+	DVBT_DEMOD_FP_SET_SPECTRUM_MODE     SetSpectrumMode;
+	DVBT_DEMOD_FP_GET_BANDWIDTH_MODE    GetBandwidthMode;
+	DVBT_DEMOD_FP_GET_IF_FREQ_HZ        GetIfFreqHz;
+	DVBT_DEMOD_FP_GET_SPECTRUM_MODE     GetSpectrumMode;
+
+	DVBT_DEMOD_FP_IS_TPS_LOCKED         IsTpsLocked;
+	DVBT_DEMOD_FP_IS_SIGNAL_LOCKED      IsSignalLocked;
+
+	DVBT_DEMOD_FP_GET_SIGNAL_STRENGTH   GetSignalStrength;
+	DVBT_DEMOD_FP_GET_SIGNAL_QUALITY    GetSignalQuality;
+
+	DVBT_DEMOD_FP_GET_BER               GetBer;
+	DVBT_DEMOD_FP_GET_SNR_DB            GetSnrDb;
+
+	DVBT_DEMOD_FP_GET_RF_AGC            GetRfAgc;
+	DVBT_DEMOD_FP_GET_IF_AGC            GetIfAgc;
+	DVBT_DEMOD_FP_GET_DI_AGC            GetDiAgc;
+
+	DVBT_DEMOD_FP_GET_TR_OFFSET_PPM     GetTrOffsetPpm;
+	DVBT_DEMOD_FP_GET_CR_OFFSET_HZ      GetCrOffsetHz;
+
+	DVBT_DEMOD_FP_GET_CONSTELLATION     GetConstellation;
+	DVBT_DEMOD_FP_GET_HIERARCHY         GetHierarchy;
+	DVBT_DEMOD_FP_GET_CODE_RATE_LP      GetCodeRateLp;
+	DVBT_DEMOD_FP_GET_CODE_RATE_HP      GetCodeRateHp;
+	DVBT_DEMOD_FP_GET_GUARD_INTERVAL    GetGuardInterval;
+	DVBT_DEMOD_FP_GET_FFT_MODE          GetFftMode;
+
+	DVBT_DEMOD_FP_UPDATE_FUNCTION       UpdateFunction;
+	DVBT_DEMOD_FP_RESET_FUNCTION        ResetFunction;
+};
+
+
+
+
+
+
+
+// DVB-T demod default I2C functions
+int
+dvbt_demod_default_SetRegPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+int
+dvbt_demod_default_SetRegBytes(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned char ByteNum
+	);
+
+int
+dvbt_demod_default_GetRegBytes(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	);
+
+int
+dvbt_demod_default_SetRegMaskBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+int
+dvbt_demod_default_GetRegMaskBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+int
+dvbt_demod_default_SetRegBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+dvbt_demod_default_GetRegBits(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+int
+dvbt_demod_default_SetRegBitsWithPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+dvbt_demod_default_GetRegBitsWithPage(
+	DVBT_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// DVB-T demod default manipulating functions
+void
+dvbt_demod_default_GetDemodType(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+void
+dvbt_demod_default_GetDeviceAddr(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+void
+dvbt_demod_default_GetCrystalFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+int
+dvbt_demod_default_GetBandwidthMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pBandwidthMode
+	);
+
+int
+dvbt_demod_default_GetIfFreqHz(
+	DVBT_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+int
+dvbt_demod_default_GetSpectrumMode(
+	DVBT_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/dvbt_nim_base.c b/drivers/media/usb/rtl2832u/dvbt_nim_base.c
new file mode 100644
index 00000000..76a5e94c
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dvbt_nim_base.c
@@ -0,0 +1,531 @@
+/**
+
+@file
+
+@brief   DVB-T NIM base module definition
+
+DVB-T NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+*/
+
+
+#include "dvbt_nim_base.h"
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_NIM_TYPE
+
+*/
+void
+dvbt_nim_default_GetNimType(
+	DVBT_NIM_MODULE *pNim,
+	int *pNimType
+	)
+{
+	// Get NIM type from NIM module.
+	*pNimType = pNim->NimType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+dvbt_nim_default_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_PARAMETERS
+
+*/
+int
+dvbt_nim_default_GetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pBandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Get tuner RF frequency in Hz.
+	if(pTuner->GetRfFreqHz(pTuner, pRfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get demod bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, pBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_IS_SIGNAL_PRESENT
+
+*/
+int
+dvbt_nim_default_IsSignalPresent(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	DVBT_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait for signal present check.
+	for(i = 0; i < DVBT_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX_DEFAULT; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check TPS present status on demod.
+		// Note: If TPS is locked, stop signal present check.
+		if(pDemod->IsTpsLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_IS_SIGNAL_LOCKED
+
+*/
+int
+dvbt_nim_default_IsSignalLocked(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	DVBT_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait for signal lock check.
+	for(i = 0; i < DVBT_NIM_SINGAL_LOCK_CHECK_TIMES_MAX_DEFAULT; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check signal lock status on demod.
+		// Note: If signal is locked, stop signal lock check.
+		if(pDemod->IsSignalLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+dvbt_nim_default_GetSignalStrength(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal strength from demod.
+	if(pDemod->GetSignalStrength(pDemod, pSignalStrength) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+dvbt_nim_default_GetSignalQuality(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal quality from demod.
+	if(pDemod->GetSignalQuality(pDemod, pSignalQuality) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_BER
+
+*/
+int
+dvbt_nim_default_GetBer(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get BER from demod.
+	if(pDemod->GetBer(pDemod, pBerNum, pBerDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_SNR_DB
+
+*/
+int
+dvbt_nim_default_GetSnrDb(
+	DVBT_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get SNR in dB from demod.
+	if(pDemod->GetSnrDb(pDemod, pSnrDbNum, pSnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+dvbt_nim_default_GetTrOffsetPpm(
+	DVBT_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get TR offset in ppm from demod.
+	if(pDemod->GetTrOffsetPpm(pDemod, pTrOffsetPpm) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+dvbt_nim_default_GetCrOffsetHz(
+	DVBT_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get CR offset in Hz from demod.
+	if(pDemod->GetCrOffsetHz(pDemod, pCrOffsetHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_TPS_INFO
+
+*/
+int
+dvbt_nim_default_GetTpsInfo(
+	DVBT_NIM_MODULE *pNim,
+	int *pConstellation,
+	int *pHierarchy,
+	int *pCodeRateLp,
+	int *pCodeRateHp,
+	int *pGuardInterval,
+	int *pFftMode
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get TPS constellation information from demod.
+	if(pDemod->GetConstellation(pDemod, pConstellation) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get TPS hierarchy information from demod.
+	if(pDemod->GetHierarchy(pDemod, pHierarchy) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get TPS low-priority code rate information from demod.
+	if(pDemod->GetCodeRateLp(pDemod, pCodeRateLp) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get TPS high-priority code rate information from demod.
+	if(pDemod->GetCodeRateHp(pDemod, pCodeRateHp) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get TPS guard interval information from demod.
+	if(pDemod->GetGuardInterval(pDemod, pGuardInterval) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get TPS FFT mode information from demod.
+	if(pDemod->GetFftMode(pDemod, pFftMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+dvbt_nim_default_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/dvbt_nim_base.h b/drivers/media/usb/rtl2832u/dvbt_nim_base.h
new file mode 100644
index 00000000..08422540
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/dvbt_nim_base.h
@@ -0,0 +1,934 @@
+#ifndef __DVBT_NIM_BASE_H
+#define __DVBT_NIM_BASE_H
+
+/**
+
+@file
+
+@brief   DVB-T NIM base module definition
+
+DVB-T NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+	unsigned long RfFreqHz;
+	int BandwidthMode;
+
+	int Answer;
+	unsigned long SignalStrength, SignalQuality;
+	unsigned long BerNum, BerDen, PerNum, PerDen;
+	double Ber, Per;
+	unsigned long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	long TrOffsetPpm, CrOffsetHz;
+
+	int Constellation;
+	int Hierarchy;
+	int CodeRateLp;
+	int CodeRateHp;
+	int GuardInterval;
+	int FftMode;
+
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		&DemodxExtraModuleMemory,		// Employ Demod-X extra module.
+		0x20,							// The Demod-X I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The Demod-X crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The Demod-X TS interface mode is serial.
+		...								// Other arguments for Demod-X
+
+		&TunerxExtraModuleMemory,		// Employ Tuner-Y extra module.
+		0xc0,							// The Tuner-Y I2C device address is 0xc0 in 8-bit format.
+		...								// Other arguments for Tuner-Y
+		);
+
+
+
+	// Get NIM type.
+	// Note: NIM types are defined in the MODULE_TYPE enumeration.
+	pNim->GetNimType(pNim, &NimType);
+
+
+
+
+
+
+
+	// ==== Initialize NIM and set its parameters =====
+
+	// Initialize NIM.
+	pNim->Initialize(pNim);
+
+	// Set NIM parameters. (RF frequency, bandwdith mode)
+	// Note: In the example:
+	//       1. RF frequency is 666 MHz.
+	//       2. Bandwidth mode is 8 MHz.
+	RfFreqHz      = 666000000;
+	BandwidthMode = DVBT_BANDWIDTH_8MHZ;
+	pNim->SetParameters(pNim, RfFreqHz, BandwidthMode);
+
+
+
+	// Wait 1 second for demod convergence.
+
+
+
+
+
+	// ==== Get NIM information =====
+
+	// Get NIM parameters. (RF frequency, bandwdith mode)
+	pNim->GetParameters(pNim, &RfFreqHz, &BandwidthMode);
+
+
+	// Get signal present status.
+	// Note: 1. The argument Answer is YES when the NIM module has found DVB-T signal in the RF channel.
+	//       2. The argument Answer is NO when the NIM module does not find DVB-T signal in the RF channel.
+	// Recommendation: Use the IsSignalPresent() function for channel scan.
+	pNim->IsSignalPresent(pNim, &Answer);
+
+	// Get signal lock status.
+	// Note: 1. The argument Answer is YES when the NIM module has locked DVB-T signal in the RF channel.
+	//          At the same time, the NIM module sends TS packets through TS interface hardware pins.
+	//       2. The argument Answer is NO when the NIM module does not lock DVB-T signal in the RF channel.
+	// Recommendation: Use the IsSignalLocked() function for signal lock check.
+	pNim->IsSignalLocked(pNim, &Answer);
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pNim->GetSignalStrength(pNim, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pNim->GetSignalQuality(pNim, &SignalQuality);
+
+
+	// Get BER.
+	pNim->GetBer(pNim, &BerNum, &BerDen);
+	Ber = (double)BerNum / (double)BerDen;
+
+	// Get SNR in dB.
+	pNim->GetSnrDb(pNim, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pNim->GetTrOffsetPpm(pNim, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pNim->GetCrOffsetHz(pNim, &CrOffsetHz);
+
+
+	// Get TPS information.
+	// Note: One can find TPS information definitions in the enumerations as follows:
+	//       1. DVBT_CONSTELLATION_MODE.
+	//       2. DVBT_HIERARCHY_MODE.
+	//       3. DVBT_CODE_RATE_MODE. (for low-priority and high-priority code rate)
+	//       4. DVBT_GUARD_INTERVAL_MODE.
+	//       5. DVBT_FFT_MODE_MODE
+	pNim->GetTpsInfo(pNim, &Constellation, &Hierarchy, &CodeRateLp, &CodeRateHp, &GuardInterval, &FftMode);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+#include "tuner_base.h"
+#include "dvbt_demod_base.h"
+
+
+
+
+
+// Definitions
+#define DVBT_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX_DEFAULT			1
+#define DVBT_NIM_SINGAL_LOCK_CHECK_TIMES_MAX_DEFAULT			1
+
+
+
+
+
+/// DVB-T NIM module pre-definition
+typedef struct DVBT_NIM_MODULE_TAG DVBT_NIM_MODULE;
+
+
+
+
+
+/**
+
+@brief   DVB-T demod type getting function pointer
+
+One can use DVBT_NIM_FP_GET_NIM_TYPE() to get DVB-T NIM type.
+
+
+@param [in]    pNim       The NIM module pointer
+@param [out]   pNimType   Pointer to an allocated memory for storing NIM type
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_NIM_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*DVBT_NIM_FP_GET_NIM_TYPE)(
+	DVBT_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM initializing function pointer
+
+One can use DVBT_NIM_FP_INITIALIZE() to initialie DVB-T NIM.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize NIM successfully.
+@retval   FUNCTION_ERROR     Initialize NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_INITIALIZE)(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM parameter setting function pointer
+
+One can use DVBT_NIM_FP_SET_PARAMETERS() to set DVB-T NIM parameters.
+
+
+@param [in]   pNim            The NIM module pointer
+@param [in]   RfFreqHz        RF frequency in Hz for setting
+@param [in]   BandwidthMode   Bandwidth mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set NIM parameters successfully.
+@retval   FUNCTION_ERROR     Set NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_SET_PARAMETERS() with the corresponding function.
+
+
+@see   DVBT_BANDWIDTH_MODE
+
+*/
+typedef int
+(*DVBT_NIM_FP_SET_PARAMETERS)(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM parameter getting function pointer
+
+One can use DVBT_NIM_FP_GET_PARAMETERS() to get DVB-T NIM parameters.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pRfFreqHz        Pointer to an allocated memory for storing NIM RF frequency in Hz
+@param [out]   pBandwidthMode   Pointer to an allocated memory for storing NIM bandwidth mode
+
+
+@retval   FUNCTION_SUCCESS   Get NIM parameters successfully.
+@retval   FUNCTION_ERROR     Get NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_PARAMETERS() with the corresponding function.
+
+
+@see   DVBT_BANDWIDTH_MODE
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_PARAMETERS)(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM signal present asking function pointer
+
+One can use DVBT_NIM_FP_IS_SIGNAL_PRESENT() to ask DVB-T NIM if signal is present.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal present asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal present asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_IS_SIGNAL_PRESENT() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_IS_SIGNAL_PRESENT)(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM signal lock asking function pointer
+
+One can use DVBT_NIM_FP_IS_SIGNAL_LOCKED() to ask DVB-T NIM if signal is locked.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal lock asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal lock asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_IS_SIGNAL_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_IS_SIGNAL_LOCKED)(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM signal strength getting function pointer
+
+One can use DVBT_NIM_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pNim              The NIM module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal strength successfully.
+@retval   FUNCTION_ERROR     Get NIM signal strength unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_SIGNAL_STRENGTH)(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM signal quality getting function pointer
+
+One can use DVBT_NIM_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal quality successfully.
+@retval   FUNCTION_ERROR     Get NIM signal quality unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_SIGNAL_QUALITY)(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM BER value getting function pointer
+
+One can use DVBT_NIM_FP_GET_BER() to get BER.
+
+
+@param [in]    pNim            The NIM module pointer
+@param [out]   pBerNum         Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen         Pointer to an allocated memory for storing BER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM BER value successfully.
+@retval   FUNCTION_ERROR     Get NIM BER value unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_BER() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_BER)(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM SNR getting function pointer
+
+One can use DVBT_NIM_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pNim        The NIM module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM SNR successfully.
+@retval   FUNCTION_ERROR     Get NIM SNR unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_SNR_DB)(
+	DVBT_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM TR offset getting function pointer
+
+One can use DVBT_NIM_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pNim           The NIM module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get NIM TR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM TR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_TR_OFFSET_PPM)(
+	DVBT_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM CR offset getting function pointer
+
+One can use DVBT_NIM_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pNim          The NIM module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get NIM CR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM CR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_CR_OFFSET_HZ)(
+	DVBT_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM TPS information getting function pointer
+
+One can use DVBT_NIM_FP_GET_TPS_INFO() to get TPS information.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pConstellation   Pointer to an allocated memory for storing demod constellation mode
+@param [out]   pHierarchy       Pointer to an allocated memory for storing demod hierarchy mode
+@param [out]   pCodeRateLp      Pointer to an allocated memory for storing demod low-priority code rate mode
+@param [out]   pCodeRateHp      Pointer to an allocated memory for storing demod high-priority code rate mode
+@param [out]   pGuardInterval   Pointer to an allocated memory for storing demod guard interval mode
+@param [out]   pFftMode         Pointer to an allocated memory for storing demod FFT mode
+
+
+@retval   FUNCTION_SUCCESS   Get NIM TPS information successfully.
+@retval   FUNCTION_ERROR     Get NIM TPS information unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_GET_TPS_INFO() with the corresponding function.
+
+
+@see   DVBT_CONSTELLATION_MODE, DVBT_HIERARCHY_MODE, DVBT_CODE_RATE_MODE, DVBT_GUARD_INTERVAL_MODE, DVBT_FFT_MODE_MODE
+
+*/
+typedef int
+(*DVBT_NIM_FP_GET_TPS_INFO)(
+	DVBT_NIM_MODULE *pNim,
+	int *pConstellation,
+	int *pHierarchy,
+	int *pCodeRateLp,
+	int *pCodeRateHp,
+	int *pGuardInterval,
+	int *pFftMode
+	);
+
+
+
+
+
+/**
+
+@brief   DVB-T NIM updating function pointer
+
+One can use DVBT_NIM_FP_UPDATE_FUNCTION() to update NIM register setting.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update NIM setting successfully.
+@retval   FUNCTION_ERROR     Update NIM setting unsuccessfully.
+
+
+@note
+	-# NIM building function will set DVBT_NIM_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		...
+		);
+
+	...
+
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pNim->UpdateFunction(pNim);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*DVBT_NIM_FP_UPDATE_FUNCTION)(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+// RTL2832 MT2266 extra module
+typedef struct RTL2832_MT2266_EXTRA_MODULE_TAG RTL2832_MT2266_EXTRA_MODULE;
+struct RTL2832_MT2266_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned char LnaConfig;
+	unsigned char UhfSens;
+	unsigned char AgcCurrentState;
+	unsigned long LnaGainOld;
+};
+
+
+
+
+
+// RTL2832 E4000 extra module
+typedef struct RTL2832_E4000_EXTRA_MODULE_TAG RTL2832_E4000_EXTRA_MODULE;
+struct RTL2832_E4000_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long TunerModeUpdateWaitTimeMax;
+	unsigned long TunerModeUpdateWaitTime;
+	unsigned char TunerGainMode;
+};
+
+
+
+
+
+// RTL2832 MT2063 extra module
+typedef struct RTL2832_MT2063_EXTRA_MODULE_TAG RTL2832_MT2063_EXTRA_MODULE;
+struct RTL2832_MT2063_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long IfFreqHz;
+};
+
+
+
+
+
+// RTL2832 FC0012 extra module
+typedef struct RTL2832_FC0012_EXTRA_MODULE_TAG RTL2832_FC0012_EXTRA_MODULE;
+struct RTL2832_FC0012_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long LnaUpdateWaitTimeMax;
+	unsigned long LnaUpdateWaitTime;
+	unsigned long RssiRCalOn;
+};
+
+
+
+
+
+// RTL2832 FC0013 extra module
+typedef struct RTL2832_FC0013_EXTRA_MODULE_TAG RTL2832_FC0013_EXTRA_MODULE;
+struct RTL2832_FC0013_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long LnaUpdateWaitTimeMax;
+	unsigned long LnaUpdateWaitTime;
+	unsigned long RssiRCalOn;
+};
+
+
+
+
+
+/// DVB-T NIM module structure
+struct DVBT_NIM_MODULE_TAG
+{
+	// Private variables
+	int NimType;
+
+	union														///<   NIM extra module used by driving module
+	{
+		RTL2832_MT2266_EXTRA_MODULE Rtl2832Mt2266;
+		RTL2832_E4000_EXTRA_MODULE  Rtl2832E4000;
+		RTL2832_MT2063_EXTRA_MODULE Rtl2832Mt2063;
+		RTL2832_FC0012_EXTRA_MODULE Rtl2832Fc0012;
+		RTL2832_FC0013_EXTRA_MODULE Rtl2832Fc0013;
+	}
+	Extra;
+
+
+	// Modules
+	BASE_INTERFACE_MODULE *pBaseInterface;						///<   Base interface module pointer
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;			///<   Base interface module memory
+
+	I2C_BRIDGE_MODULE *pI2cBridge;								///<   I2C bridge module pointer
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;					///<   I2C bridge module memory
+
+	TUNER_MODULE *pTuner;										///<   Tuner module pointer
+	TUNER_MODULE TunerModuleMemory;								///<   Tuner module memory
+
+	DVBT_DEMOD_MODULE *pDemod;									///<   DVB-T demod module pointer
+	DVBT_DEMOD_MODULE DvbtDemodModuleMemory;					///<   DVB-T demod module memory
+
+
+	// NIM manipulating functions
+	DVBT_NIM_FP_GET_NIM_TYPE          GetNimType;
+	DVBT_NIM_FP_INITIALIZE            Initialize;
+	DVBT_NIM_FP_SET_PARAMETERS        SetParameters;
+	DVBT_NIM_FP_GET_PARAMETERS        GetParameters;
+	DVBT_NIM_FP_IS_SIGNAL_PRESENT     IsSignalPresent;
+	DVBT_NIM_FP_IS_SIGNAL_LOCKED      IsSignalLocked;
+	DVBT_NIM_FP_GET_SIGNAL_STRENGTH   GetSignalStrength;
+	DVBT_NIM_FP_GET_SIGNAL_QUALITY    GetSignalQuality;
+	DVBT_NIM_FP_GET_BER               GetBer;
+	DVBT_NIM_FP_GET_SNR_DB            GetSnrDb;
+	DVBT_NIM_FP_GET_TR_OFFSET_PPM     GetTrOffsetPpm;
+	DVBT_NIM_FP_GET_CR_OFFSET_HZ      GetCrOffsetHz;
+	DVBT_NIM_FP_GET_TPS_INFO          GetTpsInfo;
+	DVBT_NIM_FP_UPDATE_FUNCTION       UpdateFunction;
+};
+
+
+
+
+
+
+
+// DVB-T NIM default manipulaing functions
+void
+dvbt_nim_default_GetNimType(
+	DVBT_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+int
+dvbt_nim_default_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+dvbt_nim_default_GetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pBandwidthMode
+	);
+
+int
+dvbt_nim_default_IsSignalPresent(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+dvbt_nim_default_IsSignalLocked(
+	DVBT_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+dvbt_nim_default_GetSignalStrength(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+int
+dvbt_nim_default_GetSignalQuality(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+int
+dvbt_nim_default_GetBer(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen
+	);
+
+int
+dvbt_nim_default_GetSnrDb(
+	DVBT_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+dvbt_nim_default_GetTrOffsetPpm(
+	DVBT_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+int
+dvbt_nim_default_GetCrOffsetHz(
+	DVBT_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+int
+dvbt_nim_default_GetTpsInfo(
+	DVBT_NIM_MODULE *pNim,
+	int *pConstellation,
+	int *pHierarchy,
+	int *pCodeRateLp,
+	int *pCodeRateHp,
+	int *pGuardInterval,
+	int *pFftMode
+	);
+
+int
+dvbt_nim_default_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/foundation.c b/drivers/media/usb/rtl2832u/foundation.c
new file mode 100644
index 00000000..c5e8e524
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/foundation.c
@@ -0,0 +1,352 @@
+/**
+
+@file
+
+@brief   Fundamental interface definition
+
+Fundamental interface contains base function pointers and some mathematics tools.
+
+*/
+
+
+#include "foundation.h"
+
+
+
+
+
+// Base interface builder
+void
+BuildBaseInterface(
+	BASE_INTERFACE_MODULE **ppBaseInterface,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	unsigned long I2cReadingByteNumMax,
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs
+	)
+{
+	// Set base interface module pointer.
+	*ppBaseInterface = pBaseInterfaceModuleMemory;
+
+
+	// Set all base interface function pointers and arguments.
+	(*ppBaseInterface)->I2cReadingByteNumMax      = I2cReadingByteNumMax;
+	(*ppBaseInterface)->I2cWritingByteNumMax      = I2cWritingByteNumMax;
+	(*ppBaseInterface)->I2cRead                   = I2cRead;
+	(*ppBaseInterface)->I2cWrite                  = I2cWrite;
+	(*ppBaseInterface)->WaitMs                    = WaitMs;
+	(*ppBaseInterface)->SetUserDefinedDataPointer = base_interface_SetUserDefinedDataPointer;
+	(*ppBaseInterface)->GetUserDefinedDataPointer = base_interface_GetUserDefinedDataPointer;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set user defined data pointer of base interface structure for custom basic function implementation.
+
+@note
+	-# Base interface builder will set BASE_FP_SET_USER_DEFINED_DATA_POINTER() function pointer with
+	   base_interface_SetUserDefinedDataPointer().
+
+@see   BASE_FP_SET_USER_DEFINED_DATA_POINTER
+
+*/
+void
+base_interface_SetUserDefinedDataPointer(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void *pUserDefinedData
+	)
+{
+	// Set user defined data pointer of base interface structure with user defined data pointer argument.
+	pBaseInterface->pUserDefinedData = pUserDefinedData;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Get user defined data pointer of base interface structure for custom basic function implementation.
+
+@note
+	-# Base interface builder will set BASE_FP_GET_USER_DEFINED_DATA_POINTER() function pointer with
+	   base_interface_GetUserDefinedDataPointer().
+
+@see   BASE_FP_GET_USER_DEFINED_DATA_POINTER
+
+*/
+void
+base_interface_GetUserDefinedDataPointer(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void **ppUserDefinedData
+	)
+{
+	// Get user defined data pointer from base interface structure to the caller user defined data pointer.
+	*ppUserDefinedData = pBaseInterface->pUserDefinedData;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Convert signed integer to binary.
+
+Convert 2's complement signed integer to binary with bit number.
+
+
+@param [in]   Value    the converting value in 2's complement format
+@param [in]   BitNum   the bit number of the converting value
+
+
+@return   Converted binary
+
+
+@note
+	The converting value must be -pow(2, BitNum - 1) ~ (pow(2, BitNum - 1) -1).
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+int main(void)
+{
+	long Value = -345;
+	unsigned long Binary;
+
+
+	// Convert 2's complement integer to binary with 10 bit number.
+	Binary = SignedIntToBin(Value, 10);
+
+
+	// Result in base 2:
+	// Value  = 1111 1111 1111 1111 1111 1110 1010 0111 b = -345  (in 32-bit 2's complement format)
+	// Binary = 0000 0000 0000 0000 0000 0010 1010 0111 b =  679  (in 10-bit binary format)
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+unsigned long
+SignedIntToBin(
+	long Value,
+	unsigned char BitNum
+	)
+{
+	unsigned int i;
+	unsigned long Mask, Binary;
+
+
+
+	// Generate Mask according to BitNum.
+	Mask = 0;
+	for(i = 0; i < BitNum; i++)
+		Mask |= 0x1 << i;
+
+
+	// Convert signed integer to binary with Mask.
+	Binary = Value & Mask;
+
+
+	return Binary;
+}
+
+
+
+
+
+/**
+
+@brief   Convert binary to signed integer.
+
+Convert binary to 2's complement signed integer with bit number.
+
+
+@param [in]   Binary   the converting binary
+@param [in]   BitNum   the bit number of the converting binary
+
+
+@return   Converted 2's complement signed integer
+
+
+@note
+	The converting binary must be 0 ~ (pow(2, BitNum) - 1).
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+int main(void)
+{
+	unsigned long Binary = 679;
+	long Value;
+
+
+	// Convert binary to 2's complement integer with 10 bit number.
+	Value = BinToSignedInt(Binary, 10);
+
+
+	// Result in base 2:
+	// Binary = 0000 0000 0000 0000 0000 0010 1010 0111 b =  679  (in 10-bit binary format)
+	// Value  = 1111 1111 1111 1111 1111 1110 1010 0111 b = -345  (in 32-bit 2's complement format)
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+long
+BinToSignedInt(
+	unsigned long Binary,
+	unsigned char BitNum
+	)
+{
+	int i;
+
+	unsigned char SignedBit;
+	unsigned long SignedBitExtension;
+
+	long Value;
+
+
+
+	// Get signed bit.
+	SignedBit = (unsigned char)((Binary >> (BitNum - 1)) & BIT_0_MASK);
+
+
+	// Generate signed bit extension.
+	SignedBitExtension = 0;
+
+	for(i = BitNum; i < LONG_BIT_NUM; i++)
+		SignedBitExtension |= SignedBit << i;
+
+
+	// Combine binary value and signed bit extension to signed integer value.
+	Value = (long)(Binary | SignedBitExtension);
+
+
+	return Value;
+}
+
+
+
+
+
+/**
+
+@brief   Get devision reult with ceiling.
+
+Get unsigned devision reult with ceiling.
+
+
+@param [in]   Dividend   the dividend
+@param [in]   Divisor    the divisor
+
+
+@return   Result with ceiling
+
+
+@note
+	The dividend and divisor must be unsigned integer.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+int main(void)
+{
+	long Value;
+
+
+	// Get ceil(100 / 20) reult.
+	Value = DivideWithCeiling(100, 20);
+
+	// Result: Value  = 5
+
+
+	// Get ceil(100 / 30) reult.
+	Value = DivideWithCeiling(100, 30);
+
+	// Result: Value  = 4
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+unsigned long
+DivideWithCeiling(
+	unsigned long Dividend,
+	unsigned long Divisor
+	)
+{
+	unsigned long Result;
+
+
+	// Get primitive division result.
+	Result = Dividend / Divisor;
+
+	// Adjust primitive result with ceiling.
+	if(Dividend % Divisor > 0)
+		Result += 1;
+
+
+	return Result;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/foundation.h b/drivers/media/usb/rtl2832u/foundation.h
new file mode 100644
index 00000000..a24d78e1
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/foundation.h
@@ -0,0 +1,1001 @@
+#ifndef __FOUNDATION_H
+#define __FOUNDATION_H
+
+/**
+
+@file
+
+@brief   Fundamental interface declaration
+
+Fundamental interface contains base function pointers and some mathematics tools.
+
+*/
+
+
+#include "i2c_bridge.h"
+#include "math_mpi.h"
+
+
+#include "dvb-usb.h"
+#include "rtl2832u_io.h"
+
+
+
+// Definitions
+
+// API version
+#define REALTEK_NIM_API_VERSION		"Realtek NIM API 2011.06.01"
+
+
+
+// Constants
+#define INVALID_POINTER_VALUE		0
+#define NO_USE						0
+
+#define LEN_1_BYTE					1
+#define LEN_2_BYTE					2
+#define LEN_3_BYTE					3
+#define LEN_4_BYTE					4
+#define LEN_5_BYTE					5
+#define LEN_6_BYTE					6
+#define LEN_11_BYTE					11
+
+#define LEN_1_BIT					1
+
+#define BYTE_MASK					0xff
+#define BYTE_SHIFT					8
+#define HEX_DIGIT_MASK				0xf
+#define BYTE_BIT_NUM				8
+#define LONG_BIT_NUM				32
+
+#define BIT_0_MASK					0x1
+#define BIT_1_MASK					0x2
+#define BIT_2_MASK					0x4
+#define BIT_3_MASK					0x8
+
+#define BIT_4_MASK					0x10
+#define BIT_5_MASK					0x20
+#define BIT_6_MASK					0x40
+#define BIT_7_MASK					0x80
+
+
+#define BIT_8_MASK					0x100
+#define BIT_7_SHIFT					7
+#define BIT_8_SHIFT					8
+
+
+
+// I2C buffer length
+// Note: I2C_BUFFER_LEN must be greater than I2cReadingByteNumMax and I2cWritingByteNumMax in BASE_INTERFACE_MODULE.
+#define I2C_BUFFER_LEN				128
+
+
+
+
+
+/// Module types
+enum MODULE_TYPE
+{
+	// DVB-T demod
+	DVBT_DEMOD_TYPE_RTL2830,				///<   RTL2830 DVB-T demod
+	DVBT_DEMOD_TYPE_RTL2832,				///<   RTL2832 DVB-T demod
+
+	// QAM demod
+	QAM_DEMOD_TYPE_RTL2840,					///<   RTL2840 DVB-C demod
+	QAM_DEMOD_TYPE_RTL2810_OC,				///<   RTL2810 OpenCable demod
+	QAM_DEMOD_TYPE_RTL2820_OC,				///<   RTL2820 OpenCable demod
+	QAM_DEMOD_TYPE_RTD2885_QAM,				///<   RTD2885 QAM demod
+	QAM_DEMOD_TYPE_RTD2932_QAM,				///<   RTD2932 QAM demod
+	QAM_DEMOD_TYPE_RTL2836B_DVBC,			///<   RTL2836 DVB-C demod
+	QAM_DEMOD_TYPE_RTL2810B_QAM,			///<   RTL2810B QAM demod
+	QAM_DEMOD_TYPE_RTD2840B_QAM,			///<   RTD2840B QAM demod
+
+	// OOB demod
+	OOB_DEMOD_TYPE_RTL2820_OOB,				///<   RTL2820 OOB demod
+
+	// ATSC demod
+	ATSC_DEMOD_TYPE_RTL2820_ATSC,			///<   RTL2820 ATSC demod
+	ATSC_DEMOD_TYPE_RTD2885_ATSC,			///<   RTD2885 ATSC demod
+	ATSC_DEMOD_TYPE_RTD2932_ATSC,			///<   RTD2932 ATSC demod
+	ATSC_DEMOD_TYPE_RTL2810B_ATSC,			///<   RTL2810B ATSC demod
+
+	// DTMB demod
+	DTMB_DEMOD_TYPE_RTL2836,				///<   RTL2836 DTMB demod
+	DTMB_DEMOD_TYPE_RTL2836B_DTMB,			///<   RTL2836B DTMB demod
+	DTMB_DEMOD_TYPE_RTD2974_DTMB,			///<   RTD2974 DTMB demod
+
+	// Tuner
+	TUNER_TYPE_TDCGG052D,					///<   TDCG-G052D tuner (QAM)
+	TUNER_TYPE_TDCHG001D,					///<   TDCH-G001D tuner (QAM)
+	TUNER_TYPE_TDQE3003A,					///<   TDQE3-003A tuner (QAM)
+	TUNER_TYPE_DCT7045,						///<   DCT-7045 tuner (QAM)
+	TUNER_TYPE_MT2062,						///<   MT2062 tuner (QAM)
+	TUNER_TYPE_MXL5005S,					///<   MxL5005S tuner (DVB-T, ATSC)
+	TUNER_TYPE_TDVMH715P,					///<   TDVM-H751P tuner (QAM, OOB, ATSC)
+	TUNER_TYPE_UBA00AL,						///<   UBA00AL tuner (QAM, ATSC)
+	TUNER_TYPE_MT2266,						///<   MT2266 tuner (DVB-T)
+	TUNER_TYPE_FC2580,						///<   FC2580 tuner (DVB-T, DTMB)
+	TUNER_TYPE_TUA9001,						///<   TUA9001 tuner (DVB-T)
+	TUNER_TYPE_DTT75300,					///<   DTT-75300 tuner (DVB-T)
+	TUNER_TYPE_MXL5007T,					///<   MxL5007T tuner (DVB-T, ATSC)
+	TUNER_TYPE_VA1T1ED6093,					///<   VA1T1ED6093 tuner (DTMB)
+	TUNER_TYPE_TUA8010,						///<   TUA8010 tuner (DVB-T)
+	TUNER_TYPE_E4000,						///<   E4000 tuner (DVB-T)
+	TUNER_TYPE_DCT70704,					///<   DCT-70704 tuner (QAM)
+	TUNER_TYPE_MT2063,						///<   MT2063 tuner (DVB-T, QAM)
+	TUNER_TYPE_FC0012,						///<   FC0012 tuner (DVB-T, DTMB)
+	TUNER_TYPE_TDAG,						///<   TDAG tuner (DTMB)
+	TUNER_TYPE_ADMTV804,					///<   ADMTV804 tuner (DVB-T, DTMB)
+	TUNER_TYPE_MAX3543,						///<   MAX3543 tuner (DVB-T)
+	TUNER_TYPE_TDA18272,					///<   TDA18272 tuner (DVB-T, QAM, DTMB)
+	TUNER_TYPE_FC0013,						///<   FC0013 tuner (DVB-T, DTMB)
+	TUNER_TYPE_FC0013B,						///<   FC0013B tuner (DVB-T, DTMB)
+	TUNER_TYPE_VA1E1ED2403,					///<   VA1E1ED2403 tuner (DTMB)
+	TUNER_TYPE_AVALON,						///<   AVALON tuner (DTMB)
+	TUNER_TYPE_SUTRE201,					///<   SUTRE201 tuner (DTMB)
+	TUNER_TYPE_MR1300,						///<   MR1300 tuner (ISDB-T 1-Seg)
+	TUNER_TYPE_TDAC7,						///<   TDAC7 tuner (DTMB, QAM)
+	TUNER_TYPE_VA1T1ER2094,					///<   VA1T1ER2094 tuner (DTMB)
+	TUNER_TYPE_TDAC3,						///<   TDAC3 tuner (DTMB)
+	TUNER_TYPE_RT910,						///<   RT910 tuner (DVB-T)
+	TUNER_TYPE_DTM4C20,						///<   DTM4C20 tuner (DTMB)
+	TUNER_TYPE_GTFD32,						///<   GTFD32 tuner (DTMB)
+	TUNER_TYPE_GTLP10,						///<   GTLP10 tuner (DTMB)
+	TUNER_TYPE_JSS66T,						///<   JSS66T tuner (DTMB)
+	TUNER_TYPE_NONE,						///<   NONE tuner (DTMB)
+
+	// DVB-T NIM
+	DVBT_NIM_USER_DEFINITION,				///<   DVB-T NIM:   User definition
+	DVBT_NIM_RTL2832_MT2266,				///<   DVB-T NIM:   RTL2832 + MT2266
+	DVBT_NIM_RTL2832_FC2580,				///<   DVB-T NIM:   RTL2832 + FC2580
+	DVBT_NIM_RTL2832_TUA9001,				///<   DVB-T NIM:   RTL2832 + TUA9001
+	DVBT_NIM_RTL2832_MXL5005S,				///<   DVB-T NIM:   RTL2832 + MxL5005S
+	DVBT_NIM_RTL2832_DTT75300,				///<   DVB-T NIM:   RTL2832 + DTT-75300
+	DVBT_NIM_RTL2832_MXL5007T,				///<   DVB-T NIM:   RTL2832 + MxL5007T
+	DVBT_NIM_RTL2832_TUA8010,				///<   DVB-T NIM:   RTL2832 + TUA8010
+	DVBT_NIM_RTL2832_E4000,					///<   DVB-T NIM:   RTL2832 + E4000
+	DVBT_NIM_RTL2832_MT2063,				///<   DVB-T NIM:   RTL2832 + MT2063
+	DVBT_NIM_RTL2832_FC0012,				///<   DVB-T NIM:   RTL2832 + FC0012
+	DVBT_NIM_RTL2832_ADMTV804,				///<   DVB-T NIM:   RTL2832 + ADMTV804
+	DVBT_NIM_RTL2832_MAX3543,				///<   DVB-T NIM:   RTL2832 + MAX3543
+	DVBT_NIM_RTL2832_TDA18272,				///<   DVB-T NIM:   RTL2832 + TDA18272
+	DVBT_NIM_RTL2832_FC0013,				///<   DVB-T NIM:   RTL2832 + FC0013
+	DVBT_NIM_RTL2832_RT910,					///<   DVB-T NIM:   RTL2832 + RT910
+
+	// QAM NIM
+	QAM_NIM_USER_DEFINITION,				///<   QAM NIM:   User definition
+	QAM_NIM_RTL2840_TDQE3003A,				///<   QAM NIM:   RTL2840 + TDQE3-003A
+	QAM_NIM_RTL2840_DCT7045,				///<   QAM NIM:   RTL2840 + DCT-7045
+	QAM_NIM_RTL2840_DCT7046,				///<   QAM NIM:   RTL2840 + DCT-7046
+	QAM_NIM_RTL2840_MT2062,					///<   QAM NIM:   RTL2840 + MT2062
+	QAM_NIM_RTL2840_DCT70704,				///<   QAM NIM:   RTL2840 + DCT-70704
+	QAM_NIM_RTL2840_MT2063,					///<   QAM NIM:   RTL2840 + MT2063
+	QAM_NIM_RTL2840_MAX3543,				///<   QAM NIM:   RTL2840 + MAX3543
+	QAM_NIM_RTL2836B_DVBC_VA1T1ED6093,		///<   QAM NIM:   RTL2836B DVB-C + VA1T1ED6093
+	QAM_NIM_RTD2885_QAM_TDA18272,			///<   QAM NIM:   RTD2885 QAM + TDA18272
+	QAM_NIM_RTL2836B_DVBC_VA1E1ED2403,		///<   QAM NIM:   RTL2836B DVB-C + VA1E1ED2403
+	QAM_NIM_RTD2840B_QAM_MT2062,            ///<   QAM NIM:   RTD2840B QAM + MT2062
+
+	// DCR NIM
+	DCR_NIM_RTL2820_TDVMH715P,				///<   DCR NIM:   RTL2820 + TDVM-H751P
+	DCR_NIM_RTD2885_UBA00AL,				///<   DCR NIM:   RTD2885 + UBA00AL
+
+	// ATSC NIM
+	ATSC_NIM_RTD2885_ATSC_TDA18272,			///<   ATSC NIM:   RTD2885 ATSC + TDA18272
+
+	// DTMB NIM
+	DTMB_NIM_RTL2836_FC2580,				///<   DTMB NIM:   RTL2836 + FC2580
+	DTMB_NIM_RTL2836_VA1T1ED6093,			///<   DTMB NIM:   RTL2836 + VA1T1ED6093
+	DTMB_NIM_RTL2836_TDAG,					///<   DTMB NIM:   RTL2836 + TDAG
+	DTMB_NIM_RTL2836_MXL5007T,				///<   DTMB NIM:   RTL2836 + MxL5007T
+	DTMB_NIM_RTL2836_E4000,					///<   DTMB NIM:   RTL2836 + E4000
+	DTMB_NIM_RTL2836_TDA18272,				///<   DTMB NIM:   RTL2836 + TDA18272
+	DTMB_NIM_RTL2836B_DTMB_VA1T1ED6093,		///<   DTMB NIM:   RTL2836B DTMB + VA1T1ED6093
+	DTMB_NIM_RTL2836B_DTMB_ADMTV804,		///<   DTMB NIM:   RTL2836B DTMB + ADMTV804
+	DTMB_NIM_RTL2836B_DTMB_E4000,			///<   DTMB NIM:   RTL2836B DTMB + E4000
+	DTMB_NIM_RTL2836B_DTMB_FC0012,			///<   DTMB NIM:   RTL2836B DTMB + FC0012
+	DTMB_NIM_RTL2836B_DTMB_VA1E1ED2403,		///<   DTMB NIM:   RTL2836B DTMB + VA1E1ED2403
+	DTMB_NIM_RTL2836B_DTMB_TDA18272,		///<   DTMB NIM:   RTL2836B DTMB + TDA18272
+	DTMB_NIM_RTL2836B_DTMB_AVALON,			///<   DTMB NIM:   RTL2836B DTMB + AVALON
+	DTMB_NIM_RTL2836B_DTMB_SUTRE201,		///<   DTMB NIM:   RTL2836B DTMB + SUTRE201
+	DTMB_NIM_RTL2836B_DTMB_TDAC7,	    	///<   DTMB NIM:   RTL2836B DTMB + ALPS TDAC7
+	DTMB_NIM_RTL2836B_DTMB_FC0013B,	    	///<   DTMB NIM:   RTL2836B DTMB + FC0013B
+	DTMB_NIM_RTL2836B_DTMB_VA1T1ER2094,		///<   DTMB NIM:   RTL2836B DTMB + VA1T1ER2094
+	DTMB_NIM_RTL2836B_DTMB_TDAC3,	    	///<   DTMB NIM:   RTL2836B DTMB + ALPS TDAC3
+	DTMB_NIM_RTL2836B_DTMB_DTM4C20,	    	///<   DTMB NIM:   RTL2836B DTMB + DTM4C20
+	DTMB_NIM_RTL2836B_DTMB_GTFD32,			///<   DTMB NIM:   RTL2836B DTMB + GTFD32
+	DTMB_NIM_RTL2836B_DTMB_GTLP10,			///<   DTMB NIM:   RTL2836B DTMB + GTFD32
+	DTMB_NIM_RTL2836B_DTMB_JSS66T,			///<   DTMB NIM:   RTL2836B DTMB + JSS66T
+	DTMB_NIM_RTL2836B_DTMB_NONE,			///<   DTMB NIM:   RTL2836B DTMB + NONE TUNER
+	DTMB_NIM_RTD2974_DTMB_VA1E1ED2403,		///<   DTMB NIM:   RTD2974 DTMB + VA1E1ED2403
+};
+
+
+
+
+
+/// On/off status
+enum ON_OFF_STATUS
+{
+	OFF,		///<   Off
+	ON,			///<   On
+};
+
+
+/// Yes/no status
+enum YES_NO_STATUS
+{
+	NO,			///<   No
+	YES,		///<   Yes
+};
+
+
+/// Lock status
+enum LOCK_STATUS
+{
+	NOT_LOCKED,			///<   Not locked
+	LOCKED,				///<   Locked
+};
+
+
+/// Loss status
+enum LOSS_STATUS
+{
+	NOT_LOST,			///<   Not lost
+	LOST,				///<   Lost
+};
+
+
+/// Function return status
+enum FUNCTION_RETURN_STATUS
+{
+	FUNCTION_SUCCESS,			///<   Execute function successfully.
+	FUNCTION_ERROR,				///<   Execute function unsuccessfully.
+};
+
+
+/// Crystal frequency
+enum CRYSTAL_FREQ_HZ
+{
+	CRYSTAL_FREQ_4000000HZ  =  4000000,			///<   Crystal frequency =    4.0 MHz
+	CRYSTAL_FREQ_16000000HZ = 16000000,			///<   Crystal frequency =   16.0 MHz
+	CRYSTAL_FREQ_16384000HZ = 16384000,			///<   Crystal frequency = 16.384 MHz
+	CRYSTAL_FREQ_16457143HZ = 16457143,			///<   Crystal frequency = 16.457 MHz
+	CRYSTAL_FREQ_20000000HZ = 20000000,			///<   Crystal frequency =   20.0 MHz
+	CRYSTAL_FREQ_20250000HZ = 20250000,			///<   Crystal frequency =  20.25 MHz
+	CRYSTAL_FREQ_20480000HZ = 20480000,			///<   Crystal frequency =  20.48 MHz
+	CRYSTAL_FREQ_24000000HZ = 24000000,			///<   Crystal frequency =   24.0 MHz
+	CRYSTAL_FREQ_25000000HZ = 25000000,			///<   Crystal frequency =   25.0 MHz
+	CRYSTAL_FREQ_25200000HZ = 25200000,			///<   Crystal frequency =   25.2 MHz
+	CRYSTAL_FREQ_26000000HZ = 26000000,			///<   Crystal frequency =   26.0 MHz
+	CRYSTAL_FREQ_26690000HZ = 26690000,			///<   Crystal frequency =  26.69 MHz
+	CRYSTAL_FREQ_27000000HZ = 27000000,			///<   Crystal frequency =   27.0 MHz
+	CRYSTAL_FREQ_28800000HZ = 28800000,			///<   Crystal frequency =   28.8 MHz
+	CRYSTAL_FREQ_32000000HZ = 32000000,			///<   Crystal frequency =   32.0 MHz
+	CRYSTAL_FREQ_36000000HZ = 36000000,			///<   Crystal frequency =   36.0 MHz
+};
+
+
+/// IF frequency
+enum IF_FREQ_HZ
+{
+	IF_FREQ_0HZ        =        0,			///<   IF frequency =      0 MHz
+	IF_FREQ_4000000HZ  =  4000000,			///<   IF frequency =    4.0 MHz
+	IF_FREQ_4570000HZ  =  4570000,			///<   IF frequency =   4.57 MHz
+	IF_FREQ_4571429HZ  =  4571429,			///<   IF frequency =  4.571 MHz
+	IF_FREQ_5000000HZ  =  5000000,			///<   IF frequency =    5.0 MHz
+	IF_FREQ_36000000HZ = 36000000,			///<   IF frequency =   36.0 MHz
+	IF_FREQ_36125000HZ = 36125000,			///<   IF frequency = 36.125 MHz
+	IF_FREQ_36150000HZ = 36150000,			///<   IF frequency =  36.15 MHz
+	IF_FREQ_36166667HZ = 36166667,			///<   IF frequency = 36.167 MHz
+	IF_FREQ_36170000HZ = 36170000,			///<   IF frequency =  36.17 MHz
+	IF_FREQ_43750000HZ = 43750000,			///<   IF frequency =  43.75 MHz
+	IF_FREQ_44000000HZ = 44000000,			///<   IF frequency =   44.0 MHz
+};
+
+
+/// Spectrum mode
+enum SPECTRUM_MODE
+{
+	SPECTRUM_NORMAL,			///<   Normal spectrum
+	SPECTRUM_INVERSE,			///<   Inverse spectrum
+};
+#define SPECTRUM_MODE_NUM		2
+
+
+/// TS interface mode
+enum TS_INTERFACE_MODE
+{
+	TS_INTERFACE_PARALLEL,			///<   Parallel TS interface
+	TS_INTERFACE_SERIAL,			///<   Serial TS interface
+};
+#define TS_INTERFACE_MODE_NUM		2
+
+
+/// Diversity mode
+enum DIVERSITY_PIP_MODE
+{
+	DIVERSITY_PIP_OFF,				///<   Diversity disable and PIP disable
+	DIVERSITY_ON_MASTER,			///<   Diversity enable for Master Demod
+	DIVERSITY_ON_SLAVE,				///<   Diversity enable for Slave Demod
+	PIP_ON_MASTER,					///<   PIP enable for Master Demod
+	PIP_ON_SLAVE,					///<   PIP enable for Slave Demod
+};
+#define DIVERSITY_PIP_MODE_NUM		5
+
+
+
+
+
+/// Base interface module alias
+typedef struct BASE_INTERFACE_MODULE_TAG BASE_INTERFACE_MODULE;
+
+
+
+
+
+/**
+
+@brief   Basic I2C reading function pointer
+
+Upper layer functions will use BASE_FP_I2C_READ() to read ByteNum bytes from I2C device to pReadingBytes buffer.
+
+
+@param [in]    pBaseInterface   The base interface module pointer
+@param [in]    DeviceAddr       I2C device address in 8-bit format
+@param [out]   pReadingBytes    Buffer pointer to an allocated memory for storing reading bytes
+@param [in]    ByteNum          Reading byte number
+
+
+@retval   FUNCTION_SUCCESS   Read bytes from I2C device with reading byte number successfully.
+@retval   FUNCTION_ERROR     Read bytes from I2C device unsuccessfully.
+
+
+@note
+	The requirements of BASE_FP_I2C_READ() function are described as follows:
+	-# Follow the I2C format for BASE_FP_I2C_READ(). \n
+	   start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+	-# Don't allocate memory on pReadingBytes.
+	-# Upper layer functions should allocate memory on pReadingBytes before using BASE_FP_I2C_READ().
+	-# Need to assign I2C reading funtion to BASE_FP_I2C_READ() for upper layer functions.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement I2C reading funciton for BASE_FP_I2C_READ function pointer.
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	unsigned char ReadingBytes[100];
+
+
+	// Assign implemented I2C reading funciton to BASE_FP_I2C_READ in base interface module.
+	BuildBaseInterface(&pBaseInterface, &BaseInterfaceModuleMemory, ..., ..., CustomI2cRead, ..., ...);
+
+	...
+
+	// Use I2cRead() to read 33 bytes from I2C device and store reading bytes to ReadingBytes.
+	pBaseInterface->I2cRead(pBaseInterface, 0x20, ReadingBytes, 33);
+	
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*BASE_FP_I2C_READ)(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   Basic I2C writing function pointer
+
+Upper layer functions will use BASE_FP_I2C_WRITE() to write ByteNum bytes from pWritingBytes buffer to I2C device.
+
+
+@param [in]   pBaseInterface   The base interface module pointer
+@param [in]   DeviceAddr       I2C device address in 8-bit format
+@param [in]   pWritingBytes    Buffer pointer to writing bytes
+@param [in]   ByteNum          Writing byte number
+
+
+@retval   FUNCTION_SUCCESS   Write bytes to I2C device with writing bytes successfully.
+@retval   FUNCTION_ERROR     Write bytes to I2C device unsuccessfully.
+
+
+@note
+	The requirements of BASE_FP_I2C_WRITE() function are described as follows:
+	-# Follow the I2C format for BASE_FP_I2C_WRITE(). \n
+	   start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+	-# Need to assign I2C writing funtion to BASE_FP_I2C_WRITE() for upper layer functions.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement I2C writing funciton for BASE_FP_I2C_WRITE function pointer.
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned char ByteNum
+	)
+{
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	unsigned char WritingBytes[100];
+
+
+	// Assign implemented I2C writing funciton to BASE_FP_I2C_WRITE in base interface module.
+	BuildBaseInterface(&pBaseInterface, &BaseInterfaceModuleMemory, ..., ..., ..., CustomI2cWrite, ...);
+
+	...
+
+	// Use I2cWrite() to write 33 bytes from WritingBytes to I2C device.
+	pBaseInterface->I2cWrite(pBaseInterface, 0x20, WritingBytes, 33);
+	
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*BASE_FP_I2C_WRITE)(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   Basic waiting function pointer
+
+Upper layer functions will use BASE_FP_WAIT_MS() to wait WaitTimeMs milliseconds.
+
+
+@param [in]   pBaseInterface   The base interface module pointer
+@param [in]   WaitTimeMs       Waiting time in millisecond
+
+
+@note
+	The requirements of BASE_FP_WAIT_MS() function are described as follows:
+	-# Need to assign a waiting function to BASE_FP_WAIT_MS() for upper layer functions.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement waiting funciton for BASE_FP_WAIT_MS function pointer.
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	...
+
+	return;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+
+	// Assign implemented waiting funciton to BASE_FP_WAIT_MS in base interface module.
+	BuildBaseInterface(&pBaseInterface, &BaseInterfaceModuleMemory, ..., ..., ..., ..., CustomWaitMs);
+
+	...
+
+	// Use WaitMs() to wait 30 millisecond.
+	pBaseInterface->WaitMs(pBaseInterface, 30);
+	
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef void
+(*BASE_FP_WAIT_MS)(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	);
+
+
+
+
+
+/**
+
+@brief   User defined data pointer setting function pointer
+
+One can use BASE_FP_SET_USER_DEFINED_DATA_POINTER() to set user defined data pointer of base interface structure for
+custom basic function implementation.
+
+
+@param [in]   pBaseInterface     The base interface module pointer
+@param [in]   pUserDefinedData   Pointer to user defined data
+
+
+@note
+	One can use BASE_FP_GET_USER_DEFINED_DATA_POINTER() to get user defined data pointer of base interface structure for
+	custom basic function implementation.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement I2C reading funciton for BASE_FP_I2C_READ function pointer.
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+	CUSTOM_USER_DEFINED_DATA *pUserDefinedData;
+
+
+	// Get user defined data pointer of base interface structure for custom I2C reading function.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&pUserDefinedData);
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	unsigned char ReadingBytes[100];
+
+	CUSTOM_USER_DEFINED_DATA UserDefinedData;
+
+
+	// Assign implemented I2C reading funciton to BASE_FP_I2C_READ in base interface module.
+	BuildBaseInterface(&pBaseInterface, &BaseInterfaceModuleMemory, ..., ..., CustomI2cRead, ..., ...);
+
+	...
+
+	// Set user defined data pointer of base interface structure for custom basic functions.
+	pBaseInterface->SetUserDefinedDataPointer(pBaseInterface, &UserDefinedData);
+
+	// Use I2cRead() to read 33 bytes from I2C device and store reading bytes to ReadingBytes.
+	pBaseInterface->I2cRead(pBaseInterface, 0x20, ReadingBytes, 33);
+	
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef void
+(*BASE_FP_SET_USER_DEFINED_DATA_POINTER)(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void *pUserDefinedData
+	);
+
+
+
+
+
+/**
+
+@brief   User defined data pointer getting function pointer
+
+One can use BASE_FP_GET_USER_DEFINED_DATA_POINTER() to get user defined data pointer of base interface structure for
+custom basic function implementation.
+
+
+@param [in]   pBaseInterface      The base interface module pointer
+@param [in]   ppUserDefinedData   Pointer to user defined data pointer
+
+
+@note
+	One can use BASE_FP_SET_USER_DEFINED_DATA_POINTER() to set user defined data pointer of base interface structure for
+	custom basic function implementation.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement I2C reading funciton for BASE_FP_I2C_READ function pointer.
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+	CUSTOM_USER_DEFINED_DATA *pUserDefinedData;
+
+
+	// Get user defined data pointer of base interface structure for custom I2C reading function.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&pUserDefinedData);
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	unsigned char ReadingBytes[100];
+
+	CUSTOM_USER_DEFINED_DATA UserDefinedData;
+
+
+	// Assign implemented I2C reading funciton to BASE_FP_I2C_READ in base interface module.
+	BuildBaseInterface(&pBaseInterface, &BaseInterfaceModuleMemory, ..., ..., CustomI2cRead, ..., ...);
+
+	...
+
+	// Set user defined data pointer of base interface structure for custom basic functions.
+	pBaseInterface->SetUserDefinedDataPointer(pBaseInterface, &UserDefinedData);
+
+	// Use I2cRead() to read 33 bytes from I2C device and store reading bytes to ReadingBytes.
+	pBaseInterface->I2cRead(pBaseInterface, 0x20, ReadingBytes, 33);
+	
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef void
+(*BASE_FP_GET_USER_DEFINED_DATA_POINTER)(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void **ppUserDefinedData
+	);
+
+
+
+
+
+/// Base interface module structure
+struct BASE_INTERFACE_MODULE_TAG
+{
+	// Variables and function pointers
+	unsigned long I2cReadingByteNumMax;
+	unsigned long I2cWritingByteNumMax;
+
+	BASE_FP_I2C_READ    I2cRead;
+	BASE_FP_I2C_WRITE   I2cWrite;
+	BASE_FP_WAIT_MS     WaitMs;
+
+	BASE_FP_SET_USER_DEFINED_DATA_POINTER   SetUserDefinedDataPointer;
+	BASE_FP_GET_USER_DEFINED_DATA_POINTER   GetUserDefinedDataPointer;
+
+
+	// User defined data
+	void *pUserDefinedData;
+};
+
+
+
+
+
+/**
+
+@brief   Base interface builder
+
+Use BuildBaseInterface() to build base interface for module functions to access basic functions.
+
+
+@param [in]   ppBaseInterface              Pointer to base interface module pointer
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+
+
+@note
+	-# One should build base interface before using module functions.
+	-# The I2C reading format is described as follows:
+	   start_bit + (device_addr | reading_bit) + reading_byte * byte_num + stop_bit
+	-# The I2cReadingByteNumMax is the maximum byte_num of the I2C reading format.
+	-# The I2C writing format is described as follows:
+	   start_bit + (device_addr | writing_bit) + writing_byte * byte_num + stop_bit
+	-# The I2cWritingByteNumMax is the maximum byte_num of the I2C writing format.
+
+
+
+@par Example:
+@code
+
+
+#include "foundation.h"
+
+
+// Implement I2C reading funciton for BASE_FP_I2C_READ function pointer.
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+// Implement I2C writing funciton for BASE_FP_I2C_WRITE function pointer.
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned char ByteNum
+	)
+{
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+
+	return FUNCTION_ERROR;
+}
+
+
+// Implement waiting funciton for BASE_FP_WAIT_MS function pointer.
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	...
+
+	return;
+}
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+
+	// Build base interface with the following settings.
+	//
+	// 1. Assign 9 to maximum I2C reading byte number.
+	// 2. Assign 8 to maximum I2C writing byte number.
+	// 3. Assign CustomI2cRead() to basic I2C reading function pointer.
+	// 4. Assign CustomI2cWrite() to basic I2C writing function pointer.
+	// 5. Assign CustomWaitMs() to basic waiting function pointer.
+	//
+	BuildBaseInterface(
+		&pBaseInterface,
+		&BaseInterfaceModuleMemory,
+		9,
+		8,
+		CustomI2cRead,
+		CustomI2cWrite,
+		CustomWaitMs
+		);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+void
+BuildBaseInterface(
+	BASE_INTERFACE_MODULE **ppBaseInterface,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	unsigned long I2cReadingByteNumMax,
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs
+	);
+
+
+
+
+
+// User data pointer of base interface structure setting and getting functions
+void
+base_interface_SetUserDefinedDataPointer(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void *pUserDefinedData
+	);
+
+void
+base_interface_GetUserDefinedDataPointer(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	void **ppUserDefinedData
+	);
+
+
+
+
+
+// Math functions
+
+// Binary and signed integer converter
+unsigned long
+SignedIntToBin(
+	long Value,
+	unsigned char BitNum
+	);
+
+long
+BinToSignedInt(
+	unsigned long Binary,
+	unsigned char BitNum
+	);
+
+
+
+// Arithmetic
+unsigned long
+DivideWithCeiling(
+	unsigned long Dividend,
+	unsigned long Divisor
+	);
+
+
+
+
+
+
+
+
+
+
+
+/**
+
+@mainpage Realtek demod Source Code Manual
+
+@note
+	-# The Realtek demod API source code is designed for demod IC driver porting.
+	-# The API source code is written in C language without floating-point arithmetic.
+	-# One can use the API to manipulate Realtek demod IC.
+	-# The API will call custom underlayer functions through API base interface module.
+
+
+@par Important:
+	-# Please assign API base interface module with custom underlayer functions instead of modifying API source code.
+	-# Please see the example code to understand the relation bewteen API and custom system.
+
+*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/i2c_bridge.h b/drivers/media/usb/rtl2832u/i2c_bridge.h
new file mode 100644
index 00000000..ce67e8b9
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/i2c_bridge.h
@@ -0,0 +1,122 @@
+#ifndef __I2C_BRIDGE_H
+#define __I2C_BRIDGE_H
+
+/**
+
+@file
+
+@brief   I2C bridge module
+
+I2C bridge module contains I2C forwarding function pointers.
+
+*/
+
+
+
+
+
+/// I2C bridge module pre-definition
+typedef struct I2C_BRIDGE_MODULE_TAG I2C_BRIDGE_MODULE;
+
+
+
+
+
+/**
+
+@brief   I2C reading command forwarding function pointer
+
+Tuner upper level functions will use I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD() to send tuner I2C reading command through
+demod.
+
+
+@param [in]    pI2cBridge      The I2C bridge module pointer
+@param [in]    DeviceAddr       I2C device address in 8-bit format
+@param [out]   pReadingBytes   Pointer to an allocated memory for storing reading bytes
+@param [in]    ByteNum         Reading byte number
+
+
+@retval   FUNCTION_SUCCESS   Forwarding I2C reading command successfully.
+@retval   FUNCTION_ERROR     Forwarding I2C reading command unsuccessfully.
+
+
+@note
+	-# Demod building function will set I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD() with the corresponding function.
+
+*/
+typedef int
+(*I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD)(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   I2C writing command forwarding function pointer
+
+Tuner upper level functions will use I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD() to send tuner I2C writing command through
+demod.
+
+
+@param [in]    pI2cBridge      The I2C bridge module pointer
+@param [in]    DeviceAddr       I2C device address in 8-bit format
+@param [out]   pWritingBytes   Pointer to writing bytes
+@param [in]    ByteNum         Writing byte number
+
+
+@retval   FUNCTION_SUCCESS   Forwarding I2C writing command successfully.
+@retval   FUNCTION_ERROR     Forwarding I2C writing command unsuccessfully.
+
+
+@note
+	-# Demod building function will set I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD() with the corresponding function.
+
+*/
+typedef int
+(*I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD)(
+	I2C_BRIDGE_MODULE *pI2cBridge,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/// I2C bridge module structure
+struct I2C_BRIDGE_MODULE_TAG
+{
+	// Private variables
+	void *pPrivateData;
+
+
+	// I2C bridge function pointers
+	I2C_BRIDGE_FP_FORWARD_I2C_READING_CMD   ForwardI2cReadingCmd;	///<   I2C reading command forwading function pointer
+	I2C_BRIDGE_FP_FORWARD_I2C_WRITING_CMD   ForwardI2cWritingCmd;   ///<   I2C writing command forwading function pointer
+
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/math_mpi.c b/drivers/media/usb/rtl2832u/math_mpi.c
new file mode 100644
index 00000000..d3a2c7c9
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/math_mpi.c
@@ -0,0 +1,1054 @@
+/**
+
+@file
+
+@brief   Mutliple precision integer (MPI) arithmetic definition
+
+One can use to mutliple precision arithmetic to manipulate large signed integers.
+
+*/
+
+
+#include "math_mpi.h"
+
+
+
+
+
+/**
+
+@brief   Set multiple precision signed integer value.
+
+Use MpiSetValue() to set multiple precision signed integer MPI value.
+
+
+@param [in]   pMpiVar   Pointer to an MPI variable
+@param [in]   Value     Value for setting
+
+
+@note
+	The MPI bit number will be minimized in MpiSetValue().
+
+*/
+void
+MpiSetValue(
+	MPI *pMpiVar,
+	long Value
+	)
+{
+	int i;
+	unsigned char SignedBit;
+	unsigned char ExtensionByte;
+
+
+
+	// Set MPI value according to ansigned value.
+	for(i = 0; i < MPI_LONG_BYTE_NUM; i++)
+		pMpiVar->Value[i] = (unsigned char)((Value >> (MPI_BYTE_SHIFT * i)) & MPI_BYTE_MASK);
+
+	
+	// Get extension byte according to signed bit.
+	SignedBit = (unsigned char)((Value >> (MPI_LONG_BIT_NUM - 1)) & MPI_BIT_0_MASK);
+	ExtensionByte = (SignedBit == 0x0) ? 0x00 : 0xff;
+
+
+	// Extend MPI signed bit with extension byte stuff.
+	for(i = MPI_LONG_BYTE_NUM; i < MPI_VALUE_BYTE_NUM_MAX; i++)
+		pMpiVar->Value[i] = ExtensionByte;
+
+
+	// Minimize MPI bit number.
+	MpiMinimizeBitNum(pMpiVar);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Get multiple precision signed integer value.
+
+Use MpiGetValue() to get multiple precision unsigned integer MPI value.
+
+
+@param [in]    MpiVar   Pointer to an MPI variable
+@param [out]   pValue   Pointer to an allocated memory for getting MPI value
+
+
+@note
+    The necessary bit number of MPI value must be less than or equal to 32 bits.
+
+*/
+void
+MpiGetValue(
+	MPI MpiVar,
+	long *pValue
+	)
+{
+	int i;
+	unsigned long Value;
+
+
+
+	// Set value with zero.
+	Value = 0x0;
+
+
+	// Combine MPI value bytes into value.
+	for(i = 0; i < MPI_LONG_BYTE_NUM; i++)
+		Value |= MpiVar.Value[i] << (MPI_BYTE_SHIFT * i);
+
+
+	// Assigned value to value pointer.
+	*pValue = (long)Value;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set multiple precision signed integer bit value.
+
+Use MpiSetBit() to set multiple precision signed integer MPI bit value.
+
+
+@param [in]   pMpiVar       Pointer to an MPI variable
+@param [in]   BitPosition   Bit position with zero-based index
+@param [in]   BitValue      Bit value for setting
+
+
+@note
+	Bit position must be 0 ~ (MPI bit number).
+
+*/
+void
+MpiSetBit(
+	MPI *pMpiVar,
+	unsigned long BitPosition,
+	unsigned char BitValue
+	)
+{
+	unsigned long TargetBytePos, TargetBitPos;
+
+
+
+	// Calculate target byte and bit position.
+	TargetBytePos = BitPosition / MPI_BYTE_BIT_NUM;
+	TargetBitPos  = BitPosition % MPI_BYTE_BIT_NUM;
+
+
+	// Set MPI bit value according to calculated target byte and bit position.
+	pMpiVar->Value[TargetBytePos] &= (unsigned char)(~(0x1 << TargetBitPos));
+	pMpiVar->Value[TargetBytePos] |= (BitValue & MPI_BIT_0_MASK) << TargetBitPos;
+
+
+	return;
+}
+
+
+
+
+
+
+/**
+
+@brief   Get multiple precision signed integer bit value.
+
+Use MpiGetBit() to get multiple precision unsigned integer MPI bit value.
+
+
+@param [in]    MpiVar        Pointer to an MPI variable
+@param [in]    BitPosition   Bit position with zero-based index
+@param [out]   pBitValue     Pointer to an allocated memory for getting MPI bit value
+
+
+@note
+	Bit position must be 0 ~ (MPI bit number).
+
+*/
+void
+MpiGetBit(
+	MPI MpiVar,
+	unsigned long BitPosition,
+	unsigned char *pBitValue
+	)
+{
+	unsigned long TargetBytePos, TargetBitPos;
+
+
+
+	// Calculate target byte and bit position.
+	TargetBytePos = BitPosition / MPI_BYTE_BIT_NUM;
+	TargetBitPos  = BitPosition % MPI_BYTE_BIT_NUM;
+
+
+	// Get MPI bit value according to calculated target byte and bit position.
+	*pBitValue = (MpiVar.Value[TargetBytePos] >> TargetBitPos) & MPI_BIT_0_MASK;
+
+
+	return;
+}
+	
+
+
+
+	
+/**
+
+@brief   Get multiple precision signed integer signed bit value.
+
+Use MpiGetBit() to get multiple precision unsigned integer MPI signed bit value.
+
+
+@param [in]    MpiVar            Pointer to an MPI variable
+@param [out]   pSignedBitValue   Pointer to an allocated memory for getting MPI signed bit value
+
+*/
+void
+MpiGetSignedBit(
+	MPI MpiVar,
+	unsigned char *pSignedBitValue
+	)
+{
+	// Get MPI variable signed bit.
+	MpiGetBit(MpiVar, MPI_VALUE_BIT_NUM_MAX - 1, pSignedBitValue);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Assign multiple precision signed integer with another one.
+
+Use MpiAssign() to assign multiple precision signed integer with another one.
+
+
+@param [out]   pResult   Pointer to an allocated memory for storing result
+@param [in]    Operand   Operand
+
+
+@note
+	The result bit number will be minimized in MpiAssign().
+
+*/
+void
+MpiAssign(
+	MPI *pResult,
+	MPI Operand
+	)
+{
+	unsigned int i;
+
+
+
+	// Copy value bytes from operand to result.
+	for(i = 0; i < MPI_VALUE_BYTE_NUM_MAX; i++)
+		pResult->Value[i] = Operand.Value[i];
+
+
+	// Minimize result bit nubmer.
+	MpiMinimizeBitNum(pResult);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Minus unary multiple precision signed integer.
+
+Use MpiUnaryMinus() to minus unary multiple precision signed integer.
+
+
+@param [out]   pResult   Pointer to an allocated memory for storing result
+@param [in]    Operand   Operand
+
+
+@note
+	The result bit number will be minimized in MpiUnaryMinus().
+
+*/
+void
+MpiUnaryMinus(
+	MPI *pResult,
+	MPI Operand
+	)
+{
+	unsigned int i;
+	MPI Const;
+
+
+
+	// Set result value byte with operand bitwise complement value byte.
+	for(i = 0; i < MPI_VALUE_BYTE_NUM_MAX; i++)
+		pResult->Value[i] = ~Operand.Value[i];
+
+
+	// Add result with 0x1.
+	// Note: MpiAdd() will minimize result bit number.
+	MpiSetValue(&Const, 0x1);
+	MpiAdd(pResult, *pResult, Const);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Add multiple precision signed integers.
+
+Use MpiAdd() to add multiple precision signed integers.
+
+
+@param [out]   pSum     Pointer to an allocated memory for storing sum
+@param [in]    Augend   Augend
+@param [in]    Addend   Addend
+
+
+@note
+	The sum bit number will be minimized in MpiAdd().
+
+*/
+void
+MpiAdd(
+	MPI *pSum,
+	MPI Augend,
+	MPI Addend
+	)
+{
+	unsigned int i;
+	unsigned long MiddleResult;
+	unsigned char Carry;
+
+
+	// Add augend and addend to sum form value LSB byte to value MSB byte.
+	Carry = 0;
+
+	for(i = 0; i < MPI_VALUE_BYTE_NUM_MAX; i++)
+	{
+		// Set current sum value byte and determine carry.
+		MiddleResult   = Augend.Value[i] + Addend.Value[i] + Carry;
+		pSum->Value[i] = (unsigned char)(MiddleResult & MPI_BYTE_MASK);
+		Carry          = (unsigned char)((MiddleResult >> MPI_BYTE_SHIFT) & MPI_BYTE_MASK);
+	}
+	
+
+	// Minimize sum bit nubmer.
+	MpiMinimizeBitNum(pSum);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   subtract multiple precision signed integers.
+
+Use MpiSub() to subtract multiple precision signed integers.
+
+
+@param [out]   pDifference   Pointer to an allocated memory for storing difference
+@param [in]    Minuend       Minuend
+@param [in]    Subtrahend    Subtrahend
+
+
+@note
+	The difference bit number will be minimized in MpiSub().
+
+*/
+void
+MpiSub(
+	MPI *pDifference,
+	MPI Minuend,
+	MPI Subtrahend
+	)
+{
+	MPI MiddleResult;
+
+
+
+	// Take subtrahend unary minus value.
+	MpiUnaryMinus(&MiddleResult, Subtrahend);
+
+
+	// Add minuend and subtrahend unary minus value to difference.
+	// Note: MpiAdd() will minimize result bit number.
+	MpiAdd(pDifference, Minuend, MiddleResult);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Multiply arbitrary precision signed integers.
+
+Use MpiMul() to multiply arbitrary precision signed integers.
+
+
+@param [out]   pProduct        Pointer to an allocated memory for storing product
+@param [in]    Multiplicand    Multiplicand
+@param [in]    Multiplicator   Multiplicator
+
+
+@note
+	-# The sum of multiplicand and multiplicator bit number must be less MPI_VALUE_BIT_NUM_MAX.
+	-# The product bit number will be minimized in MpiMul().
+
+*/
+void
+MpiMul(
+	MPI *pProduct,
+	MPI Multiplicand,
+	MPI Multiplicator
+	)
+{
+	int i;
+
+	unsigned char MultiplicandSignedBit, MultiplicatorSignedBit;
+	MPI MultiplicandAbs, MultiplicatorAbs;
+
+	unsigned char CurrentBit;
+
+
+
+	// Get multiplicand signed bit.
+	MpiGetSignedBit(Multiplicand, &MultiplicandSignedBit);
+
+	// Take absolute value of multiplicand.
+	if(MultiplicandSignedBit == 0x0)
+		MpiAssign(&MultiplicandAbs, Multiplicand);
+	else
+		MpiUnaryMinus(&MultiplicandAbs, Multiplicand);
+
+
+	// Get multiplicator signed bit.
+	MpiGetSignedBit(Multiplicator, &MultiplicatorSignedBit);
+
+	// Take absolute value of multiplicator.
+	if(MultiplicatorSignedBit == 0x0)
+		MpiAssign(&MultiplicatorAbs, Multiplicator);
+	else
+		MpiUnaryMinus(&MultiplicatorAbs, Multiplicator);
+
+
+	// Multiply multiplicand and multiplicator from LSB bit to MSB bit.
+	MpiSetValue(pProduct, 0x0);
+
+	for(i = MPI_VALUE_BIT_NUM_MAX - 1; i > -1; i--)
+	{
+		// Shift product toward left with one bit.
+		MpiLeftShift(pProduct, *pProduct, 1);
+
+		// Get current absolute multiplicator bit value.
+		MpiGetBit(MultiplicatorAbs, i, &CurrentBit);
+
+		// If current multiplicator bit is 0x1, add absolute multiplicand value to product.
+		// Note: MpiAdd() will minimize result bit number.
+		if(CurrentBit == 0x1)
+			MpiAdd(pProduct, *pProduct, MultiplicandAbs);
+	}
+
+
+	// Determine the signed bit of product according to signed bits of multiplicand and multiplicator.
+	// Note: MpiUnaryMinus() will minimize result bit number.
+	if(MultiplicandSignedBit != MultiplicatorSignedBit)
+		MpiUnaryMinus(pProduct, *pProduct);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Divide arbitrary precision signed integers.
+
+Use MpiDiv() to divide arbitrary precision signed integers.
+
+
+@param [out]   pQuotient    Pointer to an allocated memory for storing quotient
+@param [out]   pRemainder   Pointer to an allocated memory for storing remainder
+@param [in]    Dividend     Dividend
+@param [in]    Divisor      Divisor
+
+
+@note
+	-# The dividend bit number must be minimized.
+	-# The divisor must be not equal to zero.
+	-# The product bit number will be minimized in MpiDiv().
+
+*/
+void
+MpiDiv(
+	MPI *pQuotient,
+	MPI *pRemainder,
+	MPI Dividend,
+	MPI Divisor
+	)
+{
+	unsigned int i;
+
+	unsigned char DividendSignedBit, DivisorSignedBit;
+	MPI DividendAbs, DivisorAbs;
+
+	unsigned long PrimaryDividendBitNum;
+	unsigned char ShiftBit;
+
+	MPI Const;
+	MPI MiddleResult;
+
+
+
+	// Get dividend signed bit.
+	MpiGetSignedBit(Dividend, &DividendSignedBit);
+
+	// Take absolute value of dividend.
+	if(DividendSignedBit == 0x0)
+		MpiAssign(&DividendAbs, Dividend);
+	else
+		MpiUnaryMinus(&DividendAbs, Dividend);
+
+
+	// Get divisor signed bit.
+	MpiGetSignedBit(Divisor, &DivisorSignedBit);
+
+	// Take absolute value of divisor.
+	if(DivisorSignedBit == 0x0)
+		MpiAssign(&DivisorAbs, Divisor);
+	else
+		MpiUnaryMinus(&DivisorAbs, Divisor);
+
+
+	// Get primary absolute dividend bit number.
+	PrimaryDividendBitNum = DividendAbs.BitNum;
+
+
+	// Get quotient and remainder by division algorithm.
+	MpiSetValue(pQuotient, 0x0);
+	MpiSetValue(pRemainder, 0x0);
+
+	for(i = 0; i < PrimaryDividendBitNum; i++)
+	{
+		// Shift quotient toward left with one bit.
+		// Note: MpiLeftShift() will minimize result bit number.
+		MpiLeftShift(pQuotient, *pQuotient, 1);
+
+		// Shift remainder toward left with one bit.
+		MpiLeftShift(pRemainder, *pRemainder, 1);
+
+		// Shift absolute dividend toward left with one bit.
+		MpiLeftShift(&DividendAbs, DividendAbs, 1);
+
+		// Set remainder LSB according to absolute dividend.
+		MpiGetBit(DividendAbs, PrimaryDividendBitNum, &ShiftBit);
+		MpiSetBit(pRemainder, 0, ShiftBit);
+
+		// If remainder is greater than or equal to absolute divisor,
+		// substract absolute divisor from remainder and set quotient LSB with one.
+		if(MpiGreaterThan(*pRemainder, DivisorAbs) || MpiEqualTo(*pRemainder, DivisorAbs))
+		{
+			MpiSub(pRemainder, *pRemainder, DivisorAbs);
+			MpiSetBit(pQuotient, 0, 0x1);
+		}
+	}
+
+
+	// Modify quotient according to dividend signed bit, divisor signed bit, and remainder.
+
+	// Determine the signed bit of quotient.
+	if(DividendSignedBit != DivisorSignedBit)
+	{
+		// Take unary minus quotient.
+		// Note: MpiUnaryMinus() will minimize result bit number.
+		MpiUnaryMinus(pQuotient, *pQuotient);
+
+		// If remainder is greater than zero, subtract 1 from quotient.
+		// Note: MpiSub() will minimize result bit number.
+		MpiSetValue(&Const, 0x0);
+
+		if(MpiGreaterThan(*pRemainder, Const))
+		{
+			MpiSetValue(&Const, 0x1);
+			MpiSub(pQuotient, *pQuotient, Const);
+		}
+	}
+
+
+	// Modify remainder according to dividend, divisor, and quotient.
+
+	// Remainder = dividend - divisor * quotient;
+	// Note: MpiSub() will minimize result bit number.
+	MpiMul(&MiddleResult, Divisor, *pQuotient);
+	MpiSub(pRemainder, Dividend, MiddleResult);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Shift multiple precision signed integer toward right.
+
+Use MpiRightShift() to shift arbitrary precision signed integer toward right with assigned bit number.
+
+
+@param [out]   pResult       Pointer to an allocated memory for storing result
+@param [in]    Operand       Operand
+@param [in]    ShiftBitNum   Shift bit number
+
+
+@note
+	-# The result MSB bits will be stuffed with signed bit
+	-# The result bit number will be minimized in MpiRightShift().
+
+*/
+void
+MpiRightShift(
+	MPI *pResult,
+	MPI Operand,
+	unsigned long ShiftBitNum
+	)
+{
+	unsigned int i;
+	unsigned long StuffBitNum;
+	unsigned char CurrentBit;
+	unsigned char SignedBit;
+
+
+
+	// Determine stuff bit number according to shift bit nubmer.
+	StuffBitNum = (ShiftBitNum < MPI_VALUE_BIT_NUM_MAX) ? ShiftBitNum : MPI_VALUE_BIT_NUM_MAX;
+
+
+	// Copy operand bits to result with stuff bit number.
+	for(i = 0; i < (MPI_VALUE_BIT_NUM_MAX - StuffBitNum); i++)
+	{
+		MpiGetBit(Operand, i + StuffBitNum, &CurrentBit);
+		MpiSetBit(pResult, i, CurrentBit);
+	}
+
+
+	// Get operand signed bit.
+	MpiGetSignedBit(Operand, &SignedBit);
+
+
+	// Stuff result MSB bits with signed bit.
+	for(i = (MPI_VALUE_BIT_NUM_MAX - StuffBitNum); i < MPI_VALUE_BIT_NUM_MAX; i++)
+		MpiSetBit(pResult, i, SignedBit);
+
+
+	// Minimize result bit number.
+	MpiMinimizeBitNum(pResult);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Shift multiple precision signed integer toward left.
+
+Use MpiLeftShift() to shift arbitrary precision signed integer toward left with assigned bit number.
+
+
+@param [out]   pResult       Pointer to an allocated memory for storing result
+@param [in]    Operand       Operand
+@param [in]    ShiftBitNum   Shift bit number
+
+
+@note
+	The result bit number will be minimized in MpiLeftShift().
+
+*/
+void
+MpiLeftShift(
+	MPI *pResult,
+	MPI Operand,
+	unsigned long ShiftBitNum
+	)
+{
+	unsigned int i;
+	unsigned long StuffBitNum;
+	unsigned char CurrentBit;
+
+
+	// Determine stuff bit number according to shift bit nubmer.
+	StuffBitNum = (ShiftBitNum < MPI_VALUE_BIT_NUM_MAX) ? ShiftBitNum : MPI_VALUE_BIT_NUM_MAX;
+
+
+	// Stuff result LSB bits with zeros
+	for(i = 0; i < StuffBitNum; i++)
+		MpiSetBit(pResult, i, 0x0);
+
+
+	// Copy operand bits to result with stuff bit number.
+	for(i = StuffBitNum; i < MPI_VALUE_BIT_NUM_MAX; i++)
+	{
+		MpiGetBit(Operand, i - StuffBitNum, &CurrentBit);
+		MpiSetBit(pResult, i, CurrentBit);
+	}
+
+
+	// Minimize result bit number.
+	MpiMinimizeBitNum(pResult);
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Compare multiple precision signed integes with equal-to criterion.
+
+Use MpiEqualTo() to compare multiple precision signed integes with equal-to criterion.
+
+
+@param [in]   MpiLeft    Left MPI
+@param [in]   MpiRight   Right MPI
+
+
+@retval   MPI_NO    "Left MPI == Right MPI" is false.
+@retval   MPI_YES   "Left MPI == Right MPI" is true.
+
+
+@note
+	The constants MPI_YES and MPI_NO are defined in MPI_YES_NO_STATUS enumeration.
+
+*/
+int
+MpiEqualTo(
+	MPI MpiLeft,
+	MPI MpiRight
+	)
+{
+	unsigned int i;
+
+
+
+	// Check not-equal-to condition.
+	for(i = 0; i < MPI_VALUE_BYTE_NUM_MAX; i++)
+	{
+		if(MpiLeft.Value[i] != MpiRight.Value[i])
+			goto condition_others;
+	}
+		
+
+	// Right MPI is greater than left MPI.
+	return MPI_YES;
+
+
+condition_others:
+
+
+	// Other conditions.
+	return MPI_NO;
+}
+
+
+
+
+
+/**
+
+@brief   Compare multiple precision signed integes with greater-than criterion.
+
+Use MpiGreaterThan() to compare multiple precision signed integes with greater-than criterion.
+
+
+@param [in]   MpiLeft    Left MPI
+@param [in]   MpiRight   Right MPI
+
+
+@retval   MPI_NO    "Left MPI > Right MPI" is false.
+@retval   MPI_YES   "Left MPI > Right MPI" is true.
+
+
+@note
+	The constants MPI_YES and MPI_NO are defined in MPI_YES_NO_STATUS enumeration.
+
+*/
+int
+MpiGreaterThan(
+	MPI MpiLeft,
+	MPI MpiRight
+	)
+{
+	MPI MiddleResult;
+	unsigned char SignedBit;
+
+
+
+	// Check equal-to condition.
+	if(MpiEqualTo(MpiLeft, MpiRight) == MPI_YES)
+		goto condition_others;
+
+
+	// Subtract right MPI form left MPI.
+	MpiSub(&MiddleResult, MpiLeft, MpiRight);
+
+
+	// Check less-than condition.
+	MpiGetSignedBit(MiddleResult, &SignedBit);
+
+	if(SignedBit == 0x1)
+		goto condition_others;
+
+
+	// Right MPI is greater than left MPI.
+	return MPI_YES;
+
+
+condition_others:
+
+
+	// Other conditions.
+	return MPI_NO;
+}
+
+
+
+
+
+/**
+
+@brief   Compare multiple precision signed integes with less-than criterion.
+
+Use MpiLessThan() to compare multiple precision signed integes with less-than criterion.
+
+
+@param [in]   MpiLeft    Left MPI
+@param [in]   MpiRight   Right MPI
+
+
+@retval   MPI_NO    "Left MPI < Right MPI" is false.
+@retval   MPI_YES   "Left MPI < Right MPI" is true.
+
+
+@note
+	The constants MPI_YES and MPI_NO are defined in MPI_YES_NO_STATUS enumeration.
+
+*/
+int
+MpiLessThan(
+	MPI MpiLeft,
+	MPI MpiRight
+	)
+{
+	MPI MiddleResult;
+	unsigned char SignedBit;
+
+
+
+	// Check equal-to condition.
+	if(MpiEqualTo(MpiLeft, MpiRight) == MPI_YES)
+		goto condition_others;
+
+
+	// Subtract right MPI form left MPI.
+	MpiSub(&MiddleResult, MpiLeft, MpiRight);
+
+
+	// Check greater-than condition.
+	MpiGetSignedBit(MiddleResult, &SignedBit);
+
+	if(SignedBit == 0x0)
+		goto condition_others;
+
+
+	// Right MPI is less than left MPI.
+	return MPI_YES;
+
+
+condition_others:
+
+
+	// Other conditions.
+	return MPI_NO;
+}
+
+
+
+
+
+/**
+
+@brief   Minimize multiple precision signed integer bit number.
+
+Use MpiMinimizeBitNum() to minimize multiple precision signed integer MPI bit number.
+
+
+@param [in]   pMpiVar   Pointer to an allocated memory for storing result
+
+*/
+void
+MpiMinimizeBitNum(
+	MPI *pMpiVar
+	)
+{
+	int i;
+	unsigned char SignedBit;
+	unsigned char BitValue;
+
+
+
+	// Get signed bit form MPI;
+	MpiGetSignedBit(*pMpiVar, &SignedBit);
+
+
+	// Find MPI MSB position.
+	// Note: The MSB of signed integer is the rightest signed bit.
+	for(i = (MPI_VALUE_BIT_NUM_MAX - 2); i > -1; i--)
+	{
+		// Get current bit value.
+		MpiGetBit(*pMpiVar, i, &BitValue);
+
+		// Compare current bit with signed bit.
+		if(BitValue != SignedBit)
+			break;
+	}
+
+
+	// Set MPI bit number.
+	// Note: MPI bit number must be greater than one.
+	pMpiVar->BitNum = (i == -1) ? 2 : (i + 2);
+
+
+	return;
+}
+
+
+
+
+
+
+/**
+
+@brief   Calculate multiple precision signed integer logarithm with base 2.
+
+Use MpiMinimizeBitNum() to calculate multiple precision signed integer logarithm with base 2.
+
+
+@param [out]   pResult            Pointer to an allocated memory for storing result (unit: pow(2, - ResultFracBitNum))
+@param [in]    MpiVar             MPI variable for calculating
+@param [in]    ResultFracBitNum   Result fraction bit number
+
+
+@note
+	-# MPI variable bit number must be minimized.
+	-# MPI variable bit number must be less than (MPI_VALUE_BIT_NUM_MAX / 2 + 1).
+    -# MPI variable must be greater than zero.
+	-# If MPI variable is zero, the result is zero in MpiLog2().
+	-# The result bit number will be minimized in MpiLog2().
+
+*/
+void
+MpiLog2(
+	MPI *pResult,
+	MPI MpiVar,
+	unsigned long ResultFracBitNum
+	)
+{
+	unsigned int i;
+	MPI MiddleResult;
+	unsigned char BitValue;
+
+
+
+	// Get integer part of MPI logarithm result with base 2.
+	MpiSetValue(pResult, (long)(MpiVar.BitNum - 2));
+
+
+	// Get fraction part of MPI logarithm result with base 2 by logarithm algorithm.
+	// Note: Take middle result format as follows:
+	//                         x x . x x ~ x
+	//       (integer part 2 bits) . (fraction part MPI_LOG_MIDDLE_RESULT_FRAC_BIT_NUM bits)
+	
+	// Set middle result with initial value.
+	MpiLeftShift(&MiddleResult, MpiVar, (MPI_LOG_MIDDLE_RESULT_FRAC_BIT_NUM - MpiVar.BitNum + 2));
+
+	// Calculate result fraction bits.
+	for(i = 0; i < ResultFracBitNum; i++)
+	{
+		// Shift result toward left with one bit.
+		// Note: MpiLeftShift() will minimize result bit number.
+		MpiLeftShift(pResult, *pResult, 1);
+
+		// Square middle result.
+		MpiMul(&MiddleResult, MiddleResult, MiddleResult);
+
+		// Shift middle result toward right with fraction bit num.
+		MpiRightShift(&MiddleResult, MiddleResult, MPI_LOG_MIDDLE_RESULT_FRAC_BIT_NUM);
+
+		// Get middle result integer part bit 1.
+		MpiGetBit(MiddleResult, MPI_LOG_MIDDLE_RESULT_FRAC_BIT_NUM + 1, &BitValue);
+
+		// If middle result integer part bit 1 is equal to 0x1,
+		// shift middle result with one bit toward right and set result LSB with one.
+		if(BitValue == 0x1)
+		{
+			MpiRightShift(&MiddleResult, MiddleResult, 1);
+			MpiSetBit(pResult, 0, 0x1);
+		}
+	}
+
+
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/math_mpi.h b/drivers/media/usb/rtl2832u/math_mpi.h
new file mode 100644
index 00000000..73a7d1d0
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/math_mpi.h
@@ -0,0 +1,201 @@
+#ifndef __MATH_MPI_H
+#define __MATH_MPI_H
+
+/**
+
+@file
+
+@brief   Mutliple precision integer (MPI) arithmetic declaration
+
+One can use to mutliple precision arithmetic to manipulate large signed integers.
+
+*/
+
+
+
+
+
+// Constant
+#define MPI_BYTE_BIT_NUM			8
+#define MPI_LONG_BYTE_NUM			4
+#define MPI_LONG_BIT_NUM			32
+
+
+
+// Mask and shift
+#define MPI_BYTE_MASK				0xff
+#define MPI_BYTE_SHIFT				8
+
+#define MPI_BIT_0_MASK				0x1
+#define MPI_BIT_7_SHIFT				7
+
+
+
+// Multiple precision integer definition
+#define MPI_VALUE_BYTE_NUM_MAX		10												///<   Maximum MPI value byte number
+#define MPI_VALUE_BIT_NUM_MAX		(MPI_VALUE_BYTE_NUM_MAX * MPI_BYTE_BIT_NUM)		///<   Maximum MPI value bit number
+
+/// Multiple precision integer structure
+typedef struct
+{
+	unsigned long BitNum;
+	unsigned char Value[MPI_VALUE_BYTE_NUM_MAX];
+}
+MPI;
+
+
+
+///  MPI yes/no status
+enum MPI_YES_NO_STATUS
+{
+	MPI_NO,			///<   No
+	MPI_YES,		///<   Yes
+};
+
+
+
+// Logarithm with base 2
+#define MPI_LOG_MIDDLE_RESULT_FRAC_BIT_NUM			(MPI_VALUE_BIT_NUM_MAX / 2 - 2)
+
+
+
+
+
+// MPI access
+void
+MpiSetValue(
+	MPI *pMpiVar,
+	long Value
+	);
+
+void
+MpiGetValue(
+	MPI MpiVar,
+	long *pValue
+	);
+
+void
+MpiSetBit(
+	MPI *pMpiVar,
+	unsigned long BitPosition,
+	unsigned char BitValue
+	);
+
+void
+MpiGetBit(
+	MPI MpiVar,
+	unsigned long BitPosition,
+	unsigned char *pBitValue
+	);
+
+void
+MpiGetSignedBit(
+	MPI MpiVar,
+	unsigned char *pSignedBit
+	);
+
+
+
+// MPI operator
+void
+MpiAssign(
+	MPI *pResult,
+	MPI Operand
+	);
+
+void
+MpiUnaryMinus(
+	MPI *pResult,
+	MPI Operand
+	);
+
+void
+MpiAdd(
+	MPI *pSum,
+	MPI Augend,
+	MPI Addend
+	);
+
+void
+MpiSub(
+	MPI *pDifference,
+	MPI Minuend,
+	MPI Subtrahend
+	);
+
+void
+MpiMul(
+	MPI *pProduct,
+	MPI Multiplicand,
+	MPI Multiplicator
+	);
+
+void
+MpiDiv(
+	MPI *pQuotient,
+	MPI *pRemainder,
+	MPI Dividend,
+	MPI Divisor
+	);
+
+void
+MpiRightShift(
+	MPI *pResult,
+	MPI Operand,
+	unsigned long ShiftBitNum
+	);
+
+void
+MpiLeftShift(
+	MPI *pResult,
+	MPI Operand,
+	unsigned long ShiftBitNum
+	);
+
+int
+MpiEqualTo(
+	MPI MpiLeft,
+	MPI MpiRight
+	);
+
+int
+MpiGreaterThan(
+	MPI MpiLeft,
+	MPI MpiRight
+	);
+
+int
+MpiLessThan(
+	MPI MpiLeft,
+	MPI MpiRight
+	);
+
+void
+MpiMinimizeBitNum(
+	MPI *pMpiVar
+	);
+
+
+
+// MPI special function
+void
+MpiLog2(
+	MPI *pResult,
+	MPI MpiVar,
+	unsigned long ResultFracBitNum
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.c b/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.c
new file mode 100644
index 00000000..c2e9df8e
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.c
@@ -0,0 +1,1001 @@
+/**
+
+@file
+
+@brief   RTL2832 E4000 NIM module definition
+
+One can manipulate RTL2832 E4000 NIM through RTL2832 E4000 NIM module.
+RTL2832 E4000 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_e4000.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 E4000 NIM module builder
+
+Use BuildRtl2832E4000Module() to build RTL2832 E4000 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 E4000 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              E4000 I2C device address
+@param [in]   TunerCrystalFreqHz           E4000 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildRtl2832E4000Module() to build RTL2832 E4000 NIM module before using it.
+
+*/
+void
+BuildRtl2832E4000Module(
+	DVBT_NIM_MODULE **ppNim,									// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+	RTL2832_E4000_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832E4000);
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_E4000;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build E4000 tuner module.
+	BuildE4000Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_e4000_Initialize;
+	pNim->SetParameters  = rtl2832_e4000_SetParameters;
+	pNim->UpdateFunction = rtl2832_e4000_UpdateFunction;
+
+
+	// Initialize NIM extra module variables.
+	pNimExtra->TunerModeUpdateWaitTimeMax = 
+		DivideWithCeiling(RTL2832_E4000_TUNER_MODE_UPDATE_WAIT_TIME_MS, DemodUpdateFuncRefPeriodMs);
+	pNimExtra->TunerModeUpdateWaitTime    = 0;
+	pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_e4000_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_E4000_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x18    },
+		{DVBT_LOOP_GAIN2_3_0,		0x8		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x18	},
+
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x14	},
+		{DVBT_THD_DW1,				0xec	},
+
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+
+		{DVBT_REG_GPE,				0x1		},
+		{DVBT_REG_GPO,				0x1		},
+		{DVBT_REG_MONSEL,			0x1		},
+		{DVBT_REG_MON,				0x1		},
+		{DVBT_REG_4MSEL,			0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_E4000_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+int
+rtl2832_e4000_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_E4000_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x18    },
+		{DVBT_LOOP_GAIN2_3_0,		0x8		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x18	},
+
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x14	},
+		{DVBT_THD_DW1,				0xec	},
+
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+
+		{DVBT_REG_GPE,				0x1		},
+		{DVBT_REG_GPO,				0x1		},
+		{DVBT_REG_MONSEL,			0x1		},
+		{DVBT_REG_MON,				0x1		},
+		{DVBT_REG_4MSEL,			0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	//if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	//if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	//if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_E4000_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_e4000_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	E4000_EXTRA_MODULE *pTunerExtra;
+	RTL2832_E4000_EXTRA_MODULE *pNimExtra;
+
+	unsigned long TunerBandwidthHz;
+
+	int RfFreqKhz;
+	int BandwidthKhz;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.E4000);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832E4000);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)//added by annie
+		goto error_status_execute_function;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthHz according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth Hz with TunerBandwidthHz.
+	if(pTunerExtra->SetBandwidthHz(pTuner, TunerBandwidthHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner gain mode with normal condition for update procedure.
+	RfFreqKhz = (int)((RfFreqHz + 500) / 1000);
+	BandwidthKhz = (int)((TunerBandwidthHz + 500) / 1000);
+
+	if(E4000_nominal(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+//	if(E4000_sensitivity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+//	if(E4000_linearity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
+
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+int
+rtl2832_e4000_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	E4000_EXTRA_MODULE *pTunerExtra;
+	RTL2832_E4000_EXTRA_MODULE *pNimExtra;
+
+	unsigned long TunerBandwidthHz;
+
+	int RfFreqKhz;
+	int BandwidthKhz;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.E4000);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832E4000);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)//added by annie
+		goto error_status_execute_function;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthHz according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthHz = E4000_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth Hz with TunerBandwidthHz.
+	if(pTunerExtra->SetBandwidthHz(pTuner, TunerBandwidthHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner gain mode with normal condition for update procedure.
+	RfFreqKhz = (int)((RfFreqHz + 500) / 1000);
+	BandwidthKhz = (int)((TunerBandwidthHz + 500) / 1000);
+
+	if(E4000_nominal(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)//change by annie
+//	if(E4000_sensitivity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+//	if(E4000_linearity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
+
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+/**
+
+@see   DVBT_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2832_e4000_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	RTL2832_E4000_EXTRA_MODULE *pNimExtra;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832E4000);
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Increase tuner mode update waiting time.
+	pNimExtra->TunerModeUpdateWaitTime += 1;
+
+
+	// Check if need to update tuner mode according to update waiting time.
+	if(pNimExtra->TunerModeUpdateWaitTime == pNimExtra->TunerModeUpdateWaitTimeMax)
+	{
+		// Reset update waiting time.
+		pNimExtra->TunerModeUpdateWaitTime = 0;
+
+		// Enable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+
+		// Update tuner mode.
+		if(rtl2832_e4000_UpdateTunerMode(pNim) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Update tuner mode.
+
+One can use rtl2832_e4000_UpdateTunerMode() to update tuner mode.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update tuner mode successfully.
+@retval   FUNCTION_ERROR     Update tuner mode unsuccessfully.
+
+*/
+int
+rtl2832_e4000_UpdateTunerMode(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	static const long LnaGainTable[RTL2832_E4000_LNA_GAIN_TABLE_LEN][RTL2832_E4000_LNA_GAIN_BAND_NUM] =
+	{
+		// VHF Gain,	UHF Gain,		ReadingByte
+		{-50,			-50	},		//	0x0
+		{-25,			-25	},		//	0x1
+		{-50,			-50	},		//	0x2
+		{-25,			-25	},		//	0x3
+		{0,				0	},		//	0x4
+		{25,			25	},		//	0x5
+		{50,			50	},		//	0x6
+		{75,			75	},		//	0x7
+		{100,			100	},		//	0x8
+		{125,			125	},		//	0x9
+		{150,			150	},		//	0xa
+		{175,			175	},		//	0xb
+		{200,			200	},		//	0xc
+		{225,			250	},		//	0xd
+		{250,			280	},		//	0xe
+		{250,			280	},		//	0xf
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long LnaGainAddTable[RTL2832_E4000_LNA_GAIN_ADD_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		NO_USE,		//	0x0
+		NO_USE,		//	0x1
+		NO_USE,		//	0x2
+		0,			//	0x3
+		NO_USE,		//	0x4
+		20,			//	0x5
+		NO_USE,		//	0x6
+		70,			//	0x7
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long MixerGainTable[RTL2832_E4000_MIXER_GAIN_TABLE_LEN][RTL2832_E4000_MIXER_GAIN_BAND_NUM] =
+	{
+		// VHF Gain,	UHF Gain,		ReadingByte
+		{90,			40	},		//	0x0
+		{170,			120	},		//	0x1
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage1GainTable[RTL2832_E4000_IF_STAGE_1_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		-30,		//	0x0
+		60,			//	0x1
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage2GainTable[RTL2832_E4000_IF_STAGE_2_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		0,			//	0x0
+		30,			//	0x1
+		60,			//	0x2
+		90,			//	0x3
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage3GainTable[RTL2832_E4000_IF_STAGE_3_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		0,			//	0x0
+		30,			//	0x1
+		60,			//	0x2
+		90,			//	0x3
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage4GainTable[RTL2832_E4000_IF_STAGE_4_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		0,			//	0x0
+		10,			//	0x1
+		20,			//	0x2
+		20,			//	0x3
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage5GainTable[RTL2832_E4000_IF_STAGE_5_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		0,			//	0x0
+		30,			//	0x1
+		60,			//	0x2
+		90,			//	0x3
+		120,		//	0x4
+		120,		//	0x5
+		120,		//	0x6
+		120,		//	0x7
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+	static const long IfStage6GainTable[RTL2832_E4000_IF_STAGE_6_GAIN_TABLE_LEN] =
+	{
+		// Gain,		ReadingByte
+		0,			//	0x0
+		30,			//	0x1
+		60,			//	0x2
+		90,			//	0x3
+		120,		//	0x4
+		120,		//	0x5
+		120,		//	0x6
+		120,		//	0x7
+
+		// Note: The gain unit is 0.1 dB.
+	};
+
+
+	TUNER_MODULE *pTuner;
+	E4000_EXTRA_MODULE *pTunerExtra;
+	RTL2832_E4000_EXTRA_MODULE *pNimExtra;
+
+	unsigned long RfFreqHz;
+	int RfFreqKhz;
+	unsigned long BandwidthHz;
+	int BandwidthKhz;
+
+	unsigned char ReadingByte;
+	int BandIndex;
+
+	unsigned char TunerBitsLna, TunerBitsLnaAdd, TunerBitsMixer;
+	unsigned char TunerBitsIfStage1, TunerBitsIfStage2, TunerBitsIfStage3, TunerBitsIfStage4;
+	unsigned char TunerBitsIfStage5, TunerBitsIfStage6;
+
+	long TunerGainLna, TunerGainLnaAdd, TunerGainMixer;
+	long TunerGainIfStage1, TunerGainIfStage2, TunerGainIfStage3, TunerGainIfStage4;
+	long TunerGainIfStage5, TunerGainIfStage6;
+
+	long TunerGainTotal;
+	long TunerInputPower;
+
+
+	// Get tuner module.
+	pTuner = pNim->pTuner;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.E4000);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832E4000);
+
+
+	// Get tuner RF frequency in KHz.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	if(pTuner->GetRfFreqHz(pTuner, &RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	RfFreqKhz = (int)((RfFreqHz + 500) / 1000);
+
+	// Get tuner bandwidth in KHz.
+	// Note: BandwidthKhz = round(BandwidthHz / 1000)
+	if(pTunerExtra->GetBandwidthHz(pTuner, &BandwidthHz) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	BandwidthKhz = (int)((BandwidthHz + 500) / 1000);
+
+
+	// Determine band index.
+	BandIndex = (RfFreqHz < RTL2832_E4000_RF_BAND_BOUNDARY_HZ) ? 0 : 1;
+
+
+	// Get tuner LNA gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_LNA_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsLna = (ReadingByte & RTL2832_E4000_LNA_GAIN_MASK) >> RTL2832_E4000_LNA_GAIN_SHIFT;
+	TunerGainLna = LnaGainTable[TunerBitsLna][BandIndex];
+
+
+	// Get tuner LNA additional gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_LNA_GAIN_ADD_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsLnaAdd = (ReadingByte & RTL2832_E4000_LNA_GAIN_ADD_MASK) >> RTL2832_E4000_LNA_GAIN_ADD_SHIFT;
+	TunerGainLnaAdd = LnaGainAddTable[TunerBitsLnaAdd];
+
+
+	// Get tuner mixer gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_MIXER_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsMixer = (ReadingByte & RTL2832_E4000_MIXER_GAIN_MASK) >> RTL2832_E4000_LNA_GAIN_ADD_SHIFT;
+	TunerGainMixer = MixerGainTable[TunerBitsMixer][BandIndex];
+
+
+	// Get tuner IF stage 1 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_1_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage1 = (ReadingByte & RTL2832_E4000_IF_STAGE_1_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_1_GAIN_SHIFT;
+	TunerGainIfStage1 = IfStage1GainTable[TunerBitsIfStage1];
+
+
+	// Get tuner IF stage 2 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_2_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage2 = (ReadingByte & RTL2832_E4000_IF_STAGE_2_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_2_GAIN_SHIFT;
+	TunerGainIfStage2 = IfStage2GainTable[TunerBitsIfStage2];
+
+
+	// Get tuner IF stage 3 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_3_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage3 = (ReadingByte & RTL2832_E4000_IF_STAGE_3_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_3_GAIN_SHIFT;
+	TunerGainIfStage3 = IfStage3GainTable[TunerBitsIfStage3];
+
+
+	// Get tuner IF stage 4 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_4_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage4 = (ReadingByte & RTL2832_E4000_IF_STAGE_4_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_4_GAIN_SHIFT;
+	TunerGainIfStage4 = IfStage4GainTable[TunerBitsIfStage4];
+
+
+	// Get tuner IF stage 5 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_5_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage5 = (ReadingByte & RTL2832_E4000_IF_STAGE_5_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_5_GAIN_SHIFT;
+	TunerGainIfStage5 = IfStage5GainTable[TunerBitsIfStage5];
+
+
+	// Get tuner IF stage 6 gain according to reading byte and table.
+	if(pTunerExtra->GetRegByte(pTuner, RTL2832_E4000_IF_STAGE_6_GAIN_ADDR, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	TunerBitsIfStage6 = (ReadingByte & RTL2832_E4000_IF_STAGE_6_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_6_GAIN_SHIFT;
+	TunerGainIfStage6 = IfStage6GainTable[TunerBitsIfStage6];
+
+
+	// Calculate tuner total gain.
+	// Note: The unit of tuner total gain is 0.1 dB.
+	TunerGainTotal = TunerGainLna + TunerGainLnaAdd + TunerGainMixer + 
+	                 TunerGainIfStage1 + TunerGainIfStage2 + TunerGainIfStage3 + TunerGainIfStage4 +
+	                 TunerGainIfStage5 + TunerGainIfStage6;
+
+	// Calculate tuner input power.
+	// Note: The unit of tuner input power is 0.1 dBm
+	TunerInputPower = RTL2832_E4000_TUNER_OUTPUT_POWER_UNIT_0P1_DBM - TunerGainTotal;
+
+
+	// Determine tuner gain mode according to tuner input power.
+	// Note: The unit of tuner input power is 0.1 dBm
+	switch(pNimExtra->TunerGainMode)
+	{
+		default:
+		case RTL2832_E4000_TUNER_GAIN_SENSITIVE:
+
+			if(TunerInputPower > -650)
+				pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
+
+			break;
+
+
+		case RTL2832_E4000_TUNER_GAIN_NORMAL:
+
+			if(TunerInputPower < -750)
+				pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_SENSITIVE;
+
+			if(TunerInputPower > -400)
+				pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_LINEAR;
+
+			break;
+
+
+		case RTL2832_E4000_TUNER_GAIN_LINEAR:
+
+			if(TunerInputPower < -500)
+				pNimExtra->TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
+
+			break;
+	}
+
+
+	// Set tuner gain mode.
+	switch(pNimExtra->TunerGainMode)
+	{
+		default:
+		case RTL2832_E4000_TUNER_GAIN_SENSITIVE:
+
+			if(E4000_sensitivity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+				goto error_status_execute_function;
+
+			break;
+
+
+		case RTL2832_E4000_TUNER_GAIN_NORMAL:
+
+			if(E4000_nominal(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+				goto error_status_execute_function;
+
+			break;
+
+
+		case RTL2832_E4000_TUNER_GAIN_LINEAR:
+
+			if(E4000_linearity(pTuner, RfFreqKhz, BandwidthKhz) != E4000_1_SUCCESS)
+				goto error_status_execute_function;
+
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_get_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.h b/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.h
new file mode 100644
index 00000000..e23c2771
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_e4000.h
@@ -0,0 +1,226 @@
+#ifndef __NIM_RTL2832_E4000
+#define __NIM_RTL2832_E4000
+
+/**
+
+@file
+
+@brief   RTL2832 E4000 NIM module declaration
+
+One can manipulate RTL2832 E4000 NIM through RTL2832 E4000 NIM module.
+RTL2832 E4000 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_e4000.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 E4000 NIM module.
+	BuildRtl2832E4000Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,									// Maximum I2C reading byte number is 9.
+		8,									// Maximum I2C writing byte number is 8.
+		CustomI2cRead,						// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,						// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,						// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,								// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,				// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,			// The RTL2832 application mode is STB mode.
+		200,								// The RTL2832 update function reference period is 200 millisecond
+		YES,								// The RTL2832 Function 1 enabling status is YES.
+
+		0xc8,								// The E4000 I2C device address is 0xc8 in 8-bit format.
+		CRYSTAL_FREQ_26000000HZ				// The E4000 crystal frequency is 26 MHz.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_e4000.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_E4000_ADDITIONAL_INIT_REG_TABLE_LEN		34
+
+#define RTL2832_E4000_LNA_GAIN_TABLE_LEN				16
+#define RTL2832_E4000_LNA_GAIN_ADD_TABLE_LEN			8
+#define RTL2832_E4000_MIXER_GAIN_TABLE_LEN				2
+#define RTL2832_E4000_IF_STAGE_1_GAIN_TABLE_LEN			2
+#define RTL2832_E4000_IF_STAGE_2_GAIN_TABLE_LEN			4
+#define RTL2832_E4000_IF_STAGE_3_GAIN_TABLE_LEN			4
+#define RTL2832_E4000_IF_STAGE_4_GAIN_TABLE_LEN			4
+#define RTL2832_E4000_IF_STAGE_5_GAIN_TABLE_LEN			8
+#define RTL2832_E4000_IF_STAGE_6_GAIN_TABLE_LEN			8
+
+#define RTL2832_E4000_LNA_GAIN_BAND_NUM					2
+#define RTL2832_E4000_MIXER_GAIN_BAND_NUM				2
+
+#define RTL2832_E4000_RF_BAND_BOUNDARY_HZ				300000000
+
+#define RTL2832_E4000_LNA_GAIN_ADDR						0x14
+#define RTL2832_E4000_LNA_GAIN_MASK						0xf
+#define RTL2832_E4000_LNA_GAIN_SHIFT					0
+
+#define RTL2832_E4000_LNA_GAIN_ADD_ADDR					0x24
+#define RTL2832_E4000_LNA_GAIN_ADD_MASK					0x7
+#define RTL2832_E4000_LNA_GAIN_ADD_SHIFT				0
+
+#define RTL2832_E4000_MIXER_GAIN_ADDR					0x15
+#define RTL2832_E4000_MIXER_GAIN_MASK					0x1
+#define RTL2832_E4000_MIXER_GAIN_SHIFT					0
+
+#define RTL2832_E4000_IF_STAGE_1_GAIN_ADDR				0x16
+#define RTL2832_E4000_IF_STAGE_1_GAIN_MASK				0x1
+#define RTL2832_E4000_IF_STAGE_1_GAIN_SHIFT				0
+
+#define RTL2832_E4000_IF_STAGE_2_GAIN_ADDR				0x16
+#define RTL2832_E4000_IF_STAGE_2_GAIN_MASK				0x6
+#define RTL2832_E4000_IF_STAGE_2_GAIN_SHIFT				1
+
+#define RTL2832_E4000_IF_STAGE_3_GAIN_ADDR				0x16
+#define RTL2832_E4000_IF_STAGE_3_GAIN_MASK				0x18
+#define RTL2832_E4000_IF_STAGE_3_GAIN_SHIFT				3
+
+#define RTL2832_E4000_IF_STAGE_4_GAIN_ADDR				0x16
+#define RTL2832_E4000_IF_STAGE_4_GAIN_MASK				0x60
+#define RTL2832_E4000_IF_STAGE_4_GAIN_SHIFT				5
+
+#define RTL2832_E4000_IF_STAGE_5_GAIN_ADDR				0x17
+#define RTL2832_E4000_IF_STAGE_5_GAIN_MASK				0x7
+#define RTL2832_E4000_IF_STAGE_5_GAIN_SHIFT				0
+
+#define RTL2832_E4000_IF_STAGE_6_GAIN_ADDR				0x17
+#define RTL2832_E4000_IF_STAGE_6_GAIN_MASK				0x38
+#define RTL2832_E4000_IF_STAGE_6_GAIN_SHIFT				3
+
+#define RTL2832_E4000_TUNER_OUTPUT_POWER_UNIT_0P1_DBM	-100
+
+#define RTL2832_E4000_TUNER_MODE_UPDATE_WAIT_TIME_MS	1000
+
+
+// Tuner gain mode
+enum RTL2832_E4000_TUNER_GAIN_MODE
+{
+	RTL2832_E4000_TUNER_GAIN_SENSITIVE,
+	RTL2832_E4000_TUNER_GAIN_NORMAL,
+	RTL2832_E4000_TUNER_GAIN_LINEAR,
+};
+
+
+
+
+
+// Builder
+void
+BuildRtl2832E4000Module(
+	DVBT_NIM_MODULE **ppNim,									// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	);
+
+
+
+
+
+// RTL2832 E4000 NIM manipulaing functions
+int
+rtl2832_e4000_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_e4000_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+int
+rtl2832_e4000_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_e4000_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_e4000_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_e4000_UpdateTunerMode(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.c b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.c
new file mode 100644
index 00000000..0db94c75
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.c
@@ -0,0 +1,840 @@
+/**
+
+@file
+
+@brief   RTL2832 FC0012 NIM module definition
+
+One can manipulate RTL2832 FC0012 NIM through RTL2832 FC0012 NIM module.
+RTL2832 FC0012 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_fc0012.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 FC0012 NIM module builder
+
+Use BuildRtl2832Fc0012Module() to build RTL2832 FC0012 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 FC0012 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              FC0012 I2C device address
+@param [in]   TunerCrystalFreqHz           FC0012 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildRtl2832Fc0012Module() to build RTL2832 FC0012 NIM module before using it.
+
+*/
+void
+BuildRtl2832Fc0012Module(
+	DVBT_NIM_MODULE **ppNim,								// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+	RTL2832_FC0012_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0012);
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_FC0012;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build FC0012 tuner module.
+	BuildFc0012Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_fc0012_Initialize;
+	pNim->SetParameters  = rtl2832_fc0012_SetParameters;
+	pNim->UpdateFunction = rtl2832_fc0012_UpdateFunction;
+
+
+	// Initialize NIM extra module variables.
+	pNimExtra->LnaUpdateWaitTimeMax = DivideWithCeiling(RTL2832_FC0012_LNA_UPDATE_WAIT_TIME_MS, DemodUpdateFuncRefPeriodMs);
+	pNimExtra->LnaUpdateWaitTime    = 0;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_fc0012_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_FC0012_DAB_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9bf	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x11	},
+		{DVBT_THD_DW1,				0xef	},
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+
+		//test
+		{DVBT_AD_EN_REG,			0x1		},
+		{DVBT_AD_EN_REG1,			0x1		},
+//		{DVBT_EN_BK_TRK,			0x0		},
+//		{DVBT_AD_AV_REF,			0x2a	},
+//		{DVBT_REG_PI,				0x3		},
+		//----------
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0xd, 7, 0, 0x2) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0x11, 7, 0, 0x0) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0x15, 7, 0, 0x4) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	//if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	//if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_FC0012_DAB_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Get tuner RSSI value when calibration is on.
+	// Note: Need to execute rtl2832_fc0012_GetTunerRssiCalOn() after demod AD7 is on.
+	if(rtl2832_fc0012_GetTunerRssiCalOn(pNim) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_fc0012_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_FC0012_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9bf	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x11	},
+		{DVBT_THD_DW1,				0xef	},
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+//		{DVBT_REG_GPE,				0x1		},
+//		{DVBT_REG_GPO,				0x0		},
+//		{DVBT_REG_MONSEL,			0x0		},
+//		{DVBT_REG_MON,				0x3		},
+//		{DVBT_REG_4MSEL,			0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0xd, 7, 0, 0x2) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0x11, 7, 0, 0x0) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner registers.
+	if(fc0012_SetRegMaskBits(pTuner, 0x15, 7, 0, 0x4) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_FC0012_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Get tuner RSSI value when calibration is on.
+	// Note: Need to execute rtl2832_fc0012_GetTunerRssiCalOn() after demod AD7 is on.
+	if(rtl2832_fc0012_GetTunerRssiCalOn(pNim) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_fc0012_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	FC0012_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_fc0012_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	FC0012_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = FC0012_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+	
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2832_fc0012_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	RTL2832_FC0012_EXTRA_MODULE *pNimExtra;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0012);
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Increase tuner LNA_GAIN update waiting time.
+	pNimExtra->LnaUpdateWaitTime += 1;
+
+
+	// Check if need to update tuner LNA_GAIN according to update waiting time.
+	if(pNimExtra->LnaUpdateWaitTime == pNimExtra->LnaUpdateWaitTimeMax)
+	{
+		// Reset update waiting time.
+		pNimExtra->LnaUpdateWaitTime = 0;
+
+		// Enable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+
+		// Update tuner LNA gain with RSSI.
+		if(rtl2832_fc0012_UpdateTunerLnaGainWithRssi(pNim) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get tuner RSSI value when calibration is on.
+
+One can use rtl2832_fc0012_GetTunerRssiCalOn() to get tuner calibration-on RSSI value.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Get tuner calibration-on RSSI value successfully.
+@retval   FUNCTION_ERROR     Get tuner calibration-on RSSI value unsuccessfully.
+
+*/
+int
+rtl2832_fc0012_GetTunerRssiCalOn(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	FC0012_EXTRA_MODULE *pTunerExtra;
+	RTL2832_FC0012_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0012);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0012);
+
+
+	// Set tuner EN_CAL_RSSI to 0x1.
+	if(fc0012_SetRegMaskBits(pTuner, 0x9, 4, 4, 0x1) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner LNA_POWER_DOWN to 0x1.
+	if(fc0012_SetRegMaskBits(pTuner, 0x6, 0, 0, 0x1) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Get demod RSSI_R when tuner RSSI calibration is on.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSSI_R, &(pNimExtra->RssiRCalOn)) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set tuner EN_CAL_RSSI to 0x0.
+	if(fc0012_SetRegMaskBits(pTuner, 0x9, 4, 4, 0x0) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner LNA_POWER_DOWN to 0x0.
+	if(fc0012_SetRegMaskBits(pTuner, 0x6, 0, 0, 0x0) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Update tuner LNA_GAIN with RSSI.
+
+One can use rtl2832_fc0012_UpdateTunerLnaGainWithRssi() to update tuner LNA_GAIN with RSSI.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update tuner LNA_GAIN with RSSI successfully.
+@retval   FUNCTION_ERROR     Update tuner LNA_GAIN with RSSI unsuccessfully.
+
+*/
+int
+rtl2832_fc0012_UpdateTunerLnaGainWithRssi(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	FC0012_EXTRA_MODULE *pTunerExtra;
+	RTL2832_FC0012_EXTRA_MODULE *pNimExtra;
+
+	unsigned long RssiRCalOff;
+	long RssiRDiff;
+	unsigned char LnaGain;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0012);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0012);
+
+
+	// Get demod RSSI_R when tuner RSSI calibration in off.
+	// Note: Tuner EN_CAL_RSSI and LNA_POWER_DOWN are set to 0x0 after rtl2832_fc0012_GetTunerRssiCalOn() executing.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSSI_R, &RssiRCalOff) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Calculate RSSI_R difference.
+	RssiRDiff = RssiRCalOff - pNimExtra->RssiRCalOn;
+
+	// Get tuner LNA_GAIN.
+	if(fc0012_GetRegMaskBits(pTuner, 0x13, 4, 3, &LnaGain) != FC0012_I2C_SUCCESS)
+		goto error_status_get_registers;
+
+
+	deb_info("%s: current LnaGain = %d\n", __FUNCTION__, LnaGain);
+
+	// Determine next LNA_GAIN according to RSSI_R difference and current LNA_GAIN.
+	switch(LnaGain)
+	{
+		default:
+		case FC0012_LNA_GAIN_LOW:
+
+			if(RssiRDiff <= 0)
+				LnaGain = FC0012_LNA_GAIN_MIDDLE;
+
+			break;
+
+
+		case FC0012_LNA_GAIN_MIDDLE:
+
+			if(RssiRDiff >= 34)
+				LnaGain = FC0012_LNA_GAIN_LOW;
+
+			if(RssiRDiff <= 0)
+				LnaGain = FC0012_LNA_GAIN_HIGH;
+
+			break;
+
+
+		case FC0012_LNA_GAIN_HIGH:
+
+			if(RssiRDiff >= 8)
+				LnaGain = FC0012_LNA_GAIN_MIDDLE;
+
+			break;
+	}
+
+
+	deb_info("%s: next LnaGain = %d\n", __FUNCTION__, LnaGain);
+
+      
+	// Set tuner LNA_GAIN.
+	if(fc0012_SetRegMaskBits(pTuner, 0x13, 4, 3, LnaGain) != FC0012_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.h b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.h
new file mode 100644
index 00000000..befa45ad
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0012.h
@@ -0,0 +1,168 @@
+#ifndef __NIM_RTL2832_FC0012
+#define __NIM_RTL2832_FC0012
+
+/**
+
+@file
+
+@brief   RTL2832 FC0012 NIM module declaration
+
+One can manipulate RTL2832 FC0012 NIM through RTL2832 FC0012 NIM module.
+RTL2832 FC0012 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_fc0012.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 FC0012 NIM module.
+	BuildRtl2832Fc0012Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc6,							// The FC0012 I2C device address is 0xc6 in 8-bit format.
+		CRYSTAL_FREQ_36000000HZ			// The FC0012 crystal frequency is 36.0 MHz.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_fc0012.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_FC0012_DAB_ADDITIONAL_INIT_REG_TABLE_LEN		31
+#define RTL2832_FC0012_ADDITIONAL_INIT_REG_TABLE_LEN		29
+#define RTL2832_FC0012_LNA_UPDATE_WAIT_TIME_MS				1000
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Fc0012Module(
+	DVBT_NIM_MODULE **ppNim,									// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	);
+
+
+
+
+
+// RTL2832 FC0012 NIM manipulaing functions
+int
+rtl2832_fc0012_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0012_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0012_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_fc0012_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_fc0012_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0012_GetTunerRssiCalOn(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0012_UpdateTunerLnaGainWithRssi(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.c b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.c
new file mode 100644
index 00000000..16740f34
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.c
@@ -0,0 +1,1053 @@
+/**
+
+@file
+
+@brief   RTL2832 FC0013 NIM module definition
+
+One can manipulate RTL2832 FC0013 NIM through RTL2832 FC0013 NIM module.
+RTL2832 FC0013 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_fc0013.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 FC0013 NIM module builder
+
+Use BuildRtl2832Fc0013Module() to build RTL2832 FC0013 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 FC0013 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              FC0013 I2C device address
+@param [in]   TunerCrystalFreqHz           FC0013 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildRtl2832Fc0013Module() to build RTL2832 FC0013 NIM module before using it.
+
+*/
+void
+BuildRtl2832Fc0013Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+	RTL2832_FC0013_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0013);
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_FC0013;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build FC0013 tuner module.
+	BuildFc0013Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_fc0013_Initialize;
+	pNim->SetParameters  = rtl2832_fc0013_SetParameters;
+	pNim->UpdateFunction = rtl2832_fc0013_UpdateFunction;
+
+
+	// Initialize NIM extra module variables.
+	pNimExtra->LnaUpdateWaitTimeMax = DivideWithCeiling(RTL2832_FC0013_LNA_UPDATE_WAIT_TIME_MS, DemodUpdateFuncRefPeriodMs);
+	pNimExtra->LnaUpdateWaitTime    = 0;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_fc0013_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_FC0013_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9bf	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x11	},
+		{DVBT_THD_DW1,				0xef	},
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+//		{DVBT_REG_GPE,				0x1		},
+//		{DVBT_REG_GPO,				0x0		},
+//		{DVBT_REG_MONSEL,			0x0		},
+//		{DVBT_REG_MON,				0x3		},
+//		{DVBT_REG_4MSEL,			0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set FC0013 up-dowm AGC.
+	//(0xFE for master of dual).
+	//(0xFC for slave of dual, and for 2832 mini dongle).
+	if(fc0013_SetRegMaskBits(pTuner, 0x0c, 7, 0, 0xFC) != FC0013_I2C_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_FC0013_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Get tuner RSSI value when calibration is on.
+	// Note: Need to execute rtl2832_fc0013_GetTunerRssiCalOn() after demod AD7 is on.
+	if(rtl2832_fc0013_GetTunerRssiCalOn(pNim) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+error_status_set_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_fc0013_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_FC0013_DAB_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x5a	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9bf	},
+		{DVBT_EN_GI_PGA,			0x0		},
+		{DVBT_THD_LOCK_UP,			0x0		},
+		{DVBT_THD_LOCK_DW,			0x0		},
+		{DVBT_THD_UP1,				0x11	},
+		{DVBT_THD_DW1,				0xef	},
+		{DVBT_INTER_CNT_LEN,		0xc		},
+		{DVBT_GI_PGA_STATE,			0x0		},
+		{DVBT_EN_AGC_PGA,			0x1		},
+		
+		//test
+		{DVBT_AD_EN_REG,			0x1		},
+		{DVBT_AD_EN_REG1,			0x1		},
+//		{DVBT_EN_BK_TRK,			0x0		},
+//		{DVBT_AD_AV_REF,			0x2a	},
+//		{DVBT_REG_PI,				0x3		},
+		//----------
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set FC0013 up-dowm AGC.
+	//(0xFE for master of dual).
+	//(0xFC for slave of dual, and for 2832 mini dongle).
+	if(fc0013_SetRegMaskBits(pTuner, 0x0c, 7, 0, 0xFC) != FC0013_I2C_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	//if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		//goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	//if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	//if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_FC0013_DAB_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Get tuner RSSI value when calibration is on.
+	// Note: Need to execute rtl2832_fc0013_GetTunerRssiCalOn() after demod AD7 is on.
+	if(rtl2832_fc0013_GetTunerRssiCalOn(pNim) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+error_status_set_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_fc0013_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	FC0013_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset tuner IQ LPF BW.
+	if(pTunerExtra->RcCalReset(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner IQ LPF BW, val=-2 for D-book ACI test.
+	if(pTunerExtra->RcCalAdd(pTuner, -2) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_fc0013_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	FC0013_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = FC0013_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset tuner IQ LPF BW.
+	if(pTunerExtra->RcCalReset(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner IQ LPF BW, val=-2 for D-book ACI test.
+	if(pTunerExtra->RcCalAdd(pTuner, -2) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2832_fc0013_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	RTL2832_FC0013_EXTRA_MODULE *pNimExtra;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0013);
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Increase tuner LNA_GAIN update waiting time.
+	pNimExtra->LnaUpdateWaitTime += 1;
+
+
+	// Check if need to update tuner LNA_GAIN according to update waiting time.
+	if(pNimExtra->LnaUpdateWaitTime == pNimExtra->LnaUpdateWaitTimeMax)
+	{
+		// Reset update waiting time.
+		pNimExtra->LnaUpdateWaitTime = 0;
+
+		// Enable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+
+		// Update tuner LNA gain with RSSI.
+		if(rtl2832_fc0013_UpdateTunerLnaGainWithRssi(pNim) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get tuner RSSI value when calibration is on.
+
+One can use rtl2832_fc0013_GetTunerRssiCalOn() to get tuner calibration-on RSSI value.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Get tuner calibration-on RSSI value successfully.
+@retval   FUNCTION_ERROR     Get tuner calibration-on RSSI value unsuccessfully.
+
+*/
+int
+rtl2832_fc0013_GetTunerRssiCalOn(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	FC0013_EXTRA_MODULE *pTunerExtra;
+	RTL2832_FC0013_EXTRA_MODULE *pNimExtra;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0013);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0013);
+
+	// Get NIM base interface.
+	pBaseInterface = pNim->pBaseInterface;
+
+
+	// Set tuner EN_CAL_RSSI to 0x1.
+	if(fc0013_SetRegMaskBits(pTuner, 0x9, 4, 4, 0x1) != FC0013_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner LNA_POWER_DOWN to 0x1.
+	if(fc0013_SetRegMaskBits(pTuner, 0x6, 0, 0, 0x1) != FC0013_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Wait 100 ms.
+	pBaseInterface->WaitMs(pBaseInterface, 100);
+
+	// Get demod RSSI_R when tuner RSSI calibration is on.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSSI_R, &(pNimExtra->RssiRCalOn)) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Set tuner EN_CAL_RSSI to 0x0.
+	if(fc0013_SetRegMaskBits(pTuner, 0x9, 4, 4, 0x0) != FC0013_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner LNA_POWER_DOWN to 0x0.
+	if(fc0013_SetRegMaskBits(pTuner, 0x6, 0, 0, 0x0) != FC0013_I2C_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Update tuner LNA_GAIN with RSSI.
+
+One can use rtl2832_fc0013_UpdateTunerLnaGainWithRssi() to update tuner LNA_GAIN with RSSI.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update tuner LNA_GAIN with RSSI successfully.
+@retval   FUNCTION_ERROR     Update tuner LNA_GAIN with RSSI unsuccessfully.
+
+*/
+int
+rtl2832_fc0013_UpdateTunerLnaGainWithRssi(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	FC0013_EXTRA_MODULE *pTunerExtra;
+	RTL2832_FC0013_EXTRA_MODULE *pNimExtra;
+
+	unsigned long RssiRCalOff;
+	long RssiRDiff;
+	unsigned char LnaGain;
+	unsigned char ReadValue;
+
+	// added from Fitipower, 2011-2-23, v0.8
+	int boolVhfFlag;      // 0:false,  1:true
+	int boolEnInChgFlag;  // 0:false,  1:true
+	int intGainShift;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0013);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Fc0013);
+
+
+	// Get demod RSSI_R when tuner RSSI calibration in off.
+	// Note: Tuner EN_CAL_RSSI and LNA_POWER_DOWN are set to 0x0 after rtl2832_fc0013_GetTunerRssiCalOn() executing.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSSI_R, &RssiRCalOff) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// To avoid the wrong rssi calibration value in the environment with strong RF pulse signal.
+	if(RssiRCalOff < pNimExtra->RssiRCalOn)
+		pNimExtra->RssiRCalOn = RssiRCalOff;
+
+
+	// Calculate RSSI_R difference.
+	RssiRDiff = RssiRCalOff - pNimExtra->RssiRCalOn;
+
+	// Get tuner LNA_GAIN.
+	if(fc0013_GetRegMaskBits(pTuner, 0x14, 4, 0, &LnaGain) != FC0013_I2C_SUCCESS)
+		goto error_status_get_registers;
+
+
+	// Determine next LNA_GAIN according to RSSI_R difference and current LNA_GAIN.
+	switch(LnaGain)
+	{
+		default:
+
+			boolVhfFlag = 0;		
+			boolEnInChgFlag = 1;
+			intGainShift = 10;
+			LnaGain = FC0013_LNA_GAIN_HIGH_19;
+
+			// Set tuner LNA_GAIN.
+			if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+				goto error_status_set_registers;
+
+			break;
+
+
+		case FC0013_LNA_GAIN_HIGH_19:
+
+			if(RssiRDiff >= 10)
+			{
+				boolVhfFlag = 1;		
+				boolEnInChgFlag = 0;
+				intGainShift = 10;
+				LnaGain = FC0013_LNA_GAIN_HIGH_17;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+			else
+			{
+				goto success_status_Lna_Gain_No_Change;
+			}
+
+
+		case FC0013_LNA_GAIN_HIGH_17:
+			
+			if(RssiRDiff <= 2)
+			{
+				boolVhfFlag = 0;	
+				boolEnInChgFlag = 1;
+				intGainShift = 10;
+				LnaGain = FC0013_LNA_GAIN_HIGH_19;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+
+			else if(RssiRDiff >= 24)
+			{
+				boolVhfFlag = 0;	
+				boolEnInChgFlag = 0;
+				intGainShift = 7;
+				LnaGain = FC0013_LNA_GAIN_MIDDLE;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+
+			else
+			{
+				goto success_status_Lna_Gain_No_Change;
+			}
+
+
+		case FC0013_LNA_GAIN_MIDDLE:
+
+			if(RssiRDiff >= 38)
+			{
+				boolVhfFlag = 0;	
+				boolEnInChgFlag = 0;
+				intGainShift = 7;
+				LnaGain = FC0013_LNA_GAIN_LOW;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+
+			else if(RssiRDiff <= 5)
+			{
+				boolVhfFlag = 1;
+				boolEnInChgFlag = 0;
+				intGainShift = 10;
+				LnaGain = FC0013_LNA_GAIN_HIGH_17;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+
+			else
+			{
+				goto success_status_Lna_Gain_No_Change;
+			}
+
+		
+		case FC0013_LNA_GAIN_LOW:
+
+			if(RssiRDiff <= 2)
+			{
+				boolVhfFlag = 0;
+				boolEnInChgFlag = 0;
+				intGainShift = 7;
+				LnaGain = FC0013_LNA_GAIN_MIDDLE;
+
+				// Set tuner LNA_GAIN.
+				if(fc0013_SetRegMaskBits(pTuner, 0x14, 4, 0, LnaGain) != FC0013_I2C_SUCCESS)
+					goto error_status_set_registers;
+
+				break;
+			}
+
+			else
+			{
+				goto success_status_Lna_Gain_No_Change;
+			}
+	}
+
+
+	if(fc0013_GetRegMaskBits(pTuner, 0x14, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+		goto error_status_get_registers;
+
+	if( (ReadValue & 0x60) == 0 )   // disable UHF & GPS ==> lock VHF frequency
+	{
+		boolVhfFlag = 1;
+	}
+
+
+	if( boolVhfFlag == 1 )
+	{
+		//FC0013_Write(0x07, (FC0013_Read(0x07) | 0x10));				// VHF = 1
+		if(fc0013_GetRegMaskBits(pTuner, 0x07, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x07, 7, 0, ReadValue | 0x10) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+	else
+	{
+		//FC0013_Write(0x07, (FC0013_Read(0x07) & 0xEF));				// VHF = 0
+		if(fc0013_GetRegMaskBits(pTuner, 0x07, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x07, 7, 0, ReadValue & 0xEF) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+		
+
+	if( boolEnInChgFlag == 1 )
+	{
+		//FC0013_Write(0x0A, (FC0013_Read(0x0A) | 0x20));				// EN_IN_CHG = 1
+		if(fc0013_GetRegMaskBits(pTuner, 0x0A, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x0A, 7, 0, ReadValue | 0x20) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+	else
+	{
+		//FC0013_Write(0x0A, (FC0013_Read(0x0A) & 0xDF));				// EN_IN_CHG = 0
+		if(fc0013_GetRegMaskBits(pTuner, 0x0A, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x0A, 7, 0, ReadValue & 0xDF) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	if( intGainShift == 10 )
+	{
+		//FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x0A);		// GS = 10
+		if(fc0013_GetRegMaskBits(pTuner, 0x07, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x07, 7, 0, (ReadValue & 0xF0) | 0x0A) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+	else
+	{
+		//FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x07);		// GS = 7
+		if(fc0013_GetRegMaskBits(pTuner, 0x07, 7, 0, &ReadValue) != FC0013_I2C_SUCCESS)
+			goto error_status_get_registers;
+
+		if(fc0013_SetRegMaskBits(pTuner, 0x07, 7, 0, (ReadValue & 0xF0) | 0x07) != FC0013_I2C_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+success_status_Lna_Gain_No_Change:
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.h b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.h
new file mode 100644
index 00000000..0888d6e2
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc0013.h
@@ -0,0 +1,170 @@
+#ifndef __NIM_RTL2832_FC0013
+#define __NIM_RTL2832_FC0013
+
+/**
+
+@file
+
+@brief   RTL2832 FC0013 NIM module declaration
+
+One can manipulate RTL2832 FC0013 NIM through RTL2832 FC0013 NIM module.
+RTL2832 FC0013 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_fc0013.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 FC0013 NIM module.
+	BuildRtl2832Fc0013Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc6,							// The FC0013 I2C device address is 0xc6 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ			// The FC0013 crystal frequency is 28.8 MHz.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_fc0013.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_FC0013_ADDITIONAL_INIT_REG_TABLE_LEN		29
+#define RTL2832_FC0013_DAB_ADDITIONAL_INIT_REG_TABLE_LEN		31
+#define RTL2832_FC0013_LNA_UPDATE_WAIT_TIME_MS				1000
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Fc0013Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	);
+
+
+
+
+
+// RTL2832 FC0013 NIM manipulaing functions
+int
+rtl2832_fc0013_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+int
+rtl2832_fc0013_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+int
+rtl2832_fc0013_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_fc0013_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_fc0013_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0013_GetTunerRssiCalOn(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc0013_UpdateTunerLnaGainWithRssi(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.c b/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.c
new file mode 100644
index 00000000..7d12c5f0
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.c
@@ -0,0 +1,343 @@
+/**
+
+@file
+
+@brief   RTL2832 FC2580 NIM module definition
+
+One can manipulate RTL2832 FC2580 NIM through RTL2832 FC2580 NIM module.
+RTL2832 FC2580 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_fc2580.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 FC2580 NIM module builder
+
+Use BuildRtl2832Fc2580Module() to build RTL2832 FC2580 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 FC2580 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              FC2580 I2C device address
+@param [in]   TunerCrystalFreqHz           FC2580 crystal frequency in Hz
+@param [in]   TunerAgcMode                 FC2580 AGC mode
+
+
+@note
+	-# One should call BuildRtl2832Fc2580Module() to build RTL2832 FC2580 NIM module before using it.
+
+*/
+void
+BuildRtl2832Fc2580Module(
+	DVBT_NIM_MODULE **ppNim,								// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerAgcMode
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_FC2580;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build FC2580 tuner module.
+	BuildFc2580Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		TunerAgcMode
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_fc2580_Initialize;
+	pNim->SetParameters  = rtl2832_fc2580_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_fc2580_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x9c	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9f4	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_fc2580_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	FC2580_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = FC2580_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = FC2580_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = FC2580_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.h b/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.h
new file mode 100644
index 00000000..a5a7998d
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_fc2580.h
@@ -0,0 +1,141 @@
+#ifndef __NIM_RTL2832_FC2580
+#define __NIM_RTL2832_FC2580
+
+/**
+
+@file
+
+@brief   RTL2832 FC2580 NIM module declaration
+
+One can manipulate RTL2832 FC2580 NIM through RTL2832 FC2580 NIM module.
+RTL2832 FC2580 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_fc2580.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 FC2580 NIM module.
+	BuildRtl2832Fc2580Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xac,							// The FC2580 I2C device address is 0xac in 8-bit format.
+		CRYSTAL_FREQ_16384000HZ,		// The FC2580 crystal frequency is 16.384 MHz.
+		FC2580_AGC_EXTERNAL				// The FC2580 AGC mode is external AGC mode.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_fc2580.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN		21
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Fc2580Module(
+	DVBT_NIM_MODULE **ppNim,								// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerAgcMode
+	);
+
+
+
+
+
+// RTL2832 FC2580 NIM manipulaing functions
+int
+rtl2832_fc2580_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_fc2580_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.c b/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.c
new file mode 100644
index 00000000..6398437e
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.c
@@ -0,0 +1,346 @@
+/**
+
+@file
+
+@brief   RTL2832 MAX3543 NIM module definition
+
+One can manipulate RTL2832 MAX3543 NIM through RTL2832 MAX3543 NIM module.
+RTL2832 MAX3543 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_max3543.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 MAX3543 NIM module builder
+
+Use BuildRtl2832Max3543Module() to build RTL2832 MAX3543 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 MAX3543 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              MAX3543 I2C device address
+@param [in]   TunerCrystalFreqHz           MAX3543 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildRtl2832Max3543Module() to build RTL2832 MAX3543 NIM module before using it.
+
+*/
+void
+BuildRtl2832Max3543Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_MAX3543;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build MAX3543 tuner module.
+	BuildMax3543Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		RTL2832_MAX3543_STANDARD_MODE_DEFAULT,
+		RTL2832_MAX3543_IF_FREQ_HZ_DEFAULT,
+		RTL2832_MAX3543_SAW_INPUT_TYPE_DEFAULT
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_max3543_Initialize;
+	pNim->SetParameters  = rtl2832_max3543_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_max3543_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x4b	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+		{DVBT_AD_EN_REG1,			0x0		},
+		{DVBT_CKOUT_PWR_PID,		0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with NIM default.
+	if(pDemod->SetIfFreqHz(pDemod, RTL2832_MAX3543_IF_FREQ_HZ_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with NIM default.
+	if(pDemod->SetSpectrumMode(pDemod, RTL2832_MAX3543_SPECTRUM_MODE_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_max3543_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	MAX3543_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Max3543);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	// Note: MAX3543 tuner only has 7 MHz and 8 MHz settings.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = MAX3543_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = MAX3543_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = MAX3543_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.h b/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.h
new file mode 100644
index 00000000..b2b61fc8
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_max3543.h
@@ -0,0 +1,145 @@
+#ifndef __NIM_RTL2832_MAX3543
+#define __NIM_RTL2832_MAX3543
+
+/**
+
+@file
+
+@brief   RTL2832 MAX3543 NIM module declaration
+
+One can manipulate RTL2832 MAX3543 NIM through RTL2832 MAX3543 NIM module.
+RTL2832 MAX3543 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_max3543.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 MAX3543 NIM module.
+	BuildRtl2832Max3543Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc0,							// The MAX3543 I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ			// The MAX3543 Crystal frequency is 16.0 MHz.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_max3543.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN		23
+
+// Default
+#define RTL2832_MAX3543_STANDARD_MODE_DEFAULT				MAX3543_STANDARD_DVBT
+#define RTL2832_MAX3543_IF_FREQ_HZ_DEFAULT					IF_FREQ_36170000HZ
+#define RTL2832_MAX3543_SPECTRUM_MODE_DEFAULT				SPECTRUM_INVERSE
+#define RTL2832_MAX3543_SAW_INPUT_TYPE_DEFAULT				MAX3543_SAW_INPUT_SE
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Max3543Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	);
+
+
+
+
+
+// RTL2832 MAX3543 NIM manipulaing functions
+int
+rtl2832_max3543_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_max3543_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.c b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.c
new file mode 100644
index 00000000..3c475f9a
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.c
@@ -0,0 +1,360 @@
+/**
+
+@file
+
+@brief   RTL2832 MT2063 NIM module definition
+
+One can manipulate RTL2832 MT2063 NIM through RTL2832 MT2063 NIM module.
+RTL2832 MT2063 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_mt2063.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 MT2063 NIM module builder
+
+Use BuildRtl2832Mt2063Module() to build RTL2832 MT2063 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 MT2063 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              MT2063 I2C device address
+@param [in]   TunerAgcMode                 MT2063 AGC mode
+
+
+@note
+	-# One should call BuildRtl2832Mt2063Module() to build RTL2832 MT2063 NIM module before using it.
+
+*/
+void
+BuildRtl2832Mt2063Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+	unsigned long NimIfFreqHz,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+	RTL2832_MT2063_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Mt2063);
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_MT2063;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build MT2063 tuner module.
+	BuildMt2063Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		MT2063_STANDARD_DVBT,
+		MT2063_VGAGC_0X3
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_mt2063_Initialize;
+	pNim->SetParameters  = rtl2832_mt2063_SetParameters;
+
+
+	// Set NIM extra module variables.
+	pNimExtra->IfFreqHz = NimIfFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_mt2063_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+//		{DVBT_AGC_TARG_VAL_8_1,		0x32	},
+		{DVBT_AGC_TARG_VAL_8_1,		0x19	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	MT2063_EXTRA_MODULE *pTunerExtra;
+	RTL2832_MT2063_EXTRA_MODULE *pNimExtra;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+	pTunerExtra = &(pTuner->Extra.Mt2063);
+	pNimExtra = &(pNim->Extra.Rtl2832Mt2063);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner IF frequency in Hz.
+	if(pTunerExtra->SetIfFreqHz(pTuner, pNimExtra->IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency in Hz.
+	if(pDemod->SetIfFreqHz(pDemod, pNimExtra->IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_INVERSE.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_INVERSE) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_mt2063_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	MT2063_EXTRA_MODULE *pTunerExtra;
+	unsigned long BandwidthHz;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mt2063);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Determine BandwidthHz according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		BandwidthHz = MT2063_BANDWIDTH_6MHZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		BandwidthHz = MT2063_BANDWIDTH_7MHZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		BandwidthHz = MT2063_BANDWIDTH_8MHZ;		break;
+	}
+
+	// Set tuner bandwidth in Hz with BandwidthHz.
+	// Note: Need to execute SetBandwidthHz() before SetRfFreqHz() for MT2063,
+	//       because MT2063 bandwidth setting API only sets software variables.
+	if(pTunerExtra->SetBandwidthHz(pTuner, BandwidthHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.h b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.h
new file mode 100644
index 00000000..464d0c61
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2063.h
@@ -0,0 +1,160 @@
+#ifndef __NIM_RTL2832_MT2063
+#define __NIM_RTL2832_MT2063
+
+/**
+
+@file
+
+@brief   RTL2832 MT2063 NIM module declaration
+
+One can manipulate RTL2832 MT2063 NIM through RTL2832 MT2063 NIM module.
+RTL2832 MT2063 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_mt2063.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+	MT2063_EXTRA_MODULE *pTunerExtra;
+
+	...
+
+
+
+	// Build RTL2832 MT2063 NIM module.
+	BuildRtl2832Mt2063Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+		IF_FREQ_36125000HZ,				// The RTL2832 and MT2063 IF frequency is 36.125 MHz.
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc0							// The MT2063 I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get MT2063 tuner extra module.
+	pTuner = pNim->pTuner;
+	pTunerExtra = &(pTuner->Extra.Mt2063);
+
+	// Open MT2063 handle.
+	pTunerExtra->OpenHandle(pTuner);
+
+
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+
+
+
+	// Close MT2063 handle.
+	pTunerExtra->CloseHandle(pTuner);
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_mt2063.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN		21
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Mt2063Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+	unsigned long NimIfFreqHz,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	);
+
+
+
+
+
+// RTL2832 MT2063 NIM manipulaing functions
+int
+rtl2832_mt2063_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_mt2063_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.c b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.c
new file mode 100644
index 00000000..cac01e31
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.c
@@ -0,0 +1,1082 @@
+/**
+
+@file
+
+@brief   RTL2832 MT2266 NIM module definition
+
+One can manipulate RTL2832 MT2266 NIM through RTL2832 MT2266 NIM module.
+RTL2832 MT2266 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_mt2266.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 MT2266 NIM module builder
+
+Use BuildRtl2832Mt2266Module() to build RTL2832 MT2266 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 MT2266 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              MT2266 I2C device address
+
+
+@note
+	-# One should call BuildRtl2832Mt2266Module() to build RTL2832 MT2266 NIM module before using it.
+
+*/
+void
+BuildRtl2832Mt2266Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+	RTL2832_MT2266_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Mt2266);
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_MT2266;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build MT2266 tuner module.
+	BuildMt2266Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_mt2266_Initialize;
+	pNim->SetParameters  = rtl2832_mt2266_SetParameters;
+	pNim->UpdateFunction = rtl2832_mt2266_UpdateFunction;
+
+
+	// Initialize NIM extra module variables.
+	pNimExtra->LnaConfig       = 0xff;
+	pNimExtra->UhfSens         = 0xff;
+	pNimExtra->AgcCurrentState = 0xff;
+	pNimExtra->LnaGainOld      = 0xffffffff;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_mt2266_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_MT2266_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0xc0	},	// Note: The IF_AGC_MIN value will be set again by demod_pdcontrol_reset().
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x9c	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x1		},
+		{DVBT_POLAR_IF_AGC,			0x1		},
+		{DVBT_AD7_SETTING,			0xe9f4	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_MT2266_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_mt2266_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	MT2266_EXTRA_MODULE *pTunerExtra;
+	Handle_t Mt2266Handle;
+	unsigned long BandwidthHz;
+
+	RTL2832_MT2266_EXTRA_MODULE *pNimExtra;
+
+	UData_t Status;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	Mt2266Handle = pTunerExtra->DeviceHandle;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Mt2266);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine BandwidthHz according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		BandwidthHz = MT2266_BANDWIDTH_6MHZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		BandwidthHz = MT2266_BANDWIDTH_7MHZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		BandwidthHz = MT2266_BANDWIDTH_8MHZ;		break;
+	}
+
+	// Set tuner bandwidth in Hz with BandwidthHz.
+	if(pTunerExtra->SetBandwidthHz(pTuner, BandwidthHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Reset MT2266 update procedure.
+	Status = demod_pdcontrol_reset(pDemod, Mt2266Handle, &pNimExtra->AgcCurrentState);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+rtl2832_mt2266_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+	MT2266_EXTRA_MODULE *pTunerExtra;
+	RTL2832_MT2266_EXTRA_MODULE *pNimExtra;
+
+	Handle_t Mt2266Handle;
+	UData_t Status;
+	
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module and tuner handle.
+	pTunerExtra = &(pTuner->Extra.Mt2266);
+	pTunerExtra->GetHandle(pTuner, &Mt2266Handle);
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2832Mt2266);
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Update demod and tuner register setting.
+	Status = demod_pdcontrol(
+		pDemod,
+		Mt2266Handle,
+		&pNimExtra->LnaConfig,
+		&pNimExtra->UhfSens,
+		&pNimExtra->AgcCurrentState,
+		&pNimExtra->LnaGainOld
+		);
+
+/*
+	handle_t demod_handle,
+	handle_t tuner_handle,
+	unsigned char* lna_config,
+	unsigned char* uhf_sens,
+	unsigned char *agc_current_state,
+	unsigned long *lna_gain_old
+	
+	unsigned char LnaConfig;
+	unsigned char UhfSens;
+	unsigned char AgcCurrentState;
+	unsigned long LnaGainOld;	
+	
+*/
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Additional definition for mt_control.c
+UData_t
+demod_get_pd(
+	handle_t demod_handle,
+	unsigned short *pd_value
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	unsigned long RssiR;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Get RSSI_R value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_RSSI_R, &RssiR) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Set pd_value according to RSSI_R.
+	*pd_value = (unsigned short)RssiR;
+
+
+	return MT_OK;
+
+
+error_status_get_registers:
+	return MT_COMM_ERR;
+}
+
+
+
+UData_t
+demod_get_agc(
+	handle_t demod_handle,
+	unsigned short *rf_level,
+	unsigned short *bb_level
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	unsigned long RfAgc;
+	unsigned long IfAgc;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Get RF and IF AGC value.
+	if(pDemod->GetRfAgc(pDemod, &RfAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetIfAgc(pDemod, &IfAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Convert RF and IF AGC value to proper format.
+	*rf_level = (unsigned short)((RfAgc + (1 << (RTL2832_RF_AGC_REG_BIT_NUM - 1))) *
+		(1 << (MT2266_DEMOD_ASSUMED_AGC_REG_BIT_NUM - RTL2832_RF_AGC_REG_BIT_NUM)));
+
+	*bb_level = (unsigned short)((IfAgc + (1 << (RTL2832_IF_AGC_REG_BIT_NUM - 1))) *
+		(1 << (MT2266_DEMOD_ASSUMED_AGC_REG_BIT_NUM - RTL2832_IF_AGC_REG_BIT_NUM)));
+
+
+	return MT_OK;
+
+
+error_status_get_registers:
+	return MT_COMM_ERR;
+}
+
+
+
+UData_t
+demod_set_bbagclim(
+	handle_t demod_handle,
+	int on_off_status
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+	unsigned long IfAgcMinBinary;
+	long IfAgcMinInt;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Get IF_AGC_MIN binary value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_IF_AGC_MIN, &IfAgcMinBinary) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Convert IF_AGC_MIN binary value to integer.
+	IfAgcMinInt = BinToSignedInt(IfAgcMinBinary, RTL2832_MT2266_IF_AGC_MIN_BIT_NUM);
+
+	// Modify IF_AGC_MIN integer according to on_off_status.
+	switch(on_off_status)
+	{
+		case 1:
+
+			IfAgcMinInt += RTL2832_MT2266_IF_AGC_MIN_INT_STEP;
+
+			if(IfAgcMinInt > RTL2832_MT2266_IF_AGC_MIN_INT_MAX)
+				IfAgcMinInt = RTL2832_MT2266_IF_AGC_MIN_INT_MAX;
+
+			break;
+
+		default:
+		case 0:
+
+			IfAgcMinInt -= RTL2832_MT2266_IF_AGC_MIN_INT_STEP;
+
+			if(IfAgcMinInt < RTL2832_MT2266_IF_AGC_MIN_INT_MIN)
+				IfAgcMinInt = RTL2832_MT2266_IF_AGC_MIN_INT_MIN;
+
+			break;
+	}
+
+	// Convert modified IF_AGC_MIN integer to binary value.
+	IfAgcMinBinary = SignedIntToBin(IfAgcMinInt, RTL2832_MT2266_IF_AGC_MIN_BIT_NUM);
+
+	// Set IF_AGC_MIN with modified binary value.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IF_AGC_MIN, IfAgcMinBinary) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	return MT_OK;
+
+
+error_status_set_registers:
+error_status_get_registers:
+	return MT_COMM_ERR;
+}
+
+
+
+
+
+UData_t
+tuner_set_bw_normal(
+	handle_t tuner_handle,
+	handle_t demod_handle
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int DemodBandwidthMode;
+	unsigned int TunerBandwidthHz;
+	unsigned int TargetTunerBandwidthHz;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Get demod bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, &DemodBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine tuner target bandwidth.
+	switch(DemodBandwidthMode)
+	{
+		case DVBT_BANDWIDTH_6MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_6MHZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_7MHZ;		break;
+		default:
+		case DVBT_BANDWIDTH_8MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_8MHZ;		break;
+	}
+
+	// Get tuner bandwidth.
+	if(MT_IS_ERROR(MT2266_GetParam(tuner_handle, MT2266_OUTPUT_BW, &TunerBandwidthHz)))
+		goto error_status_get_tuner_bandwidth;
+
+	// Set tuner bandwidth with normal setting according to demod bandwidth mode.
+	if(TunerBandwidthHz != TargetTunerBandwidthHz)
+	{
+		if(MT_IS_ERROR(MT2266_SetParam(tuner_handle, MT2266_OUTPUT_BW, TargetTunerBandwidthHz)))
+			goto error_status_set_tuner_bandwidth;
+	}
+
+
+	return MT_OK;
+
+
+error_status_set_tuner_bandwidth:
+error_status_get_tuner_bandwidth:
+error_status_execute_function:
+	return MT_COMM_ERR;
+}
+
+
+
+
+
+UData_t
+tuner_set_bw_narrow(
+	handle_t tuner_handle,
+	handle_t demod_handle
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int DemodBandwidthMode;
+	unsigned long AciDetInd;
+	unsigned int TunerBandwidthHz;
+	unsigned int TargetTunerBandwidthHz;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Get demod bandwidth mode.
+	if(pDemod->GetBandwidthMode(pDemod, &DemodBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get demod ACI_DET_IND.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_ACI_DET_IND, &AciDetInd) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	// Determine tuner target bandwidth according to ACI_DET_IND.
+	if(AciDetInd == 0x1)
+	{
+		// Choose narrow target bandwidth.
+		switch(DemodBandwidthMode)
+		{
+			case DVBT_BANDWIDTH_6MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_5MHZ;		break;
+			case DVBT_BANDWIDTH_7MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_6MHZ;		break;
+			default:
+			case DVBT_BANDWIDTH_8MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_7MHZ;		break;
+		}
+	}
+	else
+	{
+		// Choose normal target bandwidth.
+		switch(DemodBandwidthMode)
+		{
+			case DVBT_BANDWIDTH_6MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_6MHZ;		break;
+			case DVBT_BANDWIDTH_7MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_7MHZ;		break;
+			default:
+			case DVBT_BANDWIDTH_8MHZ:	TargetTunerBandwidthHz = MT2266_BANDWIDTH_8MHZ;		break;
+		}
+	}
+
+	// Get tuner bandwidth.
+	if(MT_IS_ERROR(MT2266_GetParam(tuner_handle, MT2266_OUTPUT_BW, &TunerBandwidthHz)))
+		goto error_status_get_tuner_bandwidth;
+
+	// Set tuner bandwidth with normal setting according to demod bandwidth mode.
+	if(TunerBandwidthHz != TargetTunerBandwidthHz)
+	{
+		if(MT_IS_ERROR(MT2266_SetParam(tuner_handle, MT2266_OUTPUT_BW, TargetTunerBandwidthHz)))
+			goto error_status_set_tuner_bandwidth;
+	}
+
+
+	return MT_OK;
+
+
+error_status_set_tuner_bandwidth:
+error_status_get_tuner_bandwidth:
+error_status_get_registers:
+error_status_execute_function:
+	return MT_COMM_ERR;
+}
+
+
+
+
+
+// Microtune source code - mt_control.c
+
+
+
+UData_t demod_pdcontrol_reset(handle_t demod_handle, handle_t tuner_handle, unsigned char *agc_current_state) {
+
+	DVBT_DEMOD_MODULE *pDemod;
+	unsigned long BinaryValue;
+
+
+	// Get demod module.
+	pDemod = (DVBT_DEMOD_MODULE *)demod_handle;
+
+	// Reset AGC current state.
+	*agc_current_state = AGC_STATE_START;
+
+	// Calculate RTL2832_MT2266_IF_AGC_MIN_INT_MIN binary value.
+	BinaryValue = SignedIntToBin(RTL2832_MT2266_IF_AGC_MIN_INT_MIN, RTL2832_MT2266_IF_AGC_MIN_BIT_NUM);
+
+	// Set IF_AGC_MIN with binary value.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IF_AGC_MIN, BinaryValue) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner bandwidth with normal setting.
+	if(MT_IS_ERROR(tuner_set_bw_normal(tuner_handle, demod_handle)))
+		goto error_status_set_tuner_bandwidth;
+
+
+	return MT_OK;
+
+
+error_status_set_tuner_bandwidth:
+error_status_set_registers:
+	return MT_COMM_ERR;
+}
+
+
+
+UData_t demod_pdcontrol(handle_t demod_handle, handle_t tuner_handle, unsigned char* lna_config, unsigned char* uhf_sens,
+					 unsigned char *agc_current_state, unsigned long *lna_gain_old) {
+
+	unsigned short pd_value;
+	unsigned short rf_level, bb_level;
+	unsigned long lna_gain;
+	unsigned char zin=0;
+	unsigned int tmp_freq=0,tmp_lna_gain=0;
+	
+//	unsigned char temp[2];
+//	unsigned char agc_bb_min;
+//	demod_data_t* local_data;
+
+	
+	unsigned char band=1;  /* band=0: vhf, band=1: uhf low, band=2: uhf high */
+	unsigned long freq;
+
+	// AGC threshold values
+	unsigned short sens_on[]  = {11479, 11479, 32763};
+	unsigned short sens_off[] = {36867, 36867, 44767};
+	unsigned short lin_off[]  = {23619, 23619, 23619};
+	unsigned short lin_on[]   = {38355, 38355, 38355};
+	unsigned short pd_upper[] = {85,    85,    85};
+	unsigned short pd_lower[] = {74,    74,    74};
+	unsigned char next_state;
+
+	// demod_data_t* local_data = (demod_data_t*)demod_handle;	
+
+	if(MT_IS_ERROR(MT2266_GetParam(tuner_handle, MT2266_INPUT_FREQ, &tmp_freq))) goto error_status;
+	if(MT_IS_ERROR(MT2266_GetParam(tuner_handle, MT2266_LNA_GAIN, &tmp_lna_gain))) goto error_status;
+	if(MT_IS_ERROR(MT2266_GetReg(tuner_handle,0x1e,&zin))) goto error_status;
+
+	freq=(unsigned long)(tmp_freq);
+	lna_gain=(unsigned long)(tmp_lna_gain);
+	
+	if (freq <= 250000000) band=0;
+	else if (freq < 660000000) band=1;
+	else band=2;
+	
+	if(MT_IS_ERROR(demod_get_pd(demod_handle, &pd_value))) goto error_status;
+	if(MT_IS_ERROR(demod_get_agc(demod_handle, &rf_level, &bb_level))) goto error_status;
+
+	rf_level=0xffff-rf_level;
+	bb_level=0xffff-bb_level;
+
+/*
+#ifndef _HOST_DLL
+	uart_write_nr("St:");
+	uart_writedez(agc_current_state[num]);
+
+	uart_write_nr(" PD: ");
+	uart_writehex16(pd_value);
+
+	uart_write_nr(" AGC: ");
+	uart_writehex16(rf_level);
+	uart_writehex16(bb_level);	
+#endif
+*/
+
+	next_state = *agc_current_state;
+	
+	switch (*agc_current_state) {
+	
+	case AGC_STATE_START : {
+		if ((int)lna_gain < LNAGAIN_MIN)  
+			next_state=AGC_STATE_LNAGAIN_BELOW_MIN;
+		else if (lna_gain > LNAGAIN_MAX)  
+			next_state=AGC_STATE_LNAGAIN_ABOVE_MAX;
+		else 
+			next_state=AGC_STATE_NORMAL;
+		break;
+		}
+	
+	case AGC_STATE_LNAGAIN_BELOW_MIN : {
+		if ((int)lna_gain < LNAGAIN_MIN ) 
+			next_state=AGC_STATE_LNAGAIN_BELOW_MIN;
+		else next_state=AGC_STATE_NORMAL;
+		
+		break;
+		}
+	
+	case AGC_STATE_LNAGAIN_ABOVE_MAX : {
+		if (lna_gain > LNAGAIN_MAX ) 
+			next_state=AGC_STATE_LNAGAIN_ABOVE_MAX;
+		else next_state=AGC_STATE_NORMAL;
+		break;
+		}
+	
+	case AGC_STATE_NORMAL : {
+		if (rf_level > lin_on[band] ) {
+			*lna_gain_old = lna_gain;
+			next_state = AGC_STATE_MAS_GRANDE_SIGNAL;
+			}
+		else if (pd_value > pd_upper[band]) {
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+			}
+		else if ( (pd_value < pd_lower[band]) && (lna_gain < LNAGAIN_MAX) ) {
+			next_state = AGC_STATE_NO_INTERFERER;
+			}
+		else if ( bb_level < sens_on[band]) {
+			next_state = AGC_STATE_SMALL_SIGNAL;
+			}
+		break;
+		}
+	
+	case AGC_STATE_NO_INTERFERER : {
+		if (pd_value > pd_lower[band] ) 
+			next_state = AGC_STATE_MEDIUM_INTERFERER;
+		else if (pd_value < pd_lower[band] )
+			next_state = AGC_STATE_NORMAL;
+		else if ( lna_gain == LNAGAIN_MAX )
+			next_state = AGC_STATE_NORMAL;
+		break;
+		}
+
+	case AGC_STATE_MEDIUM_INTERFERER : {
+		if (pd_value > pd_upper[band] ) 
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+		else if (pd_value < pd_lower[band] )
+			next_state = AGC_STATE_NO_INTERFERER;
+		break;
+		}
+
+	
+	case AGC_STATE_GRANDE_INTERFERER : {
+		if (pd_value < pd_upper[band] )
+			next_state = AGC_STATE_MEDIUM_INTERFERER;
+		break;
+		}
+	
+	case AGC_STATE_MAS_GRANDE_SIGNAL : {
+		if (rf_level < lin_on[band])
+			next_state = AGC_STATE_GRANDE_SIGNAL;
+		else if (pd_value > pd_upper[band]) {
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+			}
+		break;
+		}
+		
+	case AGC_STATE_MEDIUM_SIGNAL : {
+		if (rf_level > lin_off[band])
+			next_state = AGC_STATE_GRANDE_SIGNAL;
+		else if (lna_gain >= *lna_gain_old) 
+			next_state = AGC_STATE_NORMAL;
+		else if (pd_value > pd_upper[band])
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+		break;
+		}
+	
+	case AGC_STATE_GRANDE_SIGNAL : {
+		if (rf_level > lin_on[band])
+			next_state = AGC_STATE_MAS_GRANDE_SIGNAL;
+		else if (rf_level < lin_off[band]) 
+			next_state = AGC_STATE_MEDIUM_SIGNAL;
+		else if (pd_value > pd_upper[band])
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+		break;
+		}
+	
+	case AGC_STATE_SMALL_SIGNAL : {
+		if (pd_value > pd_upper[band] ) 
+			next_state = AGC_STATE_GRANDE_INTERFERER;
+		else if (bb_level > sens_off[band]) 
+			next_state = AGC_STATE_NORMAL;
+		else if ( (bb_level < sens_on[band]) && (lna_gain == LNAGAIN_MAX) )
+			next_state = AGC_STATE_MAX_SENSITIVITY;
+		break;
+		}
+		
+	case AGC_STATE_MAX_SENSITIVITY : {
+		if (bb_level > sens_off[band]) 
+			next_state = AGC_STATE_SMALL_SIGNAL;
+		break;
+		}
+		
+	}
+			
+	*agc_current_state = next_state;	
+	
+	
+	switch (*agc_current_state) {
+		
+		case AGC_STATE_LNAGAIN_BELOW_MIN : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_INCR, LNAGAIN_MAX))) goto error_status;
+			break;
+			}
+		
+		case AGC_STATE_LNAGAIN_ABOVE_MAX : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_DECR, LNAGAIN_MIN))) goto error_status;
+			break;
+			}
+			
+		case AGC_STATE_NORMAL : {
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+			break;
+			}
+		
+		case AGC_STATE_NO_INTERFERER : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_INCR, LNAGAIN_MAX))) goto error_status;
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			break;
+			}
+
+		case AGC_STATE_MEDIUM_INTERFERER : {
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+
+			// Additional setting
+			// Set tuner with normal bandwidth.
+			if(MT_IS_ERROR(tuner_set_bw_normal(tuner_handle, demod_handle))) goto error_status;
+
+			break;
+			}
+		
+		case AGC_STATE_GRANDE_INTERFERER : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_DECR, LNAGAIN_MIN))) goto error_status;
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,1))) goto error_status;
+
+			// Additional setting
+			// Set tuner with narrow bandwidth.
+			if(MT_IS_ERROR(tuner_set_bw_narrow(tuner_handle, demod_handle))) goto error_status;
+
+			break;
+			}
+		
+		case AGC_STATE_MEDIUM_SIGNAL : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_INCR, LNAGAIN_MAX))) goto error_status;
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			break;
+			}
+			
+		case AGC_STATE_GRANDE_SIGNAL : {
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			break;
+			}
+
+		case AGC_STATE_MAS_GRANDE_SIGNAL : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_DECR, LNAGAIN_MIN))) goto error_status;
+			if (lna_gain==0) {
+				if (zin <= 64) {
+					zin += 2;
+					if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+					}
+				}
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			break;
+			}
+		
+		case AGC_STATE_SMALL_SIGNAL : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_LNA_GAIN_INCR, LNAGAIN_MAX))) goto error_status;
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_UHF_NORMAL,1))) goto error_status;
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			*uhf_sens=0;
+			break;
+			}
+		
+		case AGC_STATE_MAX_SENSITIVITY : {
+			if(MT_IS_ERROR(MT2266_SetParam(tuner_handle,MT2266_UHF_MAXSENS,1))) goto error_status;
+			if (zin >= 2) {
+				zin -= 2;
+				if(MT_IS_ERROR(MT2266_SetReg(tuner_handle,0x1e,zin))) goto error_status;
+			}
+			if(MT_IS_ERROR(demod_set_bbagclim(demod_handle,0))) goto error_status;
+			*uhf_sens=1;
+			break;
+			}
+	}	
+
+	if(MT_IS_ERROR(MT2266_GetParam(tuner_handle, MT2266_LNA_GAIN,&tmp_lna_gain))) goto error_status;
+	lna_gain=(unsigned long)(tmp_lna_gain);
+
+	*lna_config=(unsigned char)lna_gain;
+
+/*
+#ifndef _HOST_DLL
+	uart_write_nr(" LNA ");	
+	uart_writedez(lna_gain);
+	uart_write_nr(" SENS ");
+	uart_writedez(*uhf_sens);
+	uart_write_nr(" Z ");
+	uart_writedez(zin);
+	uart_write(" ");
+#endif
+*/
+
+
+
+	return MT_OK;
+
+
+error_status:
+	return MT_COMM_ERR;
+}
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.h b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.h
new file mode 100644
index 00000000..2047220f
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mt2266.h
@@ -0,0 +1,264 @@
+#ifndef __NIM_RTL2832_MT2266
+#define __NIM_RTL2832_MT2266
+
+/**
+
+@file
+
+@brief   RTL2832 MT2266 NIM module declaration
+
+One can manipulate RTL2832 MT2266 NIM through RTL2832 MT2266 NIM module.
+RTL2832 MT2266 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_mt2266.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+	TUNER_MODULE *pTuner;
+	MT2266_EXTRA_MODULE *pTunerExtra;
+
+	...
+
+
+
+	// Build RTL2832 MT2266 NIM module.
+	BuildRtl2832Mt2266Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,									// Maximum I2C reading byte number is 9.
+		8,									// Maximum I2C writing byte number is 8.
+		CustomI2cRead,						// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,						// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,						// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,								// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,				// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,			// The RTL2832 application mode is STB mode.
+		50,									// The RTL2832 update function reference period is 50 millisecond
+		YES,								// The RTL2832 Function 1 enabling status is YES.
+
+		0xc0								// The MT2266 I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get MT2266 tuner extra module.
+	pTuner = pNim->pTuner;
+	pTunerExtra = &(pTuner->Extra.Mt2266);
+
+	// Open MT2266 handle.
+	pTunerExtra->OpenHandle(pTuner);
+
+
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+
+
+
+	// Close MT2266 handle.
+	pTunerExtra->CloseHandle(pTuner);
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_mt2266.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_MT2266_ADDITIONAL_INIT_REG_TABLE_LEN		21
+
+#define RTL2832_MT2266_IF_AGC_MIN_BIT_NUM		8
+#define RTL2832_MT2266_IF_AGC_MIN_INT_MAX		36
+#define RTL2832_MT2266_IF_AGC_MIN_INT_MIN		-64
+#define RTL2832_MT2266_IF_AGC_MIN_INT_STEP		0
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Mt2266Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	);
+
+
+
+
+
+// RTL2832 MT2266 NIM manipulaing functions
+int
+rtl2832_mt2266_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_mt2266_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_mt2266_UpdateFunction(
+	DVBT_NIM_MODULE *pNim
+	);
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Additional definition for mt_control.c
+typedef void *           handle_t;
+
+#define MT2266_DEMOD_ASSUMED_AGC_REG_BIT_NUM		16
+
+
+
+// Microtune source code - mt_control.c
+
+
+
+/*  $Id: mt_control.c,v 1.6 2008/01/02 12:04:39 tune\tpinz Exp $ */
+/*! 
+ * \file mt_control.c 
+ * \author Thomas Pinz, Microtune GmbH&Co KG
+ * \author Marie-Curie-Str. 1, 85055 Ingolstadt
+ * \author E-Mail: thomas.pinz@microtune.com
+ */
+
+
+#define LNAGAIN_MIN 0
+#define LNAGAIN_MAX 14
+
+#define AGC_STATE_START 0
+#define AGC_STATE_LNAGAIN_BELOW_MIN 1
+#define AGC_STATE_LNAGAIN_ABOVE_MAX 2
+#define AGC_STATE_NORMAL 3
+#define AGC_STATE_NO_INTERFERER 4
+#define AGC_STATE_MEDIUM_INTERFERER 5
+#define AGC_STATE_GRANDE_INTERFERER 6
+#define AGC_STATE_MEDIUM_SIGNAL 7
+#define AGC_STATE_GRANDE_SIGNAL 8
+#define AGC_STATE_MAS_GRANDE_SIGNAL 9
+#define AGC_STATE_MAX_SENSITIVITY 10
+#define AGC_STATE_SMALL_SIGNAL 11
+
+
+UData_t
+demod_get_pd(
+	handle_t demod_handle,
+	unsigned short *pd_value
+	);
+
+UData_t
+demod_get_agc(
+	handle_t demod_handle,
+	unsigned short *rf_level,
+	unsigned short *bb_level
+	);
+
+UData_t
+demod_set_bbagclim(
+	handle_t demod_handle,
+	int on_off_status
+	);
+
+UData_t
+tuner_set_bw_normal(
+	handle_t tuner_handle,
+	handle_t demod_handle
+	);
+
+UData_t
+tuner_set_bw_narrow(
+	handle_t tuner_handle,
+	handle_t demod_handle
+	);
+
+UData_t
+demod_pdcontrol_reset(
+	handle_t demod_handle,
+	handle_t tuner_handle,
+	unsigned char *agc_current_state
+	);
+
+UData_t
+demod_pdcontrol(
+	handle_t demod_handle,
+	handle_t tuner_handle,
+	unsigned char* lna_config,
+	unsigned char* uhf_sens,
+	unsigned char *agc_current_state,
+	unsigned long *lna_gain_old
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.c b/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.c
new file mode 100644
index 00000000..ef06a954
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.c
@@ -0,0 +1,517 @@
+/**
+
+@file
+
+@brief   RTL2832 MxL5007T NIM module definition
+
+One can manipulate RTL2832 MxL5007T NIM through RTL2832 MxL5007T NIM module.
+RTL2832 MxL5007T NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_mxl5007t.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 MxL5007T NIM module builder
+
+Use BuildRtl2832Mxl5007tModule() to build RTL2832 MxL5007T NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 MxL5007T NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              MxL5007T I2C device address
+@param [in]   TunerCrystalFreqHz           MxL5007T crystal frequency in Hz
+@param [in]   TunerLoopThroughMode         MxL5007T loop-through mode
+@param [in]   TunerClkOutMode              MxL5007T clock output mode
+@param [in]   TunerClkOutAmpMode           MxL5007T clock output amplitude mode
+
+
+@note
+	-# One should call BuildRtl2832Mxl5007tModule() to build RTL2832 MxL5007T NIM module before using it.
+
+*/
+void
+BuildRtl2832Mxl5007tModule(
+	DVBT_NIM_MODULE **ppNim,								// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerLoopThroughMode,
+	int TunerClkOutMode,
+	int TunerClkOutAmpMode
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_MXL5007T;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build Mxl5007T tuner module.
+	BuildMxl5007tModule(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		RTL2832_MXL5007T_STANDARD_MODE_DEFAULT,
+		RTL2832_MXL5007T_IF_FREQ_HZ_DEFAULT,
+		RTL2832_MXL5007T_SPECTRUM_MODE_DEFAULT,
+		TunerLoopThroughMode,
+		TunerClkOutMode,
+		TunerClkOutAmpMode,
+		RTL2832_MXL5007T_QAM_IF_DIFF_OUT_LEVEL_DEFAULT
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_mxl5007t_Initialize;
+	pNim->SetParameters  = rtl2832_mxl5007t_SetParameters;
+
+
+	return;
+}
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_mxl5007t_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x4b	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+		{DVBT_AD_EN_REG1,			0x0		},
+		{DVBT_CKOUT_PWR_PID,		0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	//if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		//goto error_status_execute_function;
+
+	// Set demod IF frequency with NIM default.
+	//if(pDemod->SetIfFreqHz(pDemod, RTL2832_MXL5007T_IF_FREQ_HZ_DEFAULT) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+	// Set demod spectrum mode with NIM default.
+	//if(pDemod->SetSpectrumMode(pDemod, RTL2832_MXL5007T_SPECTRUM_MODE_DEFAULT) != FUNCTION_SUCCESS)
+	//	goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_mxl5007t_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x4b	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9d4	},
+		{DVBT_AD_EN_REG1,			0x0		},
+		{DVBT_CKOUT_PWR_PID,		0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with NIM default.
+	if(pDemod->SetIfFreqHz(pDemod, RTL2832_MXL5007T_IF_FREQ_HZ_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with NIM default.
+	if(pDemod->SetSpectrumMode(pDemod, RTL2832_MXL5007T_SPECTRUM_MODE_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_mxl5007t_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	MXL5007T_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mxl5007t);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+int
+rtl2832_mxl5007t_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	MXL5007T_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mxl5007t);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_6000000HZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_7000000HZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = MXL5007T_BANDWIDTH_8000000HZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.h b/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.h
new file mode 100644
index 00000000..bdf43adb
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_mxl5007t.h
@@ -0,0 +1,165 @@
+#ifndef __NIM_RTL2832_MXL5007T
+#define __NIM_RTL2832_MXL5007T
+
+/**
+
+@file
+
+@brief   RTL2832 MxL5007T NIM module declaration
+
+One can manipulate RTL2832 MxL5007T NIM through RTL2832 MxL5007T NIM module.
+RTL2832 MxL5007T NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_mxl5007t.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+	RTL2832_EXTRA_MODULE Rtl2832ExtraModuleMemory;
+	MXL5007T_EXTRA_MODULE Mxl5007tExtraModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 MxL5007T NIM module.
+	BuildRtl2832Mxl5007tModule(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		&Rtl2832ExtraModuleMemory,		// Employ RTL2832 extra module for RTL2832 module.
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		50,								// The RTL2832 update function reference period is 50 millisecond
+		ON,								// The RTL2832 Function 1 enabling status is on.
+
+		&Mxl5007tExtraModuleMemory,		// Employ Mxl5007T extra module for Mxl5007T module.
+		0xc0,							// The MxL5007T I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,		// The MxL5007T Crystal frequency is 16.0 MHz.
+		MXL5007T_LOOP_THROUGH_DISABLE,	// The MxL5007T loop-through mode is disabled.
+		MXL5007T_CLK_OUT_DISABLE,		// The MxL5007T clock output mode is disabled.
+		MXL5007T_CLK_OUT_AMP_0			// The MxL5007T clock output amplitude is 0.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_mxl5007t.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN		23
+
+// Default
+#define RTL2832_MXL5007T_STANDARD_MODE_DEFAULT				MXL5007T_STANDARD_DVBT
+#define RTL2832_MXL5007T_IF_FREQ_HZ_DEFAULT					IF_FREQ_4570000HZ
+#define RTL2832_MXL5007T_SPECTRUM_MODE_DEFAULT				SPECTRUM_NORMAL
+#define RTL2832_MXL5007T_QAM_IF_DIFF_OUT_LEVEL_DEFAULT		0
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Mxl5007tModule(
+	DVBT_NIM_MODULE **ppNim,								// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerLoopThroughMode,
+	int TunerClkOutMode,
+	int TunerClkOutAmpMode
+	);
+
+
+
+int
+rtl2832_mxl5007t_Initialize_fm(
+	DVBT_NIM_MODULE *pNim
+	);
+
+// RTL2832 MxL5007T NIM manipulaing functions
+int
+rtl2832_mxl5007t_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_mxl5007t_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_mxl5007t_SetParameters_fm(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.c b/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.c
new file mode 100644
index 00000000..a8dee779
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.c
@@ -0,0 +1,408 @@
+/**
+
+@file
+
+@brief   RTL2832 TDA18272 NIM module definition
+
+One can manipulate RTL2832 TDA18272 NIM through RTL2832 TDA18272 NIM module.
+RTL2832 TDA18272 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_tda18272.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 TDA18272 NIM module builder
+
+Use BuildRtl2832Tda18272Module() to build RTL2832 TDA18272 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 TDA18272 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              TDA18272 I2C device address
+@param [in]   TunerCrystalFreqHz           TDA18272 crystal frequency in Hz
+@param [in]   TunerUnitNo                  TDA18272 unit number
+@param [in]   TunerIfOutputVppMode         TDA18272 IF output Vp-p mode
+
+
+@note
+	-# One should call BuildRtl2832Tda18272Module() to build RTL2832 TDA18272 NIM module before using it.
+
+*/
+void
+BuildRtl2832Tda18272Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerUnitNo,
+	int TunerIfOutputVppMode
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_TDA18272;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build TDA18272 tuner module.
+	BuildTda18272Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		TunerUnitNo,
+		TunerIfOutputVppMode
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize    = rtl2832_tda18272_Initialize;
+	pNim->SetParameters = rtl2832_tda18272_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_tda18272_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_TDA18272_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x40	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x8		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x18	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x80	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9f4	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	// Note: TDA18272 tuner uses dynamic IF frequency, so we will set demod IF frequency in SetParameters().
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_INVERSE.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_INVERSE) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_TDA18272_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_tda18272_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	TDA18272_EXTRA_MODULE *pTunerExtra;
+	int TunerStandardBandwidthMode;
+	unsigned long IfFreqHz;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Tda18272);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:	TunerStandardBandwidthMode = TDA18272_STANDARD_BANDWIDTH_DVBT_6MHZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:	TunerStandardBandwidthMode = TDA18272_STANDARD_BANDWIDTH_DVBT_7MHZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:	TunerStandardBandwidthMode = TDA18272_STANDARD_BANDWIDTH_DVBT_8MHZ;		break;
+	}
+
+	// Set tuner standard and bandwidth mode with TunerStandardBandwidthMode.
+	if(pTunerExtra->SetStandardBandwidthMode(pTuner, TunerStandardBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner RF frequency in Hz.
+	// Note: Must run SetRfFreqHz() after SetStandardBandwidthMode(), because SetRfFreqHz() needs some
+	//       SetStandardBandwidthMode() information.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get tuner IF frequency in Hz.
+	// Note: 1. Must run GetIfFreqHz() after SetRfFreqHz(), because GetIfFreqHz() needs some SetRfFreqHz() information.
+	//       2. TDA18272 tuner uses dynamic IF frequency.
+	if(pTunerExtra->GetIfFreqHz(pTuner, &IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod IF frequency according to IfFreqHz.
+	// Note: TDA18272 tuner uses dynamic IF frequency.
+	if(pDemod->SetIfFreqHz(pDemod, IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_GET_RF_POWER_LEVEL_DBM
+
+*/
+int
+rtl2832_tda18272_GetRfPowerLevelDbm(
+	DVBT_NIM_MODULE *pNim,
+	long *pRfPowerLevelDbm
+	)
+{
+	DVBT_DEMOD_MODULE *pDemod;
+
+	unsigned long FsmStage;
+	int IfAgc;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get FSM stage and IF AGC value.
+	if(pDemod->GetRegBitsWithPage(pDemod, DVBT_FSM_STAGE, &FsmStage) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+	if(pDemod->GetIfAgc(pDemod, &IfAgc) != FUNCTION_SUCCESS)
+		goto error_status_get_registers;
+
+
+	//  Determine signal strength according to FSM stage and IF AGC value.
+	if(FsmStage < 10)
+		*pRfPowerLevelDbm = -120;
+	else
+	{
+		if(IfAgc > -1250)
+			*pRfPowerLevelDbm = -71 - (IfAgc / 165);
+		else
+			*pRfPowerLevelDbm = -60;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.h b/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.h
new file mode 100644
index 00000000..25c8ef17
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_tda18272.h
@@ -0,0 +1,148 @@
+#ifndef __NIM_RTL2832_TDA18272
+#define __NIM_RTL2832_TDA18272
+
+/**
+
+@file
+
+@brief   RTL2832 TDA18272 NIM module declaration
+
+One can manipulate RTL2832 TDA18272 NIM through RTL2832 TDA18272 NIM module.
+RTL2832 TDA18272 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_tda18272.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 TDA18272 NIM module.
+	BuildRtl2832Tda18272Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc0,							// The TDA18272 I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,		// The TDA18272 crystal frequency is 16.0 MHz.
+		TDA18272_UNIT_0,				// The TDA18272 unit number is 0.
+		TDA18272_IF_OUTPUT_VPP_0P7V		// The TDA18272 IF output Vp-p is 0.7 V.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_tda18272.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_TDA18272_ADDITIONAL_INIT_REG_TABLE_LEN		21
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Tda18272Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerUnitNo,
+	int TunerIfOutputVppMode
+	);
+
+
+
+
+
+// RTL2832 TDA18272 NIM manipulaing functions
+int
+rtl2832_tda18272_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_tda18272_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+int
+rtl2832_tda18272_GetRfPowerLevelDbm(
+	DVBT_NIM_MODULE *pNim,
+	long *pRfPowerLevelDbm
+	);
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.c b/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.c
new file mode 100644
index 00000000..92f2f5f3
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.c
@@ -0,0 +1,340 @@
+/**
+
+@file
+
+@brief   RTL2832 TUA9001 NIM module definition
+
+One can manipulate RTL2832 TUA9001 NIM through RTL2832 TUA9001 NIM module.
+RTL2832 TUA9001 NIM module is derived from DVB-T NIM module.
+
+*/
+
+
+#include "nim_rtl2832_tua9001.h"
+
+
+
+
+
+/**
+
+@brief   RTL2832 TUA9001 NIM module builder
+
+Use BuildRtl2832Tua9001Module() to build RTL2832 TUA9001 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2832 TUA9001 NIM module pointer
+@param [in]   pDvbtNimModuleMemory         Pointer to an allocated DVB-T NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2832 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2832 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2832 TS interface mode for setting
+@param [in]   DemodAppMode                 RTL2832 application mode for setting
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2832 update function reference period in millisecond for setting
+@param [in]   DemodIsFunc1Enabled          RTL2832 Function 1 enabling status for setting
+@param [in]   TunerDeviceAddr              TUA9001 I2C device address
+
+
+@note
+	-# One should call BuildRtl2832Tua9001Module() to build RTL2832 TUA9001 NIM module before using it.
+
+*/
+void
+BuildRtl2832Tua9001Module(
+	DVBT_NIM_MODULE **ppNim,							// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	)
+{
+	DVBT_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDvbtNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DVBT_NIM_RTL2832_TUA9001;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2832 demod module.
+	BuildRtl2832Module(
+		&pNim->pDemod,
+		&pNim->DvbtDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodAppMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled
+		);
+
+	// Build TUA9001 tuner module.
+	BuildTua9001Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dvbt_nim_default_GetNimType;
+	pNim->GetParameters     = dvbt_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dvbt_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dvbt_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dvbt_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dvbt_nim_default_GetSignalQuality;
+	pNim->GetBer            = dvbt_nim_default_GetBer;
+	pNim->GetSnrDb          = dvbt_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dvbt_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dvbt_nim_default_GetCrOffsetHz;
+	pNim->GetTpsInfo        = dvbt_nim_default_GetTpsInfo;
+	pNim->UpdateFunction    = dvbt_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2832_tua9001_Initialize;
+	pNim->SetParameters  = rtl2832_tua9001_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2832_tua9001_Initialize(
+	DVBT_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2832_TUA9001_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DVBT_DAGC_TRG_VAL,			0x39	},
+		{DVBT_AGC_TARG_VAL_0,		0x0		},
+		{DVBT_AGC_TARG_VAL_8_1,		0x5a	},
+		{DVBT_AAGC_LOOP_GAIN,		0x16    },
+		{DVBT_LOOP_GAIN2_3_0,		0x6		},
+		{DVBT_LOOP_GAIN2_4,			0x1		},
+		{DVBT_LOOP_GAIN3,			0x16	},
+		{DVBT_VTOP1,				0x35	},
+		{DVBT_VTOP2,				0x21	},
+		{DVBT_VTOP3,				0x21	},
+		{DVBT_KRF1,					0x0		},
+		{DVBT_KRF2,					0x40	},
+		{DVBT_KRF3,					0x10	},
+		{DVBT_KRF4,					0x10	},
+		{DVBT_IF_AGC_MIN,			0x80	},
+		{DVBT_IF_AGC_MAX,			0x7f	},
+		{DVBT_RF_AGC_MIN,			0x9c	},
+		{DVBT_RF_AGC_MAX,			0x7f	},
+		{DVBT_POLAR_RF_AGC,			0x0		},
+		{DVBT_POLAR_IF_AGC,			0x0		},
+		{DVBT_AD7_SETTING,			0xe9f4	},
+		{DVBT_OPT_ADC_IQ,			0x1		},
+		{DVBT_AD_AVI,				0x0		},
+		{DVBT_AD_AVQ,				0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2832_TUA9001_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DVBT_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2832_tua9001_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	DVBT_DEMOD_MODULE *pDemod;
+
+	TUA9001_EXTRA_MODULE *pTunerExtra;
+	int TunerBandwidthMode;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Tua9001);
+
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Determine TunerBandwidthMode according to bandwidth mode.
+	switch(BandwidthMode)
+	{
+		default:
+		case DVBT_BANDWIDTH_6MHZ:		TunerBandwidthMode = TUA9001_BANDWIDTH_6MHZ;		break;
+		case DVBT_BANDWIDTH_7MHZ:		TunerBandwidthMode = TUA9001_BANDWIDTH_7MHZ;		break;
+		case DVBT_BANDWIDTH_8MHZ:		TunerBandwidthMode = TUA9001_BANDWIDTH_8MHZ;		break;
+	}
+
+	// Set tuner bandwidth mode with TunerBandwidthMode.
+	if(pTunerExtra->SetBandwidthMode(pTuner, TunerBandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Set demod bandwidth mode.
+	if(pDemod->SetBandwidthMode(pDemod, BandwidthMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.h b/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.h
new file mode 100644
index 00000000..5eded7df
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2832_tua9001.h
@@ -0,0 +1,137 @@
+#ifndef __NIM_RTL2832_TUA9001
+#define __NIM_RTL2832_TUA9001
+
+/**
+
+@file
+
+@brief   RTL2832 TUA9001 NIM module declaration
+
+One can manipulate RTL2832 TUA9001 NIM through RTL2832 TUA9001 NIM module.
+RTL2832 TUA9001 NIM module is derived from DVB-T NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dvbt_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2832_tua9001.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DVBT_NIM_MODULE *pNim;
+	DVBT_NIM_MODULE DvbtNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2832 TUA9001 NIM module.
+	BuildRtl2832Tua9001Module(
+		&pNim,
+		&DvbtNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x20,							// The RTL2832 I2C device address is 0x20 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2832 TS interface mode is serial.
+		RTL2832_APPLICATION_STB,		// The RTL2832 application mode is STB mode.
+		200,							// The RTL2832 update function reference period is 200 millisecond
+		YES,							// The RTL2832 Function 1 enabling status is YES.
+
+		0xc0							// The TUA9001 I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+	// See the example for other NIM functions in dvbt_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2832.h"
+#include "tuner_tua9001.h"
+#include "dvbt_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2832_TUA9001_ADDITIONAL_INIT_REG_TABLE_LEN		24
+
+
+
+
+
+// Builder
+void
+BuildRtl2832Tua9001Module(
+	DVBT_NIM_MODULE **ppNim,						// DVB-T NIM dependence
+	DVBT_NIM_MODULE *pDvbtNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,				// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,					// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodAppMode,
+	unsigned long UpdateFuncRefPeriodMs,
+	int IsFunc1Enabled,
+
+	unsigned char TunerDeviceAddr					// Tuner dependence
+	);
+
+
+
+
+
+// RTL2832 TUA9001 NIM manipulaing functions
+int
+rtl2832_tua9001_Initialize(
+	DVBT_NIM_MODULE *pNim
+	);
+
+int
+rtl2832_tua9001_SetParameters(
+	DVBT_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int BandwidthMode
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.c b/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.c
new file mode 100644
index 00000000..f501e6ea
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.c
@@ -0,0 +1,308 @@
+/**
+
+@file
+
+@brief   RTL2836 FC2580 NIM module definition
+
+One can manipulate RTL2836 FC2580 NIM through RTL2836 FC2580 NIM module.
+RTL2836 FC2580 NIM module is derived from DTMB NIM module.
+
+*/
+
+
+#include "nim_rtl2836_fc2580.h"
+
+
+
+
+
+/**
+
+@brief   RTL2836 FC2580 NIM module builder
+
+Use BuildRtl2836Fc2580Module() to build RTL2836 FC2580 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2836 FC2580 NIM module pointer
+@param [in]   pDtmbNimModuleMemory         Pointer to an allocated DTMB NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2836 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2836 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2836 TS interface mode
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2836 update function reference period in millisecond
+@param [in]   DemodIsFunc1Enabled          RTL2836 Function 1 enabling status for setting
+@param [in]   DemodIsFunc2Enabled          RTL2836 Function 2 enabling status for setting
+@param [in]   TunerDeviceAddr              FC2580 I2C device address
+@param [in]   TunerCrystalFreqHz           FC2580 crystal frequency in Hz
+@param [in]   TunerAgcMode                 FC2580 AGC mode
+
+
+@note
+	-# One should call BuildRtl2836Fc2580Module() to build RTL2836 FC2580 NIM module before using it.
+
+*/
+void
+BuildRtl2836Fc2580Module(
+	DTMB_NIM_MODULE **ppNim,							// DTMB NIM dependence
+	DTMB_NIM_MODULE *pDtmbNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+	int DemodIsFunc2Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerAgcMode
+	)
+{
+	DTMB_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDtmbNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DTMB_NIM_RTL2836_FC2580;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2836 demod module.
+	BuildRtl2836Module(
+		&pNim->pDemod,
+		&pNim->DtmbDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled,
+		DemodIsFunc2Enabled
+		);
+
+	// Build FC2580 tuner module.
+	BuildFc2580Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		TunerAgcMode
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dtmb_nim_default_GetNimType;
+	pNim->GetParameters     = dtmb_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dtmb_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dtmb_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dtmb_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dtmb_nim_default_GetSignalQuality;
+	pNim->GetBer            = dtmb_nim_default_GetBer;
+	pNim->GetPer            = dtmb_nim_default_GetPer;
+	pNim->GetSnrDb          = dtmb_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dtmb_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dtmb_nim_default_GetCrOffsetHz;
+	pNim->GetSignalInfo     = dtmb_nim_default_GetSignalInfo;
+	pNim->UpdateFunction    = dtmb_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2836_fc2580_Initialize;
+	pNim->SetParameters  = rtl2836_fc2580_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2836_fc2580_Initialize(
+	DTMB_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2836_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DTMB_TARGET_VAL,			0x38	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DTMB_DEMOD_MODULE *pDemod;
+	FC2580_EXTRA_MODULE *pTunerExtra;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Enable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner bandwidth mode with 8 MHz.
+	if(pTunerExtra->SetBandwidthMode(pTuner, FC2580_BANDWIDTH_8000000HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with 0 Hz.
+	if(pDemod->SetIfFreqHz(pDemod, IF_FREQ_0HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_NORMAL.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_NORMAL) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2836_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2836_fc2580_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.h b/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.h
new file mode 100644
index 00000000..cc827ec7
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2836_fc2580.h
@@ -0,0 +1,140 @@
+#ifndef __NIM_RTL2836_FC2580
+#define __NIM_RTL2836_FC2580
+
+/**
+
+@file
+
+@brief   RTL2836 FC2580 NIM module declaration
+
+One can manipulate RTL2836 FC2580 NIM through RTL2836 FC2580 NIM module.
+RTL2836 FC2580 NIM module is derived from DTMB NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dtmb_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2836_fc2580.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DTMB_NIM_MODULE *pNim;
+	DTMB_NIM_MODULE DtmbNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2836 FC2580 NIM module.
+	BuildRtl2836Fc2580Module(
+		&pNim,
+		&DtmbNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x3e,							// The RTL2836 I2C device address is 0x3e in 8-bit format.
+		CRYSTAL_FREQ_27000000HZ,		// The RTL2836 crystal frequency is 27.0 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2836 TS interface mode is serial.
+		50,								// The RTL2836 update function reference period is 50 millisecond
+		YES,							// The RTL2836 Function 1 enabling status is YES.
+		YES,							// The RTL2836 Function 2 enabling status is YES.
+
+		0xac,							// The FC2580 I2C device address is 0xac in 8-bit format.
+		CRYSTAL_FREQ_16384000HZ,		// The FC2580 crystal frequency is 16.384 MHz.
+		FC2580_AGC_INTERNAL				// The FC2580 AGC mode is internal AGC mode.
+		);
+
+
+
+	// See the example for other NIM functions in dtmb_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2836.h"
+#include "tuner_fc2580.h"
+#include "dtmb_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2836_FC2580_ADDITIONAL_INIT_REG_TABLE_LEN		1
+
+
+
+
+
+// Builder
+void
+BuildRtl2836Fc2580Module(
+	DTMB_NIM_MODULE **ppNim,							// DTMB NIM dependence
+	DTMB_NIM_MODULE *pDtmbNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+	int DemodIsFunc2Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerAgcMode
+	);
+
+
+
+
+
+// RTL2836 FC2580 NIM manipulaing functions
+int
+rtl2836_fc2580_Initialize(
+	DTMB_NIM_MODULE *pNim
+	);
+
+int
+rtl2836_fc2580_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.c b/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.c
new file mode 100644
index 00000000..8eaec8b7
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.c
@@ -0,0 +1,319 @@
+/**
+
+@file
+
+@brief   RTL2836 MxL5007T NIM module definition
+
+One can manipulate RTL2836 MxL5007T NIM through RTL2836 MxL5007T NIM module.
+RTL2836 MxL5007T NIM module is derived from DTMB NIM module.
+
+*/
+
+
+#include "nim_rtl2836_mxl5007t.h"
+
+
+
+
+
+/**
+
+@brief   RTL2836 MxL5007T NIM module builder
+
+Use BuildRtl2836Mxl5007tModule() to build RTL2836 MxL5007T NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                        Pointer to RTL2836 MxL5007T NIM module pointer
+@param [in]   pDtmbNimModuleMemory         Pointer to an allocated DTMB NIM module memory
+@param [in]   I2cReadingByteNumMax         Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax         Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                      Basic I2C reading function pointer
+@param [in]   I2cWrite                     Basic I2C writing function pointer
+@param [in]   WaitMs                       Basic waiting function pointer
+@param [in]   DemodDeviceAddr              RTL2836 I2C device address
+@param [in]   DemodCrystalFreqHz           RTL2836 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode         RTL2836 TS interface mode
+@param [in]   DemodUpdateFuncRefPeriodMs   RTL2836 update function reference period in millisecond
+@param [in]   DemodIsFunc1Enabled          RTL2836 Function 1 enabling status for setting
+@param [in]   DemodIsFunc2Enabled          RTL2836 Function 2 enabling status for setting
+@param [in]   TunerDeviceAddr              MxL5007T I2C device address
+@param [in]   TunerCrystalFreqHz           MxL5007T crystal frequency in Hz
+@param [in]   TunerLoopThroughMode         MxL5007T loop-through mode
+@param [in]   TunerClkOutMode              MxL5007T clock output mode
+@param [in]   TunerClkOutAmpMode           MxL5007T clock output amplitude mode
+
+
+@note
+	-# One should call BuildRtl2836Mxl5007tModule() to build RTL2836 MxL5007T NIM module before using it.
+
+*/
+void
+BuildRtl2836Mxl5007tModule(
+	DTMB_NIM_MODULE **ppNim,							// DTMB NIM dependence
+	DTMB_NIM_MODULE *pDtmbNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+	int DemodIsFunc2Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerLoopThroughMode,
+	int TunerClkOutMode,
+	int TunerClkOutAmpMode
+	)
+{
+	DTMB_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pDtmbNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+
+	// Set NIM type.
+	pNim->NimType = DTMB_NIM_RTL2836_MXL5007T;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2836 demod module.
+	BuildRtl2836Module(
+		&pNim->pDemod,
+		&pNim->DtmbDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodUpdateFuncRefPeriodMs,
+		DemodIsFunc1Enabled,
+		DemodIsFunc2Enabled
+		);
+
+	// Build MxL5007T tuner module.
+	BuildMxl5007tModule(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		RTL2836_MXL5007T_STANDARD_MODE_DEFAULT,
+		RTL2836_MXL5007T_IF_FREQ_HZ_DEFAULT,
+		RTL2836_MXL5007T_SPECTRUM_MODE_DEFAULT,
+		TunerLoopThroughMode,
+		TunerClkOutMode,
+		TunerClkOutAmpMode,
+		RTL2836_MXL5007T_QAM_IF_DIFF_OUT_LEVEL_DEFAULT
+		);
+
+
+	// Set NIM module function pointers with default functions.
+	pNim->GetNimType        = dtmb_nim_default_GetNimType;
+	pNim->GetParameters     = dtmb_nim_default_GetParameters;
+	pNim->IsSignalPresent   = dtmb_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = dtmb_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = dtmb_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = dtmb_nim_default_GetSignalQuality;
+	pNim->GetBer            = dtmb_nim_default_GetBer;
+	pNim->GetPer            = dtmb_nim_default_GetPer;
+	pNim->GetSnrDb          = dtmb_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = dtmb_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = dtmb_nim_default_GetCrOffsetHz;
+	pNim->GetSignalInfo     = dtmb_nim_default_GetSignalInfo;
+	pNim->UpdateFunction    = dtmb_nim_default_UpdateFunction;
+
+	// Set NIM module function pointers with particular functions.
+	pNim->Initialize     = rtl2836_mxl5007t_Initialize;
+	pNim->SetParameters  = rtl2836_mxl5007t_SetParameters;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2836_mxl5007t_Initialize(
+	DTMB_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2836_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,				Value
+		{DTMB_TARGET_VAL,			0x38	},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	DTMB_DEMOD_MODULE *pDemod;
+
+	MXL5007T_EXTRA_MODULE *pTunerExtra;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+	// Get tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mxl5007t);
+
+
+	// Enable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner bandwidth mode with 8 MHz.
+	if(pTunerExtra->SetBandwidthMode(pTuner, MXL5007T_BANDWIDTH_8000000HZ) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency with NIM default.
+	if(pDemod->SetIfFreqHz(pDemod, RTL2836_MXL5007T_IF_FREQ_HZ_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with NIM default.
+	if(pDemod->SetSpectrumMode(pDemod, RTL2836_MXL5007T_SPECTRUM_MODE_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod registers.
+	for(i = 0; i < RTL2836_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   DTMB_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2836_mxl5007t_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	DTMB_DEMOD_MODULE *pDemod;
+
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Enable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x1) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Disable demod DTMB_I2CT_EN_CTRL.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, DTMB_I2CT_EN_CTRL, 0x0) != FUNCTION_SUCCESS)
+		goto error_status_set_registers;
+
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+error_status_set_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.h b/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.h
new file mode 100644
index 00000000..41e874f8
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2836_mxl5007t.h
@@ -0,0 +1,150 @@
+#ifndef __NIM_RTL2836_MXL5007T
+#define __NIM_RTL2836_MXL5007T
+
+/**
+
+@file
+
+@brief   RTL2836 MxL5007T NIM module declaration
+
+One can manipulate RTL2836 MxL5007T NIM through RTL2836 MxL5007T NIM module.
+RTL2836 MxL5007T NIM module is derived from DTMB NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in dtmb_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2836_mxl5007t.h"
+
+
+...
+
+
+
+int main(void)
+{
+	DTMB_NIM_MODULE *pNim;
+	DTMB_NIM_MODULE DtmbNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2836 MxL5007T NIM module.
+	BuildRtl2836Mxl5007tModule(
+		&pNim,
+		&DtmbNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x3e,							// The RTL2836 I2C device address is 0x3e in 8-bit format.
+		CRYSTAL_FREQ_27000000HZ,		// The RTL2836 crystal frequency is 27.0 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2836 TS interface mode is serial.
+		50,								// The RTL2836 update function reference period is 50 millisecond
+		YES,							// The RTL2836 Function 1 enabling status is YES.
+		YES,							// The RTL2836 Function 2 enabling status is YES.
+
+		0xc0,							// The MxL5007T I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,		// The MxL5007T Crystal frequency is 16.0 MHz.
+		MXL5007T_LOOP_THROUGH_DISABLE,	// The MxL5007T loop-through mode is disabled.
+		MXL5007T_CLK_OUT_DISABLE,		// The MxL5007T clock output mode is disabled.
+		MXL5007T_CLK_OUT_AMP_0			// The MxL5007T clock output amplitude is 0.
+		);
+
+
+
+	// See the example for other NIM functions in dtmb_nim_base.h
+
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2836.h"
+#include "tuner_mxl5007t.h"
+#include "dtmb_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2836_MXL5007T_ADDITIONAL_INIT_REG_TABLE_LEN		1
+
+// Default
+#define RTL2836_MXL5007T_STANDARD_MODE_DEFAULT				MXL5007T_STANDARD_DVBT
+#define RTL2836_MXL5007T_IF_FREQ_HZ_DEFAULT					IF_FREQ_4570000HZ
+#define RTL2836_MXL5007T_SPECTRUM_MODE_DEFAULT				SPECTRUM_NORMAL
+#define RTL2836_MXL5007T_QAM_IF_DIFF_OUT_LEVEL_DEFAULT		0
+
+
+
+
+
+// Builder
+void
+BuildRtl2836Mxl5007tModule(
+	DTMB_NIM_MODULE **ppNim,							// DTMB NIM dependence
+	DTMB_NIM_MODULE *pDtmbNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	unsigned long DemodUpdateFuncRefPeriodMs,
+	int DemodIsFunc1Enabled,
+	int DemodIsFunc2Enabled,
+
+	unsigned char TunerDeviceAddr,						// Tuner dependence
+	unsigned long TunerCrystalFreqHz,
+	int TunerLoopThroughMode,
+	int TunerClkOutMode,
+	int TunerClkOutAmpMode
+	);
+
+
+
+
+
+// RTL2836 MxL5007T NIM manipulaing functions
+int
+rtl2836_mxl5007t_Initialize(
+	DTMB_NIM_MODULE *pNim
+	);
+
+int
+rtl2836_mxl5007t_SetParameters(
+	DTMB_NIM_MODULE *pNim,
+	unsigned long RfFreqHz
+	);
+
+
+
+
+
+
+
+#endif
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.c b/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.c
new file mode 100644
index 00000000..25daa3f5
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.c
@@ -0,0 +1,341 @@
+/**
+
+@file
+
+@brief   RTL2840 MAX3543 NIM module definition
+
+One can manipulate RTL2840 MAX3543 NIM through RTL2840 MAX3543 NIM module.
+RTL2840 MAX3543 NIM module is derived from QAM NIM module.
+
+*/
+
+
+#include "nim_rtl2840_max3543.h"
+
+
+
+
+
+/**
+
+@brief   RTL2840 MAX3543 NIM module builder
+
+Use BuildRtl2840Max3543Module() to build RTL2840 MAX3543 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                       Pointer to RTL2840 MAX3543 NIM module pointer
+@param [in]   pQamNimModuleMemory         Pointer to an allocated QAM NIM module memory
+@param [in]   I2cReadingByteNumMax        Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax        Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                     Basic I2C reading function pointer
+@param [in]   I2cWrite                    Basic I2C writing function pointer
+@param [in]   WaitMs                      Basic waiting function pointer
+@param [in]   DemodDeviceAddr             RTL2840 I2C device address
+@param [in]   DemodCrystalFreqHz          RTL2840 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode        RTL2840 TS interface mode for setting
+@param [in]   DemodEnhancementMode        RTL2840 enhancement mode for setting
+@param [in]   TunerDeviceAddr             MAX3543 I2C device address
+@param [in]   TunerCrystalFreqHz          MAX3543 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildRtl2840Max3543Module() to build RTL2840 MAX3543 NIM module before using it.
+
+*/
+void
+BuildRtl2840Max3543Module(
+	QAM_NIM_MODULE **ppNim,							// QAM NIM dependence
+	QAM_NIM_MODULE *pQamNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,				// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,					// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodEnhancementMode,
+
+	unsigned char TunerDeviceAddr,					// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	)
+{
+	QAM_NIM_MODULE *pNim;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pQamNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Set enhancement mode in NIM module.
+	pNim->EnhancementMode = DemodEnhancementMode;
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2840 QAM demod module.
+	BuildRtl2840Module(
+		&pNim->pDemod,
+		&pNim->QamDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodEnhancementMode
+		);
+
+	// Build MAX3543 tuner module.
+	BuildMax3543Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+		TunerCrystalFreqHz,
+		RTL2840_MAX3543_STANDARD_MODE_DEFAULT,
+		RTL2840_MAX3543_IF_FREQ_HZ_DEFAULT,
+		RTL2840_MAX3543_SAW_INPUT_TYPE_DEFAULT
+		);
+
+
+	// Set NIM module manipulating function pointers.
+	pNim->Initialize        = rtl2840_max3543_Initialize;
+	pNim->SetParameters     = rtl2840_max3543_SetParameters;
+
+	// Set NIM module manipulating function pointers with default.
+	pNim->GetNimType        = qam_nim_default_GetNimType;
+	pNim->GetParameters     = qam_nim_default_GetParameters;
+	pNim->IsSignalPresent   = qam_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = qam_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = qam_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = qam_nim_default_GetSignalQuality;
+	pNim->GetErrorRate      = qam_nim_default_GetErrorRate;
+	pNim->GetSnrDb          = qam_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = qam_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = qam_nim_default_GetCrOffsetHz;
+	pNim->UpdateFunction    = qam_nim_default_UpdateFunction;
+
+
+	// Set NIM type.
+	pNim->NimType = QAM_NIM_RTL2840_MAX3543;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2840_max3543_Initialize(
+	QAM_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2840_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,					Value
+		{QAM_OPT_RF_AAGC_DRIVE,			0x1		},
+		{QAM_OPT_IF_AAGC_DRIVE,			0x1		},
+		{QAM_OPT_RF_AAGC_OEN,			0x1		},
+		{QAM_OPT_IF_AAGC_OEN,			0x1		},
+		{QAM_RF_AAGC_MAX,				0xff	},
+		{QAM_RF_AAGC_MIN,				0x0		},
+		{QAM_IF_AAGC_MAX,				0xff	},
+		{QAM_IF_AAGC_MIN,				0x0		},
+		{QAM_AAGC_MODE_SEL,				0x0		},
+	};
+
+
+	QAM_DEMOD_MODULE *pDemod;
+	TUNER_MODULE *pTuner;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+	// Get demod module and tuner module.
+	pDemod = pNim->pDemod;
+	pTuner = pNim->pTuner;
+
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency in Hz with NIM default.
+	if(pDemod->SetIfFreqHz(pDemod, RTL2840_MAX3543_IF_FREQ_HZ_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with NIM default.
+	if(pDemod->SetSpectrumMode(pDemod, RTL2840_MAX3543_SPECTRUM_MODE_DEFAULT) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod AAGC registers.
+	// Note: SetParameters() will set QAM_AAGC_TARGET and QAM_VTOP according to parameters.
+	for(i = 0; i < RTL2840_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2840_max3543_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	TUNER_MODULE *pTuner;
+
+
+	// Get demod module and tuner module.
+	pDemod = pNim->pDemod;
+	pTuner = pNim->pTuner;
+
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod QAM mode.
+	if(pDemod->SetQamMode(pDemod, QamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod symbol rate in Hz.
+	if(pDemod->SetSymbolRateHz(pDemod, SymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod alpha mode.
+	if(pDemod->SetAlphaMode(pDemod, AlphaMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set demod QAM_AAGC_TARGET and QAM_VTOP according to QAM mode and enhancement mode.
+	switch(QamMode)
+	{
+		default:
+		case QAM_QAM_4:
+		case QAM_QAM_16:
+		case QAM_QAM_32:
+		case QAM_QAM_64:
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_VTOP, 0x3f) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			switch(pNim->EnhancementMode)
+			{
+				case QAM_DEMOD_EN_NONE:
+
+					if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_AAGC_TARGET, 0x6b) != FUNCTION_SUCCESS)
+						goto error_status_execute_function;
+
+					break;
+
+				default:
+				case QAM_DEMOD_EN_AM_HUM:
+
+					if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_AAGC_TARGET, 0x64) != FUNCTION_SUCCESS)
+						goto error_status_execute_function;
+
+					break;
+			}
+
+			break;
+
+		case QAM_QAM_128:
+		case QAM_QAM_256:
+		case QAM_QAM_512:
+		case QAM_QAM_1024:
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_VTOP, 0x38) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, QAM_AAGC_TARGET, 0x6b) != FUNCTION_SUCCESS)
+				goto error_status_execute_function;
+
+			break;
+	}
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.h b/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.h
new file mode 100644
index 00000000..ff4ec2f6
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2840_max3543.h
@@ -0,0 +1,146 @@
+#ifndef __NIM_RTL2840_MAX3543_H
+#define __NIM_RTL2840_MAX3543_H
+
+/**
+
+@file
+
+@brief   RTL2840 MAX3543 NIM module definition
+
+One can manipulate RTL2840 MAX3543 NIM through RTL2840 MAX3543 NIM module.
+RTL2840 MAX3543 NIM module is derived from QAM NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in qam_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2840_max3543.h"
+
+
+...
+
+
+
+int main(void)
+{
+	QAM_NIM_MODULE *pNim;
+	QAM_NIM_MODULE QamNimModuleMemory;
+
+	...
+
+
+
+	// Build RTL2840 MAX3543 NIM module.
+	BuildRtl2840Max3543Module(
+		&pNim,
+		&QamNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		0x44,							// The RTL2840 I2C device address is 0x44 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The RTL2840 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The RTL2840 TS interface mode is serial.
+		QAM_DEMOD_EN_AM_HUM,			// Use AM-hum enhancement mode.
+
+		0xc0,							// The MAX3543 I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ			// The MAX3543 Crystal frequency is 16.0 MHz.
+		);
+
+
+
+	// See the example for other NIM functions in qam_nim_base.h
+	...
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2840.h"
+#include "tuner_max3543.h"
+#include "qam_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2840_MAX3543_ADDITIONAL_INIT_REG_TABLE_LEN		9
+
+// Default
+#define RTL2840_MAX3543_STANDARD_MODE_DEFAULT				MAX3543_STANDARD_QAM
+#define RTL2840_MAX3543_IF_FREQ_HZ_DEFAULT					IF_FREQ_36170000HZ
+#define RTL2840_MAX3543_SPECTRUM_MODE_DEFAULT				SPECTRUM_INVERSE
+#define RTL2840_MAX3543_SAW_INPUT_TYPE_DEFAULT				MAX3543_SAW_INPUT_SE
+
+
+
+
+
+// Builder
+void
+BuildRtl2840Max3543Module(
+	QAM_NIM_MODULE **ppNim,							// QAM NIM dependence
+	QAM_NIM_MODULE *pQamNimModuleMemory,
+
+	unsigned long I2cReadingByteNumMax,				// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,					// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodEnhancementMode,
+
+	unsigned char TunerDeviceAddr,					// Tuner dependence
+	unsigned long TunerCrystalFreqHz
+	);
+
+
+
+
+
+// RTL2840 MAX3543 NIM manipulaing functions
+int
+rtl2840_max3543_Initialize(
+	QAM_NIM_MODULE *pNim
+	);
+
+int
+rtl2840_max3543_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.c b/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.c
new file mode 100644
index 00000000..3df31e62
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.c
@@ -0,0 +1,307 @@
+/**
+
+@file
+
+@brief   RTL2840 MT2063 NIM module definition
+
+One can manipulate RTL2840 MT2063 NIM through RTL2840 MT2063 NIM module.
+RTL2840 MT2063 NIM module is derived from QAM NIM module.
+
+*/
+
+
+#include "nim_rtl2840_mt2063.h"
+
+
+
+
+
+/**
+
+@brief   RTL2840 MT2063 NIM module builder
+
+Use BuildRtl2840Mt2063Module() to build RTL2840 MT2063 NIM module, set all module function pointers with the
+corresponding functions, and initialize module private variables.
+
+
+@param [in]   ppNim                  Pointer to RTL2840 MT2063 NIM module pointer
+@param [in]   pQamNimModuleMemory    Pointer to an allocated QAM NIM module memory
+@param [in]   I2cReadingByteNumMax   Maximum I2C reading byte number for basic I2C reading function
+@param [in]   I2cWritingByteNumMax   Maximum I2C writing byte number for basic I2C writing function
+@param [in]   I2cRead                Basic I2C reading function pointer
+@param [in]   I2cWrite               Basic I2C writing function pointer
+@param [in]   WaitMs                 Basic waiting function pointer
+@param [in]   DemodDeviceAddr        RTL2840 I2C device address
+@param [in]   DemodCrystalFreqHz     RTL2840 crystal frequency in Hz
+@param [in]   DemodTsInterfaceMode   RTL2840 TS interface mode for setting
+@param [in]   DemodEnhancementMode   RTL2840 enhancement mode for setting
+@param [in]   TunerDeviceAddr        MT2063 I2C device address
+
+
+@note
+	-# One should call BuildRtl2840Mt2063Module() to build RTL2840 MT2063 NIM module before using it.
+
+*/
+void
+BuildRtl2840Mt2063Module(
+	QAM_NIM_MODULE **ppNim,								// QAM NIM dependence
+	QAM_NIM_MODULE *pQamNimModuleMemory,
+	unsigned long NimIfFreqHz,
+
+	unsigned long I2cReadingByteNumMax,					// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,						// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodEnhancementMode,
+
+	unsigned char TunerDeviceAddr						// Tuner dependence
+	)
+{
+	QAM_NIM_MODULE *pNim;
+	RTL2840_MT2063_EXTRA_MODULE *pNimExtra;
+
+
+
+	// Set NIM module pointer with NIM module memory.
+	*ppNim = pQamNimModuleMemory;
+	
+	// Get NIM module.
+	pNim = *ppNim;
+
+	// Set I2C bridge module pointer with I2C bridge module memory.
+	pNim->pI2cBridge = &pNim->I2cBridgeModuleMemory;
+
+	// Get NIM extra module.
+	pNimExtra = &(pNim->Extra.Rtl2840Mt2063);
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pNim->pBaseInterface,
+		&pNim->BaseInterfaceModuleMemory,
+		I2cReadingByteNumMax,
+		I2cWritingByteNumMax,
+		I2cRead,
+		I2cWrite,
+		WaitMs
+		);
+
+	// Build RTL2840 QAM demod module.
+	BuildRtl2840Module(
+		&pNim->pDemod,
+		&pNim->QamDemodModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		DemodDeviceAddr,
+		DemodCrystalFreqHz,
+		DemodTsInterfaceMode,
+		DemodEnhancementMode
+		);
+
+	// Build MT2063 tuner module.
+	BuildMt2063Module(
+		&pNim->pTuner,
+		&pNim->TunerModuleMemory,
+		&pNim->BaseInterfaceModuleMemory,
+		&pNim->I2cBridgeModuleMemory,
+		TunerDeviceAddr,
+//		MT2063_STANDARD_QAM,
+		MT2063_STANDARD_DVBT,
+		MT2063_VGAGC_0X1
+		);
+
+
+	// Set NIM module manipulating function pointers.
+	pNim->Initialize        = rtl2840_mt2063_Initialize;
+	pNim->SetParameters     = rtl2840_mt2063_SetParameters;
+
+	// Set NIM module manipulating function pointers with default.
+	pNim->GetNimType        = qam_nim_default_GetNimType;
+	pNim->GetParameters     = qam_nim_default_GetParameters;
+	pNim->IsSignalPresent   = qam_nim_default_IsSignalPresent;
+	pNim->IsSignalLocked    = qam_nim_default_IsSignalLocked;
+	pNim->GetSignalStrength = qam_nim_default_GetSignalStrength;
+	pNim->GetSignalQuality  = qam_nim_default_GetSignalQuality;
+	pNim->GetErrorRate      = qam_nim_default_GetErrorRate;
+	pNim->GetSnrDb          = qam_nim_default_GetSnrDb;
+	pNim->GetTrOffsetPpm    = qam_nim_default_GetTrOffsetPpm;
+	pNim->GetCrOffsetHz     = qam_nim_default_GetCrOffsetHz;
+	pNim->UpdateFunction    = qam_nim_default_UpdateFunction;
+
+
+	// Set NIM type.
+	pNim->NimType = QAM_NIM_RTL2840_MT2063;
+
+	// Set enhancement mode in NIM module.
+	pNim->EnhancementMode = DemodEnhancementMode;
+
+	// Set IF frequency variable in NIM extra module.
+	pNimExtra->IfFreqHz = NimIfFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_INITIALIZE
+
+*/
+int
+rtl2840_mt2063_Initialize(
+	QAM_NIM_MODULE *pNim
+	)
+{
+	typedef struct
+	{
+		int RegBitName;
+		unsigned long Value;
+	}
+	REG_VALUE_ENTRY;
+
+
+	static const REG_VALUE_ENTRY AdditionalInitRegValueTable[RTL2840_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN] =
+	{
+		// RegBitName,					Value
+		{QAM_OPT_RF_AAGC_DRIVE,			0x1		},
+		{QAM_OPT_IF_AAGC_DRIVE,			0x1		},
+		{QAM_OPT_RF_AAGC_OEN,			0x1		},
+		{QAM_OPT_IF_AAGC_OEN,			0x1		},
+		{QAM_RF_AAGC_MAX,				0x80	},
+		{QAM_RF_AAGC_MIN,				0x80	},
+		{QAM_IF_AAGC_MAX,				0xff	},
+		{QAM_IF_AAGC_MIN,				0x0		},
+		{QAM_AAGC_MODE_SEL,				0x0		},
+	};
+
+
+	TUNER_MODULE *pTuner;
+	QAM_DEMOD_MODULE *pDemod;
+	MT2063_EXTRA_MODULE *pTunerExtra;
+	RTL2840_MT2063_EXTRA_MODULE *pNimExtra;
+
+	int i;
+
+	int RegBitName;
+	unsigned long Value;
+
+
+	// Get modules.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+	pTunerExtra = &(pTuner->Extra.Mt2063);
+	pNimExtra = &(pNim->Extra.Rtl2840Mt2063);
+
+
+	// Initialize tuner.
+	if(pTuner->Initialize(pTuner) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner IF frequency in Hz.
+	if(pTunerExtra->SetIfFreqHz(pTuner, pNimExtra->IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Initialize demod.
+	if(pDemod->Initialize(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod IF frequency in Hz.
+	if(pDemod->SetIfFreqHz(pDemod, pNimExtra->IfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod spectrum mode with SPECTRUM_INVERSE.
+	if(pDemod->SetSpectrumMode(pDemod, SPECTRUM_INVERSE) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod AAGC registers.
+	// Note: SetParameters() will set QAM_AAGC_TARGET and QAM_VTOP according to parameters.
+	for(i = 0; i < RTL2840_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN; i++)
+	{
+		// Get register bit name and its value.
+		RegBitName = AdditionalInitRegValueTable[i].RegBitName;
+		Value      = AdditionalInitRegValueTable[i].Value;
+
+		// Set demod registers
+		if(pDemod->RegAccess.Addr8Bit.SetRegBitsWithPage(pDemod, RegBitName, Value) != FUNCTION_SUCCESS)
+			goto error_status_set_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_registers:
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_SET_PARAMETERS
+
+*/
+int
+rtl2840_mt2063_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module and tuner module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod QAM mode.
+	if(pDemod->SetQamMode(pDemod, QamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod symbol rate in Hz.
+	if(pDemod->SetSymbolRateHz(pDemod, SymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod alpha mode.
+	if(pDemod->SetAlphaMode(pDemod, AlphaMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.h b/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.h
new file mode 100644
index 00000000..0e4e6731
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/nim_rtl2840_mt2063.h
@@ -0,0 +1,163 @@
+#ifndef __NIM_RTL2840_MT2063_H
+#define __NIM_RTL2840_MT2063_H
+
+/**
+
+@file
+
+@brief   RTL2840 MT2063 NIM module definition
+
+One can manipulate RTL2840 MT2063 NIM through RTL2840 MT2063 NIM module.
+RTL2840 MT2063 NIM module is derived from QAM NIM module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the NIM example in qam_nim_base.h except the listed lines.
+
+
+
+#include "nim_rtl2840_mt2063.h"
+
+
+...
+
+
+
+int main(void)
+{
+	QAM_NIM_MODULE *pNim;
+	QAM_NIM_MODULE QamNimModuleMemory;
+	TUNER_MODULE *pTuner;
+	MT2063_EXTRA_MODULE *pTunerExtra;
+
+	...
+
+
+
+	// Build RTL2840 MT2063 NIM module.
+	BuildRtl2840Mt2063Module(
+		&pNim,
+		&QamNimModuleMemory,
+		IF_FREQ_36125000HZ,					// The RTL2840 and MT2063 IF frequency is 36.125 MHz.
+
+		9,									// Maximum I2C reading byte number is 9.
+		8,									// Maximum I2C writing byte number is 8.
+		CustomI2cRead,						// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,						// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,						// Employ CustomWaitMs() as basic waiting function.
+
+		0x44,								// The RTL2840 I2C device address is 0x44 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,			// The RTL2840 crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,				// The RTL2840 TS interface mode is serial.
+		QAM_DEMOD_EN_AM_HUM,				// Use AM-hum enhancement mode.
+
+		0xc0								// The MT2063 I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get MT2063 tuner extra module.
+	pTuner = pNim->pTuner;
+	pTunerExtra = &(pTuner->Extra.Mt2063);
+
+	// Open MT2063 handle.
+	pTunerExtra->OpenHandle(pTuner);
+
+
+
+
+
+	// See the example for other NIM functions in qam_nim_base.h
+	...
+
+
+
+
+
+	// Close MT2063 handle.
+	pTunerExtra->CloseHandle(pTuner);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "demod_rtl2840.h"
+#include "tuner_mt2063.h"
+#include "qam_nim_base.h"
+
+
+
+
+
+// Definitions
+#define RTL2840_MT2063_ADDITIONAL_INIT_REG_TABLE_LEN		9
+
+
+
+
+
+// Builder
+void
+BuildRtl2840Mt2063Module(
+	QAM_NIM_MODULE **ppNim,							// QAM NIM dependence
+	QAM_NIM_MODULE *pQamNimModuleMemory,
+	unsigned long NimIfFreqHz,
+
+	unsigned long I2cReadingByteNumMax,				// Base interface dependence
+	unsigned long I2cWritingByteNumMax,
+	BASE_FP_I2C_READ I2cRead,
+	BASE_FP_I2C_WRITE I2cWrite,
+	BASE_FP_WAIT_MS WaitMs,
+
+	unsigned char DemodDeviceAddr,					// Demod dependence
+	unsigned long DemodCrystalFreqHz,
+	int DemodTsInterfaceMode,
+	int DemodEnhancementMode,
+
+	unsigned char TunerDeviceAddr					// Tuner dependence
+	);
+
+
+
+
+
+// RTL2840 MT2063 NIM manipulaing functions
+int
+rtl2840_mt2063_Initialize(
+	QAM_NIM_MODULE *pNim
+	);
+
+int
+rtl2840_mt2063_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/qam_demod_base.c b/drivers/media/usb/rtl2832u/qam_demod_base.c
new file mode 100644
index 00000000..8843ab52
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/qam_demod_base.c
@@ -0,0 +1,1289 @@
+/**
+
+@file
+
+@brief   QAM demod default function definition
+
+QAM demod default functions.
+
+*/
+
+#include "qam_demod_base.h"
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE
+
+*/
+int
+qam_demod_addr_8bit_default_SetRegPage(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBytes[LEN_2_BYTE];
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Set demod register page with page number.
+	// Note: The I2C format of demod register page setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + QAM_DEMOD_PAGE_REG_ADDR + PageNo + stop_bit
+	WritingBytes[0] = QAM_DEMOD_PAGE_REG_ADDR;
+	WritingBytes[1] = (unsigned char)PageNo;
+
+	if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBytes, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+	if( mutex_lock_interruptible(&d->usb_mutex) )	goto error;
+
+	 pDemod->CurrentPageNo = PageNo;
+
+	mutex_unlock(&d->usb_mutex);
+
+	return FUNCTION_SUCCESS;
+
+error:
+
+	return FUNCTION_ERROR;
+
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_BYTES
+
+*/
+int
+qam_demod_addr_8bit_default_SetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = (unsigned char)(RegStartAddr + i);
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) +
+		//       stop_bit
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, WritingByteNum + LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned char WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+	unsigned long PageNo=0;
+
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	PageNo=pDemod->CurrentPageNo;
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = RegStartAddr + i;
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+		
+		// Set demod register bytes with writing buffer.
+		if(write_demod_register(d, DeviceAddr, PageNo, WritingBuffer[0], WritingBuffer+1, WritingByteNum))
+			goto error_status_set_demod_registers;	
+
+		
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_BYTES
+
+*/
+int
+qam_demod_addr_8bit_default_GetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+	unsigned char DeviceAddr;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = (unsigned char)(RegStartAddr + i);
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, &RegReadingAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned int i;
+	unsigned char DeviceAddr;
+	unsigned char ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+	unsigned long PageNo;
+
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+	
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);  //add by chialing
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	PageNo=pDemod->CurrentPageNo;
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = RegStartAddr + i;
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+		// Get demod register bytes.
+		if(read_demod_register(d, DeviceAddr, PageNo,  RegReadingAddr,  pReadingBytes, ReadingByteNum))
+			goto error_status_get_demod_registers;	
+
+		
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+//error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_MASK_BITS
+
+*/
+int
+qam_demod_addr_8bit_default_SetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+	unsigned char WritingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Reserve unsigned integer value unmask bit with mask and inlay writing value into it.
+	Value &= ~Mask;
+	Value |= (WritingValue << Shift) & Mask;
+
+
+	// Separate unsigned integer value into writing bytes.
+	// Note: Pick up lower address byte from value LSB.
+	//       Pick up upper address byte from value MSB.
+	for(i = 0; i < ByteNum; i++)
+		WritingBytes[i] = (unsigned char)((Value >> (BYTE_SHIFT * i)) & BYTE_MASK);
+
+
+	// Write demod register bytes with writing bytes.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBytes(pDemod, RegStartAddr, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_MASK_BITS
+
+*/
+int
+qam_demod_addr_8bit_default_GetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Get register bits from unsigned integaer value with mask and shift
+	*pReadingValue = (Value & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_BITS
+
+*/
+int
+qam_demod_addr_8bit_default_SetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->BaseRegTable.Addr8Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from base register table with register bit name key.
+	RegStartAddr = pDemod->BaseRegTable.Addr8Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->BaseRegTable.Addr8Bit[RegBitName].Msb;
+	Lsb          = pDemod->BaseRegTable.Addr8Bit[RegBitName].Lsb;
+
+
+	// Set register mask bits.
+	if(pDemod->RegAccess.Addr8Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_BITS
+
+*/
+int
+qam_demod_addr_8bit_default_GetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->BaseRegTable.Addr8Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from base register table with register bit name key.
+	RegStartAddr = pDemod->BaseRegTable.Addr8Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->BaseRegTable.Addr8Bit[RegBitName].Msb;
+	Lsb          = pDemod->BaseRegTable.Addr8Bit[RegBitName].Lsb;
+
+
+	// Get register mask bits.
+	if(pDemod->RegAccess.Addr8Bit.GetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+*/
+int
+qam_demod_addr_8bit_default_SetRegBitsWithPage(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned char PageNo;
+
+
+	// Get register page number from base register table with register bit name key.
+	PageNo = pDemod->BaseRegTable.Addr8Bit[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Set register mask bits with register bit name key.
+	if(pDemod->RegAccess.Addr8Bit.SetRegBits(pDemod, RegBitName, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+*/
+int
+qam_demod_addr_8bit_default_GetRegBitsWithPage(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned char PageNo;
+
+
+	// Get register page number from base register table with register bit name key.
+	PageNo = pDemod->BaseRegTable.Addr8Bit[RegBitName].PageNo;
+
+
+	// Set register page number.
+	if(pDemod->RegAccess.Addr8Bit.SetRegPage(pDemod, PageNo) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	// Get register mask bits with register bit name key.
+	if(pDemod->RegAccess.Addr8Bit.GetRegBits(pDemod, RegBitName, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_BYTES
+
+*/
+int
+qam_demod_addr_16bit_default_SetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i, j;
+
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned short RegWritingAddr;
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set demod register bytes with writing bytes.
+	// Note: Set demod register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = (unsigned short)(RegStartAddr + i);
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of demod register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddrMsb + RegWritingAddrLsb +
+		//       writing_bytes (WritingByteNum bytes) + stop_bit
+		WritingBuffer[0] = (RegWritingAddr >> BYTE_SHIFT) & BYTE_MASK;
+		WritingBuffer[1] = RegWritingAddr & BYTE_MASK;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_2_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set demod register bytes with writing buffer.
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, WritingByteNum + LEN_2_BYTE) !=
+			FUNCTION_SUCCESS)
+			goto error_status_set_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_BYTES
+
+*/
+int
+qam_demod_addr_16bit_default_GetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned long i;
+	unsigned char DeviceAddr;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned short RegReadingAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+
+	// Get base interface.
+	pBaseInterface = pDemod->pBaseInterface;
+
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get demod register bytes.
+	// Note: Get demod register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = (unsigned short)(RegStartAddr + i);
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set demod register reading address.
+		// Note: The I2C format of demod register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddrMsb + RegReadingAddrLsb + stop_bit
+		WritingBuffer[0] = (RegReadingAddr >> BYTE_SHIFT) & BYTE_MASK;
+		WritingBuffer[1] = RegReadingAddr & BYTE_MASK;
+
+		if(pBaseInterface->I2cWrite(pBaseInterface, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_demod_register_reading_address;
+
+		// Get demod register bytes.
+		// Note: The I2C format of demod register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pBaseInterface->I2cRead(pBaseInterface, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_demod_registers;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_register_reading_address:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_MASK_BITS
+
+*/
+int
+qam_demod_addr_16bit_default_SetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+	unsigned char WritingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr16Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Reserve unsigned integer value unmask bit with mask and inlay writing value into it.
+	Value &= ~Mask;
+	Value |= (WritingValue << Shift) & Mask;
+
+
+	// Separate unsigned integer value into writing bytes.
+	// Note: Pick up lower address byte from value LSB.
+	//       Pick up upper address byte from value MSB.
+	for(i = 0; i < ByteNum; i++)
+		WritingBytes[i] = (unsigned char)((Value >> (BYTE_SHIFT * i)) & BYTE_MASK);
+
+
+	// Write demod register bytes with writing bytes.
+	if(pDemod->RegAccess.Addr16Bit.SetRegBytes(pDemod, RegStartAddr, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_MASK_BITS
+
+*/
+int
+qam_demod_addr_16bit_default_GetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingBytes[LEN_4_BYTE];
+
+	unsigned char ByteNum;
+	unsigned long Mask;
+	unsigned char Shift;
+
+	unsigned long Value;
+
+
+	// Calculate writing byte number according to MSB.
+	ByteNum = Msb / BYTE_BIT_NUM + LEN_1_BYTE;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (unsigned char)(Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get demod register bytes according to register start adddress and byte number.
+	if(pDemod->RegAccess.Addr16Bit.GetRegBytes(pDemod, RegStartAddr, ReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	// Combine reading bytes into an unsigned integer value.
+	// Note: Put lower address byte on value LSB.
+	//       Put upper address byte on value MSB.
+	Value = 0;
+
+	for(i = 0; i < ByteNum; i++)
+		Value |= (unsigned long)ReadingBytes[i] << (BYTE_SHIFT * i);
+
+
+	// Get register bits from unsigned integaer value with mask and shift
+	*pReadingValue = (Value & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_SET_REG_BITS
+
+*/
+int
+qam_demod_addr_16bit_default_SetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	)
+{
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->BaseRegTable.Addr16Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from base register table with register bit name key.
+	RegStartAddr = pDemod->BaseRegTable.Addr16Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->BaseRegTable.Addr16Bit[RegBitName].Msb;
+	Lsb          = pDemod->BaseRegTable.Addr16Bit[RegBitName].Lsb;
+
+
+	// Set register mask bits.
+	if(pDemod->RegAccess.Addr16Bit.SetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, WritingValue) != FUNCTION_SUCCESS)
+		goto error_status_set_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_set_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_REG_BITS
+
+*/
+int
+qam_demod_addr_16bit_default_GetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	)
+{
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+
+
+	// Check if register bit name is available.
+	if(pDemod->BaseRegTable.Addr16Bit[RegBitName].IsAvailable == NO)
+		goto error_status_register_bit_name;
+
+
+	// Get register start address, MSB, and LSB from base register table with register bit name key.
+	RegStartAddr = pDemod->BaseRegTable.Addr16Bit[RegBitName].RegStartAddr;
+	Msb          = pDemod->BaseRegTable.Addr16Bit[RegBitName].Msb;
+	Lsb          = pDemod->BaseRegTable.Addr16Bit[RegBitName].Lsb;
+
+
+	// Get register mask bits.
+	if(pDemod->RegAccess.Addr16Bit.GetRegMaskBits(pDemod, RegStartAddr, Msb, Lsb, pReadingValue) != FUNCTION_SUCCESS)
+		goto error_status_get_demod_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_register_bit_name:
+error_status_get_demod_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_DEMOD_TYPE
+
+*/
+void
+qam_demod_default_GetDemodType(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	)
+{
+	// Get demod type from demod module.
+	*pDemodType = pDemod->DemodType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_DEVICE_ADDR
+
+*/
+void
+qam_demod_default_GetDeviceAddr(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get demod I2C device address from demod module.
+	*pDeviceAddr = pDemod->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_CRYSTAL_FREQ_HZ
+
+*/
+void
+qam_demod_default_GetCrystalFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	)
+{
+	// Get demod crystal frequency in Hz from demod module.
+	*pCrystalFreqHz = pDemod->CrystalFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_QAM_MODE
+
+*/
+int
+qam_demod_default_GetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	)
+{
+	// Get demod QAM mode from demod module.
+	if(pDemod->IsQamModeSet != YES)
+		goto error_status_get_demod_qam_mode;
+
+	*pQamMode = pDemod->QamMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_qam_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_SYMBOL_RATE_HZ
+
+*/
+int
+qam_demod_default_GetSymbolRateHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSymbolRateHz
+	)
+{
+	// Get demod symbol rate in Hz from demod module.
+	if(pDemod->IsSymbolRateHzSet != YES)
+		goto error_status_get_demod_symbol_rate;
+
+	*pSymbolRateHz = pDemod->SymbolRateHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_symbol_rate:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_ALPHA_MODE
+
+*/
+int
+qam_demod_default_GetAlphaMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAlphaMode
+	)
+{
+	// Get demod alpha mode from demod module.
+	if(pDemod->IsAlphaModeSet != YES)
+		goto error_status_get_demod_alpha_mode;
+
+	*pAlphaMode = pDemod->AlphaMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_alpha_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_IF_FREQ_HZ
+
+*/
+int
+qam_demod_default_GetIfFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	)
+{
+	// Get demod IF frequency in Hz from demod module.
+	if(pDemod->IsIfFreqHzSet != YES)
+		goto error_status_get_demod_if_frequency;
+
+	*pIfFreqHz = pDemod->IfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_if_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_DEMOD_FP_GET_SPECTRUM_MODE
+
+*/
+int
+qam_demod_default_GetSpectrumMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	)
+{
+	// Get demod spectrum mode from demod module.
+	if(pDemod->IsSpectrumModeSet != YES)
+		goto error_status_get_demod_spectrum_mode;
+
+	*pSpectrumMode = pDemod->SpectrumMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_spectrum_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/qam_demod_base.h b/drivers/media/usb/rtl2832u/qam_demod_base.h
new file mode 100644
index 00000000..0eba9363
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/qam_demod_base.h
@@ -0,0 +1,2827 @@
+#ifndef __QAM_DEMOD_BASE_H
+#define __QAM_DEMOD_BASE_H
+
+/**
+
+@file
+
+@brief   QAM demod base module definition
+
+QAM demod base module definitions contains demod module structure, demod funciton pointers, and demod definitions.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_xxx.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE QamDemodModuleMemory;
+
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;
+
+	int QamMode;
+	unsigned long SymbolRateHz;
+	int AlphaMode;
+	unsigned long IfFreqHz;
+	int SpectrumMode;
+
+	int DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+
+	long RfAgc, IfAgc;
+	unsigned long DiAgc;
+
+	int Answer;
+	long TrOffsetPpm, CrOffsetHz;
+	unsigned long BerNum, BerDen, PerNum, PerDen;
+	double Ber, Per;
+	long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	unsigned long SignalStrength, SignalQuality;
+
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pBaseInterface,
+		&BaseInterfaceModuleMemory,
+		9,								// Set maximum I2C reading byte number with 9.
+		8,								// Set maximum I2C writing byte number with 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs					// Employ CustomWaitMs() as basic waiting function.
+		);
+
+
+	// Build QAM demod XXX module.
+	BuildXxxModule(
+		&pDemod,
+		&QamDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0x44,							// Demod I2C device address is 0x44 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// Demod crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// Demod TS interface mode is serial.
+		...								// Other arguments by each demod module
+		);
+
+
+
+
+
+	// ==== Initialize QAM demod and set its parameters =====
+
+	// Initialize demod.
+	pDemod->Initialize(pDemod);
+
+
+	// Set demod parameters. (QAM mode, symbol rate, alpha mode, IF frequency, spectrum mode)
+	// Note: In the example:
+	//       1. QAM is 64.
+	//       2. Symbol rate is 6.952 MHz.
+	//       3. Alpha is 0.15.
+	//       4. IF frequency is 36 MHz.
+	//       5. Spectrum mode is SPECTRUM_INVERSE.
+	QamMode      = QAM_QAM_64;
+	SymbolRateHz = 6952000;
+	AlphaMode    = QAM_ALPHA_0P15;
+	IfFreqHz     = IF_FREQ_36000000HZ;
+	SpectrumMode = SPECTRUM_INVERSE;
+
+	pDemod->SetQamMode(pDemod,      QamMode);
+	pDemod->SetSymbolRateHz(pDemod, SymbolRateHz);
+	pDemod->SetAlphaMode(pDemod,    AlphaMode);
+	pDemod->SetIfFreqHz(pDemod,     IfFreqHz);
+	pDemod->SetSpectrumMode(pDemod, SpectrumMode);
+
+
+	// Need to set tuner before demod software reset.
+	// The order to set demod and tuner is not important.
+	// Note: One can use "pDemod->SetRegBitsWithPage(pDemod, QAM_OPT_I2C_RELAY, 0x1);"
+	//       for tuner I2C command forwarding.
+
+
+	// Reset demod by software reset.
+	pDemod->SoftwareReset(pDemod);
+
+
+	// Wait maximum 1000 ms for demod converge.
+	for(i = 0; i < 25; i++)
+	{
+		// Wait 40 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 40);
+
+		// Check signal lock status through frame lock.
+		// Note: If Answer is YES, frame is locked.
+		//       If Answer is NO, frame is not locked.
+		pDemod->IsFrameLocked(pDemod, &Answer);
+
+		if(Answer == YES)
+		{
+			// Signal is locked.
+			break;
+		}
+	}
+
+
+
+
+
+	// ==== Get QAM demod information =====
+
+	// Get demod type.
+	// Note: One can find demod type in MODULE_TYPE enumeration.
+	pDemod->GetDemodType(pDemod, &DemodType);
+
+	// Get demod I2C device address.
+	pDemod->GetDeviceAddr(pDemod, &DeviceAddr);
+
+	// Get demod crystal frequency in Hz.
+	pDemod->GetCrystalFreqHz(pDemod, &CrystalFreqHz);
+
+
+	// Ask demod if it is connected to I2C bus.
+	// Note: If Answer is YES, demod is connected to I2C bus.
+	//       If Answer is NO, demod is not connected to I2C bus.
+	pDemod->IsConnectedToI2c(pDemod, &Answer);
+
+
+	// Get demod parameters. (QAM mode, symbol rate, alpha mode, IF frequency, spectrum mode)
+	pDemod->GetQamMode(pDemod,      &QamMode);
+	pDemod->GetSymbolRateHz(pDemod, &SymbolRateHz);
+	pDemod->GetAlphaMode(pDemod,    &AlphaMode);
+	pDemod->GetIfFreqHz(pDemod,     &IfFreqHz);
+	pDemod->GetSpectrumMode(pDemod, &SpectrumMode);
+
+
+	// Get demod AGC value.
+	// Note: The range of RF AGC and IF AGC value is -1024 ~ 1023.
+	//       The range of digital AGC value is 0 ~ 134217727.
+	pDemod->GetRfAgc(pDemod, &RfAgc);
+	pDemod->GetIfAgc(pDemod, &IfAgc);
+	pDemod->GetDiAgc(pDemod, &DiAgc);
+
+
+	// Get demod lock status.
+	// Note: If Answer is YES, it is locked.
+	//       If Answer is NO, it is not locked.
+	pDemod->IsAagcLocked(pDemod,  &Answer);
+	pDemod->IsEqLocked(pDemod,    &Answer);
+	pDemod->IsFrameLocked(pDemod, &Answer);
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pDemod->GetTrOffsetPpm(pDemod, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pDemod->GetCrOffsetHz(pDemod, &CrOffsetHz);
+
+
+	// Get BER and PER.
+	// Note: Test packet number = pow(2, (2 * 5 + 4)) = 16384
+	//       Maximum wait time  = 1000 ms = 1 second
+	pDemod->GetErrorRate(pDemod, 5, 1000, &BerNum, &BerDen, &PerNum, &PerDen);
+	Ber = (double)BerNum / (double)BerDen;
+	Per = (double)PerNum / (double)PerDen;
+
+	// Get SNR in dB.
+	pDemod->GetSnrDb(pDemod, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pDemod->GetSignalStrength(pDemod, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pDemod->GetSignalQuality(pDemod, &SignalQuality);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+
+
+
+
+
+// Definitions
+
+// Page register address
+#define QAM_DEMOD_PAGE_REG_ADDR					0x0
+
+
+/// QAM QAM modes
+enum QAM_QAM_MODE
+{
+	QAM_QAM_4,					///<   QPSK
+	QAM_QAM_16,					///<   16 QAM
+	QAM_QAM_32,					///<   32 QAM
+	QAM_QAM_64,					///<   64 QAM
+	QAM_QAM_128,				///<   128 QAM
+	QAM_QAM_256,				///<   256 QAM
+	QAM_QAM_512,				///<   512 QAM
+	QAM_QAM_1024,				///<   1024 QAM
+};
+#define QAM_QAM_MODE_NUM			8
+
+
+/// QAM alpha modes
+enum QAM_ALPHA_MODE
+{
+	QAM_ALPHA_0P12,				///<   Alpha = 0.12
+	QAM_ALPHA_0P13,				///<   Alpha = 0.13
+	QAM_ALPHA_0P15,				///<   Alpha = 0.15
+	QAM_ALPHA_0P18,				///<   Alpha = 0.18
+	QAM_ALPHA_0P20,				///<   Alpha = 0.20
+};
+#define QAM_ALPHA_MODE_NUM			5
+
+
+/// QAM demod enhancement modes
+enum QAM_DEMOD_EN_MODE
+{
+	QAM_DEMOD_EN_NONE,			///<   None demod enhancement
+	QAM_DEMOD_EN_AM_HUM,		///<   AM-hum demod enhancement
+};
+#define QAM_DEMOD_EN_MODE_NUM		2
+
+
+/// QAM demod configuration mode
+enum QAM_DEMOD_CONFIG_MODE
+{
+	QAM_DEMOD_CONFIG_OC,			///<   OpenCable demod configuration
+	QAM_DEMOD_CONFIG_DVBC,			///<   DVB-C demod configuration
+};
+#define QAM_DEMOD_CONFIG_MODE_NUM		2
+
+
+
+
+
+// Register entry definitions
+
+// Base register entry for 8-bit address
+typedef struct
+{
+	int IsAvailable;
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+QAM_BASE_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Primary base register entry for 8-bit address
+typedef struct
+{
+	int RegBitName;
+	unsigned char PageNo;
+	unsigned char RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+QAM_PRIMARY_BASE_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Monitor register entry for 8-bit address
+#define QAM_MONITOR_REG_INFO_TABLE_LEN		2
+typedef struct
+{
+	int IsAvailable;
+	unsigned char      InfoNum;
+
+	struct
+	{
+		unsigned char SelRegAddr;
+		unsigned char SelValue;
+		int           RegBitName;
+		unsigned char Shift;
+	}
+	InfoTable[QAM_MONITOR_REG_INFO_TABLE_LEN];
+}
+QAM_MONITOR_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Primary monitor register entry for 8-bit address
+typedef struct
+{
+	int MonitorRegBitName;
+	unsigned char      InfoNum;
+
+	struct
+	{
+		unsigned char SelRegAddr;
+		unsigned char SelValue;
+		int           RegBitName;
+		unsigned char Shift;
+	}
+	InfoTable[QAM_MONITOR_REG_INFO_TABLE_LEN];
+}
+QAM_PRIMARY_MONITOR_REG_ENTRY_ADDR_8BIT;
+
+
+
+// Base register entry for 16-bit address
+typedef struct
+{
+	int IsAvailable;
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+QAM_BASE_REG_ENTRY_ADDR_16BIT;
+
+
+
+// Primary base register entry for 16-bit address
+typedef struct
+{
+	int RegBitName;
+	unsigned short RegStartAddr;
+	unsigned char Msb;
+	unsigned char Lsb;
+}
+QAM_PRIMARY_BASE_REG_ENTRY_ADDR_16BIT;
+
+
+
+// Monitor register entry for 16-bit address
+#define QAM_MONITOR_REG_INFO_TABLE_LEN		2
+typedef struct
+{
+	int IsAvailable;
+	unsigned char InfoNum;
+
+	struct
+	{
+		unsigned short SelRegAddr;
+		unsigned char SelValue;
+		int RegBitName;
+		unsigned char Shift;
+	}
+	InfoTable[QAM_MONITOR_REG_INFO_TABLE_LEN];
+}
+QAM_MONITOR_REG_ENTRY_ADDR_16BIT;
+
+
+
+// Primary monitor register entry for 16-bit address
+typedef struct
+{
+	int MonitorRegBitName;
+	unsigned char InfoNum;
+
+	struct
+	{
+		unsigned short SelRegAddr;
+		unsigned char SelValue;
+		int RegBitName;
+		unsigned char Shift;
+	}
+	InfoTable[QAM_MONITOR_REG_INFO_TABLE_LEN];
+}
+QAM_PRIMARY_MONITOR_REG_ENTRY_ADDR_16BIT;
+
+
+
+
+
+// Register bit name definitions
+
+/// Base register bit name
+enum QAM_REG_BIT_NAME
+{
+	// Generality
+	QAM_SYS_VERSION,
+	QAM_OPT_I2C_RELAY,
+	QAM_I2CT_EN_CTRL,						// for RTL2836B DVB-C only
+	QAM_SOFT_RESET,
+	QAM_SOFT_RESET_FF,
+
+	// Miscellany
+	QAM_OPT_I2C_DRIVE_CURRENT,
+	QAM_GPIO2_OEN,
+	QAM_GPIO3_OEN,
+	QAM_GPIO2_O,
+	QAM_GPIO3_O,
+	QAM_GPIO2_I,
+	QAM_GPIO3_I,
+	QAM_INNER_DATA_STROBE,
+	QAM_INNER_DATA_SEL1,
+	QAM_INNER_DATA_SEL2,
+	QAM_INNER_DATA1,
+	QAM_INNER_DATA2,
+
+	// QAM mode
+	QAM_QAM_MODE,
+
+	// AD
+	QAM_AD_AV,								// for RTL2840 only
+
+	// AAGC
+	QAM_OPT_RF_AAGC_DRIVE_CURRENT,			// for RTL2840, RTD2885 QAM only
+	QAM_OPT_IF_AAGC_DRIVE_CURRENT,			// for RTL2840, RTD2885 QAM only
+	QAM_AGC_DRIVE_LV,						// for RTL2836B DVB-C only
+	QAM_OPT_RF_AAGC_DRIVE,
+	QAM_OPT_IF_AAGC_DRIVE,
+	QAM_OPT_RF_AAGC_OEN,					// for RTL2840 only
+	QAM_OPT_IF_AAGC_OEN,					// for RTL2840 only
+	QAM_PAR_RF_SD_IB,
+	QAM_PAR_IF_SD_IB,
+	QAM_AAGC_FZ_OPTION,
+	QAM_AAGC_TARGET,
+	QAM_RF_AAGC_MAX,
+	QAM_RF_AAGC_MIN,
+	QAM_IF_AAGC_MAX,
+	QAM_IF_AAGC_MIN,
+	QAM_VTOP,
+	QAM_KRF,								// for RTD2885 QAM only
+	QAM_KRF_MSB,
+	QAM_KRF_LSB,
+	QAM_AAGC_MODE_SEL,
+	QAM_AAGC_LD,
+	QAM_OPT_RF_AAGC_OE,						// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_OPT_IF_AAGC_OE,						// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_IF_AGC_DRIVING,						// for RTL2820 OpenCable only
+	QAM_RF_AGC_DRIVING,						// for RTL2820 OpenCable only
+	QAM_AAGC_INIT_LEVEL,
+
+	// DDC
+	QAM_DDC_FREQ,
+	QAM_SPEC_INV,
+
+	// Timing recovery
+	QAM_TR_DECI_RATIO,
+
+	// Carrier recovery
+	QAM_CR_LD,
+
+	// Equalizer
+	QAM_EQ_LD,
+	QAM_MSE,
+
+	// Frame sync. indicator
+	QAM_SYNCLOST,							// for RTL2840, RTD2885 QAM only
+	QAM_FS_SYNC_STROBE,						// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_FS_SYNC_LOST,						// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_OC_MPEG_SYNC_MODE,
+
+
+	// BER
+	QAM_BER_RD_STROBE,
+	QAM_BERT_EN,
+	QAM_BERT_HOLD,
+	QAM_DIS_AUTO_MODE,
+	QAM_TEST_VOLUME,
+	QAM_BER_REG0,
+	QAM_BER_REG1,
+	QAM_BER_REG2_15_0,
+	QAM_BER_REG2_18_16,
+
+	QAM_OC_BER_RD_STROBE,					// for RTD2885 QAM only
+	QAM_OC_BERT_EN,							// for RTD2885 QAM only
+	QAM_OC_BERT_HOLD,						// for RTD2885 QAM only
+	QAM_OC_DIS_AUTO_MODE,					// for RTD2885 QAM only
+	QAM_OC_TEST_VOLUME,						// for RTD2885 QAM only
+	QAM_OC_BER_REG0,						// for RTD2885 QAM only
+	QAM_OC_BER_REG1,						// for RTD2885 QAM only
+	QAM_OC_BER_REG2_15_0,					// for RTD2885 QAM only
+	QAM_OC_BER_REG2_18_16,					// for RTD2885 QAM only
+
+	QAM_DVBC_BER_RD_STROBE,					// for RTD2885 QAM only
+	QAM_DVBC_BERT_EN,						// for RTD2885 QAM only
+	QAM_DVBC_BERT_HOLD,						// for RTD2885 QAM only
+	QAM_DVBC_DIS_AUTO_MODE,					// for RTD2885 QAM only
+	QAM_DVBC_TEST_VOLUME,					// for RTD2885 QAM only
+	QAM_DVBC_BER_REG0,						// for RTD2885 QAM only
+	QAM_DVBC_BER_REG1,						// for RTD2885 QAM only
+	QAM_DVBC_BER_REG2_15_0,					// for RTD2885 QAM only
+	QAM_DVBC_BER_REG2_18_16,				// for RTD2885 QAM only
+
+
+	// MPEG TS output interface
+	QAM_CKOUTPAR,
+	QAM_CKOUT_PWR,
+	QAM_CDIV_PH0,
+	QAM_CDIV_PH1,
+	QAM_MPEG_OUT_EN,						// for RTL2840 only
+	QAM_OPT_MPEG_DRIVE_CURRENT,				// for RTL2840 only
+	QAM_NO_REINVERT,						// for RTL2840 only
+	QAM_FIX_TEI,							// for RTL2840 only
+	QAM_SERIAL,								// for RTL2840 only
+	QAM_OPT_MPEG_IO,						// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_OPT_M_OEN,							// for RTL2820 OpenCable, RTD2885 QAM only
+	QAM_REPLA_SD_EN,						// for RTL2820 OpenCable only
+	QAM_TEI_SD_ERR_EN,						// for RTL2820 OpenCable only
+	QAM_TEI_RS_ERR_EN,						// for RTL2820 OpenCable only
+	QAM_SET_MPEG_ERR,						// for RTL2820 OpenCable only
+
+	QAM_OC_CKOUTPAR,						// for RTD2885 QAM only
+	QAM_OC_CKOUT_PWR,						// for RTD2885 QAM only
+	QAM_OC_CDIV_PH0,						// for RTD2885 QAM only
+	QAM_OC_CDIV_PH1,						// for RTD2885 QAM only
+	QAM_OC_SERIAL,							// for RTD2885 QAM only
+
+	QAM_DVBC_CKOUTPAR,						// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_CKOUT_PWR,						// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_CDIV_PH0,						// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_CDIV_PH1,						// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_NO_REINVERT,					// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_FIX_TEI,						// for RTD2885 QAM, RTL2836B DVB-C only
+	QAM_DVBC_SERIAL,						// for RTD2885 QAM, RTL2836B DVB-C only
+
+
+	// Monitor
+	QAM_ADC_CLIP_CNT_REC,
+	QAM_DAGC_LEVEL_26_11,
+	QAM_DAGC_LEVEL_10_0,
+	QAM_RF_AAGC_SD_IN,
+	QAM_IF_AAGC_SD_IN,
+	QAM_KI_TR_OUT_30_15,
+	QAM_KI_TR_OUT_14_0,
+	QAM_KI_CR_OUT_15_0,
+	QAM_KI_CR_OUT_31_16,
+
+	// Specific register
+	QAM_SPEC_SIGNAL_INDICATOR,
+	QAM_SPEC_ALPHA_STROBE,
+	QAM_SPEC_ALPHA_SEL,
+	QAM_SPEC_ALPHA_VAL,
+	QAM_SPEC_SYMBOL_RATE_REG_0,
+	QAM_SPEC_SYMBOL_RATE_STROBE,
+	QAM_SPEC_SYMBOL_RATE_SEL,
+	QAM_SPEC_SYMBOL_RATE_VAL,
+	QAM_SPEC_REG_0_STROBE,
+	QAM_SPEC_REG_0_SEL,
+	QAM_SPEC_INIT_A0,						// for RTL2840 only
+	QAM_SPEC_INIT_A1,						// for RTL2840 only
+	QAM_SPEC_INIT_A2,						// for RTL2840 only
+	QAM_SPEC_INIT_B0,						// for RTL2820 OpenCable only
+	QAM_SPEC_INIT_C1,						// for RTL2820 OpenCable only
+	QAM_SPEC_INIT_C2,						// for RTL2820 OpenCable only
+	QAM_SPEC_INIT_C3,						// for RTL2820 OpenCable only
+
+	// GPIO
+	QAM_OPT_GPIOA_OE,						// for RTL2836B DVB-C only
+
+	// Pseudo register for test only
+	QAM_TEST_REG_0,
+	QAM_TEST_REG_1,
+	QAM_TEST_REG_2,
+	QAM_TEST_REG_3,
+
+
+	// Item terminator
+	QAM_REG_BIT_NAME_ITEM_TERMINATOR,
+};
+
+
+/// Monitor register bit name
+enum QAM_MONITOR_REG_BIT_NAME
+{
+	// Generality
+	QAM_ADC_CLIP_CNT,
+	QAM_DAGC_VALUE,
+	QAM_RF_AGC_VALUE,
+	QAM_IF_AGC_VALUE,
+	QAM_TR_OFFSET,
+	QAM_CR_OFFSET,
+
+	// Specific monitor register
+	QAM_SPEC_MONITER_INIT_0,
+
+	// Item terminator
+	QAM_MONITOR_REG_BIT_NAME_ITEM_TERMINATOR,
+};
+
+
+
+// Register table length definitions
+#define QAM_BASE_REG_TABLE_LEN_MAX			QAM_REG_BIT_NAME_ITEM_TERMINATOR
+#define QAM_MONITOR_REG_TABLE_LEN_MAX		QAM_MONITOR_REG_BIT_NAME_ITEM_TERMINATOR
+
+
+
+
+
+/// QAM demod module pre-definition
+typedef struct QAM_DEMOD_MODULE_TAG QAM_DEMOD_MODULE;
+
+
+
+
+
+/**
+
+@brief   QAM demod register page setting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_SET_REG_PAGE() to set demod register page.
+
+
+@param [in]   pDemod   The demod module pointer
+@param [in]   PageNo   Page number
+
+
+@retval   FUNCTION_SUCCESS   Set register page successfully with page number.
+@retval   FUNCTION_ERROR     Set register page unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_REG_PAGE() with the corresponding function.
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register page with page number 2.
+	pDemod->SetRegPage(pDemod, 2);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_SET_REG_PAGE)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register byte setting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_SET_REG_BYTES() to set demod register bytes.
+
+
+@param [in]   pDemod          The demod module pointer
+@param [in]   RegStartAddr    Demod register start address
+@param [in]   pWritingBytes   Pointer to writing bytes
+@param [in]   ByteNum         Writing byte number
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bytes successfully with writing bytes.
+@retval   FUNCTION_ERROR     Set demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by QAM_DEMOD_FP_SET_REG_PAGE() before using QAM_DEMOD_FP_SET_REG_BYTES().
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_GET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char WritingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bytes (page 1, address 0x17 ~ 0x1b) with 5 writing bytes.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBytes(pDemod, 0x17, WritingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BYTES)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_SET_REG_BYTES)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register byte getting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_GET_REG_BYTES() to get demod register bytes.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [out]   pReadingBytes   Pointer to an allocated memory for storing reading bytes
+@param [in]    ByteNum         Reading byte number
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bytes successfully with reading byte number.
+@retval   FUNCTION_ERROR     Get demod register bytes unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_REG_BYTES() with the corresponding function.
+	-# Need to set register page by QAM_DEMOD_FP_SET_REG_PAGE() before using QAM_DEMOD_FP_GET_REG_BYTES().
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_SET_REG_BYTES
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned char ReadingBytes[10];
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bytes (page 1, address 0x17 ~ 0x1b) with reading byte number 5.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBytes(pDemod, 0x17, ReadingBytes, 5);
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BYTES)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_GET_REG_BYTES)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register mask bits setting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_SET_REG_MASK_BITS() to set demod register mask bits.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegStartAddr   Demod register start address
+@param [in]   Msb            Mask MSB with 0-based index
+@param [in]   Lsb            Mask LSB with 0-based index
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register mask bits successfully with writing value.
+@retval   FUNCTION_ERROR     Set demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by QAM_DEMOD_FP_SET_REG_PAGE() before using QAM_DEMOD_FP_SET_REG_MASK_BITS().
+	-# The constraints of QAM_DEMOD_FP_SET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_GET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits (page 1, address {0x18, 0x17} [12:5]) with writing value 0x1d.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegMaskBits(pDemod, 0x17, 12, 5, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_SET_REG_MASK_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_SET_REG_MASK_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register mask bits getting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_GET_REG_MASK_BITS() to get demod register mask bits.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegStartAddr    Demod register start address
+@param [in]    Msb             Mask MSB with 0-based index
+@param [in]    Lsb             Mask LSB with 0-based index
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register mask bits successfully.
+@retval   FUNCTION_ERROR     Get demod register mask bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_REG_MASK_BITS() with the corresponding function.
+	-# Need to set register page by QAM_DEMOD_FP_SET_REG_PAGE() before using QAM_DEMOD_FP_GET_REG_MASK_BITS().
+	-# The constraints of QAM_DEMOD_FP_GET_REG_MASK_BITS() function usage are described as follows:
+		-# The mask MSB and LSB must be 0~31.
+		-# The mask MSB must be greater than or equal to LSB.
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_SET_REG_MASK_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits (page 1, address {0x18, 0x17} [12:5]).
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegMaskBits(pDemod, 0x17, 12, 5, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_GET_REG_MASK_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_GET_REG_MASK_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register bits setting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_SET_REG_BITS() to set demod register bits with bit name.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using QAM_DEMOD_FP_SET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_GET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->SetRegBits(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_SET_REG_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register bits getting function pointer
+
+Demod upper level functions will use QAM_DEMOD_FP_GET_REG_BITS() to get demod register bits with bit name.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_REG_BITS() with the corresponding function.
+	-# Need to set register page before using QAM_DEMOD_FP_GET_REG_BITS().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   QAM_DEMOD_FP_SET_REG_PAGE, QAM_DEMOD_FP_SET_REG_BITS
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegPage(pDemod, 1);
+	pDemod->GetRegBits(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+typedef int
+(*QAM_DEMOD_FP_ADDR_16BIT_GET_REG_BITS)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register bits setting function pointer (with page setting)
+
+Demod upper level functions will use QAM_DEMOD_FP_SET_REG_BITS_WITH_PAGE() to set demod register bits with bit name and
+page setting.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   RegBitName     Pre-defined demod register bit name
+@param [in]   WritingValue   The mask bits writing value
+
+
+@retval   FUNCTION_SUCCESS   Set demod register bits successfully with bit name, page setting, and writing value.
+@retval   FUNCTION_ERROR     Set demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using QAM_DEMOD_FP_SET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   QAM_DEMOD_FP_GET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Set demod register bits with bit name PSEUDO_REG_BIT_NAME and writing value 0x1d.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->SetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, 0x1d);
+
+
+	// Result:
+	//
+	// Writing value = 0x1d = 0001 1101 b
+	// 
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BITS_WITH_PAGE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod register bits getting function pointer (with page setting)
+
+Demod upper level functions will use QAM_DEMOD_FP_GET_REG_BITS_WITH_PAGE() to get demod register bits with bit name and
+page setting.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    RegBitName      Pre-defined demod register bit name
+@param [out]   pReadingValue   Pointer to an allocated memory for storing reading value
+
+
+@retval   FUNCTION_SUCCESS   Get demod register bits successfully with bit name and page setting.
+@retval   FUNCTION_ERROR     Get demod register bits unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_REG_BITS_WITH_PAGE() with the corresponding function.
+	-# Don't need to set register page before using QAM_DEMOD_FP_GET_REG_BITS_WITH_PAGE().
+	-# Register bit names are pre-defined keys for bit access, and one can find these in demod header file.
+
+
+@see   QAM_DEMOD_FP_SET_REG_BITS_WITH_PAGE
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE DvbcDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+	unsigned long ReadingValue;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &DvbcDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Get demod register bits with bit name PSEUDO_REG_BIT_NAME.
+	// The corresponding information of PSEUDO_REG_BIT_NAME is address {0x18, 0x17} [12:5] on page 1.
+	pDemod->GetRegBitsWithPage(pDemod, PSEUDO_REG_BIT_NAME, &ReadingValue);
+
+
+	// Result:
+	//
+	// Page 1
+	// Register address   0x18          0x17
+	// Register value     xxx0 0011 b   101x xxxx b
+	//
+	// Reading value = 0001 1101 b = 0x1d
+
+	...
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BITS_WITH_PAGE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// Demod register access for 8-bit address
+typedef struct
+{
+	QAM_DEMOD_FP_ADDR_8BIT_SET_REG_PAGE             SetRegPage;
+	QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BYTES            SetRegBytes;
+	QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BYTES            GetRegBytes;
+	QAM_DEMOD_FP_ADDR_8BIT_SET_REG_MASK_BITS        SetRegMaskBits;
+	QAM_DEMOD_FP_ADDR_8BIT_GET_REG_MASK_BITS        GetRegMaskBits;
+	QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BITS             SetRegBits;
+	QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BITS             GetRegBits;
+	QAM_DEMOD_FP_ADDR_8BIT_SET_REG_BITS_WITH_PAGE   SetRegBitsWithPage;
+	QAM_DEMOD_FP_ADDR_8BIT_GET_REG_BITS_WITH_PAGE   GetRegBitsWithPage;
+}
+QAM_DEMOD_REG_ACCESS_ADDR_8BIT;
+
+
+
+
+
+// Demod register access for 16-bit address
+typedef struct
+{
+	QAM_DEMOD_FP_ADDR_16BIT_SET_REG_BYTES       SetRegBytes;
+	QAM_DEMOD_FP_ADDR_16BIT_GET_REG_BYTES       GetRegBytes;
+	QAM_DEMOD_FP_ADDR_16BIT_SET_REG_MASK_BITS   SetRegMaskBits;
+	QAM_DEMOD_FP_ADDR_16BIT_GET_REG_MASK_BITS   GetRegMaskBits;
+	QAM_DEMOD_FP_ADDR_16BIT_SET_REG_BITS        SetRegBits;
+	QAM_DEMOD_FP_ADDR_16BIT_GET_REG_BITS        GetRegBits;
+}
+QAM_DEMOD_REG_ACCESS_ADDR_16BIT;
+
+
+
+
+
+/**
+
+@brief   QAM demod type getting function pointer
+
+One can use QAM_DEMOD_FP_GET_DEMOD_TYPE() to get QAM demod type.
+
+
+@param [in]    pDemod       The demod module pointer
+@param [out]   pDemodType   Pointer to an allocated memory for storing demod type
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_DEMOD_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*QAM_DEMOD_FP_GET_DEMOD_TYPE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod I2C device address getting function pointer
+
+One can use QAM_DEMOD_FP_GET_DEVICE_ADDR() to get QAM demod I2C device address.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pDeviceAddr   Pointer to an allocated memory for storing demod I2C device address
+
+
+@retval   FUNCTION_SUCCESS   Get demod device address successfully.
+@retval   FUNCTION_ERROR     Get demod device address unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_DEVICE_ADDR() with the corresponding function.
+
+*/
+typedef void
+(*QAM_DEMOD_FP_GET_DEVICE_ADDR)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod crystal frequency getting function pointer
+
+One can use QAM_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() to get QAM demod crystal frequency in Hz.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pCrystalFreqHz   Pointer to an allocated memory for storing demod crystal frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod crystal frequency successfully.
+@retval   FUNCTION_ERROR     Get demod crystal frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_CRYSTAL_FREQ_HZ() with the corresponding function.
+
+*/
+typedef void
+(*QAM_DEMOD_FP_GET_CRYSTAL_FREQ_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod I2C bus connection asking function pointer
+
+One can use QAM_DEMOD_FP_IS_CONNECTED_TO_I2C() to ask QAM demod if it is connected to I2C bus.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_IS_CONNECTED_TO_I2C() with the corresponding function.
+
+*/
+typedef void
+(*QAM_DEMOD_FP_IS_CONNECTED_TO_I2C)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod software resetting function pointer
+
+One can use QAM_DEMOD_FP_SOFTWARE_RESET() to reset QAM demod by software reset.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod by software reset successfully.
+@retval   FUNCTION_ERROR     Reset demod by software reset unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SOFTWARE_RESET() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SOFTWARE_RESET)(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod initializing function pointer
+
+One can use QAM_DEMOD_FP_INITIALIZE() to initialie QAM demod.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize demod successfully.
+@retval   FUNCTION_ERROR     Initialize demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_INITIALIZE)(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod QAM mode setting function pointer
+
+One can use QAM_DEMOD_FP_SET_QAM_MODE() to set QAM demod QAM mode.
+
+
+@param [in]   pDemod    The demod module pointer
+@param [in]   QamMode   QAM mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod QAM mode successfully.
+@retval   FUNCTION_ERROR     Set demod QAM mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_QAM_MODE() with the corresponding function.
+
+
+@see   QAM_QAM_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SET_QAM_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int QamMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod symbol rate setting function pointer
+
+One can use QAM_DEMOD_FP_SET_SYMBOL_RATE_HZ() to set QAM demod symbol rate in Hz.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   SymbolRateHz   Symbol rate in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod symbol rate successfully.
+@retval   FUNCTION_ERROR     Set demod symbol rate unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_SYMBOL_RATE_HZ() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SET_SYMBOL_RATE_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long SymbolRateHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod alpha mode setting function pointer
+
+One can use QAM_DEMOD_FP_SET_ALPHA_MODE() to set QAM demod alpha mode.
+
+
+@param [in]   pDemod      The demod module pointer
+@param [in]   AlphaMode   Alpha mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod alpha mode successfully.
+@retval   FUNCTION_ERROR     Set demod alpha mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_ALPHA_MODE() with the corresponding function.
+
+
+@see   QAM_ALPHA_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SET_ALPHA_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int AlphaMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod IF frequency setting function pointer
+
+One can use QAM_DEMOD_FP_SET_IF_FREQ_HZ() to set QAM demod IF frequency in Hz.
+
+
+@param [in]   pDemod     The demod module pointer
+@param [in]   IfFreqHz   IF frequency in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Set demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SET_IF_FREQ_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long IfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod spectrum mode setting function pointer
+
+One can use QAM_DEMOD_FP_SET_SPECTRUM_MODE() to set QAM demod spectrum mode.
+
+
+@param [in]   pDemod         The demod module pointer
+@param [in]   SpectrumMode   Spectrum mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Set demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_SET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_SET_SPECTRUM_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int SpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod QAM mode getting function pointer
+
+One can use QAM_DEMOD_FP_GET_QAM_MODE() to get QAM demod QAM mode.
+
+
+@param [in]    pDemod     The demod module pointer
+@param [out]   pQamMode   Pointer to an allocated memory for storing demod QAM mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod QAM mode successfully.
+@retval   FUNCTION_ERROR     Get demod QAM mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_QAM_MODE() with the corresponding function.
+
+
+@see   QAM_QAM_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_QAM_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod symbol rate getting function pointer
+
+One can use QAM_DEMOD_FP_GET_SYMBOL_RATE_HZ() to get QAM demod symbol rate in Hz.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pSymbolRateHz   Pointer to an allocated memory for storing demod symbol rate in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod symbol rate successfully.
+@retval   FUNCTION_ERROR     Get demod symbol rate unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_SYMBOL_RATE_HZ() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_SYMBOL_RATE_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSymbolRateHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod alpha mode getting function pointer
+
+One can use QAM_DEMOD_FP_GET_ALPHA_MODE() to get QAM demod alpha mode.
+
+
+@param [in]    pDemod       The demod module pointer
+@param [out]   pAlphaMode   Pointer to an allocated memory for storing demod alpha mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod alpha mode successfully.
+@retval   FUNCTION_ERROR     Get demod alpha mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_ALPHA_MODE() with the corresponding function.
+
+
+@see   QAM_ALPHA_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_ALPHA_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAlphaMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod IF frequency getting function pointer
+
+One can use QAM_DEMOD_FP_GET_IF_FREQ_HZ() to get QAM demod IF frequency in Hz.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pIfFreqHz   Pointer to an allocated memory for storing demod IF frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF frequency successfully.
+@retval   FUNCTION_ERROR     Get demod IF frequency unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_IF_FREQ_HZ() with the corresponding function.
+
+
+@see   IF_FREQ_HZ
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_IF_FREQ_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod spectrum mode getting function pointer
+
+One can use QAM_DEMOD_FP_GET_SPECTRUM_MODE() to get QAM demod spectrum mode.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [out]   pSpectrumMode   Pointer to an allocated memory for storing demod spectrum mode
+
+
+@retval   FUNCTION_SUCCESS   Get demod spectrum mode successfully.
+@retval   FUNCTION_ERROR     Get demod spectrum mode unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_SPECTRUM_MODE() with the corresponding function.
+
+
+@see   SPECTRUM_MODE
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_SPECTRUM_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod RF AGC getting function pointer
+
+One can use QAM_DEMOD_FP_GET_RF_AGC() to get QAM demod RF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pRfAgc   Pointer to an allocated memory for storing RF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod RF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod RF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_RF_AGC() with the corresponding function.
+	-# The range of RF AGC value is (-pow(2, 10)) ~ (pow(2, 10) - 1).
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_RF_AGC)(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pRfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod IF AGC getting function pointer
+
+One can use QAM_DEMOD_FP_GET_IF_AGC() to get QAM demod IF AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pIfAgc   Pointer to an allocated memory for storing IF AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod IF AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod IF AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_IF_AGC() with the corresponding function.
+	-# The range of IF AGC value is (-pow(2, 10)) ~ (pow(2, 10) - 1).
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_IF_AGC)(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pIfAgc
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod digital AGC getting function pointer
+
+One can use QAM_DEMOD_FP_GET_DI_AGC() to get QAM demod digital AGC value.
+
+
+@param [in]    pDemod   The demod module pointer
+@param [out]   pDiAgc   Pointer to an allocated memory for storing digital AGC value
+
+
+@retval   FUNCTION_SUCCESS   Get demod digital AGC value successfully.
+@retval   FUNCTION_ERROR     Get demod digital AGC value unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_DI_AGC() with the corresponding function.
+	-# The range of digital AGC value is 0 ~ (pow(2, 27) - 1).
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_DI_AGC)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pDiAgc
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod TR offset getting function pointer
+
+One can use QAM_DEMOD_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pDemod         The demod module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get demod TR offset successfully.
+@retval   FUNCTION_ERROR     Get demod TR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_TR_OFFSET_PPM)(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod CR offset getting function pointer
+
+One can use QAM_DEMOD_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pDemod        The demod module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get demod CR offset successfully.
+@retval   FUNCTION_ERROR     Get demod CR offset unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_CR_OFFSET_HZ)(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod AAGC lock asking function pointer
+
+One can use QAM_DEMOD_FP_IS_AAGC_LOCKED() to ask QAM demod if it is AAGC-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform AAGC lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform AAGC lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_IS_AAGC_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_IS_AAGC_LOCKED)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod EQ lock asking function pointer
+
+One can use QAM_DEMOD_FP_IS_EQ_LOCKED() to ask QAM demod if it is EQ-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform EQ lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform EQ lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_IS_EQ_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_IS_EQ_LOCKED)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod frame lock asking function pointer
+
+One can use QAM_DEMOD_FP_IS_FRAME_LOCKED() to ask QAM demod if it is frame-locked.
+
+
+@param [in]    pDemod    The demod module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform frame lock asking to demod successfully.
+@retval   FUNCTION_ERROR     Perform frame lock asking to demod unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_IS_FRAME_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_IS_FRAME_LOCKED)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod error rate value getting function pointer
+
+One can use QAM_DEMOD_FP_GET_ERROR_RATE() to get error rate value.
+
+
+@param [in]    pDemod          The demod module pointer
+@param [in]    TestVolume      Test volume for setting
+@param [in]    WaitTimeMsMax   Maximum waiting time in ms
+@param [out]   pBerNum         Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen         Pointer to an allocated memory for storing BER denominator
+@param [out]   pPerNum         Pointer to an allocated memory for storing PER numerator
+@param [out]   pPerDen         Pointer to an allocated memory for storing PER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod error rate value successfully.
+@retval   FUNCTION_ERROR     Get demod error rate value unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_ERROR_RATE() with the corresponding function.
+	-# The error test packet number is pow(2, (2 * TestVolume + 4)).
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_ERROR_RATE)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod SNR getting function pointer
+
+One can use QAM_DEMOD_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pDemod      The demod module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get demod SNR successfully.
+@retval   FUNCTION_ERROR     Get demod SNR unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_SNR_DB)(
+	QAM_DEMOD_MODULE *pDemod,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod signal strength getting function pointer
+
+One can use QAM_DEMOD_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pDemod            The demod module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal strength successfully.
+@retval   FUNCTION_ERROR     Get demod signal strength unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_SIGNAL_STRENGTH)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod signal quality getting function pointer
+
+One can use QAM_DEMOD_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pDemod           The demod module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get demod signal quality successfully.
+@retval   FUNCTION_ERROR     Get demod signal quality unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*QAM_DEMOD_FP_GET_SIGNAL_QUALITY)(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod updating function pointer
+
+One can use QAM_DEMOD_FP_UPDATE_FUNCTION() to update demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update demod setting successfully.
+@retval   FUNCTION_ERROR     Update demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE QamDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &QamDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_UPDATE_FUNCTION)(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/**
+
+@brief   QAM demod reseting function pointer
+
+One can use QAM_DEMOD_FP_RESET_FUNCTION() to reset demod register setting.
+
+
+@param [in]   pDemod   The demod module pointer
+
+
+@retval   FUNCTION_SUCCESS   Reset demod setting successfully.
+@retval   FUNCTION_ERROR     Reset demod setting unsuccessfully.
+
+
+@note
+	-# Demod building function will set QAM_DEMOD_FP_RESET_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_pseudo.h"
+
+
+int main(void)
+{
+	QAM_DEMOD_MODULE *pDemod;
+	QAM_DEMOD_MODULE QamDemodModuleMemory;
+	PSEUDO_EXTRA_MODULE PseudoExtraModuleMemory;
+
+
+	// Build pseudo demod module.
+	BuildPseudoDemodModule(&pDemod, &QamDemodModuleMemory, &PseudoExtraModuleMemory);
+
+	...
+
+	// Execute ResetFunction() before demod software reset.
+	pDemod->ResetFunction(pDemod);
+
+	// Reset demod by software.
+	pDemod->SoftwareReset(pDemod);
+
+	...
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pDemod->UpdateFunction(pDemod);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_DEMOD_FP_RESET_FUNCTION)(
+	QAM_DEMOD_MODULE *pDemod
+	);
+
+
+
+
+
+/// RTD2885 QAM extra module
+typedef struct RTD2885_QAM_EXTRA_MODULE_TAG RTD2885_QAM_EXTRA_MODULE;
+
+// RTD2885 QAM extra manipulaing functions
+typedef void
+(*RTD2885_QAM_FP_GET_CONFIG_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pConfigMode
+	);
+
+// RTD2885 QAM extra module
+struct RTD2885_QAM_EXTRA_MODULE_TAG
+{
+	// Variables
+	int ConfigMode;
+	unsigned char Func1TickNum;
+
+	// Functions
+	RTD2885_QAM_FP_GET_CONFIG_MODE   GetConfigMode;
+};
+
+
+
+
+
+/// RTD2840B QAM extra module
+typedef struct RTD2840B_QAM_EXTRA_MODULE_TAG RTD2840B_QAM_EXTRA_MODULE;
+
+// RTD2840B QAM extra manipulaing functions
+typedef void
+(*RTD2840B_QAM_FP_GET_CONFIG_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pConfigMode
+	);
+
+// RTD2840B QAM extra module
+struct RTD2840B_QAM_EXTRA_MODULE_TAG
+{
+	// Variables
+	int ConfigMode;
+	unsigned char Func1TickNum;
+
+	// Functions
+	RTD2840B_QAM_FP_GET_CONFIG_MODE   GetConfigMode;
+};
+
+
+
+
+
+/// RTD2932 QAM extra module alias
+typedef struct RTD2932_QAM_EXTRA_MODULE_TAG RTD2932_QAM_EXTRA_MODULE;
+
+// RTD2932 QAM extra manipulaing functions
+typedef void
+(*RTD2932_QAM_FP_GET_CONFIG_MODE)(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pConfigMode
+	);
+
+// RTD2932 QAM extra module
+struct RTD2932_QAM_EXTRA_MODULE_TAG
+{
+	// Variables
+	int ConfigMode;
+	unsigned char Func1TickNum;
+
+	// Functions
+	RTD2932_QAM_FP_GET_CONFIG_MODE   GetConfigMode;
+};
+
+
+
+
+
+/// RTL2820 OpenCable extra module alias
+typedef struct RTL2820_OC_EXTRA_MODULE_TAG RTL2820_OC_EXTRA_MODULE;
+
+// RTL2820 OpenCable extra module
+struct RTL2820_OC_EXTRA_MODULE_TAG
+{
+	// Variables
+	unsigned char Func1TickNum;
+};
+
+
+
+
+
+/// QAM demod module structure
+struct QAM_DEMOD_MODULE_TAG
+{
+	unsigned long CurrentPageNo;
+	// Private variables
+	int           DemodType;
+	unsigned char DeviceAddr;
+	unsigned long CrystalFreqHz;
+	int           TsInterfaceMode;
+
+	int           QamMode;
+	unsigned long SymbolRateHz;
+	int           AlphaMode;
+	unsigned long IfFreqHz;
+	int           SpectrumMode;
+
+	int IsQamModeSet;
+	int IsSymbolRateHzSet;
+	int IsAlphaModeSet;
+	int IsIfFreqHzSet;
+	int IsSpectrumModeSet;
+
+	union											///<   Demod extra module used by driving module
+	{
+		RTD2885_QAM_EXTRA_MODULE  Rtd2885Qam;
+		RTD2840B_QAM_EXTRA_MODULE Rtd2840bQam;
+		RTD2932_QAM_EXTRA_MODULE  Rtd2932Qam;
+		RTL2820_OC_EXTRA_MODULE   Rtl2820Oc;
+	}
+	Extra;
+
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+
+	// Register tables
+	union
+	{
+		QAM_BASE_REG_ENTRY_ADDR_8BIT  Addr8Bit[QAM_BASE_REG_TABLE_LEN_MAX];
+		QAM_BASE_REG_ENTRY_ADDR_16BIT Addr16Bit[QAM_BASE_REG_TABLE_LEN_MAX];
+	}
+	BaseRegTable;
+
+	union
+	{
+		QAM_MONITOR_REG_ENTRY_ADDR_8BIT  Addr8Bit[QAM_MONITOR_REG_TABLE_LEN_MAX];
+		QAM_MONITOR_REG_ENTRY_ADDR_16BIT Addr16Bit[QAM_MONITOR_REG_TABLE_LEN_MAX];
+	}
+	MonitorRegTable;
+
+
+	// Demod I2C function pointers
+	union
+	{
+		QAM_DEMOD_REG_ACCESS_ADDR_8BIT  Addr8Bit;
+		QAM_DEMOD_REG_ACCESS_ADDR_16BIT Addr16Bit;
+	}
+	RegAccess;
+
+
+	// Demod manipulating function pointers
+	QAM_DEMOD_FP_GET_DEMOD_TYPE        GetDemodType;
+	QAM_DEMOD_FP_GET_DEVICE_ADDR       GetDeviceAddr;
+	QAM_DEMOD_FP_GET_CRYSTAL_FREQ_HZ   GetCrystalFreqHz;
+
+	QAM_DEMOD_FP_IS_CONNECTED_TO_I2C   IsConnectedToI2c;
+	QAM_DEMOD_FP_SOFTWARE_RESET        SoftwareReset;
+
+	QAM_DEMOD_FP_INITIALIZE            Initialize;
+	QAM_DEMOD_FP_SET_QAM_MODE          SetQamMode;
+	QAM_DEMOD_FP_SET_SYMBOL_RATE_HZ    SetSymbolRateHz;
+	QAM_DEMOD_FP_SET_ALPHA_MODE        SetAlphaMode;
+	QAM_DEMOD_FP_SET_IF_FREQ_HZ        SetIfFreqHz;
+	QAM_DEMOD_FP_SET_SPECTRUM_MODE     SetSpectrumMode;
+	QAM_DEMOD_FP_GET_QAM_MODE          GetQamMode;
+	QAM_DEMOD_FP_GET_SYMBOL_RATE_HZ    GetSymbolRateHz;
+	QAM_DEMOD_FP_GET_ALPHA_MODE        GetAlphaMode;
+	QAM_DEMOD_FP_GET_IF_FREQ_HZ        GetIfFreqHz;
+	QAM_DEMOD_FP_GET_SPECTRUM_MODE     GetSpectrumMode;
+
+	QAM_DEMOD_FP_GET_RF_AGC            GetRfAgc;
+	QAM_DEMOD_FP_GET_IF_AGC            GetIfAgc;
+	QAM_DEMOD_FP_GET_DI_AGC            GetDiAgc;
+	QAM_DEMOD_FP_GET_TR_OFFSET_PPM     GetTrOffsetPpm;
+	QAM_DEMOD_FP_GET_CR_OFFSET_HZ      GetCrOffsetHz;
+
+	QAM_DEMOD_FP_IS_AAGC_LOCKED        IsAagcLocked;
+	QAM_DEMOD_FP_IS_EQ_LOCKED          IsEqLocked;
+	QAM_DEMOD_FP_IS_FRAME_LOCKED       IsFrameLocked;
+
+	QAM_DEMOD_FP_GET_ERROR_RATE        GetErrorRate;
+	QAM_DEMOD_FP_GET_SNR_DB            GetSnrDb;
+
+	QAM_DEMOD_FP_GET_SIGNAL_STRENGTH   GetSignalStrength;
+	QAM_DEMOD_FP_GET_SIGNAL_QUALITY    GetSignalQuality;
+
+	QAM_DEMOD_FP_UPDATE_FUNCTION       UpdateFunction;
+	QAM_DEMOD_FP_RESET_FUNCTION        ResetFunction;
+};
+
+
+
+
+
+
+
+// QAM demod default I2C functions for 8-bit address
+int
+qam_demod_addr_8bit_default_SetRegPage(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long PageNo
+	);
+
+int
+qam_demod_addr_8bit_default_SetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+int
+qam_demod_addr_8bit_default_GetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+qam_demod_addr_8bit_default_SetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+int
+qam_demod_addr_8bit_default_GetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+int
+qam_demod_addr_8bit_default_SetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+qam_demod_addr_8bit_default_GetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+int
+qam_demod_addr_8bit_default_SetRegBitsWithPage(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+qam_demod_addr_8bit_default_GetRegBitsWithPage(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// QAM demod default I2C functions for 16-bit address
+int
+qam_demod_addr_16bit_default_SetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	);
+
+int
+qam_demod_addr_16bit_default_GetRegBytes(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	);
+
+int
+qam_demod_addr_16bit_default_SetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned long WritingValue
+	);
+
+int
+qam_demod_addr_16bit_default_GetRegMaskBits(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned short RegStartAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned long *pReadingValue
+	);
+
+int
+qam_demod_addr_16bit_default_SetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	const unsigned long WritingValue
+	);
+
+int
+qam_demod_addr_16bit_default_GetRegBits(
+	QAM_DEMOD_MODULE *pDemod,
+	int RegBitName,
+	unsigned long *pReadingValue
+	);
+
+
+
+
+
+// QAM demod default manipulating functions
+void
+qam_demod_default_GetDemodType(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pDemodType
+	);
+
+void
+qam_demod_default_GetDeviceAddr(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned char *pDeviceAddr
+	);
+
+void
+qam_demod_default_GetCrystalFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pCrystalFreqHz
+	);
+
+int
+qam_demod_default_GetQamMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pQamMode
+	);
+
+int
+qam_demod_default_GetSymbolRateHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pSymbolRateHz
+	);
+
+int
+qam_demod_default_GetAlphaMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pAlphaMode
+	);
+
+int
+qam_demod_default_GetIfFreqHz(
+	QAM_DEMOD_MODULE *pDemod,
+	unsigned long *pIfFreqHz
+	);
+
+int
+qam_demod_default_GetSpectrumMode(
+	QAM_DEMOD_MODULE *pDemod,
+	int *pSpectrumMode
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/qam_nim_base.c b/drivers/media/usb/rtl2832u/qam_nim_base.c
new file mode 100644
index 00000000..726eab40
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/qam_nim_base.c
@@ -0,0 +1,496 @@
+/**
+
+@file
+
+@brief   QAM NIM base module definition
+
+QAM NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+*/
+
+
+#include "qam_nim_base.h"
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_NIM_TYPE
+
+*/
+void
+qam_nim_default_GetNimType(
+	QAM_NIM_MODULE *pNim,
+	int *pNimType
+	)
+{
+	// Get NIM type from NIM module.
+	*pNimType = pNim->NimType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_SET_PARAMETERS
+
+*/
+int
+qam_nim_default_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Set tuner RF frequency in Hz.
+	if(pTuner->SetRfFreqHz(pTuner, RfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod QAM mode.
+	if(pDemod->SetQamMode(pDemod, QamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod symbol rate in Hz.
+	if(pDemod->SetSymbolRateHz(pDemod, SymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set demod alpha mode.
+	if(pDemod->SetAlphaMode(pDemod, AlphaMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod particular registers.
+	if(pDemod->ResetFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Reset demod by software reset.
+	if(pDemod->SoftwareReset(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_PARAMETERS
+
+*/
+int
+qam_nim_default_GetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pQamMode,
+	unsigned long *pSymbolRateHz,
+	int *pAlphaMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get tuner module and demod module.
+	pTuner = pNim->pTuner;
+	pDemod = pNim->pDemod;
+
+
+	// Get tuner RF frequency in Hz.
+	if(pTuner->GetRfFreqHz(pTuner, pRfFreqHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get demod QAM mode.
+	if(pDemod->GetQamMode(pDemod, pQamMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get demod symbol rate in Hz.
+	if(pDemod->GetSymbolRateHz(pDemod, pSymbolRateHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+	// Get demod alpha mode.
+	if(pDemod->GetAlphaMode(pDemod, pAlphaMode) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_IS_SIGNAL_PRESENT
+
+*/
+int
+qam_nim_default_IsSignalPresent(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	QAM_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait maximum 1000 ms for signal present check.
+	for(i = 0; i < DEFAULT_QAM_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check signal present status on demod.
+		// Note: If frame is locked, stop signal present check.
+		if(pDemod->IsFrameLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_IS_SIGNAL_LOCKED
+
+*/
+int
+qam_nim_default_IsSignalLocked(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	QAM_DEMOD_MODULE *pDemod;
+	int i;
+
+
+	// Get base interface and demod module.
+	pBaseInterface = pNim->pBaseInterface;
+	pDemod         = pNim->pDemod;
+
+
+	// Wait maximum 1000 ms for signal lock check.
+	for(i = 0; i < DEFAULT_QAM_NIM_SINGAL_LOCK_CHECK_TIMES_MAX; i++)
+	{
+		// Wait 20 ms.
+		pBaseInterface->WaitMs(pBaseInterface, 20);
+
+		// Check frame lock status on demod.
+		// Note: If frame is locked, stop signal lock check.
+		if(pDemod->IsFrameLocked(pDemod, pAnswer) != FUNCTION_SUCCESS)
+			goto error_status_execute_function;
+
+		if(*pAnswer == YES)
+			break;
+	}
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_SIGNAL_STRENGTH
+
+*/
+int
+qam_nim_default_GetSignalStrength(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal strength from demod.
+	if(pDemod->GetSignalStrength(pDemod, pSignalStrength) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_SIGNAL_QUALITY
+
+*/
+int
+qam_nim_default_GetSignalQuality(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get signal quality from demod.
+	if(pDemod->GetSignalQuality(pDemod, pSignalQuality) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_ERROR_RATE
+
+*/
+int
+qam_nim_default_GetErrorRate(
+	QAM_NIM_MODULE *pNim,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get error rate from demod.
+	if(pDemod->GetErrorRate(pDemod, TestVolume, WaitTimeMsMax, pBerNum, pBerDen, pPerNum, pPerDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_SNR_DB
+
+*/
+int
+qam_nim_default_GetSnrDb(
+	QAM_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get SNR in dB from demod.
+	if(pDemod->GetSnrDb(pDemod, pSnrDbNum, pSnrDbDen) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_TR_OFFSET_PPM
+
+*/
+int
+qam_nim_default_GetTrOffsetPpm(
+	QAM_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get TR offset in ppm from demod.
+	if(pDemod->GetTrOffsetPpm(pDemod, pTrOffsetPpm) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_GET_CR_OFFSET_HZ
+
+*/
+int
+qam_nim_default_GetCrOffsetHz(
+	QAM_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Get CR offset in Hz from demod.
+	if(pDemod->GetCrOffsetHz(pDemod, pCrOffsetHz) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   QAM_NIM_FP_UPDATE_FUNCTION
+
+*/
+int
+qam_nim_default_UpdateFunction(
+	QAM_NIM_MODULE *pNim
+	)
+{
+	QAM_DEMOD_MODULE *pDemod;
+
+
+	// Get demod module.
+	pDemod = pNim->pDemod;
+
+
+	// Update demod particular registers.
+	if(pDemod->UpdateFunction(pDemod) != FUNCTION_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/qam_nim_base.h b/drivers/media/usb/rtl2832u/qam_nim_base.h
new file mode 100644
index 00000000..abeea776
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/qam_nim_base.h
@@ -0,0 +1,864 @@
+#ifndef __QAM_NIM_BASE_H
+#define __QAM_NIM_BASE_H
+
+/**
+
+@file
+
+@brief   QAM NIM base module definition
+
+QAM NIM base module definitions contains NIM module structure, NIM funciton pointers, NIM definitions, and NIM default
+functions.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	QAM_NIM_MODULE *pNim;
+	QAM_NIM_MODULE QamNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+	unsigned long RfFreqHz;
+	int QamMode;
+	unsigned long SymbolRateHz;
+	int AlphaMode;
+
+	int Answer;
+	unsigned long SignalStrength, SignalQuality;
+	unsigned long BerNum, BerDen, PerNum, PerDen;
+	double Ber, Per;
+	unsigned long SnrDbNum, SnrDbDen;
+	double SnrDb;
+	long TrOffsetPpm, CrOffsetHz;
+
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		&pNim,
+		&QamNimModuleMemory,
+
+		9,								// Maximum I2C reading byte number is 9.
+		8,								// Maximum I2C writing byte number is 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs,					// Employ CustomWaitMs() as basic waiting function.
+
+		&DemodxExtraModuleMemory,		// Employ Demod-X extra module.
+		0x44,							// The Demod-X I2C device address is 0x44 in 8-bit format.
+		CRYSTAL_FREQ_28800000HZ,		// The Demod-X crystal frequency is 28.8 MHz.
+		TS_INTERFACE_SERIAL,			// The Demod-X TS interface mode is serial.
+		...								// Other arguments for Demod-X
+
+		&TunerxExtraModuleMemory,		// Employ Tuner-Y extra module.
+		0xc0,							// The Tuner-Y I2C device address is 0xc0 in 8-bit format.
+		...								// Other arguments for Tuner-Y
+		);
+
+
+
+	// Get NIM type.
+	// Note: NIM types are defined in the MODULE_TYPE enumeration.
+	pNim->GetNimType(pNim, &NimType);
+
+
+
+
+
+
+
+	// ==== Initialize NIM and set its parameters =====
+
+	// Initialize NIM.
+	pNim->Initialize(pNim);
+
+	// Set NIM parameters. (RF frequency, QAM mode, symbol rate, alpha mode)
+	// Note: In the example:
+	//       1. RF frequency is 738 MHz.
+	//       2. QAM is 64.
+	//       3. Symbol rate is 6.952 MHz.
+	//       4. Alpha is 0.15.
+	RfFreqHz     = 738000000;
+	QamMode      = QAM_QAM_64;
+	SymbolRateHz = 6952000;
+	AlphaMode    = QAM_ALPHA_0P15;
+	pNim->SetParameters(pNim, RfFreqHz, QamMode, SymbolRateHz, AlphaMode);
+
+
+
+	// Wait 1 second for demod convergence.
+
+
+
+
+
+	// ==== Get NIM information =====
+
+	// Get NIM parameters. (RF frequency, QAM mode, symbol rate, alpha mode)
+	pNim->GetParameters(pNim, &RfFreqHz, &QamMode, &SymbolRateHz, &AlphaMode);
+
+
+	// Get signal present status.
+	// Note: 1. The argument Answer is YES when the NIM module has found QAM signal in the RF channel.
+	//       2. The argument Answer is NO when the NIM module does not find QAM signal in the RF channel.
+	// Recommendation: Use the IsSignalPresent() function for channel scan.
+	pNim->IsSignalPresent(pNim, &Answer);
+
+	// Get signal lock status.
+	// Note: 1. The argument Answer is YES when the NIM module has locked QAM signal in the RF channel.
+	//          At the same time, the NIM module sends TS packets through TS interface hardware pins.
+	//       2. The argument Answer is NO when the NIM module does not lock QAM signal in the RF channel.
+	// Recommendation: Use the IsSignalLocked() function for signal lock check.
+	pNim->IsSignalLocked(pNim, &Answer);
+
+
+	// Get signal strength.
+	// Note: 1. The range of SignalStrength is 0~100.
+	//       2. Need to map SignalStrength value to UI signal strength bar manually.
+	pNim->GetSignalStrength(pNim, &SignalStrength);
+
+	// Get signal quality.
+	// Note: 1. The range of SignalQuality is 0~100.
+	//       2. Need to map SignalQuality value to UI signal quality bar manually.
+	pNim->GetSignalQuality(pNim, &SignalQuality);
+
+
+	// Get BER and PER.
+	// Note: Test packet number = pow(2, (2 * 4 + 4)) = 4096
+	//       Maximum wait time  = 1000 ms = 1 second
+	pNim->GetErrorRate(pNim, 4, 1000, &BerNum, &BerDen, &PerNum, &PerDen);
+	Ber = (double)BerNum / (double)BerDen;
+	Per = (double)PerNum / (double)PerDen;
+
+	// Get SNR in dB.
+	pNim->GetSnrDb(pNim, &SnrDbNum, &SnrDbDen);
+	SnrDb = (double)SnrDbNum / (double)SnrDbDen;
+
+
+	// Get TR offset (symbol timing offset) in ppm.
+	pNim->GetTrOffsetPpm(pNim, &TrOffsetPpm);
+
+	// Get CR offset (RF frequency offset) in Hz.
+	pNim->GetCrOffsetHz(pNim, &CrOffsetHz);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+#include "tuner_base.h"
+#include "qam_demod_base.h"
+
+
+
+
+
+// Definitions
+#define DEFAULT_QAM_NIM_SINGAL_PRESENT_CHECK_TIMES_MAX		1
+#define DEFAULT_QAM_NIM_SINGAL_LOCK_CHECK_TIMES_MAX			1
+
+
+
+
+
+/// QAM NIM module pre-definition
+typedef struct QAM_NIM_MODULE_TAG QAM_NIM_MODULE;
+
+
+
+
+
+/**
+
+@brief   QAM demod type getting function pointer
+
+One can use QAM_NIM_FP_GET_NIM_TYPE() to get QAM NIM type.
+
+
+@param [in]    pNim       The NIM module pointer
+@param [out]   pNimType   Pointer to an allocated memory for storing NIM type
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_NIM_TYPE() with the corresponding function.
+
+
+@see   MODULE_TYPE
+
+*/
+typedef void
+(*QAM_NIM_FP_GET_NIM_TYPE)(
+	QAM_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM initializing function pointer
+
+One can use QAM_NIM_FP_INITIALIZE() to initialie QAM NIM.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize NIM successfully.
+@retval   FUNCTION_ERROR     Initialize NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_INITIALIZE)(
+	QAM_NIM_MODULE *pNim
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM parameter setting function pointer
+
+One can use QAM_NIM_FP_SET_PARAMETERS() to set QAM NIM parameters.
+
+
+@param [in]   pNim           The NIM module pointer
+@param [in]   RfFreqHz       RF frequency in Hz for setting
+@param [in]   QamMode        QAM mode for setting
+@param [in]   SymbolRateHz   Symbol rate in Hz for setting
+@param [in]   AlphaMode      Alpha mode for setting
+
+
+@retval   FUNCTION_SUCCESS   Set NIM parameters successfully.
+@retval   FUNCTION_ERROR     Set NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_SET_PARAMETERS() with the corresponding function.
+
+
+@see   QAM_QAM_MODE, QAM_ALPHA_MODE
+
+*/
+typedef int
+(*QAM_NIM_FP_SET_PARAMETERS)(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM parameter getting function pointer
+
+One can use QAM_NIM_FP_GET_PARAMETERS() to get QAM NIM parameters.
+
+
+@param [in]    pNim            The NIM module pointer
+@param [out]   pRfFreqHz       Pointer to an allocated memory for storing NIM RF frequency in Hz
+@param [out]   pQamMode        Pointer to an allocated memory for storing NIM QAM mode
+@param [out]   pSymbolRateHz   Pointer to an allocated memory for storing NIM symbol rate in Hz
+@param [out]   pAlphaMode      Pointer to an allocated memory for storing NIM alpha mode
+
+
+@retval   FUNCTION_SUCCESS   Get NIM parameters successfully.
+@retval   FUNCTION_ERROR     Get NIM parameters unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_PARAMETERS() with the corresponding function.
+
+
+@see   QAM_QAM_MODE, QAM_ALPHA_MODE
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_PARAMETERS)(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pQamMode,
+	unsigned long *pSymbolRateHz,
+	int *pAlphaMode
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM signal present asking function pointer
+
+One can use QAM_NIM_FP_IS_SIGNAL_PRESENT() to ask QAM NIM if signal is present.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal present asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal present asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_IS_SIGNAL_PRESENT() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_IS_SIGNAL_PRESENT)(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM signal lock asking function pointer
+
+One can use QAM_NIM_FP_IS_SIGNAL_LOCKED() to ask QAM NIM if signal is locked.
+
+
+@param [in]    pNim      The NIM module pointer
+@param [out]   pAnswer   Pointer to an allocated memory for storing answer
+
+
+@retval   FUNCTION_SUCCESS   Perform signal lock asking to NIM successfully.
+@retval   FUNCTION_ERROR     Perform signal lock asking to NIM unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_IS_SIGNAL_LOCKED() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_IS_SIGNAL_LOCKED)(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM signal strength getting function pointer
+
+One can use QAM_NIM_FP_GET_SIGNAL_STRENGTH() to get signal strength.
+
+
+@param [in]    pNim              The NIM module pointer
+@param [out]   pSignalStrength   Pointer to an allocated memory for storing signal strength (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal strength successfully.
+@retval   FUNCTION_ERROR     Get NIM signal strength unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_SIGNAL_STRENGTH() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_SIGNAL_STRENGTH)(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM signal quality getting function pointer
+
+One can use QAM_NIM_FP_GET_SIGNAL_QUALITY() to get signal quality.
+
+
+@param [in]    pNim             The NIM module pointer
+@param [out]   pSignalQuality   Pointer to an allocated memory for storing signal quality (value = 0 ~ 100)
+
+
+@retval   FUNCTION_SUCCESS   Get NIM signal quality successfully.
+@retval   FUNCTION_ERROR     Get NIM signal quality unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_SIGNAL_QUALITY() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_SIGNAL_QUALITY)(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM error rate value getting function pointer
+
+One can use QAM_NIM_FP_GET_ERROR_RATE() to get error rate value.
+
+
+@param [in]    pNim            The NIM module pointer
+@param [in]    TestVolume      Test volume for setting
+@param [in]    WaitTimeMsMax   Maximum waiting time in ms
+@param [out]   pBerNum         Pointer to an allocated memory for storing BER numerator
+@param [out]   pBerDen         Pointer to an allocated memory for storing BER denominator
+@param [out]   pPerNum         Pointer to an allocated memory for storing PER numerator
+@param [out]   pPerDen         Pointer to an allocated memory for storing PER denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM error rate value successfully.
+@retval   FUNCTION_ERROR     Get NIM error rate value unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_ERROR_RATE() with the corresponding function.
+	-# The error test packet number is pow(2, (2 * TestVolume + 4)).
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_ERROR_RATE)(
+	QAM_NIM_MODULE *pNim,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM SNR getting function pointer
+
+One can use QAM_NIM_FP_GET_SNR_DB() to get SNR in dB.
+
+
+@param [in]    pNim        The NIM module pointer
+@param [out]   pSnrDbNum   Pointer to an allocated memory for storing SNR dB numerator
+@param [out]   pSnrDbDen   Pointer to an allocated memory for storing SNR dB denominator
+
+
+@retval   FUNCTION_SUCCESS   Get NIM SNR successfully.
+@retval   FUNCTION_ERROR     Get NIM SNR unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_SNR_DB() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_SNR_DB)(
+	QAM_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM TR offset getting function pointer
+
+One can use QAM_NIM_FP_GET_TR_OFFSET_PPM() to get TR offset in ppm.
+
+
+@param [in]    pNim           The NIM module pointer
+@param [out]   pTrOffsetPpm   Pointer to an allocated memory for storing TR offset in ppm
+
+
+@retval   FUNCTION_SUCCESS   Get NIM TR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM TR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_TR_OFFSET_PPM() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_TR_OFFSET_PPM)(
+	QAM_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM CR offset getting function pointer
+
+One can use QAM_NIM_FP_GET_CR_OFFSET_HZ() to get CR offset in Hz.
+
+
+@param [in]    pNim          The NIM module pointer
+@param [out]   pCrOffsetHz   Pointer to an allocated memory for storing CR offset in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get NIM CR offset successfully.
+@retval   FUNCTION_ERROR     Get NIM CR offset unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_GET_CR_OFFSET_HZ() with the corresponding function.
+
+*/
+typedef int
+(*QAM_NIM_FP_GET_CR_OFFSET_HZ)(
+	QAM_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+
+
+
+
+/**
+
+@brief   QAM NIM updating function pointer
+
+One can use QAM_NIM_FP_UPDATE_FUNCTION() to update NIM register setting.
+
+
+@param [in]   pNim   The NIM module pointer
+
+
+@retval   FUNCTION_SUCCESS   Update NIM setting successfully.
+@retval   FUNCTION_ERROR     Update NIM setting unsuccessfully.
+
+
+@note
+	-# NIM building function will set QAM_NIM_FP_UPDATE_FUNCTION() with the corresponding function.
+
+
+
+@par Example:
+@code
+
+
+#include "nim_demodx_tunery.h"
+
+
+int main(void)
+{
+	QAM_NIM_MODULE *pNim;
+	QAM_NIM_MODULE QamNimModuleMemory;
+	DEMODX_EXTRA_MODULE DemodxExtraModuleMemory;
+	TUNERY_EXTRA_MODULE TuneryExtraModuleMemory;
+
+
+	// Build Demod-X Tuner-Y NIM module.
+	BuildDemodxTuneryModule(
+		...
+		);
+
+	...
+
+
+	return 0;
+}
+
+
+void PeriodicallyExecutingFunction
+{
+	// Executing UpdateFunction() periodically.
+	pNim->UpdateFunction(pNim);
+}
+
+
+@endcode
+
+*/
+typedef int
+(*QAM_NIM_FP_UPDATE_FUNCTION)(
+	QAM_NIM_MODULE *pNim
+	);
+
+
+
+
+
+// RTL2840 MT2062 extra module
+typedef struct RTL2840_MT2062_EXTRA_MODULE_TAG RTL2840_MT2062_EXTRA_MODULE;
+struct RTL2840_MT2062_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long IfFreqHz;
+};
+
+
+
+
+
+// RTL2840 MT2063 extra module
+typedef struct RTL2840_MT2063_EXTRA_MODULE_TAG RTL2840_MT2063_EXTRA_MODULE;
+struct RTL2840_MT2063_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long IfFreqHz;
+};
+
+
+
+
+
+// RTD2840B QAM MT2062 extra module
+typedef struct RTD2840B_QAM_MT2062_EXTRA_MODULE_TAG RTD2840B_QAM_MT2062_EXTRA_MODULE;
+struct RTD2840B_QAM_MT2062_EXTRA_MODULE_TAG
+{
+	// Extra variables
+	unsigned long IfFreqHz;
+};
+
+
+
+
+
+/// QAM NIM module structure
+struct QAM_NIM_MODULE_TAG
+{
+	// Private variables
+	int NimType;
+	int EnhancementMode;
+	int ConfigMode;
+
+	union														///<   NIM extra module used by driving module
+	{
+		RTL2840_MT2062_EXTRA_MODULE Rtl2840Mt2062;
+		RTL2840_MT2063_EXTRA_MODULE Rtl2840Mt2063;
+		RTD2840B_QAM_MT2062_EXTRA_MODULE  Rtd2840bQamMt2062;
+	}
+	Extra;
+
+
+	// Modules
+	BASE_INTERFACE_MODULE *pBaseInterface;						///<   Base interface module pointer
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;			///<   Base interface module memory
+
+	I2C_BRIDGE_MODULE *pI2cBridge;								///<   I2C bridge module pointer
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;					///<   I2C bridge module memory
+
+	TUNER_MODULE *pTuner;										///<   Tuner module pointer
+	TUNER_MODULE TunerModuleMemory;								///<   Tuner module memory
+
+	QAM_DEMOD_MODULE *pDemod;									///<   QAM demod module pointer
+	QAM_DEMOD_MODULE QamDemodModuleMemory;						///<   QAM demod module memory
+
+
+	// NIM manipulating functions
+	QAM_NIM_FP_GET_NIM_TYPE          GetNimType;
+	QAM_NIM_FP_INITIALIZE            Initialize;
+	QAM_NIM_FP_SET_PARAMETERS        SetParameters;
+	QAM_NIM_FP_GET_PARAMETERS        GetParameters;
+	QAM_NIM_FP_IS_SIGNAL_PRESENT     IsSignalPresent;
+	QAM_NIM_FP_IS_SIGNAL_LOCKED      IsSignalLocked;
+	QAM_NIM_FP_GET_SIGNAL_STRENGTH   GetSignalStrength;
+	QAM_NIM_FP_GET_SIGNAL_QUALITY    GetSignalQuality;
+	QAM_NIM_FP_GET_ERROR_RATE        GetErrorRate;
+	QAM_NIM_FP_GET_SNR_DB            GetSnrDb;
+	QAM_NIM_FP_GET_TR_OFFSET_PPM     GetTrOffsetPpm;
+	QAM_NIM_FP_GET_CR_OFFSET_HZ      GetCrOffsetHz;
+	QAM_NIM_FP_UPDATE_FUNCTION       UpdateFunction;
+};
+
+
+
+
+
+
+
+// QAM NIM default manipulaing functions
+void
+qam_nim_default_GetNimType(
+	QAM_NIM_MODULE *pNim,
+	int *pNimType
+	);
+
+int
+qam_nim_default_SetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long RfFreqHz,
+	int QamMode,
+	unsigned long SymbolRateHz,
+	int AlphaMode
+	);
+
+int
+qam_nim_default_GetParameters(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pRfFreqHz,
+	int *pQamMode,
+	unsigned long *pSymbolRateHz,
+	int *pAlphaMode
+	);
+
+int
+qam_nim_default_IsSignalPresent(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+qam_nim_default_IsSignalLocked(
+	QAM_NIM_MODULE *pNim,
+	int *pAnswer
+	);
+
+int
+qam_nim_default_GetSignalStrength(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalStrength
+	);
+
+int
+qam_nim_default_GetSignalQuality(
+	QAM_NIM_MODULE *pNim,
+	unsigned long *pSignalQuality
+	);
+
+int
+qam_nim_default_GetErrorRate(
+	QAM_NIM_MODULE *pNim,
+	unsigned long TestVolume,
+	unsigned int WaitTimeMsMax,
+	unsigned long *pBerNum,
+	unsigned long *pBerDen,
+	unsigned long *pPerNum,
+	unsigned long *pPerDen
+	);
+
+int
+qam_nim_default_GetSnrDb(
+	QAM_NIM_MODULE *pNim,
+	long *pSnrDbNum,
+	long *pSnrDbDen
+	);
+
+int
+qam_nim_default_GetTrOffsetPpm(
+	QAM_NIM_MODULE *pNim,
+	long *pTrOffsetPpm
+	);
+
+int
+qam_nim_default_GetCrOffsetHz(
+	QAM_NIM_MODULE *pNim,
+	long *pCrOffsetHz
+	);
+
+int
+qam_nim_default_UpdateFunction(
+	QAM_NIM_MODULE *pNim
+	);
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/rtl2832u.c b/drivers/media/usb/rtl2832u/rtl2832u.c
new file mode 100644
index 00000000..f34e8958
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u.c
@@ -0,0 +1,1622 @@
+
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include "rtl2832u.h"
+#include "rtl2832u_io.h"
+#include "rtl2832u_audio.h"
+//#include "rtl2832u_ioctl.h"
+
+
+int dvb_usb_rtl2832u_debug=3;
+module_param_named(debug,dvb_usb_rtl2832u_debug, int, 0644);
+MODULE_PARM_DESC(debug, "Set debugging level (1=info,xfer=2 (or-able),rc=3)." DVB_USB_DEBUG_STATUS);
+
+
+int demod_default_type=0;
+module_param_named(demod, demod_default_type, int, 0644);
+MODULE_PARM_DESC(demod, "Set default demod type(0=dvb-t, 1=dtmb, 2=dvb-c)"DVB_USB_DEBUG_STATUS);
+
+int dtmb_error_packet_discard;
+module_param_named(dtmb_err_discard, dtmb_error_packet_discard, int, 0644);
+MODULE_PARM_DESC(dtmb_err_discard, "Set error packet discard type(0=not discard, 1=discard)"DVB_USB_DEBUG_STATUS);
+
+int dvb_use_rtl2832u_rc_mode=2;
+module_param_named(rtl2832u_rc_mode, dvb_use_rtl2832u_rc_mode, int, 0644);
+MODULE_PARM_DESC(rtl2832u_rc_mode, "Set default rtl2832u_rc_mode(0=rc6, 1=rc5, 2=nec, 3=disable rc, default=2)."DVB_USB_DEBUG_STATUS);
+
+int dvb_use_rtl2832u_card_type=0;
+module_param_named(rtl2832u_card_type, dvb_use_rtl2832u_card_type, int, 0644);
+MODULE_PARM_DESC(rtl2832u_card_type, "Set default rtl2832u_card_type type(0=dongle, 1=mini card, default=0)."DVB_USB_DEBUG_STATUS);
+
+
+
+
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+//#endif
+
+#define	USB_EPA_CTL	0x0148
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#if 0
+
+#define RT_RC_POLLING_INTERVAL_TIME_MS			287
+#define MAX_RC_PROTOCOL_NUM				3
+
+struct rc_map_table rtl2832u_rc_keys_map_table[] = {// realtek Key map
+		{ 0x0400, KEY_0 },           // 0
+		{ 0xc03f, KEY_1 },           // 1
+		{ 0x807f, KEY_2 },           // 2
+		{ 0x609f, KEY_3 },           // 3
+		{ 0x0404, KEY_4 },           // 4
+		{ 0x0405, KEY_5 },           // 5
+		{ 0x0406, KEY_6 },           // 6
+		{ 0x0407, KEY_7 },           // 7
+		{ 0x0408, KEY_8 },           // 8
+		{ 0x0409, KEY_9 },           // 9
+		{ 0x040c, KEY_POWER },       // POWER
+		{ 0x040e, KEY_MUTE },        // MUTE
+		{ 0x0410, KEY_VOLUMEUP },    // VOL UP
+		{ 0x0411, KEY_VOLUMEDOWN },  // VOL DOWN
+		{ 0x0412, KEY_CHANNELUP },   // CH UP
+		{ 0x0413, KEY_CHANNELDOWN }, // CH DOWN
+		{ 0x0416, KEY_PLAY },        // PLAY
+		{ 0x0417, KEY_RECORD },      // RECORD
+		{ 0x0418, KEY_PLAYPAUSE },   // PAUSE
+		{ 0x0419, KEY_STOP },        // STOP
+		{ 0x041e, KEY_UP},	     // UP
+		{ 0x041f, KEY_DOWN},	     // DOWN
+		{ 0x0420, KEY_LEFT },        // LEFT
+		{ 0x0421, KEY_RIGHT },       // RIGHT
+		{ 0x0422, KEY_ZOOM },        // FULL SCREEN  -->OK
+		{ 0x0447, KEY_AUDIO },       // MY AUDIO
+		{ 0x045b, KEY_MENU},         // RED
+		{ 0x045c, KEY_EPG },         // GREEN
+		{ 0x045d, KEY_FIRST },       // YELLOW
+		{ 0x045e, KEY_LAST },        // BLUE
+		{ 0x045a, KEY_TEXT },        // TEXT TV
+		{ 0x0423, KEY_BACK },        // <- BACK
+		{ 0x0414, KEY_FORWARD }    // >>
+	};
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+enum   rc_status_define{
+	RC_FUNCTION_SUCCESS =0,
+	RC_FUNCTION_UNSUCCESS
+};
+
+int rtl2832u_remote_control_state=0;
+static int SampleNum2TNum[] =
+{
+	0,0,0,0,0,
+	1,1,1,1,1,1,1,1,1,
+	2,2,2,2,2,2,2,2,2,
+	3,3,3,3,3,3,3,3,3,
+	4,4,4,4,4,4,4,4,4,
+	5,5,5,5,5,5,5,5,
+	6,6,6,6,6,6,6,6,6,
+	7,7,7,7,7,7,7,7,7,
+	8,8,8,8,8,8,8,8,8,
+	9,9,9,9,9,9,9,9,9,
+	10,10,10,10,10,10,10,10,10,
+	11,11,11,11,11,11,11,11,11,
+	12,12,12,12,12,12,12,12,12,
+	13,13,13,13,13,13,13,13,13,
+	14,14,14,14,14,14,14
+};
+
+//IRRC register table
+static const RT_rc_set_reg_struct p_rtl2832u_rc_initial_table[]=
+{
+	{RTD2832U_SYS,RC_USE_DEMOD_CTL1		,0x00,OP_AND,0xfb},
+	{RTD2832U_SYS,RC_USE_DEMOD_CTL1		,0x00,OP_AND,0xf7},
+	{RTD2832U_USB,USB_CTRL			,0x00,OP_OR ,0x20},
+	{RTD2832U_SYS,SYS_GPD			,0x00,OP_AND,0xf7},
+	{RTD2832U_SYS,SYS_GPOE			,0x00,OP_OR ,0x08},
+	{RTD2832U_SYS,SYS_GPO			,0x00,OP_OR ,0x08},
+	{RTD2832U_RC,IR_RX_CTRL			,0x20,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_BUFFER_CTRL		,0x80,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_IF			,0xff,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_IE			,0xff,OP_NO ,0xff},
+	{RTD2832U_RC,IR_MAX_DURATION0		,0xd0,OP_NO ,0xff},
+	{RTD2832U_RC,IR_MAX_DURATION1		,0x07,OP_NO ,0xff},
+	{RTD2832U_RC,IR_IDLE_LEN0		,0xc0,OP_NO ,0xff},
+	{RTD2832U_RC,IR_IDLE_LEN1		,0x00,OP_NO ,0xff},
+	{RTD2832U_RC,IR_GLITCH_LEN		,0x03,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_CLK			,0x09,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_CONFIG		,0x1c,OP_NO ,0xff},
+	{RTD2832U_RC,IR_MAX_H_Tolerance_LEN	,0x1e,OP_NO ,0xff},
+	{RTD2832U_RC,IR_MAX_L_Tolerance_LEN	,0x1e,OP_NO ,0xff},
+	{RTD2832U_RC,IR_RX_CTRL			,0x80,OP_NO ,0xff}
+
+};
+
+
+
+
+int rtl2832u_remoto_control_initial_setting(struct dvb_usb_device *d)
+{
+
+
+
+	//begin setting
+	int ret = RC_FUNCTION_SUCCESS;
+	u8 data=0,i=0,NumberOfRcInitialTable=0;
+
+
+	deb_rc("+rc_%s\n", __FUNCTION__);
+
+	NumberOfRcInitialTable = sizeof(p_rtl2832u_rc_initial_table)/sizeof(RT_rc_set_reg_struct);
+
+
+	for (i=0;i<NumberOfRcInitialTable;i++)
+	{
+		switch(p_rtl2832u_rc_initial_table[i].type)
+		{
+			case RTD2832U_SYS:
+			case RTD2832U_USB:
+				data=p_rtl2832u_rc_initial_table[i].data;
+				if (p_rtl2832u_rc_initial_table[i].op != OP_NO)
+				{
+					if ( read_usb_sys_char_bytes( d ,
+								      p_rtl2832u_rc_initial_table[i].type ,
+								      p_rtl2832u_rc_initial_table[i].address,
+								      &data ,
+								      LEN_1) )
+					{
+						deb_rc("+%s : rc- usb or sys register read error! \n", __FUNCTION__);
+						ret=RC_FUNCTION_UNSUCCESS;
+						goto error;
+					}
+
+					if (p_rtl2832u_rc_initial_table[i].op == OP_AND){
+					        data &=  p_rtl2832u_rc_initial_table[i].op_mask;
+					}
+					else{//OP_OR
+						data |=  p_rtl2832u_rc_initial_table[i].op_mask;
+					}
+				}
+
+				if ( write_usb_sys_char_bytes( d ,
+							      p_rtl2832u_rc_initial_table[i].type ,
+							      p_rtl2832u_rc_initial_table[i].address,
+							      &data ,
+							      LEN_1) )
+				{
+						deb_rc("+%s : rc- usb or sys register write error! \n", __FUNCTION__);
+						ret= RC_FUNCTION_UNSUCCESS;
+						goto error;
+				}
+
+			break;
+			case RTD2832U_RC:
+				data= p_rtl2832u_rc_initial_table[i].data;
+				if (p_rtl2832u_rc_initial_table[i].op != OP_NO)
+				{
+					if ( read_rc_char_bytes( d ,
+								 p_rtl2832u_rc_initial_table[i].type ,
+								 p_rtl2832u_rc_initial_table[i].address,
+								 &data ,
+								 LEN_1) )
+					{
+						deb_rc("+%s : rc -ir register read error! \n", __FUNCTION__);
+						ret=RC_FUNCTION_UNSUCCESS;
+						goto error;
+					}
+
+					if (p_rtl2832u_rc_initial_table[i].op == OP_AND){
+					        data &=  p_rtl2832u_rc_initial_table[i].op_mask;
+					}
+					else{//OP_OR
+					    data |=  p_rtl2832u_rc_initial_table[i].op_mask;
+					}
+				}
+				if ( write_rc_char_bytes( d ,
+							      p_rtl2832u_rc_initial_table[i].type ,
+							      p_rtl2832u_rc_initial_table[i].address,
+							      &data ,
+							      LEN_1) )
+				{
+					deb_rc("+%s : rc -ir register write error! \n", __FUNCTION__);
+					ret=RC_FUNCTION_UNSUCCESS;
+					goto error;
+				}
+
+			break;
+			default:
+				deb_rc("+%s : rc table error! \n", __FUNCTION__);
+				ret=RC_FUNCTION_UNSUCCESS;
+				goto error;
+			break;
+		}
+	}
+	rtl2832u_remote_control_state=RC_INSTALL_OK;
+	ret=RC_FUNCTION_SUCCESS;
+error:
+	deb_rc("-rc_%s ret = %d \n", __FUNCTION__, ret);
+	return ret;
+
+
+}
+
+
+static int frt0(u8* rt_uccode,u8 byte_num,u8 *p_uccode)
+{
+	u8 *pCode = rt_uccode;
+	int TNum =0;
+	u8   ucBits[frt0_bits_num];
+	u8  i=0,state=WAITING_6T;
+	int  LastTNum = 0,CurrentBit = 0;
+	int ret=RC_FUNCTION_SUCCESS;
+	u8 highestBit = 0,lowBits=0;
+	u32 scancode=0;
+
+	if(byte_num < frt0_para1){
+		deb_rc("Bad rt uc code received, byte_num is error\n");
+		ret= RC_FUNCTION_UNSUCCESS;
+		goto error;
+	}
+	while(byte_num > 0)
+	{
+
+		highestBit = (*pCode)&0x80;
+		lowBits = (*pCode) & 0x7f;
+		TNum=SampleNum2TNum[lowBits];
+
+		if(highestBit != 0)	TNum = -TNum;
+
+		pCode++;
+		byte_num--;
+
+		if(TNum <= -6)	 state = WAITING_6T;
+
+		if(WAITING_6T == state)
+		{
+			if(TNum <= -6)	state = WAITING_2T_AFTER_6T;
+		}
+		else if(WAITING_2T_AFTER_6T == state)
+		{
+			if(2 == TNum)
+			{
+				state = WAITING_NORMAL_BITS;
+				LastTNum   = 0;
+				CurrentBit = 0;
+			}
+			else 	state = WAITING_6T;
+		}
+		else if(WAITING_NORMAL_BITS == state)
+		{
+			if(0 == LastTNum)	LastTNum = TNum;
+			else	{
+				if(LastTNum < 0)	ucBits[CurrentBit]=1;
+				else			ucBits[CurrentBit]=0;
+
+				CurrentBit++;
+
+				if(CurrentBit >= frt0_bits_num)	{
+ 					deb_rc("Bad frame received, bits num is error\n");
+					CurrentBit = frt0_bits_num -1 ;
+
+				}
+				if(TNum > 3)	{
+						for(i=0;i<frt0_para2;i++){
+							if (ucBits[i+frt0_para4])	scancode  |= (0x01 << (frt0_para2-i-1));
+						}
+				}
+				else{
+					LastTNum += TNum;
+				}
+			}
+		}
+
+	}
+	p_uccode[0]=(u8)((scancode>>24)  &  frt0_BITS_mask0);
+	p_uccode[1]=(u8)((scancode>>16)  &  frt0_BITS_mask1);
+	p_uccode[2]=(u8)((scancode>>8)  & frt0_BITS_mask2);
+	p_uccode[3]=(u8)((scancode>>0)  & frt0_BITS_mask3);
+
+	deb_rc("-rc_%s 3::rc6:%x %x %x %x \n", __FUNCTION__,p_uccode[0],p_uccode[1],p_uccode[2],p_uccode[3]);
+	ret= RC_FUNCTION_SUCCESS;
+error:
+
+	return ret;
+}
+
+
+static int frt1(u8* rt_uccode,u8 byte_num,u8 *p_uccode)
+{
+	u8 *pCode = rt_uccode;
+	u8  ucBits[frt1_bits_num];
+	u8 i=0,CurrentBit=0,index=0;
+	u32 scancode=0;
+	int ret= RC_FUNCTION_SUCCESS;
+
+	deb_rc("+rc_%s \n", __FUNCTION__);
+	if(byte_num < frt1_para1)	{
+		deb_rc("Bad rt uc code received, byte_num = %d is error\n",byte_num);
+		ret = RC_FUNCTION_UNSUCCESS;
+		goto error;
+	}
+
+	memset(ucBits,0,frt1_bits_num);
+
+	for(i = 0; i < byte_num; i++)	{
+		if ((pCode[i] & frt1_para2)< frt1_para3)    index=frt1_para5 ;
+		else 					    index=frt1_para6 ;
+
+		ucBits[i]= (pCode[i] & 0x80) + index;
+	}
+	if(ucBits[0] !=frt1_para_uc_1 && ucBits[0] !=frt1_para_uc_2 )   {ret= RC_FUNCTION_UNSUCCESS; goto error;}
+
+	if(ucBits[1] !=frt1_para5  && ucBits[1] !=frt1_para6)   	{ret= RC_FUNCTION_UNSUCCESS;goto error;}
+
+	if(ucBits[2] >= frt1_para_uc_1)  				ucBits[2] -= 0x01;
+	else			 					{ret= RC_FUNCTION_UNSUCCESS;goto error;}
+
+
+   	i = 0x02;
+	CurrentBit = 0x00;
+
+	while(i < byte_num-1)
+	{
+		if(CurrentBit >= 32)	{
+			break;
+		}
+
+		if((ucBits[i] & 0x0f) == 0x0)	{
+			i++;
+			continue;
+		}
+		if(ucBits[i++] == 0x81)	{
+						if(ucBits[i] >=0x01)	{
+							scancode |= 0x00 << (31 - CurrentBit++);
+						}
+		}
+		else	{
+				if(ucBits[i] >=0x81)	{
+					scancode |= 0x01 << (31 - CurrentBit++);
+				}
+		}
+
+		ucBits[i] -= 0x01;
+		continue;
+	}
+	p_uccode[3]=(u8)((scancode>>16)  &  frt1_bits_mask3);
+	p_uccode[2]=(u8)((scancode>>24)  &  frt1_bits_mask2);
+	p_uccode[1]=(u8)((scancode>>8)   &  frt1_bits_mask1);
+	p_uccode[0]=(u8)((scancode>>0)   &  frt1_bits_mask0);
+
+
+	deb_rc("-rc_%s rc5:%x %x %x %x -->scancode =%x\n", __FUNCTION__,p_uccode[0],p_uccode[1],p_uccode[2],p_uccode[3],scancode);
+	ret= RC_FUNCTION_SUCCESS;
+error:
+	return ret;
+}
+
+static int frt2(u8* rt_uccode,u8 byte_num,u8 *p_uccode)
+{
+	u8 *pCode = rt_uccode;
+	u8  i=0;
+	u32 scancode=0;
+	u8  out_io=0;
+
+	int ret= RC_FUNCTION_SUCCESS;
+
+	deb_rc("+rc_%s \n", __FUNCTION__);
+
+	if(byte_num < frt2_para1)  				goto error;
+    	if(pCode[0] != frt2_para2) 				goto error;
+	if((pCode[1] <frt2_para3 )||(pCode[1] >frt2_para4))	goto error;
+
+
+	if( (pCode[2] <frt2_para5 ) && (pCode[2] >frt2_para6) )
+	{
+
+		if( (pCode[3] <frt2_para7 ) && (pCode[3] >frt2_para8 ) &&(pCode[4]==frt2_para9 ))  scancode=0xffff;
+		else goto error;
+
+	}
+	else if( (pCode[2] <frt2_para10  ) && (pCode[2] >frt2_para11 ) )
+	{
+
+	 	for (i = 3; i <68; i++)
+		{
+                        if ((i% 2)==1)
+			{
+				if( (pCode[i]>frt2_para7 ) || (pCode[i] <frt2_para8 ) )
+				{
+					deb_rc("Bad rt uc code received[4]\n");
+					ret= RC_FUNCTION_UNSUCCESS;
+					goto error;
+				}
+			}
+			else
+			{
+				if(pCode[i]<frt2_para12  )  out_io=0;
+				else			    out_io=1;
+				scancode |= (out_io << (31 -(i-4)/2) );
+			}
+		}
+
+
+
+	}
+	else  	goto error;
+	deb_rc("-rc_%s nec:%x\n", __FUNCTION__,scancode);
+	p_uccode[0]=(u8)((scancode>>24)  &  frt2_bits_mask0);
+	p_uccode[1]=(u8)((scancode>>16)  &  frt2_bits_mask1);
+	p_uccode[2]=(u8)((scancode>>8)   &  frt2_bits_mask2);
+	p_uccode[3]=(u8)((scancode>>0)   &  frt2_bits_mask3);
+	ret= RC_FUNCTION_SUCCESS;
+error:
+
+	return ret;
+}
+
+
+#define receiveMaskFlag1  0x80
+#define receiveMaskFlag2  0x03
+#define flush_step_Number 0x05
+#define rt_code_len       0x80
+
+
+static int rtl2832u_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+
+	static const RT_rc_set_reg_struct p_flush_table1[]={
+		{RTD2832U_RC,IR_RX_CTRL			,0x20,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_BUFFER_CTRL		,0x80,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_IF			,0xff,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_IE			,0xff,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_CTRL			,0x80,OP_NO ,0xff}
+
+	};
+	static const RT_rc_set_reg_struct p_flush_table2[]={
+		{RTD2832U_RC,IR_RX_IF			,0x03,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_BUFFER_CTRL		,0x80,OP_NO ,0xff},
+		{RTD2832U_RC,IR_RX_CTRL			,0x80,OP_NO ,0xff}
+
+	};
+
+
+	u8  data=0,i=0,byte_count=0;
+	int ret=0;
+	u8  rt_u8_code[rt_code_len];
+	u8  ucode[4];
+	u16 scancode=0;
+
+	//printk(".............%s chialing4444\n", __FUNCTION__);
+
+	deb_rc("+%s \n", __FUNCTION__);
+	if (dvb_use_rtl2832u_rc_mode >= MAX_RC_PROTOCOL_NUM)
+	{
+
+		deb_rc("%s : dvb_use_rtl2832u_rc_mode=%d \n", __FUNCTION__,dvb_use_rtl2832u_rc_mode);
+		return 0;
+	}
+
+	if(rtl2832u_remote_control_state == RC_NO_SETTING)
+	{
+                deb_rc("%s : IrDA Initial Setting rtl2832u_remote_control_state=%d\n", __FUNCTION__,rtl2832u_remote_control_state);
+		ret=rtl2832u_remoto_control_initial_setting(d);
+
+	}
+	if ( read_rc_char_bytes( d ,RTD2832U_RC, IR_RX_IF,&data ,LEN_1) )
+	{
+		ret=-1;
+		deb_rc("%s : Read IrDA IF is failed\n", __FUNCTION__);
+		goto error;
+	}
+	/* debug */
+	if (data != 0)
+	{
+		deb_rc("%s : IR_RX_IF= 0x%x\n", __FUNCTION__,data);
+	}
+
+		deb_rc("%s : IR_RX_IF= 0x%x.....chialing\n", __FUNCTION__,data);
+
+
+
+
+	if (!(data & receiveMaskFlag1))
+	{
+		ret =0 ;
+		deb_rc("%s : goto error 1\n", __FUNCTION__);
+		goto error;
+	}
+
+	if (data & receiveMaskFlag2)
+	{
+			/* delay */
+			msleep(287);
+
+			if ( read_rc_char_bytes( d ,RTD2832U_RC,IR_RX_BC,&byte_count ,LEN_1) )
+			{
+				deb_rc("%s : rc -ir register read error! \n", __FUNCTION__);
+				ret=-1;
+				goto error;
+			}
+			if (byte_count == 0 )
+			{
+				//ret=0;
+				deb_rc("%s : goto error 2\n", __FUNCTION__);
+				goto error;
+
+			}
+
+			if ((byte_count%LEN_2) == 1)   byte_count+=LEN_1;
+			if (byte_count > rt_code_len)  byte_count=rt_code_len;
+
+			memset(rt_u8_code,0,rt_code_len);
+			deb_rc("%s : byte_count= %d type = %d \n", __FUNCTION__,byte_count,dvb_use_rtl2832u_rc_mode);
+			if ( read_rc_char_bytes( d ,RTD2832U_RC,IR_RX_BUF,rt_u8_code ,0x80) )
+			{
+				deb_rc("%s : rc -ir register read error! \n", __FUNCTION__);
+				ret=-1;
+				goto error;
+			}
+
+			memset(ucode,0,4);
+
+
+			ret=0;
+			if (dvb_use_rtl2832u_rc_mode == 0)		ret =frt0(rt_u8_code,byte_count,ucode);
+			else if (dvb_use_rtl2832u_rc_mode == 1)		ret =frt1(rt_u8_code,byte_count,ucode);
+			else if (dvb_use_rtl2832u_rc_mode== 2)		ret =frt2(rt_u8_code,byte_count,ucode);
+			else
+			{
+					deb_rc("%s : rc - unknow rc protocol set ! \n", __FUNCTION__);
+					ret=-1;
+					goto error;
+			}
+
+			if((ret != RC_FUNCTION_SUCCESS) || (ucode[0] ==0 && ucode[1] ==0 && ucode[2] ==0 && ucode[3] ==0))
+ 			{
+					deb_rc("%s : rc-rc is error scan code ! %x %x %x %x \n", __FUNCTION__,ucode[0],ucode[1],ucode[2],ucode[3]);
+					ret=-1;
+					goto error;
+			}
+			scancode=(ucode[2]<<8) | ucode[3] ;
+			deb_info("-%s scan code %x %x %x %x,(0x%x) -- len=%d\n", __FUNCTION__,ucode[0],ucode[1],ucode[2],ucode[3],scancode,byte_count);
+			////////// map/////////////////////////////////////////////////////////////////////////////////////////////////////
+			for (i = 0; i < ARRAY_SIZE(rtl2832u_rc_keys_map_table); i++) {
+				if(rtl2832u_rc_keys_map_table[i].scancode ==scancode ){
+					*event = rtl2832u_rc_keys_map_table[i].keycode;
+					*state = REMOTE_KEY_PRESSED;
+					deb_rc("%s : map number = %d \n", __FUNCTION__,i);
+					break;
+				}
+
+			}
+
+			memset(rt_u8_code,0,rt_code_len);
+			byte_count=0;
+			for (i=0;i<3;i++){
+				data= p_flush_table2[i].data;
+				if ( write_rc_char_bytes( d ,RTD2832U_RC, p_flush_table2[i].address,&data,LEN_1) ) {
+					deb_rc("+%s : rc -ir register write error! \n", __FUNCTION__);
+					ret=-1;
+					goto error;
+				}
+
+			}
+
+			ret =0;
+			return ret;
+	}
+error:
+			memset(rt_u8_code,0,rt_code_len);
+			byte_count=0;
+			for (i=0;i<flush_step_Number;i++){
+				data= p_flush_table1[i].data;
+				if ( write_rc_char_bytes( d ,RTD2832U_RC, p_flush_table1[i].address,&data,LEN_1) ) {
+					deb_rc("+%s : rc -ir register write error! \n", __FUNCTION__);
+					ret=-1;
+					break;
+				}
+
+			}
+			ret =0;    //must return 0
+			return ret;
+
+}
+
+
+#endif
+
+
+
+static int rtl2832u_streaming_ctrl(struct dvb_usb_adapter *adap , int onoff)
+{
+	u8 data[2];
+	//3 to avoid  scanning  channels loss
+	if(onoff)
+	{
+		data[0] = data[1] = 0;
+		if ( write_usb_sys_char_bytes( adap->dev , RTD2832U_USB , USB_EPA_CTL , data , 2) ) goto error;
+	}
+	else
+	{
+		data[0] = 0x10;	//3stall epa, set bit 4 to 1
+		data[1] = 0x02;	//3reset epa, set bit 9 to 1
+		if ( write_usb_sys_char_bytes( adap->dev , RTD2832U_USB , USB_EPA_CTL , data , 2) ) goto error;
+	}
+
+	return 0;
+error:
+	return -1;
+}
+
+
+static int rtl2832u_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	adap->fe_adap[0].fe = rtl2832u_fe_attach(adap->dev);
+
+	return 0;
+}
+
+
+static void rtl2832u_usb_disconnect(struct usb_interface *intf)
+{
+	try_module_get(THIS_MODULE);
+	dvb_usb_device_exit(intf);
+}
+
+
+static struct dvb_usb_device_properties rtl2832u_1st_properties;
+static struct dvb_usb_device_properties rtl2832u_2nd_properties;
+static struct dvb_usb_device_properties rtl2832u_3th_properties;
+static struct dvb_usb_device_properties rtl2832u_4th_properties;
+static struct dvb_usb_device_properties rtl2832u_5th_properties;
+static struct dvb_usb_device_properties rtl2832u_6th_properties;
+static struct dvb_usb_device_properties rtl2832u_7th_properties;
+static struct dvb_usb_device_properties rtl2832u_8th_properties;
+static struct dvb_usb_device_properties rtl2832u_9th_properties;
+
+
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static int rtl2832u_usb_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if ( ( 0== dvb_usb_device_init(intf,&rtl2832u_1st_properties,THIS_MODULE,NULL,adapter_nr) )||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_2nd_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_3th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_4th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_5th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_6th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_7th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_8th_properties,THIS_MODULE,NULL,adapter_nr) ) ||
+		( 0== dvb_usb_device_init(intf,&rtl2832u_9th_properties,THIS_MODULE,NULL,adapter_nr) ) )
+		return 0;
+
+	return -ENODEV;
+}
+
+static struct usb_device_id rtl2832u_usb_table [] = {
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2832_WARM) },		// 0
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2838_WARM) },		// 1
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2836_WARM) },		// 2
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2839_WARM) },		// 3
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2840_WARM) },		// 4
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2841_WARM) },		// 5
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2834_WARM) },		// 6
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2837_WARM) },		// 7
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2820_WARM) },		// 8
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2821_WARM) },		// 9
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2822_WARM) },		// 10
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2823_WARM) },		// 11
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2810_WARM) },		// 12
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2811_WARM) },		// 13
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2824_WARM) },		// 14
+	{ USB_DEVICE(USB_VID_REALTEK, USB_PID_RTL2825_WARM) },		// 15
+
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1101) },		// 16
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1102) },		// 17
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1103) },		// 18
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1104) },		// 19
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1105) },		// 20
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1106) },		// 21
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1107) },		// 22
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_1108) },		// 23
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_2101) },		// 24
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_8202) },		// 25
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_9201) },		// 26
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_3103) },		// 27
+	{ USB_DEVICE(USB_VID_DEXATEK, USB_PID_DEXATEK_9202) },		// 28
+
+	{ USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_00A9)},	// 29
+	{ USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_00B3)},	// 30
+
+	{ USB_DEVICE(USB_VID_AZUREWAVE_2, USB_PID_AZUREWAVE_3234) },	// 31
+	{ USB_DEVICE(USB_VID_AZUREWAVE_2, USB_PID_AZUREWAVE_3274) },	// 32
+	{ USB_DEVICE(USB_VID_AZUREWAVE_2, USB_PID_AZUREWAVE_3282) },	// 33
+
+	{ USB_DEVICE(USB_VID_THP, USB_PID_THP_5013)},				// 34
+	{ USB_DEVICE(USB_VID_THP, USB_PID_THP_5020)},				// 35
+	{ USB_DEVICE(USB_VID_THP, USB_PID_THP_5026)},				// 36
+
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D393) },	// 37
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D394) },	// 38
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D395) },	// 39
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D396) },	// 40
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D397) },	// 41
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D398) },	// 42
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D39A) },	// 43
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D39B) },	// 44
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D39C) },	// 45
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D39E) },	// 46
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_E77B) },	// 47
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3A1) },	// 48
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3A4) },	// 49
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3A7) },	// 50
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3A8) },	// 51
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3AC) },	// 52
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3AD) },	// 53
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_D3AE) },	// 54
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_C880) },	// 55
+	{ USB_DEVICE(USB_VID_KWORLD_1ST, USB_PID_KWORLD_E41D) },	// 56
+	{ USB_DEVICE(USB_VID_GOTVIEW, USB_PID_GOTVIEW_CA42) },	        // 57
+
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_0837)},		// 58
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_A803)},		// 59
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_B803)},		// 60
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_C803)},		// 61
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_D803)},		// 62
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_C280)},		// 63
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_D286)},		// 64
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_0139)},		// 65
+	{ USB_DEVICE(USB_VID_GTEK, USB_PID_GTEK_WARM_A683)},		// 66
+
+	{ USB_DEVICE(USB_VID_LEADTEK, USB_PID_LEADTEK_WARM_1)},		// 67
+	{ USB_DEVICE(USB_VID_LEADTEK, USB_PID_LEADTEK_WARM_2)},		// 68
+
+	{ USB_DEVICE(USB_VID_YUAN, USB_PID_YUAN_WARM)},			//69
+        { USB_DEVICE(USB_VID_YUAN, USB_PID_YUAN_WARM80)},		//70
+	{ USB_DEVICE(USB_VID_YUAN, USB_PID_YUAN_WARM84)},	 	//71
+
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_0620)},	// 72
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_0630)},	// 73
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_0640)},	// 74
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_0650)},	// 75
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_0680)},	// 76
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_9580)},	// 77
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_9550)},	// 78
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_9540)},	// 79
+	{ USB_DEVICE(USB_VID_COMPRO, USB_PID_COMPRO_WARM_9530)},	// 80
+	{ USB_DEVICE(USB_VID_COMPRO,  USB_PID_COMPRO_WARM_9520)},	// 81
+
+	{ USB_DEVICE(USB_VID_GOLDENBRIDGE, USB_PID_GOLDENBRIDGE_WARM)},	//82
+
+	{ 0 },
+};
+
+
+MODULE_DEVICE_TABLE(usb, rtl2832u_usb_table);
+
+
+
+static struct dvb_usb_device_properties rtl2832u_1st_properties = {
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[0], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[1], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[2], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[3], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[4], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[5], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[6], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[7], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[8], NULL },
+		},
+		{ NULL },
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_2nd_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[9], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[10], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[11], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[12], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[13], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[14], NULL },
+		},
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[15], NULL },
+		},
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[16], NULL },
+		},
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[17], NULL },
+		},
+		{ NULL },
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_3th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[18], NULL },
+		},
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[19], NULL },
+		},
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[20], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[21], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[22], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[23], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[24], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[25], NULL },
+		},
+		{
+		  .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[26], NULL },
+		}
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_4th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[27], NULL },
+		},
+		{ .name = "DK DONGLE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[28], NULL },
+		},
+		{ .name = "Terratec Cinergy T Stick Black",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[29], NULL },
+		},
+		{
+		  .name = "Terratec Cinergy T Stick Black",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[30], NULL },
+		},
+		{
+		  .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[31], NULL },
+		},
+		{
+		  .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[32], NULL },
+		},
+
+		{
+		  .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[33], NULL },
+		},
+
+		{
+		  .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[34], NULL },
+		},
+
+		{
+		  .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[35], NULL },
+		},
+
+
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_5th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "RTL2832U DVB-T USB DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[36], NULL },
+		},
+		{ .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[37], NULL },
+		},
+		{ .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[38], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[39], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[40], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[41], NULL },
+		},
+
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[42], NULL },
+		},
+
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[43], NULL },
+		},
+
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[44], NULL },
+		},
+
+
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_6th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[45], NULL },
+		},
+		{ .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[46], NULL },
+		},
+		{ .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[47], NULL },
+		},
+		{
+		  .name ="USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[48], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[49], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[50], NULL },
+		},
+		{
+		  .name ="USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[51], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[52], NULL },
+		},
+		{
+		  .name = "USB DVB-T DEVICE",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[53], NULL },
+		},
+
+		{ NULL },
+
+
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_7th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[54], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[55], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[56], NULL },
+		},
+		{
+		  .name ="DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[57], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[58], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[59], NULL },
+		},
+		{ .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[60], NULL },
+		},
+		{
+		  .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[61], NULL },
+		},
+		{
+		  .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[62], NULL },
+		},
+
+		{ NULL },
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_8th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{ .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[63], NULL },
+		},
+		{ .name = "USB DVB-T Device",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[64], NULL },
+		},
+		{ .name = "VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[65], NULL },
+		},
+		{
+		  .name ="VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[66], NULL },
+		},
+		{ .name = "VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[67], NULL },
+		},
+		{ .name = "VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[68], NULL },
+		},
+		{ .name = "VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[69], NULL },
+		},
+		{
+		  .name ="VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[70], NULL },
+		},
+		{
+		  .name ="VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[71], NULL },
+		},
+
+		{ NULL },
+	}
+};
+
+
+
+static struct dvb_usb_device_properties rtl2832u_9th_properties = {
+
+
+	.num_adapters = 1,
+	.adapter =
+	{
+		{
+			.num_frontends = 1,
+			.fe = {{
+				/* .pid_filter_ctrl = af9005_pid_filter_control, */
+				.frontend_attach = rtl2832u_frontend_attach,
+				/* .tuner_attach     = af9005_tuner_attach, */
+				/* parameter for the MPEG2-data transfer */
+				.stream =
+				{
+					.type = USB_BULK,
+					.count = RTD2831_URB_NUMBER,
+					.endpoint = 0x01,
+					.u =
+					{
+						.bulk =
+						{
+							.buffersize = RTD2831_URB_SIZE,	/* actual size seen is 3948 */
+						}
+				      }
+				},
+			}},
+		}
+	},
+
+
+	//.rc.legacy = {
+	//	.rc_interval = RT_RC_POLLING_INTERVAL_TIME_MS,
+	//	.rc_map_table = rtl2832u_rc_keys_map_table,
+	//	.rc_map_size = ARRAY_SIZE(rtl2832u_rc_keys_map_table),
+	//	.rc_query = rtl2832u_rc_query,
+	//},
+
+	.num_device_descs = 9,
+	.devices = {
+		{
+		  .name ="VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[72], NULL },
+		},
+		{
+		  .name ="VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[73], NULL },
+		},
+		{ .name = "VideoMate DTV",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[74], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[75], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[76], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[77], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[78], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[79], NULL },
+		},
+		{ .name = "DVB-T TV Stick",
+		  .cold_ids = { NULL, NULL },
+		  .warm_ids = { &rtl2832u_usb_table[80], NULL },
+		},
+		{ NULL },
+	}
+};
+
+
+
+static struct usb_driver rtl2832u_usb_driver = {
+	.name		= "dvb_usb_rtl2832u",
+	.probe		= rtl2832u_usb_probe,
+	.disconnect	= rtl2832u_usb_disconnect,
+	.id_table		= rtl2832u_usb_table,
+};
+
+
+static int __init rtl2832u_usb_module_init(void)
+{
+	int result =0 ;
+
+	deb_info("+info debug open_%s\n", __FUNCTION__);
+	if ((result = usb_register(&rtl2832u_usb_driver))) {
+		err("usb_register failed. (%d)",result);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit rtl2832u_usb_module_exit(void)
+{
+	usb_deregister(&rtl2832u_usb_driver);
+
+	return ;
+}
+
+
+
+module_init(rtl2832u_usb_module_init);
+module_exit(rtl2832u_usb_module_exit);
+
+
+MODULE_AUTHOR("Realtek");
+MODULE_AUTHOR("Chialing Lu <chialing@realtek.com>");
+MODULE_AUTHOR("Dean Chung<DeanChung@realtek.com>");
+MODULE_DESCRIPTION("Driver for the RTL2832U DVB-T / RTL2836 DTMB USB2.0 device");
+MODULE_VERSION("3.0.0");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u.h b/drivers/media/usb/rtl2832u/rtl2832u.h
new file mode 100644
index 00000000..b99ab603
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u.h
@@ -0,0 +1,270 @@
+
+#ifndef _RTL2832U_H_
+#define _RTL2832U_H_
+
+
+
+#include "dvb-usb.h"
+
+#define	USB_VID_REALTEK						0x0BDA
+#define	USB_PID_RTL2832_WARM				0x2832
+#define	USB_PID_RTL2838_WARM				0x2838
+#define	USB_PID_RTL2836_WARM					0x2836
+#define	USB_PID_RTL2839_WARM					0x2839
+#define	USB_PID_RTL2840_WARM					0x2840
+#define	USB_PID_RTL2841_WARM					0x2841
+#define	USB_PID_RTL2834_WARM					0x2834
+#define	USB_PID_RTL2837_WARM          			0x2837
+#define	USB_PID_RTL2820_WARM					0x2820
+#define	USB_PID_RTL2821_WARM          			0x2821
+#define	USB_PID_RTL2822_WARM					0x2822
+#define	USB_PID_RTL2823_WARM          			0x2823
+#define	USB_PID_RTL2810_WARM					0x2810
+#define	USB_PID_RTL2811_WARM          			0x2811
+#define	USB_PID_RTL2824_WARM					0x2824
+#define	USB_PID_RTL2825_WARM          			0x2825
+
+
+#define	USB_VID_DEXATEK						0x1D19
+#define	USB_PID_DEXATEK_1101					0x1101
+#define	USB_PID_DEXATEK_1102					0x1102
+#define	USB_PID_DEXATEK_1103					0x1103
+#define	USB_PID_DEXATEK_1104					0x1104
+#define	USB_PID_DEXATEK_1105					0x1105
+#define	USB_PID_DEXATEK_1106					0x1106
+#define	USB_PID_DEXATEK_1107					0x1107
+#define	USB_PID_DEXATEK_1108					0x1108
+#define	USB_PID_DEXATEK_2101					0x2101
+#define	USB_PID_DEXATEK_8202					0x8202
+#define	USB_PID_DEXATEK_9201					0x9201
+#define	USB_PID_DEXATEK_3103					0x3103
+#define	USB_PID_DEXATEK_9202					0x9202
+
+
+#define	USB_VID_TERRATEC						0x0CCD
+#define	USB_PID_TERRATEC_00A9				0x00A9
+#define	USB_PID_TERRATEC_00B3				0x00B3
+
+
+#define	USB_VID_AZUREWAVE_2					0x13D3
+#define	USB_PID_AZUREWAVE_3234				0x3234
+#define	USB_PID_AZUREWAVE_3274				0x3274
+#define	USB_PID_AZUREWAVE_3282				0x3282
+
+
+#define	USB_VID_THP							0x1554
+#define	USB_PID_THP_5013						0x5013
+#define	USB_PID_THP_5020						0x5020
+#define	USB_PID_THP_5026						0x5026
+
+
+#define	USB_VID_KWORLD_1ST					0x1B80
+#define	USB_PID_KWORLD_D393					0xD393
+#define	USB_PID_KWORLD_D394					0xD394
+#define	USB_PID_KWORLD_D395					0xD395
+#define	USB_PID_KWORLD_D396					0xD396
+#define	USB_PID_KWORLD_D397					0xD397
+#define	USB_PID_KWORLD_D398					0xD398
+#define	USB_PID_KWORLD_D39A					0xD39A
+#define	USB_PID_KWORLD_D39B					0xD39B
+#define	USB_PID_KWORLD_D39C					0xD39C
+#define	USB_PID_KWORLD_D39E					0xD39E
+#define	USB_PID_KWORLD_E77B					0xE77B
+#define	USB_PID_KWORLD_D3A1					0xD3A1
+#define	USB_PID_KWORLD_D3A4					0xD3A4
+#define	USB_PID_KWORLD_D3A7					0xD3A7
+#define	USB_PID_KWORLD_D3A8					0xD3A8
+#define	USB_PID_KWORLD_D3AC					0xD3AC
+#define	USB_PID_KWORLD_D3AD					0xD3AD
+#define	USB_PID_KWORLD_D3AE					0xD3AE
+#define	USB_PID_KWORLD_C880					0xC880
+#define	USB_PID_KWORLD_E41D					0xE41D
+
+#define	USB_VID_GOTVIEW								0x5654
+#define	USB_PID_GOTVIEW_CA42					0xCA42
+
+#define	USB_VID_GOLDENBRIDGE					0x1680
+#define	USB_PID_GOLDENBRIDGE_WARM			0xA332
+
+
+#define	USB_VID_YUAN							0x1164
+#define	USB_PID_YUAN_WARM					0x6601
+#define USB_PID_YUAN_WARM80				0x3280
+#define USB_PID_YUAN_WARM84	                        0x3284
+
+
+#define	USB_VID_GTEK							0x1F4D
+#define	USB_PID_GTEK_WARM_0837				0x0837
+#define	USB_PID_GTEK_WARM_A803				0xA803
+#define	USB_PID_GTEK_WARM_B803				0xB803
+#define	USB_PID_GTEK_WARM_C803				0xC803
+#define	USB_PID_GTEK_WARM_D803				0xD803
+#define	USB_PID_GTEK_WARM_C280				0xC280
+#define	USB_PID_GTEK_WARM_D286				0xD286
+#define	USB_PID_GTEK_WARM_0139				0x0139
+#define	USB_PID_GTEK_WARM_A683				0xA683
+
+
+#define	USB_VID_LEADTEK						0x0413
+#define	USB_PID_LEADTEK_WARM_1				0x6680
+#define	USB_PID_LEADTEK_WARM_2				0x6F11
+
+
+#ifndef  USB_VID_COMPRO/*define in dvb-usb-ids.h*/
+	#define USB_VID_COMPRO						0x185B
+#endif
+#define USB_PID_COMPRO_WARM_0620				0x0620
+#define USB_PID_COMPRO_WARM_0630				0x0630
+#define USB_PID_COMPRO_WARM_0640				0x0640
+#define USB_PID_COMPRO_WARM_0650				0x0650
+#define USB_PID_COMPRO_WARM_0680				0x0680
+#define USB_PID_COMPRO_WARM_9580				0x9580
+#define USB_PID_COMPRO_WARM_9550				0x9550
+#define USB_PID_COMPRO_WARM_9540				0x9540
+#define USB_PID_COMPRO_WARM_9530				0x9530
+#define USB_PID_COMPRO_WARM_9520				0x9520
+
+#define RTD2831_URB_SIZE				4096// 39480
+#define RTD2831_URB_NUMBER				10 //  4
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+//			remote control
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+//define rtl283u rc register address
+#define IR_RX_BUF			0xFC00
+#define IR_RX_IE			0xFD00
+#define IR_RX_IF			0xFD01
+#define IR_RX_CTRL			0xFD02
+#define IR_RX_CONFIG			0xFD03
+#define IR_MAX_DURATION0		0xFD04
+#define IR_MAX_DURATION1		0xFD05
+#define IR_IDLE_LEN0			0xFD06
+#define IR_IDLE_LEN1			0xFD07
+#define IR_GLITCH_LEN			0xFD08
+#define IR_RX_BUFFER_CTRL		0xFD09
+#define IR_RX_BUFFER_DATA		0xFD0A
+#define IR_RX_BC			0xFD0B
+#define IR_RX_CLK			0xFD0C
+#define IR_RX_C_COUNT_L			0xFD0D
+#define IR_RX_C_COUNT_H			0xFD0E
+
+#define IR_SUSPEND_CTRL			0xFD10
+#define IR_Err_Tolerance_CTRL		0xFD11
+#define IR_UNIT_LEN			0xFD12
+#define IR_Err_Tolerance_LEN		0xFD13
+#define IR_MAX_H_Tolerance_LEN		0xFD14
+#define IR_MAX_L_Tolerance_LEN		0xFD15
+#define IR_MASK_CTRL			0xFD16
+#define IR_MASK_DATA			0xFD17
+#define IR_RESUME_MASK_ADDR		0xFD18
+#define IR_RESUME_MASK_T_LEN		0xFD19
+
+#define USB_CTRL			0x0010
+#define SYS_GPD				0x0004
+#define SYS_GPOE			0x0003
+#define SYS_GPO				0x0001
+#define RC_USE_DEMOD_CTL1		0x000B
+
+//define use len
+#define LEN_1				0x01
+#define LEN_2				0x02
+#define LEN_3				0x03
+#define LEN_4				0x04
+
+
+
+//function
+int rtl2832u_remoto_control_initial_setting(struct dvb_usb_device *d);
+#define	USB_EPA_CTL			0x0148
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+//decode control para define
+#define frt0_para1 			0x3c
+#define frt0_para2 			0x20
+#define frt0_para3			0x7f
+#define frt0_para4      		0x05
+#define frt0_bits_num 			0x80
+#define frt0_BITS_mask 			0x01
+#define frt0_BITS_mask0			0x00
+#define frt0_BITS_mask1			0x00
+#define frt0_BITS_mask2			0x0f
+#define frt0_BITS_mask3			0xff
+
+#define frt1_para1 			0x12
+#define frt1_para3 			0x1a
+#define frt1_para2 			0x7f
+#define frt1_para4 			0x80
+#define frt1_para5 			0x01
+#define frt1_para6 			0x02
+#define frt1_bits_num 			0x80
+#define frt1_para_uc_1			0x81
+#define frt1_para_uc_2 			0x82
+#define frt1_bits_mask0			0x00
+#define frt1_bits_mask1			0x00
+#define frt1_bits_mask2			0x7f
+#define frt1_bits_mask3			0xff
+
+#define frt2_para1  			0x0a
+#define frt2_para2  			0xFF
+#define frt2_para3 			0xb0
+#define frt2_para4 			0xc6
+#define frt2_para5  			0x30
+#define frt2_para6  			0x1b
+#define frt2_para7  			0x8f
+#define frt2_para8  			0x89
+#define frt2_para9  			0x7f
+#define frt2_para10 			0x60
+#define frt2_para11 			0x38
+#define frt2_para12  			0x15
+#define frt2_bits_num			0x80
+#define frt2_bits_mask0			0x00
+#define frt2_bits_mask1			0x00
+#define frt2_bits_mask2			0xff
+#define frt2_bits_mask3			0xff
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+//			remote control
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+enum protocol_type_for_RT{
+				RT_RC6=0,
+				RT_RC5,
+				RT_NEC,
+				RT_TEST
+};
+// op define
+enum OP{
+	OP_NO	=0,
+	OP_AND	  ,
+	OP_OR
+};
+
+typedef enum RT_UC_CODE_STATE{
+	WAITING_6T,
+	WAITING_2T_AFTER_6T,
+	WAITING_NORMAL_BITS
+}RT_UC_CODE_STATE;
+
+//struct define
+typedef struct RT_rc_set_reg_struct{
+		u8	type;
+		u16 	address;
+		u8      data;
+		u8	op;
+		u8	op_mask;
+}RT_rc_set_reg_struct;
+
+enum RTL2832U_RC_STATE{
+	RC_NO_SETTING=0,
+	RC_INSTALL_OK,
+	RC__POLLING_OK,
+	RC_STOP_OK
+};
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+extern struct dvb_frontend * rtl2832u_fe_attach(struct dvb_usb_device *d);
+
+#endif
+
+
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_audio.c b/drivers/media/usb/rtl2832u/rtl2832u_audio.c
new file mode 100644
index 00000000..9b8e4364
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_audio.c
@@ -0,0 +1,905 @@
+
+#if 0
+
+#include "rtl2832u_audio.h"
+#include "rtl2832u_ioctl.h"
+
+
+
+#define RTK_Demod_Byte_Write(page, offset, length, data) \
+	((write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, page, offset, data, length)) ? 0 : 1 )
+
+
+#define RTK_Demod_Byte_Read(page, offset, length, data) \
+	((read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, page, offset, data, length)) ? 0 : 1 )
+
+
+int Set1(struct rtl2832_state*	p_state)
+{	
+	unsigned char data[1];
+	unsigned short	length = 1;
+	int hr = 1;
+	
+	data[0] = 202;
+	hr &= RTK_Demod_Byte_Write(1, 0x1C, length, data);
+		
+	data[0] = 220;
+	hr &= RTK_Demod_Byte_Write(1, 0x1D, length, data);
+		
+	data[0] = 215;
+	hr &= RTK_Demod_Byte_Write(1, 0x1E, length, data);
+		
+	data[0] = 216;
+	hr &= RTK_Demod_Byte_Write(1, 0x1F, length, data);
+		
+	data[0] = 224;
+	hr &= RTK_Demod_Byte_Write(1, 0x20, length, data);
+		
+	data[0] = 242;
+	hr &= RTK_Demod_Byte_Write(1, 0x21, length, data);
+		
+	data[0] = 14;
+	hr &= RTK_Demod_Byte_Write(1, 0x22, length, data);
+	
+	data[0] = 53;
+	hr &= RTK_Demod_Byte_Write(1, 0x23, length, data);
+	
+	data[0] = 6;
+	hr &= RTK_Demod_Byte_Write(1, 0x24, length, data);
+		
+	data[0] = 80;
+	hr &= RTK_Demod_Byte_Write(1, 0x25, length, data);
+		
+	data[0] = 156;
+	hr &= RTK_Demod_Byte_Write(1, 0x26, length, data);
+		
+	data[0] = 13;
+	hr &= RTK_Demod_Byte_Write(1, 0x27, length, data);
+		
+	data[0] = 113;
+	hr &= RTK_Demod_Byte_Write(1, 0x28, length, data);
+		
+	data[0] = 17;
+	hr &= RTK_Demod_Byte_Write(1, 0x29, length, data);
+		
+	data[0] = 20;
+	hr &= RTK_Demod_Byte_Write(1, 0x2A, length, data);
+		
+	data[0] = 113;
+	hr &= RTK_Demod_Byte_Write(1, 0x2B, length, data);
+		
+	data[0] = 116;
+	hr &= RTK_Demod_Byte_Write(1, 0x2C, length, data);
+		
+	data[0] = 25;
+	hr &= RTK_Demod_Byte_Write(1, 0x2D, length, data);
+		
+	data[0] = 65;
+	hr &= RTK_Demod_Byte_Write(1, 0x2E, length, data);
+		
+	data[0] = 165;
+	hr &= RTK_Demod_Byte_Write(1, 0x2F, length, data);
+
+	return hr;	
+}
+
+int Set2(struct rtl2832_state*	p_state)
+{
+	UCHAR FM_coe2[6] = {-1, 1, 6, 13, 22, 27}; 	
+	unsigned char data[1];
+    	unsigned short addr = 0x1F;
+
+	int i;
+	BOOL rst = 1;
+	for(i=0; i<6; i++)
+	{
+		data[0] = FM_coe2[i];
+	
+		rst &= RTK_Demod_Byte_Write(0, addr, 1, data);
+		addr--;
+	}
+
+	return rst;
+}   
+
+ int RTL2832_SWReset(struct rtl2832_state*	p_state)
+{
+	unsigned char data[1];
+	int hr = 1;
+
+	hr &= RTK_Demod_Byte_Read(1, 0x01, 1, data);
+	data[0] = data[0] | 0x04;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, 1, data);
+	data[0] = data[0] & 0xFB;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, 1, data);
+
+	return hr; 
+}	
+
+ int RTL2832_SWReset_2(struct rtl2832_state* p_state)
+{
+	unsigned char data[1];
+	unsigned char tmp;
+	int hr = 1;
+
+	// disable
+	hr &= RTK_Demod_Byte_Read(0, 0x19, 1, data);
+	data[0] = data[0] & 0xFE;
+	tmp = data[0];
+	hr &= RTK_Demod_Byte_Write(0, 0x19, 1, data);
+
+
+	// sw reset
+	hr &= RTK_Demod_Byte_Read(1, 0x01, 1, data);
+	data[0] = data[0] | 0x04;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, 1, data);
+	data[0] = data[0] & 0xFB;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, 1, data);
+
+	//enable
+	tmp = tmp | 0x1;
+	hr &= RTK_Demod_Byte_Write(0, 0x19, 1, &tmp);
+
+	return hr; 
+}
+
+
+
+int Initial_2832_fm(struct rtl2832_state*	p_state)
+{
+	unsigned char data[4];
+	unsigned short length;
+	int hr = 1;
+
+ 	length = 2;
+	data[0] = 0x00;
+	data[1] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x3E, length, data);
+	
+    	length = 1;
+	data[0] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x15, length, data);
+
+	length = 3;
+	data[0] = 0x00;
+	data[1] = 0x00;
+	data[2] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x16, length, data);
+
+	if(p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+		data[0] = 0x35;
+		data[1] = 0xD8;
+		data[2] = 0x2E;
+		hr &= RTK_Demod_Byte_Write(1, 0x19, 3, data);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+	{
+        	data[0] = 0x00;
+		data[1] = 0x00;
+		data[2] = 0x00;	
+		hr &= RTK_Demod_Byte_Write(1, 0x19, 3, data);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)
+	{
+		data[0] = 0x00;
+		data[1] = 0x00;
+		data[2] = 0x00;	
+		hr &= RTK_Demod_Byte_Write(1, 0x19, 3, data);
+	}
+
+   	length = 4;
+	data[0] = 0x03;
+	data[1] = 0x84;
+	data[2] = 0x00;
+	data[3] = 0x00;
+    	hr &= RTK_Demod_Byte_Write(1, 0x9F, length, data);
+
+    	hr &= Set1(p_state);
+
+ 	length = 1;
+	data[0] = 0x11;
+	hr &= RTK_Demod_Byte_Write(0, 0x17, length, data);
+    
+	length = 1;
+	data[0] = 0x10;
+	hr &= RTK_Demod_Byte_Write(0, 0x18, length, data);
+    
+	length = 1;
+	data[0] = 0x21;
+   	hr &= RTK_Demod_Byte_Write(0, 0x19, length, data);
+    
+ 	hr &= Set2(p_state);
+
+      length = 1;
+	data[0] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x92, length, data);
+
+	length = 1;
+	data[0] = 0xF0;
+	hr &= RTK_Demod_Byte_Write(1, 0x93, length, data);
+
+   	length = 1;
+	data[0] = 0x0F;
+	hr &= RTK_Demod_Byte_Write(1, 0x94, length, data);
+   
+	length = 1;
+	data[0] = 0x60;
+	hr &= RTK_Demod_Byte_Write(0, 0x61, length, data);//output of PID filter
+
+	length = 1;
+	data[0] = 0x80;
+	hr &= RTK_Demod_Byte_Write(0, 0x06, length, data);
+
+	if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012  || p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+	{
+		data[0] = 0xCD;
+    		hr &= RTK_Demod_Byte_Write(0, 0x08, 1, data);
+
+		data[0] = 0x1;
+		hr &= RTK_Demod_Byte_Write(1, 0xB1, 1, data);
+	}
+
+     	hr &= RTL2832_SWReset(p_state);
+ 	if(!hr)
+	{
+		deb_info("FM Func: Initial 2832 register failed\n");
+	}
+
+	if(hr != 1)
+		return  -1;
+	
+	return 0;
+}
+
+
+int Initial_2832_dab(struct rtl2832_state*	p_state)
+{
+	unsigned char data[4];
+	unsigned short length;	
+	BOOL hr = 1;
+	
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+	{
+		length = 1;
+		data[0] = 0xCD;//enable ADC_I, ADC_Q for zero-IF
+		//data[0] = 0x8D;//enable ADC_I 
+		hr &= RTK_Demod_Byte_Write(0, 0x08, length, data);
+		
+		//bit 0, enable en_bbin
+		//bit 2,1  DC offset
+		//bit 4,3  IQ mismatch
+		length = 1;
+		data[0] = 0x1F;//ZeroIF //?? data[0] = 0x1E;
+		hr &= RTK_Demod_Byte_Write(1, 0xB1, length, data);
+	}
+   
+	//----------------------------------------------
+	//set each time change 
+	//en_sfreq_sync = 0   page 1, 0x3E, bit6
+	//pset_sfreq_off default = 0  page 1, 0x{3E, 3F}
+	length = 2;
+	data[0] = 0x00;
+	data[1] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x3E, length, data);
+	//-----------------------------------------------
+
+	//spec_inv = 0; en_aci = 0; en_cfreq_sync = 0
+	length = 1;
+	data[0] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x15, length, data);
+	
+	//pset_cfreq_off = 0    Pre-set value of carrier frequency offset. 
+	length = 3;
+	data[0] = 0x00;
+	data[1] = 0x00;
+	data[2] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x16, length, data);
+
+	//---- DDC Setting ------
+	//pset_iffreq   IF frequency //36.125M  0x2F; 0xB8; 0xE4;
+	if(p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{//IF 4.57M
+		length = 3;
+		data[0] = 0x35;
+		data[1] = 0xD8;
+		data[2] = 0x2E;
+		hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+	{//ZERO IF
+		length = 3;
+		data[0] = 0x00;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	}
+	else if(p_state->tuner_type ==  RTL2832_TUNER_TYPE_FC0012)
+	{//FC0012_TUNER is zero IF, but can set tunner to other frequency to avoid DC cancellation, frequency noise...
+		
+		//length = 3;
+		//data[0] = 0x00;
+		//data[1] = 0x00;
+		//data[2] = 0x00;
+		//hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	
+		// Set pset_iffreg of 2832
+		length = 3;
+		data[0] = 0x00;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	}
+	//20110413 add by alan
+	else if(p_state->tuner_type ==  RTL2832_TUNER_TYPE_FC0013)
+	{//FC0013_TUNER is zero IF, but can set tunner to other frequency to avoid DC cancellation, frequency noise...
+		
+		//length = 3;
+		//data[0] = 0x00;
+		//data[1] = 0x00;
+		//data[2] = 0x00;
+		//hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	
+		// Set pset_iffreg of 2832
+		length = 3;
+		data[0] = 0x00;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		hr &= RTK_Demod_Byte_Write(1, 0x19, length, data);
+	}
+	//end	
+	//------ Resampler Setting -------
+	//resample ratio 28.8M --> 8.192M
+	length = 4;
+	data[0] = 0x03;
+	data[1] = 0x84;
+	data[2] = 0x00;
+	data[3] = 0x00;
+	hr &= RTK_Demod_Byte_Write(1, 0x9F, length, data);
+
+ 	//------- DDC LPF coe -------------
+	// used in OpenDevice? more possible setFreq  
+	length = 1;
+	data[0] = 202;
+	hr &= RTK_Demod_Byte_Write(1, 0x1C, length, data);
+
+	length = 1;
+	data[0] = 220;
+	hr &= RTK_Demod_Byte_Write(1, 0x1D, length, data);
+
+	length = 1;
+	data[0] = 215;
+	hr &= RTK_Demod_Byte_Write(1, 0x1E, length, data);
+
+	length = 1;
+	data[0] = 216;
+	hr &= RTK_Demod_Byte_Write(1, 0x1F, length, data);
+
+	length = 1;
+	data[0] = 224;
+	hr &= RTK_Demod_Byte_Write(1, 0x20, length, data);
+
+	length = 1;
+	data[0] = 242;
+	hr &= RTK_Demod_Byte_Write(1, 0x21, length, data);
+
+	length = 1;
+	data[0] = 14;
+	hr &= RTK_Demod_Byte_Write(1, 0x22, length, data);
+
+	length = 1;
+	data[0] = 53;
+	hr &= RTK_Demod_Byte_Write(1, 0x23, length, data);
+  
+	length = 1;
+	data[0] = 6;
+	hr &= RTK_Demod_Byte_Write(1, 0x24, length, data);
+
+	length = 1;
+	data[0] = 80;
+	hr &= RTK_Demod_Byte_Write(1, 0x25, length, data);
+
+	length = 1;
+	data[0] = 156;
+	hr &= RTK_Demod_Byte_Write(1, 0x26, length, data);
+
+	length = 1;
+	data[0] = 13;
+	hr &= RTK_Demod_Byte_Write(1, 0x27, length, data);
+
+	length = 1;
+	data[0] = 113;
+	hr &= RTK_Demod_Byte_Write(1, 0x28, length, data);
+
+	length = 1;
+	data[0] = 17;
+	hr &= RTK_Demod_Byte_Write(1, 0x29, length, data);
+
+	length = 1;
+	data[0] = 20;
+	hr &= RTK_Demod_Byte_Write(1, 0x2A, length, data);
+ 
+	length = 1;
+	data[0] = 113;
+	hr &= RTK_Demod_Byte_Write(1, 0x2B, length, data);
+
+	length = 1;
+	data[0] = 116;
+	hr &= RTK_Demod_Byte_Write(1, 0x2C, length, data);
+
+	length = 1;
+	data[0] = 25;
+	hr &= RTK_Demod_Byte_Write(1, 0x2D, length, data);
+
+	length = 1;
+	data[0] = 65;
+	hr &= RTK_Demod_Byte_Write(1, 0x2E, length, data);
+
+	length = 1;
+	data[0] = 165;
+	hr &= RTK_Demod_Byte_Write(1, 0x2F, length, data);
+
+	//-------- DAB Setting ---------
+	//dab dagc_target;     (S,8,7f) when dagc on 
+	length = 1;
+	data[0] = 0x11;//default: 0x13
+	hr &= RTK_Demod_Byte_Write(0, 0x17, length, data);
+    
+	//dagc_gain_set;  (S,8,1f) when dagc off
+	length = 1;
+	data[0] = 0x10;//default: 0x10
+	hr &= RTK_Demod_Byte_Write(0, 0x18, length, data);
+    
+	//0x19 [0]   0x01    1 for dab_enable;     0 for soft reset or module disable;       
+	//0x19 [2:1] 0x02    mode  10 for DAB , 00 for FM , 01/11 for pattern
+ 	//0x19 [4:3] 0x00    dagc_loop_gain; 0~3 for 2^-10 ~ 2^-7:                     
+	//0x19 [5]   0x01    dagc_on;        0 for off , 1 for on                    
+	length = 1;
+	data[0] = 0x25;//0x25;//0x27;
+	hr &= RTK_Demod_Byte_Write(0, 0x19, length, data);
+	//-------------------------------
+
+	//------- hold stage ------------
+	// stage 11 is possible
+	// hold stage 4 now !
+	length = 1;
+	data[0] = 0x00;//0x7F;//
+	hr &= RTK_Demod_Byte_Write(1, 0x92, length, data);
+
+	length = 1;
+	data[0] = 0xF0;//0xF7;//
+	hr &= RTK_Demod_Byte_Write(1, 0x93, length, data);
+
+ 	length = 1;
+	data[0] = 0x0F;//0xFF;//
+	hr &= RTK_Demod_Byte_Write(1, 0x94, length, data);
+	//----------------------------------
+
+	// DAB input from PIP ?
+	length = 1;
+	data[0] = 0x60;
+	hr &= RTK_Demod_Byte_Write(0, 0x61, length, data);//output of PID filter
+ 
+	//if(currentTunner == MT2266_TUNER || currentTunner == FC2580_TUNER || currentTunner == TUA9001_TUNER || currentTunner == FC0012_TUNER)
+	{//???
+		length = 1;
+		data[0] = 0x40;//08.03.10
+		hr &= RTK_Demod_Byte_Write(0, 0x20, length, data);
+	}
+	
+	length = 1;
+	//if(p_state->tuner_type == TUA9001_TUNER)// pay attention: for infineon tunner, exchange I and Q
+	//{
+	//	data[0] = 0x90;
+	//}
+	//else
+	{	
+		data[0] = 0x80;
+	}
+	hr &= RTK_Demod_Byte_Write(0, 0x06, length, data);
+
+	//end
+	//---- software reset -----
+	//page 1, 0x01, bit 2, first 1 then zero
+	length = 1;
+	hr &= RTK_Demod_Byte_Read(1, 0x01, length, data);
+	data[0] = data[0] | 0x04;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, length, data);
+	data[0] = data[0] & 0xFB;
+	hr &= RTK_Demod_Byte_Write(1, 0x01, length, data);
+
+	if(!hr)
+	{
+		deb_info("DAB DLL: initial 2832 register fail\n");
+	}
+
+	if(hr != 1)
+		return  -1;
+	
+	return 0;
+}
+
+
+
+int switch_mode(struct rtl2832_state* p_state, int audio_mdoe)
+{
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	if(p_state->tuner_type != RTL2832_TUNER_TYPE_FC0012 && 
+				p_state->tuner_type != RTL2832_TUNER_TYPE_MXL5007T &&
+				p_state->tuner_type != RTL2832_TUNER_TYPE_E4000 &&
+				p_state->tuner_type != RTL2832_TUNER_TYPE_FC0013)
+	{
+		deb_info("Illegal tuner type\n");
+		goto error;
+	}
+	
+	deb_info("+switch_mode\n");
+
+	if(p_state->demod_support_type & SUPPORT_DVBT_MODE)
+	{
+		// if current state is 2832
+		if(p_state->demod_type == RTL2832)
+		{
+	      		// Demod  H/W Reset
+           		if(rtl2832_hw_reset( p_state))
+					goto error;
+					
+			if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)
+			{
+				if(rtl2832_fc0012_Initialize_fm(p_state->pNim))
+					goto error;
+			}
+			else if(p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+			{
+				if(rtl2832_mxl5007t_Initialize_fm(p_state->pNim))
+					goto error;
+			}
+			else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+			{	
+				if(rtl2832_e4000_Initialize_fm(p_state->pNim))
+					goto error;
+			}
+			else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013)
+			{	
+				if(rtl2832_fc0013_Initialize_fm(p_state->pNim))
+					goto error;
+			}
+
+
+			switch(audio_mdoe)
+			{
+				case FM_MODE:
+					if (Initial_2832_fm(p_state)) 
+					{
+						deb_info("%s: fail to initial fm\n",__FUNCTION__);
+						goto error;
+					}
+					deb_info("%s: switch to fm.....\n",__FUNCTION__);	
+				break;
+
+				case DAB_MODE:
+					if (Initial_2832_dab(p_state)) 
+					{
+						deb_info("%s: fail to initial dab\n",__FUNCTION__);
+						goto error;
+					}
+					deb_info("%s: switch to dab.....\n",__FUNCTION__);	
+				break;	
+			}
+		}
+	}
+
+	deb_info("-switch_mode\n");
+
+       mutex_unlock(&p_state->i2c_repeater_mutex);
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+mutex_error:
+	return -1;
+}
+
+
+//3 Related to urb behavior
+struct usb_data_stream stream_cp;
+struct  fm_stream_ctrl_struct
+{
+	u8  fm_stream_buf[24064];
+	int  fm_stream_index;
+};
+struct fm_stream_ctrl_struct fm_struct;
+struct fm_stream_ctrl_struct* fm_stream;
+
+static void dvb_dmx_fm_filter(struct dvb_demux *demux, const u8 *buf, size_t count)
+{
+
+       struct dvb_demux_feed *feed;
+	int p,i,j;
+
+	spin_lock(&demux->lock);
+
+       list_for_each_entry(feed, &demux->feed_list, list_head) {
+		if(feed->pid != 0x2000)
+			continue;
+
+	p = 0;
+	if (fm_stream->fm_stream_index) {
+		i = fm_stream->fm_stream_index;
+		j = 24064 - i;
+
+		if (count < j) {
+			memcpy(&fm_stream->fm_stream_buf[i], buf, count);
+			fm_stream->fm_stream_index += count; 
+			goto bailout;
+		}
+		
+		memcpy(&fm_stream->fm_stream_buf[i], buf, j);
+		feed->cb.ts(fm_stream->fm_stream_buf, 24064, NULL, 0, &feed->feed.ts, DMX_OK);
+		fm_stream->fm_stream_index = 0;
+		p += j;
+	}
+
+	while (p < count) {
+		if (count - p >= 24064) {
+				feed->cb.ts(&buf[p], 24064, NULL, 0, &feed->feed.ts, DMX_OK);
+				p += 24064;
+		} else {
+				i = count - p;
+				memcpy(fm_stream->fm_stream_buf, &buf[p], i);
+				fm_stream->fm_stream_index = i;
+				goto bailout;
+		}
+	}
+
+	}
+
+bailout:
+	spin_unlock(&demux->lock);
+}
+
+
+//3--> dvb_usb_data_complete
+static void fm_usb_data_complete(struct usb_data_stream *stream, u8 *buffer, size_t length)
+{
+	struct dvb_usb_adapter *adap = stream->user_priv;
+	
+	//deb_info("%s: length %d\n ", __func__, length);//debug
+	if (adap->feedcount > 0 && adap->state & DVB_USB_ADAP_STATE_DVB)
+		dvb_dmx_fm_filter(&adap->demux, buffer, length);
+}
+
+void fm_stream_ctrl(int f,  struct dvb_usb_adapter*  adapter)
+{
+	if(f)
+	{//store  usb_data_stream part
+		memcpy(&stream_cp, &adapter->stream, sizeof(struct usb_data_stream));
+		adapter->stream.complete = fm_usb_data_complete;	
+	}
+	else
+	{//resume dvb-t usb_data_stream part
+		memcpy(&adapter->stream, &stream_cp, sizeof(struct usb_data_stream));
+	}
+}
+
+int fe_fm_cmd_ctrl(struct dvb_frontend *fe, void *parg)
+{
+	deb_info("+fe_fm_cmd_ctrl\n");
+
+	struct rtl2832_state*	p_state = fe->demodulator_priv;
+	struct dvb_usb_adapter*  adapter = p_state->d->adapter;//ptr to adapter[0]
+	struct fm_cmd_struct*  fm_ctrl = (struct fm_cmd_struct*)parg;
+	int fm_cmd = fm_ctrl->cmd_num;
+	unsigned int tmp2;
+	unsigned char data[4];
+	int hr;
+	struct fm_cmd_struct  tmp_str;
+	unsigned int orgValue;
+	unsigned int psetValue;
+   
+	switch(fm_cmd)
+	{
+		case FE_ENABLE_FM:
+
+			deb_info("FE_OPEN_FM\n");
+
+			if(p_state->rtl2832_audio_video_mode == RTK_AUDIO)
+			{
+				deb_info("It has been FM mode\n");
+				return 1;
+			}
+
+			//check whether it is legal, no dvb-t, no fm
+					
+			//switch to fm mode
+			if(switch_mode(p_state, FM_MODE))
+				return -1;
+			
+			//change usb_data_stream part
+			//fm_stream = vmalloc(sizeof(struct fm_stream_ctrl_struct));
+			fm_stream = &fm_struct;
+			fm_stream_ctrl(1, adapter);
+		
+			p_state->rtl2832_audio_video_mode = RTK_AUDIO;//FM or DAB
+
+			tmp_str.tuner= p_state->tuner_type;//tuner type
+			memcpy(parg, &tmp_str, sizeof(struct fm_cmd_struct));//will be copy to user
+	
+			return 1;//break;
+
+		case FE_ENABLE_DAB:
+
+			deb_info("FE_OPEN_DAB\n");
+
+			if(p_state->rtl2832_audio_video_mode == RTK_AUDIO)
+			{
+				deb_info("It has been DAB mode\n");
+				return 1;
+			}
+
+			//check whether it is legal, no dvb-t, no fm
+					
+			//switch to fm mode
+			if(switch_mode(p_state, DAB_MODE))
+				return -1;
+			
+			//change usb_data_stream part
+			//fm_stream = vmalloc(sizeof(struct fm_stream_ctrl_struct));
+			fm_stream = &fm_struct;
+			fm_stream_ctrl(1, adapter);
+		
+			p_state->rtl2832_audio_video_mode = RTK_AUDIO;//FM or DAB
+
+			tmp_str.tuner= p_state->tuner_type;//tuner type
+			memcpy(parg, &tmp_str, sizeof(struct fm_cmd_struct));//will be copy to user
+	
+			return 1;//break;
+
+			
+		case FE_DISABLE_FM:
+		case FE_DISABLE_DAB:
+			
+			deb_info("FE_CLOSE_FM or DAB\n");
+
+			if(p_state->rtl2832_audio_video_mode != RTK_AUDIO)
+			{
+				deb_info("It is not start from FM or DAB mode\n");
+				return 1;
+			}
+			
+			fm_stream_ctrl(0, adapter);
+			p_state->rtl2832_audio_video_mode = RTK_VIDEO;
+			return 1;//break;
+
+		case CR_D:
+
+			deb_info("CR_d\n");
+
+			tmp2 = (fm_ctrl->cr)  & 0x3FFFFF;
+	    		data[0] = (tmp2>>16) & 0x3F;
+	    		data[1] = (tmp2>>8) & 0xFF;
+			data[2] = tmp2 & 0xFF;
+	    		hr = RTK_Demod_Byte_Write(1, 0x16, 3, data);
+			if(!hr)
+				return -1;
+
+			hr = RTL2832_SWReset_2(p_state);
+			if(!hr)
+				return -1;
+
+			deb_info("CR_d done\n");
+			return 1;
+
+		case CR_A:
+
+			deb_info("CR_a\n");
+
+			hr = RTK_Demod_Byte_Read(1, 0x16, 3, data);
+			if(!hr)
+			{
+				return -1;
+			}
+
+			tmp2 = (fm_ctrl->cr)  & 0x3FFFFF;
+
+			orgValue =  (((unsigned int)data[0]&0x3F)<<16) | (((unsigned int)data[1])<<8) | (unsigned short)data[2];
+			psetValue = tmp2 + orgValue; 
+			
+			data[0] = (psetValue>>16) & 0x3F;
+			data[1] = (psetValue>>8) & 0xFF;
+			data[2] = psetValue & 0xFF;
+			hr = RTK_Demod_Byte_Write(1, 0x16, 3, data);
+			if(!hr)
+				return -1;
+
+			hr = RTL2832_SWReset_2(p_state);
+			if(!hr)
+				return -1;	
+
+			deb_info("CR_a done\n");
+			return 1;
+
+		case TR_D:   
+
+			deb_info("TR_d \n");
+
+			tmp2 = (fm_ctrl->cr);
+			data[0] = (tmp2>>8) & 0x3F;
+			data[1] = tmp2 & 0xFF;
+			hr = RTK_Demod_Byte_Write(1, 0x3E, 2, data);//0x3E 0x3F
+			if(!hr)
+				return -1;
+
+			hr = RTL2832_SWReset(p_state);
+			if(!hr)
+				return -1;
+
+			deb_info("TR_d done\n");
+			return 1;
+
+		case TR_A:    //increasing value
+
+			deb_info("TR_a\n");
+
+			hr = RTK_Demod_Byte_Read(1, 0x3E, 2, data);//0x3E, 0x3F
+			if(!hr)
+				return -1;
+
+			tmp2 = (fm_ctrl->cr);
+			orgValue =  (((unsigned int)data[0] & 0x3F) << 8) | (unsigned int)data[1];
+			psetValue = (tmp2 & 0x3FFF) + orgValue; 
+	
+			data[0] = (psetValue>>8) & 0x3F;
+			data[1] = psetValue & 0xFF;
+
+			hr = RTK_Demod_Byte_Write(1, 0x3E, 2, data);//0x3E, 0x3F
+			if(!hr)
+				return -1;			
+			
+			hr = RTL2832_SWReset(p_state);
+			if(!hr)
+				return -1;
+
+			deb_info("TR_a done\n");
+			return 1;
+
+		default:
+			return -1;			
+	}
+
+	return 0;		
+}
+
+
+int rtl2832_fe_ioctl_override(struct dvb_frontend *fe,unsigned int cmd, void *parg, unsigned int stage)
+{
+	
+	//deb_info("rtl2832_fe_ioctl_override : cmd =%d\n", cmd);
+	
+	int ret = 0;
+
+	if(stage == DVB_FE_IOCTL_PRE)
+	{
+		switch(cmd)
+		{
+			case FE_FM_CMD:
+
+				ret = fe_fm_cmd_ctrl(fe, parg);
+			break;
+	
+		}
+	}
+	//else
+	//{
+	//deb_info("rtl2832_fe_ioctl_override : xxxxx\n");
+	//}	
+
+	return ret;
+}
+
+
+#endif 
+
+
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_audio.h b/drivers/media/usb/rtl2832u/rtl2832u_audio.h
new file mode 100644
index 00000000..fcb70195
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_audio.h
@@ -0,0 +1,58 @@
+
+#ifndef __RTL2832U_AUDIO_H__
+#define __RTL2832U_AUDIO_H__
+
+
+#if 0
+
+#include "rtl2832u_fe.h"
+#include "rtl2832u_io.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb-usb.h"
+
+#define UCHAR  unsigned char
+
+
+
+struct fm_cmd_struct
+{
+	int cmd_num;
+	int cr;
+	int tuner;	
+	int tr;
+};
+
+
+#define FE_FM_CMD    _IOWR('o', 90,  struct fm_cmd_struct)
+
+enum
+{
+	FE_ENABLE_FM=0,
+	FE_DISABLE_FM,
+	CR_D,
+	CR_A,
+	CR_S,
+	READ_BYTE,
+	WRITE_BYTE,
+	FE_ENABLE_DAB,
+	FE_DISABLE_DAB,
+	TR_D,
+	TR_A,
+};
+
+enum
+{
+	FM_MODE = 0,
+	DAB_MODE,
+};
+
+
+
+int rtl2832_fe_ioctl_override(struct dvb_frontend *fe,unsigned int cmd, void *parg, unsigned int stage);
+void fm_stream_ctrl(int f,  struct dvb_usb_adapter*  adapter);
+
+
+#endif
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_fe.c b/drivers/media/usb/rtl2832u/rtl2832u_fe.c
new file mode 100644
index 00000000..b82d0ff8
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_fe.c
@@ -0,0 +1,4184 @@
+
+#include "rtl2832u_fe.h"
+#include "rtl2832u_io.h"
+#include "rtl2832u.h"
+#include "rtl2832u_audio.h"
+#include "si2168rtl.h"
+//#include "rtl2832u_ioctl.h"
+
+extern int demod_default_type;
+extern int dtmb_error_packet_discard;
+extern int dvb_use_rtl2832u_card_type;
+extern int dvb_use_rtl2832u_rc_mode;
+//extern int rtl2832u_remote_control_state;
+
+static struct rtl2832_reg_addr rtl2832_reg_map[]= {
+	/* RTD2831_RMAP_INDEX_USB_CTRL_BIT5*/			{ RTD2832U_USB, USB_CTRL, 5, 5		},
+	/* RTD2831_RMAP_INDEX_USB_STAT*/				{ RTD2832U_USB, USB_STAT, 0, 7		},
+	/* RTD2831_RMAP_INDEX_USB_EPA_CTL*/			{ RTD2832U_USB, USB_EPA_CTL, 0, 31	},
+	/* RTD2831_RMAP_INDEX_USB_SYSCTL*/				{ RTD2832U_USB, USB_SYSCTL, 0, 31		},
+	/* RTD2831_RMAP_INDEX_USB_EPA_CFG*/			{ RTD2832U_USB, USB_EPA_CFG, 0, 31	},
+	/* RTD2831_RMAP_INDEX_USB_EPA_MAXPKT*/		{ RTD2832U_USB, USB_EPA_MAXPKT, 0, 31},
+	/* RTD2831_RMAP_INDEX_USB_EPA_FIFO_CFG*/		{ RTD2832U_USB, USB_EPA_FIFO_CFG, 0, 31},
+
+	/* RTD2831_RMAP_INDEX_SYS_DEMOD_CTL*/			{ RTD2832U_SYS, DEMOD_CTL, 0, 7	       },
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL*/	{ RTD2832U_SYS, GPIO_OUTPUT_VAL, 0, 7	},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT3*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 3, 3	},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT3*/		{ RTD2832U_SYS, GPIO_DIR, 3, 3		},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_CFG0_BIT67*/	{ RTD2832U_SYS, GPIO_CFG0, 6, 7		},
+	/* RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1*/		{ RTD2832U_SYS, DEMOD_CTL1, 0, 7	       },
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT1*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 1, 1	},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT1*/		{ RTD2832U_SYS, GPIO_DIR, 1, 1		},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT6*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 6, 6	},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT6*/		{ RTD2832U_SYS, GPIO_DIR, 6, 6		},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT5*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 5, 5},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT5*/      { RTD2832U_SYS, GPIO_DIR, 5, 5},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT2*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 2, 2},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT2*/      { RTD2832U_SYS, GPIO_DIR, 2, 2},
+    /* RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT0*/{ RTD2832U_SYS, GPIO_OUTPUT_EN, 0, 0},
+	/* RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT0*/      { RTD2832U_SYS, GPIO_DIR, 0, 0},
+
+#if 0
+	/* RTD2831_RMAP_INDEX_SYS_GPD*/			{ RTD2832U_SYS, GPD, 0, 7		},
+	/* RTD2831_RMAP_INDEX_SYS_GPOE*/			{ RTD2832U_SYS, GPOE, 0, 7	},
+	/* RTD2831_RMAP_INDEX_SYS_GPO*/			{ RTD2832U_SYS, GPO, 0, 7		},
+	/* RTD2831_RMAP_INDEX_SYS_SYS_0*/			{ RTD2832U_SYS, SYS_0, 0, 7	},
+#endif
+
+	/* DTMB related */
+
+
+};
+
+static int rtl2832_reg_mask[32]= {
+    0x00000001,
+    0x00000003,
+    0x00000007,
+    0x0000000f,
+    0x0000001f,
+    0x0000003f,
+    0x0000007f,
+    0x000000ff,
+    0x000001ff,
+    0x000003ff,
+    0x000007ff,
+    0x00000fff,
+    0x00001fff,
+    0x00003fff,
+    0x00007fff,
+    0x0000ffff,
+    0x0001ffff,
+    0x0003ffff,
+    0x0007ffff,
+    0x000fffff,
+    0x001fffff,
+    0x003fffff,
+    0x007fffff,
+    0x00ffffff,
+    0x01ffffff,
+    0x03ffffff,
+    0x07ffffff,
+    0x0fffffff,
+    0x1fffffff,
+    0x3fffffff,
+    0x7fffffff,
+    0xffffffff
+};
+
+typedef struct FC0012_LNA_REG_MAP
+{
+	unsigned char	Lna_regValue;
+	long			LnaGain;
+}FC0012_LNA_REG_MAP;
+
+FC0012_LNA_REG_MAP  FC0012_LNA_GAIN_TABLE[]= {
+	{0x00 , -63},{0x01 , -58},{0x02 , -99},{0x03 , -73},{0x04 , -63},{0x05 , -65}
+	,{0x06 , -54},{0x07 , -60},{0x08 , 71 },{0x09 , 70 },{0x0a , 68 },{0x0b , 67 }
+	,{0x0c , 65 },{0x0d , 63 },{0x0e , 61 },{0x0f , 58 },{0x10 , 197},{0x11 , 191}
+	,{0x12 , 188},{0x13 , 186},{0x14 , 184},{0x15 , 182},{0x16 , 181},{0x17 , 179}
+};
+
+static int check_dtmb_support(struct rtl2832_state* p_state);
+
+static int 	check_dvbc_support(struct rtl2832_state* p_state);
+
+static int
+set_demod_2836_power(
+		struct rtl2832_state* p_state,
+		int  onoff);
+
+static int
+set_demod_2168_power(
+		struct rtl2832_state* p_state,
+		int  onoff);
+
+static int
+rtl2840_on_hwreset(
+		struct rtl2832_state* p_state);
+
+
+static int
+set_demod_2840_power(
+		struct rtl2832_state* p_state,
+		int  onoff);
+
+
+static int
+demod_init_setting(
+	struct rtl2832_state * p_state);
+
+static int
+build_nim_module(
+	struct rtl2832_state*  p_state);
+
+static int
+rtl2836_scan_procedure(
+		struct rtl2832_state * p_state);
+static int
+fc0012_get_signal_strength(
+	struct rtl2832_state	*p_state,
+	unsigned long *strength);
+static int
+rtl2832_sleep_mode(struct rtl2832_state* p_state);
+
+static void
+custom_wait_ms(
+	BASE_INTERFACE_MODULE*	pBaseInterface,
+	unsigned long				WaitTimeMs)
+{
+	platform_wait(WaitTimeMs);
+	return;
+}
+
+
+static int
+custom_i2c_read(
+	BASE_INTERFACE_MODULE*	pBaseInterface,
+	unsigned char				DeviceAddr,
+	unsigned char*			pReadingBytes,
+	unsigned long				ByteNum
+	)
+{
+	struct dvb_usb_device *d;
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);
+	if ( read_rtl2832_stdi2c( d, DeviceAddr , pReadingBytes , ByteNum ) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+
+
+static int
+custom_i2c_write(
+	BASE_INTERFACE_MODULE*	pBaseInterface,
+	unsigned char				DeviceAddr,
+	const unsigned char*			pWritingBytes,
+	unsigned long				ByteNum)
+{
+	struct dvb_usb_device *d;
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);
+	if ( write_rtl2832_stdi2c( d, DeviceAddr , (unsigned char*)pWritingBytes , ByteNum ) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+
+
+static int
+read_usb_sys_register(
+	struct rtl2832_state*		p_state,
+	rtl2832_reg_map_index		reg_map_index,
+	int*						p_val)
+{
+	RegType			reg_type=	rtl2832_reg_map[reg_map_index].reg_type;
+	unsigned short	reg_addr=	rtl2832_reg_map[reg_map_index].reg_addr;
+	int				bit_low=	rtl2832_reg_map[reg_map_index].bit_low;
+	int				bit_high=	rtl2832_reg_map[reg_map_index].bit_high;
+
+	int	n_byte_read=(bit_high>> 3)+ 1;
+
+	*p_val= 0;
+	if (read_usb_sys_int_bytes(p_state->d, reg_type, reg_addr, n_byte_read, p_val)) goto error;
+
+	*p_val= ((*p_val>> bit_low) & rtl2832_reg_mask[bit_high- bit_low]);
+
+	return 0;
+
+error:
+	return 1;
+}
+
+
+
+
+static int
+write_usb_sys_register(
+	struct rtl2832_state*		p_state,
+	rtl2832_reg_map_index		reg_map_index,
+	int						val_write)
+{
+	RegType			reg_type=	rtl2832_reg_map[reg_map_index].reg_type;
+	unsigned short	reg_addr=	rtl2832_reg_map[reg_map_index].reg_addr;
+	int				bit_low=	rtl2832_reg_map[reg_map_index].bit_low;
+	int				bit_high=	rtl2832_reg_map[reg_map_index].bit_high;
+
+	int	n_byte_write=	(bit_high>> 3)+ 1;
+	int	val_read= 0;
+	int	new_val_write;
+
+	if (read_usb_sys_int_bytes(p_state->d, reg_type, reg_addr, n_byte_write, &val_read)) goto error;
+
+	new_val_write= (val_read & (~(rtl2832_reg_mask[bit_high- bit_low]<< bit_low))) | (val_write<< bit_low);
+
+	if (write_usb_sys_int_bytes(p_state->d, reg_type, reg_addr, n_byte_write, new_val_write)) goto error;
+	return 0;
+
+error:
+	return 1;
+}
+
+
+
+
+static int
+max3543_set_power(
+	struct rtl2832_state*	p_state,
+	unsigned char			onoff
+	)
+{
+	unsigned char	data;
+	unsigned char	i2c_repeater;
+
+
+	if( p_state->tuner_type != RTL2832_TUNER_TYPE_MAX3543)		return 0;
+
+	deb_info(" %s : onoff =%d\n", __FUNCTION__, onoff);
+
+	read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+	i2c_repeater |= BIT3;
+	write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+
+	if(onoff)
+	{
+		//turn on BIT7=0
+		read_rtl2832_tuner_register(p_state->d, MAX3543_TUNER_ADDR, MAX3543_SHUTDOWN_OFFSET, &data, LEN_1_BYTE);
+		data &=(~BIT_7_MASK);
+		write_rtl2832_tuner_register(p_state->d, MAX3543_TUNER_ADDR, MAX3543_SHUTDOWN_OFFSET, &data, LEN_1_BYTE);
+	}
+	else
+	{
+		//turn off  BIT7=1
+		read_rtl2832_tuner_register(p_state->d, MAX3543_TUNER_ADDR, MAX3543_SHUTDOWN_OFFSET, &data, LEN_1_BYTE);
+		data |=BIT_7_MASK;
+		write_rtl2832_tuner_register(p_state->d, MAX3543_TUNER_ADDR, MAX3543_SHUTDOWN_OFFSET, &data, LEN_1_BYTE);
+	}
+
+	read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+	i2c_repeater &= (~BIT3);
+	write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+
+
+	return 0;
+
+}
+
+
+static int
+set_tuner_power(
+	struct rtl2832_state*	p_state,
+	unsigned char			b_gpio4,
+	unsigned char			onoff)
+{
+
+	int			data;
+
+	if(onoff==0)		max3543_set_power(p_state, onoff);
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+
+	if(b_gpio4)
+	{
+		if(onoff)		data &= ~(BIT4);   //set bit4 to 0
+		else			data |= BIT4;		//set bit4 to 1
+
+	}
+	else
+	{
+		if(onoff)		data &= ~(BIT3);   //set bit3 to 0
+		else			data |= BIT3;		//set bit3 to 1
+	}
+
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,data) ) goto error;
+
+
+	if(onoff==1)		max3543_set_power(p_state, onoff);
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+error:
+	return 1;
+}
+
+
+static int
+set_demod_power(
+	struct rtl2832_state*	p_state,
+	unsigned char			onoff)
+{
+
+	int			data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+	if(onoff)		data &= ~(BIT0);   //set bit0 to 0
+	else			data |= BIT0;		//set bit0 to 1
+	data &= ~(BIT0);   //3 Demod Power always ON => hw issue.
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,data) ) goto error;
+
+	deb_info(" -%s \n", __FUNCTION__);
+	return 0;
+error:
+	return 1;
+}
+
+
+//3//////// Set GPIO3 "OUT"  => Turn ON/OFF Tuner Power
+//3//////// Set GPIO3 "IN"      => Button  Wake UP (USB IF) , NO implement in rtl2832u linux driver
+
+static int
+gpio3_out_setting(
+	struct rtl2832_state*	p_state)
+{
+	int			data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	// GPIO3_PAD Pull-HIGH, BIT76
+	data = 2;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_CFG0_BIT67,data) ) goto error;
+
+	// GPO_GPIO3 = 1, GPIO3 output value = 1
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+	data |= BIT3;		//set bit3 to 1
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,data) ) goto error;
+
+	// GPD_GPIO3=0, GPIO3 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT3,data) ) goto error;
+
+	// GPOE_GPIO3=1, GPIO3 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT3,data) ) goto error;
+
+	//BTN_WAKEUP_DIS = 1
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_CTRL_BIT5,data) ) goto error;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+error:
+	return 1;
+}
+
+
+
+
+
+
+static int
+usb_epa_fifo_reset(
+	struct rtl2832_state*	p_state)
+{
+
+	int					data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	//3 reset epa fifo:
+	//3[9] Reset EPA FIFO
+	//3 [5] FIFO Flush,Write 1 to flush the oldest TS packet (a 188 bytes block)
+
+	data = 0x0210;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_CTL,data) ) goto error;
+
+	data = 0xffff;
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_CTL,&data) ) goto error;
+
+	if( (data & 0xffff) != 0x0210)
+	{
+		deb_info("Write error RTD2831_RMAP_INDEX_USB_EPA_CTL = 0x%x\n",data);
+	 	goto error;
+	}
+
+	data=0x0000;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_CTL,data) ) goto error;
+
+	data = 0xffff;
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_CTL,&data) ) goto error;
+
+	if( ( data  & 0xffff) != 0x0000)
+	{
+		deb_info("Write error RTD2831_RMAP_INDEX_USB_EPA_CTL = 0x%x\n",data);
+	 	goto error;
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+error:
+	return 1;
+
+}
+
+
+
+static int
+usb_init_bulk_setting(
+	struct rtl2832_state*	p_state)
+{
+
+	int					data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	//3 1.FULL packer mode(for bulk)
+	//3 2.DMA enable.
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_SYSCTL, &data) ) goto error;
+
+	data &=0xffffff00;
+	data |= 0x09;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_SYSCTL, data) ) goto error;
+
+	data=0;
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_SYSCTL, &data) ) goto error;
+
+	if((data&0xff)!=0x09)
+	{
+		deb_info("Open bulk FULL packet mode error!!\n");
+	 	goto error;
+	}
+
+	//3check epa config,
+	//3[9-8]:00, 1 transaction per microframe
+	//3[7]:1, epa enable
+	//3[6-5]:10, bulk mode
+	//3[4]:1, device to host
+	//3[3:0]:0001, endpoint number
+	data = 0;
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_CFG, &data) ) goto error;
+	if((data&0x0300)!=0x0000 || (data&0xff)!=0xd1)
+	{
+		deb_info("Open bulk EPA config error! data=0x%x \n" , data);
+	 	goto error;
+	}
+
+	//3 EPA maxsize packet
+	//3 512:highspeedbulk, 64:fullspeedbulk.
+	//3 940:highspeediso,  940:fullspeediso.
+
+	//3 get info :HIGH_SPEED or FULL_SPEED
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_STAT, &data) ) goto error;
+	if(data&0x01)
+	{
+		data = 0x00000200;
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_MAXPKT, data) ) goto error;
+
+		data=0;
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_MAXPKT, &data) ) goto error;
+
+		if((data&0xffff)!=0x0200)
+		{
+			deb_info("Open bulk EPA max packet size error!\n");
+		 	goto error;
+		}
+
+		deb_info("HIGH SPEED\n");
+	}
+	else
+    	{
+		data = 0x00000040;
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_MAXPKT, data) ) goto error;
+
+		data=0;
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_MAXPKT, &data) ) goto error;
+
+		if((data&0xffff)!=0x0200)
+		{
+			deb_info("Open bulk EPA max packet size error!\n");
+		 	goto error;
+		}
+
+		deb_info("FULL SPEED\n");
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+error:
+	return 1;
+}
+
+
+static int
+usb_init_setting(
+	struct rtl2832_state*	p_state)
+{
+
+	int					data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if ( usb_init_bulk_setting(p_state) ) goto error;
+
+	//3 change fifo length of EPA
+	data = 0x00000014;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_FIFO_CFG, data) ) goto error;
+	data = 0xcccccccc;
+	if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_USB_EPA_FIFO_CFG, &data) ) goto error;
+	if( (data & 0xff) != 0x14)
+	{
+		deb_info("Write error RTD2831_RMAP_INDEX_USB_EPA_FIFO_CFG =0x%x\n",data);
+	 	goto error;
+	}
+
+	if ( usb_epa_fifo_reset(p_state) ) goto error;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+error:
+	return 1;
+}
+
+
+
+static int
+suspend_latch_setting(
+	struct rtl2832_state*	p_state,
+	unsigned char			resume)
+{
+
+	int					data;
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if (resume)
+	{
+		//3 Suspend_latch_en = 0  => Set BIT4 = 0
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+		data &= (~BIT4);	//set bit4 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+	}
+	else
+	{
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+		data |= BIT4;		//set bit4 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+error:
+	return 1;
+
+}
+
+
+
+
+
+//3////// DEMOD_CTL1  => IR Setting , IR wakeup from suspend mode
+//3////// if resume =1, resume
+//3////// if resume = 0, suspend
+
+
+static int
+demod_ctl1_setting(
+	struct rtl2832_state*	p_state,
+	unsigned char			resume)
+{
+
+	int					data;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if(resume)
+	{
+		// IR_suspend
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+		data &= (~BIT2);		//set bit2 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+
+		//Clk_400k
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+		data &= (~BIT3);		//set bit3 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+	}
+	else
+	{
+		//Clk_400k
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+		data |= BIT3;		//set bit3 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+
+		// IR_suspend
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1, &data) ) goto error;
+
+		data |= BIT2;		//set bit2 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,data) ) goto error;
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+error:
+	return 1;
+
+}
+
+
+
+
+static int
+demod_ctl_setting(
+	struct rtl2832_state*	p_state,
+	unsigned char			resume,
+	unsigned char               on)
+{
+
+	int					data;
+	unsigned char			tmp;
+
+	deb_info(" +%s \n", __FUNCTION__);
+    printk("ADC:%d,%d\n",resume,on);
+	if(resume)
+	{
+		// PLL setting
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data |= BIT7;		//set bit7 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+
+
+
+
+		//2 + Begin LOCK
+		// Demod  H/W Reset
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data &= (~BIT5);	//set bit5 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data |= BIT5;		//set bit5 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		//3 reset page chache to 0
+		if ( read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 0, 1, &tmp, 1 ) ) goto error;
+		//2 -End LOCK
+
+		// delay 5ms
+		platform_wait(5);
+
+
+		if(on)
+		{
+			// ADC_Q setting on
+			if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+			data |= BIT3;		//set bit3 to 1
+			if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+			// ADC_I setting on
+			if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+			data |= BIT6;		//set bit6 to 1
+			if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+		}
+		else
+		{
+			// ADC_I setting off
+			if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+			data &= (~BIT6);		//set bit3 to 0
+			if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+			// ADC_Q setting off
+			if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+			data &= (~BIT3);		//set bit6 to 0
+			if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+		}
+	}
+	else
+	{
+
+		// ADC_I setting
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data &= (~BIT6);		//set bit6 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		// ADC_Q setting
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data &= (~BIT3);		//set bit3 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		// PLL setting
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+		data &= (~BIT7);		//set bit7 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+error:
+	return 1;
+
+}
+
+
+static int
+read_tuner_id_register(
+	struct rtl2832_state*	p_state,
+	unsigned char			tuner_addr,
+	unsigned char			tuner_offset,
+	unsigned char*		id_data,
+	unsigned char			length)
+{
+	unsigned char				i2c_repeater;
+	struct dvb_usb_device*	d = p_state->d;
+
+	//2 + Begin LOCK
+	if(read_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+	i2c_repeater |= BIT3;
+	if(write_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+
+	if(read_rtl2832_tuner_register(d, tuner_addr, tuner_offset, id_data, length)) goto error;
+
+	if(read_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+	i2c_repeater &= (~BIT3);
+	if(write_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+	//2 - End LOCK
+	return 0;
+
+error:
+	return 1;
+}
+
+
+
+static int
+check_mxl5007t_chip_version(
+	struct rtl2832_state*	p_state,
+	unsigned char			*chipversion)
+{
+
+	unsigned char Buffer[LEN_2_BYTE];
+	unsigned char	i2c_repeater;
+
+	struct dvb_usb_device*	d = p_state->d;
+
+
+	Buffer[0] = (unsigned char)MXL5007T_I2C_READING_CONST;
+	Buffer[1] = (unsigned char)MXL5007T_CHECK_ADDRESS;
+
+
+	if(read_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+	i2c_repeater |= BIT3;
+	if(write_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+
+
+	write_rtl2832_stdi2c(d, MXL5007T_BASE_ADDRESS , Buffer, LEN_2_BYTE);
+
+	read_rtl2832_stdi2c(d, MXL5007T_BASE_ADDRESS, Buffer, LEN_1_BYTE);
+
+	if(read_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+	i2c_repeater &= (~BIT3);
+	if(write_demod_register(d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 )) goto error;
+
+
+
+	switch(Buffer[0])
+	{
+		case MXL5007T_CHECK_VALUE:
+			*chipversion = MxL_5007T_V4;
+			break;
+		default:
+			*chipversion = MxL_UNKNOWN_ID;
+			break;
+	}
+
+	return 0;
+
+error:
+
+	return 1;
+
+}
+
+
+
+
+
+
+static int
+check_tuner_type(
+	struct rtl2832_state	*p_state)
+{
+
+	unsigned char				tuner_id_data[2];
+	unsigned char				chip_version;
+
+       deb_info(" +%s\n", __FUNCTION__);
+	if ((!read_tuner_id_register(p_state, MT2266_TUNER_ADDR, MT2266_OFFSET,  tuner_id_data, LEN_1_BYTE)) &&
+		( tuner_id_data[0] == MT2266_CHECK_VAL ))
+	{
+	 	p_state->tuner_type = RTL2832_TUNER_TYPE_MT2266;
+
+		deb_info(" -%s : MT2266 tuner on board...\n", __FUNCTION__);
+	}
+	else if ((!read_tuner_id_register(p_state, FC2580_TUNER_ADDR, FC2580_OFFSET,  tuner_id_data, LEN_1_BYTE)) &&
+			((tuner_id_data[0]&(~BIT7)) == FC2580_CHECK_VAL ))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_FC2580;
+
+		deb_info(" -%s : FC2580 tuner on board...\n", __FUNCTION__);
+	}
+	else if(( !read_tuner_id_register(p_state, MT2063_TUNER_ADDR, MT2063_CHECK_OFFSET,  tuner_id_data, LEN_1_BYTE)) &&
+			( tuner_id_data[0]==MT2063_CHECK_VALUE || tuner_id_data[0]==MT2063_CHECK_VALUE_2))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_MT2063;
+
+		deb_info(" -%s : MT2063 tuner on board...\n", __FUNCTION__);
+
+	}
+	else if(( !read_tuner_id_register(p_state, MAX3543_TUNER_ADDR, MAX3543_CHECK_OFFSET,  tuner_id_data, LEN_1_BYTE)) &&
+			( tuner_id_data[0]==MAX3543_CHECK_VALUE))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_MAX3543;
+
+		deb_info(" -%s : MAX3543 tuner on board...\n", __FUNCTION__);
+
+	}
+	else if ((!read_tuner_id_register(p_state, TUA9001_TUNER_ADDR, TUA9001_OFFSET,  tuner_id_data, LEN_2_BYTE)) &&
+				(((tuner_id_data[0]<<8)|tuner_id_data[1]) == TUA9001_CHECK_VAL ))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_TUA9001;
+
+		deb_info(" -%s : TUA9001 tuner on board...\n", __FUNCTION__);
+	}
+	else	 if ((!check_mxl5007t_chip_version(p_state, &chip_version)) &&
+			(chip_version == MXL5007T_CHECK_VALUE) )
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_MXL5007T;
+
+		deb_info(" -%s : MXL5007T tuner on board...\n", __FUNCTION__);
+	}
+	else if ((!read_tuner_id_register(p_state, FC0012_BASE_ADDRESS , FC0012_CHECK_ADDRESS,  tuner_id_data, LEN_1_BYTE)) &&
+			(tuner_id_data[0] == FC0012_CHECK_VALUE))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_FC0012;
+
+		deb_info(" -%s : FC0012 tuner on board...\n", __FUNCTION__);
+	}
+	else	if((!read_tuner_id_register(p_state, E4000_BASE_ADDRESS, E4000_CHECK_ADDRESS, tuner_id_data, LEN_1_BYTE)) &&
+			(tuner_id_data[0] == E4000_CHECK_VALUE))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_E4000;
+		deb_info(" -%s : E4000 tuner on board...\n", __FUNCTION__);
+	}
+	else if(( !read_tuner_id_register(p_state, TDA18272_TUNER_ADDR, TDA18272_CHECK_OFFSET,  tuner_id_data, LEN_2_BYTE)) &&
+			( (tuner_id_data[0]==TDA18272_CHECK_VALUE1) && (tuner_id_data[1]==TDA18272_CHECK_VALUE2)))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_TDA18272;
+
+		deb_info(" -%s : Tda18272 tuner on board...\n", __FUNCTION__);
+
+	}
+	else if ((!read_tuner_id_register(p_state, FC0013_BASE_ADDRESS , FC0013_CHECK_ADDRESS,  tuner_id_data, LEN_1_BYTE)) &&
+			(tuner_id_data[0] == FC0013_CHECK_VALUE))
+	{
+		p_state->tuner_type = RTL2832_TUNER_TYPE_FC0013;
+
+		deb_info(" -%s : FC0013 tuner on board...\n", __FUNCTION__);
+	}
+	else
+	{
+		//p_state->tuner_type = RTL2832_TUNER_TYPE_UNKNOWN;
+
+		//deb_info(" -%s : Unknown tuner on board...\n", __FUNCTION__);
+		//goto error;
+		p_state->tuner_type = RTL2832_TUNER_TYPE_SI2148;
+		deb_info(" -%s : SI2148 tuner on board...\n", __FUNCTION__);
+	}
+
+	return 0;
+//error:
+//	return -1;
+}
+
+static int
+gpio1_output_enable_direction(
+	struct rtl2832_state*	p_state)
+{
+	int data;
+	// GPD_GPIO1=0, GPIO1 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT1,data) ) goto error;
+
+	// GPOE_GPIO1=1, GPIO1 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT1,data) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+
+static int
+gpio6_output_enable_direction(
+	struct rtl2832_state*	p_state)
+{
+	int data;
+	// GPD_GPIO6=0, GPIO6 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT6,data) ) goto error;
+
+	// GPOE_GPIO6=1, GPIO6 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT6,data) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+
+static int
+gpio5_output_enable_direction(
+	struct rtl2832_state*	p_state)
+{
+	int data;
+	// GPD_GPIO5=0, GPIO5 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT5,data) ) goto error;
+
+	// GPOE_GPIO5=1, GPIO5 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT5,data) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+static int
+gpio2_output_enable_direction(
+	struct rtl2832_state*	p_state)
+{
+	int data;
+	// GPD_GPIO2=0, GPIO2 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT2,data) ) goto error;
+
+	// GPOE_GPIO2=1, GPIO2 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT2,data) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+static int
+gpio0_output_enable_direction(
+	struct rtl2832_state*	p_state)
+{
+	int data;
+	// GPD_GPIO0=0, GPIO0 output direction
+	data = 0;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT0,data) ) goto error;
+
+	// GPOE_GPIO0=1, GPIO0 output enable
+	data = 1;
+	if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT0,data) ) goto error;
+
+	return 0;
+error:
+	return 1;
+}
+
+static int
+check_dvbt_reset_parameters(
+
+	struct rtl2832_state*	p_state,
+	unsigned long			frequency,
+	enum fe_bandwidth	bandwidth,
+	int*					reset_needed)
+{
+
+	int							is_lock;
+	unsigned int					diff_ms;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	*reset_needed = 1;	 //3initialize "reset_needed"
+
+	if( (p_state->current_frequency == frequency) && (p_state->current_bandwidth == bandwidth) )
+	{
+		if( p_state->pNim->IsSignalLocked(p_state->pNim, &is_lock) ) goto error;
+		diff_ms = 0;
+
+		while( !(is_lock == LOCKED || diff_ms > 200) )
+		{
+			platform_wait(40);
+			diff_ms += 40;
+			if( p_state->pNim->IsSignalLocked(p_state->pNim, &is_lock) ) goto error;
+		}
+
+	       if (is_lock==YES)
+	       {
+		   *reset_needed = 0;		 //3 set "reset_needed" = 0
+		   deb_info("%s : The same frequency = %d setting\n", __FUNCTION__, (int)frequency);
+	       }
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+error:
+
+	*reset_needed = 1; 	//3 set "reset_needed" = 1
+	return 1;
+}
+
+
+#if UPDATE_FUNC_ENABLE_2832
+void
+rtl2832_update_functions(struct work_struct *work)
+{
+	struct rtl2832_state* p_state = container_of( work,  struct rtl2832_state,  update2832_procedure_work.work);
+	//unsigned  long ber_num, ber_dem;
+	//long snr_num = 0;
+	//long snr_dem = 0;
+	//long _snr= 0;
+
+	if(p_state->pNim == NULL)
+	{
+		//deb_info("%s error\n", __FUNCTION__);
+		goto mutex_error;
+	}
+
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+	if(!p_state->is_frequency_valid)
+	{
+		//deb_info("  %s no need \n", __FUNCTION__);
+		goto advance_exit;
+	}
+
+	// Update tuner mode
+	deb_info(" +%s run update\n", __FUNCTION__);
+	if( p_state->pNim->UpdateFunction(p_state->pNim)){
+		deb_info(" --->%s run update fail\n", __FUNCTION__);
+		goto advance_exit;
+	}
+
+	/* p_state->pNim->UpdateFunction(p_state->pNim);
+	p_state->pNim->GetBer( p_state->pNim , &ber_num , &ber_dem);
+	p_state->pNim->GetSnrDb(p_state->pNim, &snr_num, &snr_dem) ;
+
+	_snr = snr_num / snr_dem;
+	if( _snr < 0 ) _snr = 0;
+
+	deb_info("%s : ber = %lu, snr = %lu\n", __FUNCTION__,ber_num,_snr);
+	*/
+
+advance_exit:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	schedule_delayed_work(&p_state->update2832_procedure_work, UPDATE_PROCEDURE_PERIOD_2832);
+
+	deb_info(" -%s\n", __FUNCTION__);
+
+	return;
+
+mutex_error:
+	return;
+
+}
+#endif
+
+#if UPDATE_FUNC_ENABLE_2836
+void
+rtl2836_update_function(struct work_struct *work)
+{
+	struct rtl2832_state* p_state;
+	unsigned long Per1, Per2;
+	long Data1,Data2;
+	unsigned char data;
+	DTMB_DEMOD_MODULE * pDtmbDemod;
+
+	p_state = container_of(work , struct rtl2832_state , update2836_procedure_work.work);
+	if(p_state->pNim2836 == NULL)
+	{
+		deb_info("%s error\n", __FUNCTION__);
+		goto mutex_error;
+	}
+	pDtmbDemod = p_state->pNim2836->pDemod;
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s\n", __FUNCTION__);
+	if(!p_state->is_frequency_valid)
+	{
+		deb_info(" %s no need \n", __FUNCTION__);
+		goto advance_exit;
+	}
+
+	if(pDtmbDemod->UpdateFunction(pDtmbDemod))
+	{
+		deb_info("%s -- UpdateFunction failed\n", __FUNCTION__);
+	}
+
+	pDtmbDemod->GetPer(pDtmbDemod,&Per1,&Per2);
+	deb_info("%s -- ***GetPer= %d***\n", __FUNCTION__, (int)Per1);
+
+	pDtmbDemod->GetSnrDb(pDtmbDemod,&Data1,&Data2);
+	deb_info("%s -- ***SNR = %d***\n",__FUNCTION__, (int)(Data1>>2));
+
+	read_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR, PAGE_6, 0xc0, &data, LEN_1_BYTE);
+	deb_info("%s --***FSM = %d***\n", __FUNCTION__, (data&0x1f));
+
+advance_exit:
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	schedule_delayed_work(&p_state->update2836_procedure_work,  UPDATE_PROCEDURE_PERIOD_2836);
+
+	deb_info(" -%s\n", __FUNCTION__);
+	return;
+
+mutex_error:
+	return;
+
+}
+#endif
+
+static int
+rtl2832_init(
+	struct dvb_frontend*	fe)
+{
+	struct rtl2832_state*	p_state = fe->demodulator_priv;
+
+////////////////
+
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	p ->delivery_system = SYS_DVBT;
+
+//////////
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+	//usb_reset_device(p_state->d->udev);
+
+	if( usb_init_setting(p_state) ) goto error;
+
+	if( gpio3_out_setting(p_state) ) goto error;				//3Set GPIO3 OUT
+
+	if( demod_ctl1_setting(p_state , 1) ) goto error;		//3	DEMOD_CTL1, resume = 1
+
+	if (dvb_use_rtl2832u_card_type)
+	{
+		if( set_demod_power(p_state , 1) ) goto error;			//3	turn ON demod power
+	}
+
+	if( suspend_latch_setting(p_state , 1) ) goto error;		//3 suspend_latch_en = 0, resume = 1
+
+	if( demod_ctl_setting(p_state , 1,  1) ) goto error;		//3 DEMOD_CTL, resume =1; ADC on
+
+	if( set_tuner_power(p_state, 1, 1) ) goto error;		//3	turn ON tuner power
+
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_TUA9001)
+	{
+		if( gpio1_output_enable_direction(p_state) )	goto error;
+	}
+	else if( p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+		//3 MXL5007T : Set GPIO6 OUTPUT_EN & OUTPUT_DIR & OUTPUT_VAL for YUAN
+		int	data;
+		if( gpio6_output_enable_direction(p_state) )	goto error;
+
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+		data |= BIT6;
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,data) ) goto error;
+
+	}
+	else if( p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)
+	{
+		int data;
+		if( gpio5_output_enable_direction(p_state))		goto error;
+
+		if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+		data |= BIT5; // set GPIO5 high
+		if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data) ) goto error;
+		data &= ~(BIT5); // set GPIO5 low
+		if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data) ) goto error;
+	}
+
+	switch(p_state->demod_type)
+	{
+		case RTL2836:
+		{
+			if ( set_demod_2836_power(p_state,  1))  goto error;//32836 on
+
+			// RTL2832 ADC_I& ADC_Q OFF
+			if( demod_ctl_setting(p_state,  1,  0)) goto error;// ADC off
+
+		}
+		break;
+
+		case RTL2840:
+		{
+			if ( set_demod_2840_power(p_state,  1))  goto error;//2840 on
+
+			// RTL2832 ADC_I& ADC_Q OFF
+			if( demod_ctl_setting(p_state,  1,  0)) goto error;//ADC off
+		}
+		break;
+
+		case SI2168:
+		{
+			if ( set_demod_2168_power(p_state,  1))  goto error;//2168 on
+
+			// RTL2832 ADC_I& ADC_Q OFF
+			if( demod_ctl_setting(p_state,  1,  0)) goto error;// ADC off
+
+		}
+		break;
+	}
+
+	//3 Nim initial
+	switch(p_state->demod_type)
+	{
+		case RTL2832:
+		{
+			// Nim initialize for 2832
+			if ( p_state->pNim->Initialize(p_state->pNim) ) goto error;
+		}
+		break;
+
+		case RTL2836:
+		{
+			// Enable demod DVBT_IIC_REPEAT.
+		       if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) )   goto error;
+
+	             // Nim initialize for 2836
+			if ( p_state->pNim2836->Initialize(p_state->pNim2836)) goto error;
+
+			// Disable demod DVBT_IIC_REPEAT.
+		       if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0))  goto error;
+
+			if(dtmb_error_packet_discard)
+			{
+				unsigned char val=0;
+				if(read_demod_register(p_state->d,  RTL2832_DEMOD_ADDR, PAGE_0, 0x21, &val,  LEN_1_BYTE)) goto error;
+				val &= ~(BIT5);
+				if(write_demod_register(p_state->d,  RTL2832_DEMOD_ADDR, PAGE_0, 0x21, &val,  LEN_1_BYTE)) goto error;
+
+				if(read_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR, PAGE_4, 0x26, &val,  LEN_1_BYTE)) goto error;
+				val &= ~(BIT0);
+				if(write_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR, PAGE_4, 0x26, &val,  LEN_1_BYTE)) goto error;
+
+				deb_info(" dtmb discard error packets\n");
+			}
+			else
+			{
+				deb_info(" dtmb NOT discard error packets\n");
+			}
+		}
+		break;
+
+		case RTL2840:
+		{
+			// Enable demod DVBT_IIC_REPEAT.
+			if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) )   goto error;
+
+			// Nim initialize for 2840
+			if ( p_state->pNim2840->Initialize(p_state->pNim2840)) goto error;
+
+			// Disable demod DVBT_IIC_REPEAT.
+			if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0))  goto error;
+		}
+		break;
+
+		case SI2168: //Yann Init
+		{
+		    printk("Yann Init\n");
+		}
+		break;
+	}
+
+	//3  RTL2832U AGC Setting, Serial Mode Switch Setting, PIP Setting based on demod_type
+	if(demod_init_setting(p_state)) goto error;
+
+	p_state->is_initial = 1;
+	//if(p_state->rtl2832_audio_video_mode == RTK_AUDIO)
+	//{
+	//	  deb_info("%s: previous mode is audio? \n", __func__);
+	//      fm_stream_ctrl(0, p_state->d->adapter);
+	//}
+	p_state->rtl2832_audio_video_mode = RTK_VIDEO;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+#if UPDATE_FUNC_ENABLE_2840
+       if(p_state->demod_type == RTL2840)
+	   	schedule_delayed_work(&(p_state->update2840_procedure_work), 0);//3 Initialize update function
+#endif
+
+#if UPDATE_FUNC_ENABLE_2836
+       if(p_state->demod_type == RTL2836)
+	   	schedule_delayed_work(&(p_state->update2836_procedure_work),  0);
+#endif
+
+#if UPDATE_FUNC_ENABLE_2832
+       if(p_state->demod_type == RTL2832)
+	   	schedule_delayed_work(&(p_state->update2832_procedure_work), 0);//3 Initialize update function
+#endif
+
+	return 0;
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	deb_info(" -%s  error end\n", __FUNCTION__);
+
+	p_state->rtl2832_audio_video_mode = RTK_UNKNOWN;
+
+	return -1;
+}
+
+
+static void
+rtl2832_release(
+	struct dvb_frontend*	fe)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+	MT2266_EXTRA_MODULE*	p_mt2266_extra=NULL;
+	MT2063_EXTRA_MODULE*	p_mt2063_extra=NULL;
+
+	TUNER_MODULE*		pTuner=NULL;
+
+	deb_info("  +%s \n", __FUNCTION__);
+
+	if( p_state->pNim== NULL)
+	{
+		deb_info(" %s pNim = NULL \n", __FUNCTION__);
+		return;
+	}
+
+	if( (p_state->is_mt2266_nim_module_built) && (p_state->demod_type==RTL2832) )
+	{
+		pTuner = p_state->pNim->pTuner;
+		p_mt2266_extra = &(pTuner->Extra.Mt2266);
+		p_mt2266_extra->CloseHandle(pTuner);
+		p_state->is_mt2266_nim_module_built = 0;
+	}
+
+	if( p_state->is_mt2063_nim_module_built)
+	{
+
+		switch(p_state->demod_type)
+		{
+		case RTL2832:
+			pTuner=p_state->pNim->pTuner;
+		break;
+
+		case RTL2840:
+			pTuner=p_state->pNim2840->pTuner;
+		break;
+
+		}
+		p_mt2063_extra=&(pTuner->Extra.Mt2063);
+		p_mt2063_extra->CloseHandle(pTuner);
+		p_state->is_mt2063_nim_module_built = 0;
+
+	}
+
+	if(p_state->is_initial)
+	{
+#if UPDATE_FUNC_ENABLE_2840
+        if(p_state->demod_type == RTL2840)
+        {
+			cancel_delayed_work( &(p_state->update2840_procedure_work) );//cancel_rearming_delayed_work
+			flush_scheduled_work();
+        }
+#endif
+
+#if UPDATE_FUNC_ENABLE_2836
+		if(p_state->demod_type == RTL2836)
+		{
+            cancel_delayed_work( &(p_state->update2836_procedure_work));
+			flush_scheduled_work();
+		}
+#endif
+
+#if UPDATE_FUNC_ENABLE_2832
+        if(p_state->demod_type == RTL2832)
+        {
+			cancel_delayed_work( &(p_state->update2832_procedure_work) );
+			flush_scheduled_work();
+        }
+#endif
+		p_state->is_initial = 0;
+	}
+	p_state->is_frequency_valid = 0;
+	p_state->rtl2832_audio_video_mode = RTK_UNKNOWN;
+	//IrDA
+	//rtl2832u_remote_control_state = RC_NO_SETTING;
+
+	kfree(p_state);
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return;
+}
+
+
+
+
+static int
+rtl2832_sleep_mode(struct rtl2832_state* p_state)
+{
+	int data=0;
+
+
+	if(p_state->tuner_type == RTL2832_TUNER_TYPE_MAX3543)
+	{
+		//+set MAX3543_CHECK_VALUE to Default value
+		unsigned char	i2c_repeater;
+		unsigned char	data = MAX3543_CHECK_VALUE;
+
+		read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+		i2c_repeater |= BIT3;
+		write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+
+		write_rtl2832_tuner_register(p_state->d, MAX3543_TUNER_ADDR, MAX3543_CHECK_OFFSET, &data, LEN_1_BYTE);
+
+		read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+		i2c_repeater &= (~BIT3);
+		write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 1, 1, &i2c_repeater, 1 );
+		//-set MAX3543_CHECK_VALUE to Default value
+	}
+
+
+	if( p_state->is_initial )
+	{
+
+#if UPDATE_FUNC_ENABLE_2840
+		if(p_state->demod_type == RTL2840)
+		{
+			cancel_delayed_work( &(p_state->update2840_procedure_work));
+			flush_scheduled_work();
+		}
+#endif
+
+#if UPDATE_FUNC_ENABLE_2836
+		if(p_state->demod_type == RTL2836)
+		{
+			cancel_delayed_work( &(p_state->update2836_procedure_work));
+			flush_scheduled_work();
+		}
+#endif
+
+#if UPDATE_FUNC_ENABLE_2832
+        if(p_state->demod_type == RTL2832)
+        {
+	        cancel_delayed_work( &(p_state->update2832_procedure_work));
+		    flush_scheduled_work();
+        }
+#endif
+		p_state->is_initial = 0;
+	}
+	p_state->is_frequency_valid = 0;
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+#if 0
+	//2 For debug
+	/* for( page_no = 0; page_no < 3; page_no++ )//2832
+	{
+		pDemod->SetRegPage(pDemod, page_no);
+		for( addr_no = 0; addr_no < 256; addr_no++ )
+		{
+			pDemod->GetRegBytes(pDemod, addr_no, &reg_value, 1);
+			printk("0x%x, 0x%x, 0x%x\n", page_no, addr_no, reg_value);
+		}
+	}*/
+      for( page_no = 0; page_no < 10; page_no++ )//2836
+	{
+		pDemod2836->SetRegPage(pDemod2836, page_no);
+		for( addr_no = 0; addr_no < 256; addr_no++ )
+		{
+			pDemod2836->GetRegBytes(pDemod2836, addr_no, &reg_value, 1);
+			printk("0x%x, 0x%x, 0x%x\n", page_no, addr_no, reg_value);
+		}
+	}
+#endif
+
+	 if( p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+		//3 MXL5007T : Set GPIO6 OUTPUT_VAL  OFF for YUAN
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+		data &= (~BIT6);
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,data) ) goto error;
+
+	}
+
+
+	if( demod_ctl1_setting(p_state , 0) ) goto error;		//3	DEMOD_CTL1, resume = 0
+
+	if( set_tuner_power(p_state, 1, 0) ) goto error;		//3	turn OFF tuner power
+
+	if( demod_ctl_setting(p_state , 0,  0) ) goto error;		//3 	DEMOD_CTL, resume =0
+
+	if (p_state->demod_type != RTL2832)
+	{
+	    if (p_state->demod_type == RTL2836)
+	    {
+            set_demod_2836_power(p_state,  0);   //3 RTL2836 power OFF
+            deb_info(" ->%s::RTL2836 power OFF\n", __FUNCTION__);
+	    }
+	    if (p_state->demod_type == RTL2840)
+	    {
+            set_demod_2840_power(p_state,  0);   //3 RTL2840 power OFF
+            deb_info(" ->%s ::RTL2840 power OFF\n", __FUNCTION__);
+	    }
+	    if (p_state->demod_type == SI2168)
+	    {
+            set_demod_2168_power(p_state,  0);   //3 SI2168 power OFF
+            deb_info(" ->%s ::SI2168 power OFF\n", __FUNCTION__);
+	    }
+	}
+	//2 for H/W reason
+	//if( suspend_latch_setting(p_state , 0) ) goto error;		//3 suspend_latch_en = 1, resume = 0
+	if (dvb_use_rtl2832u_card_type)
+	{
+		deb_info(" -%s ::mini card mode gpio0 set high ,demod power off\n", __FUNCTION__);
+		if( set_demod_power(p_state , 0) ) goto error;		//3	turn OFF demod power
+	}
+
+	//if(p_state->rtl2832_audio_video_mode == RTK_AUDIO)
+	//{
+	//	fm_stream_ctrl(0,  p_state->d->adapter);
+	//}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	deb_info(" -%s fail\n", __FUNCTION__);
+	return 1;
+
+
+}
+static int
+rtl2832_sleep(
+	struct dvb_frontend*	fe)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+
+	return rtl2832_sleep_mode(p_state);
+}
+
+
+
+static int
+rtl2840_set_parameters(
+	struct dvb_frontend*	fe
+	)
+{
+
+	struct dtv_frontend_properties*	param = &fe->dtv_property_cache;
+	struct rtl2832_state				*p_state = fe->demodulator_priv;
+	//ruct dvb_qam_parameters 		*p_qam_param= &param->modulation;
+	unsigned long						frequency = param->frequency;
+
+	DVBT_DEMOD_MODULE				*pDemod2832;
+	int								QamMode;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	if(p_state->demod_type == RTL2840 && p_state->pNim2840 == NULL )
+	{
+		deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+
+		return -1;
+	 }
+
+
+	deb_info(" +%s Freq=%lu , Symbol rate=%u, QAM=%u\n", __FUNCTION__, frequency, param->symbol_rate, param->modulation);
+
+	pDemod2832 = p_state->pNim->pDemod;
+
+	switch(param->modulation)
+	{
+		case QPSK :		QamMode = QAM_QAM_4;		break;
+		case QAM_16 :	QamMode = QAM_QAM_16;		break;
+		case QAM_32 :	QamMode = QAM_QAM_32;		break;
+		case QAM_64 :	QamMode = QAM_QAM_64;		break;
+		case QAM_128 :	QamMode = QAM_QAM_128;		break;
+		case QAM_256 :	QamMode = QAM_QAM_256;		break;
+
+		case QAM_AUTO :
+		default:
+		deb_info(" XXX %s  : unknown QAM \n", __FUNCTION__);
+		goto  mutex_error;
+		break;
+
+	}
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod2832->SetRegBitsWithPage(pDemod2832,  DVBT_IIC_REPEAT, 0x1) )   goto error;
+
+	p_state->pNim2840->SetParameters(p_state->pNim2840, frequency, QamMode, param->symbol_rate, QAM_ALPHA_0P15);
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod2832->SetRegBitsWithPage(pDemod2832, DVBT_IIC_REPEAT, 0x0))  goto error;
+
+	if(pDemod2832->SoftwareReset(pDemod2832))//2832 swreset
+		goto error;
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+
+	deb_info(" -XXX %s \n", __FUNCTION__);
+
+	return 1;
+
+}
+
+
+
+static int rtl2832_set_parameters(struct dvb_frontend *fe)
+{
+
+	struct dtv_frontend_properties *param = &fe->dtv_property_cache;
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+//	struct dvb_ofdm_parameters*	p_ofdm_param= &param->u.ofdm;
+//	struct dvb_ofdm_parameters*	p_of_dm_param;
+	enum fe_bandwidth	nbandwidth=BANDWIDTH_AUTO;
+
+	unsigned long					frequency = param->frequency;
+	int							bandwidth_mode;
+	int							is_signal_present;
+	int							reset_needed;
+	unsigned char                             data;
+	int							int_data;
+
+
+	//TUNER_MODULE *                      pTuner;
+       DTMB_DEMOD_MODULE *           pDemod2836;
+	DVBT_DEMOD_MODULE *           pDemod2832;
+deb_info(" rtl2832_set_parameters ", __FUNCTION__);
+
+
+    //if( p_state->pNim == NULL)
+    //{
+    //  deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+    //}
+
+	if(p_state->demod_type == RTL2836 && p_state->pNim2836 == NULL )
+	{
+		deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+		return -1;
+	 }
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s frequency = %lu , bandwidth = %u\n", __FUNCTION__, frequency ,param->bandwidth_hz);
+
+//	frequency = 533000000;
+//	p_ofdm_param->bandwidth = BANDWIDTH_6_MHZ;
+	if(p_state->demod_type == RTL2832)
+	{
+	deb_info(" rtl2832_set_parameters p_state->demod_type == RTL2832 ", __FUNCTION__);
+//	frequency = 533000000;
+
+		switch(param->bandwidth_hz)
+			{
+			defualt:
+			case 6000000:
+				nbandwidth = BANDWIDTH_6_MHZ;
+				break;
+			case 7000000:
+				nbandwidth = BANDWIDTH_7_MHZ;
+				break;
+			case 8000000:
+				nbandwidth = BANDWIDTH_8_MHZ;
+				break;
+
+
+			}
+		if ( check_dvbt_reset_parameters( p_state , frequency , nbandwidth, &reset_needed) ) goto error;
+
+		if( reset_needed == 0 )
+		{
+			mutex_unlock(&p_state->i2c_repeater_mutex);
+			return 0;
+		}
+/*////
+		case BANDWIDTH_10_MHZ:
+			c->bandwidth_hz = 10000000;
+			break;
+		case BANDWIDTH_8_MHZ:
+			c->bandwidth_hz = 8000000;
+			break;
+		case BANDWIDTH_7_MHZ:
+			c->bandwidth_hz = 7000000;
+			break;
+		case BANDWIDTH_6_MHZ:
+			c->bandwidth_hz = 6000000;
+			break;
+		case BANDWIDTH_5_MHZ:
+			c->bandwidth_hz = 5000000;
+
+*////
+		switch (param->bandwidth_hz)
+	      {
+		//case BANDWIDTH_6_MHZ:
+		case 6000000:
+		bandwidth_mode = DVBT_BANDWIDTH_6MHZ;
+		break;
+
+//		case BANDWIDTH_7_MHZ:
+		case 7000000:
+		bandwidth_mode = DVBT_BANDWIDTH_7MHZ;
+		break;
+
+//		case BANDWIDTH_8_MHZ:
+		case 8000000:
+		default:
+		bandwidth_mode = DVBT_BANDWIDTH_8MHZ;
+		break;
+	       }
+
+	       	//add by Dean
+	        if (p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012 )
+	        {
+
+	   		if( gpio6_output_enable_direction(p_state) )	goto error;
+
+
+			if (frequency > 300000000)
+			{
+
+				read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &int_data);
+				int_data |= BIT6; // set GPIO6 high
+				write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, int_data);
+				deb_info("  %s : Tuner :FC0012 V-band (GPIO6 high)\n", __FUNCTION__);
+			}
+			else
+			{
+
+				read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &int_data);
+				int_data &= (~BIT6); // set GPIO6 low
+				write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, int_data);
+				deb_info("  %s : Tuner :FC0012 U-band (GPIO6 low)\n", __FUNCTION__);
+
+			}
+		}
+
+
+
+
+
+		if ( p_state->pNim->SetParameters( p_state->pNim,  frequency , bandwidth_mode ) ) goto error;
+
+		if ( p_state->pNim->IsSignalPresent( p_state->pNim, &is_signal_present) ) goto error;
+		deb_info("  %s : ****** Signal Present = %d ******\n", __FUNCTION__, is_signal_present);
+
+
+
+
+		p_state->is_frequency_valid = 1;
+
+
+	}
+	else if(p_state->demod_type == RTL2836)
+	{
+		pDemod2836 =  p_state->pNim2836->pDemod;
+		pDemod2832 = p_state->pNim->pDemod;
+
+		//if ( check_dtmb_reset_parameters( p_state , frequency ,  &reset_needed) ) goto error;
+		//if( reset_needed == 0 )
+		//{
+		//	mutex_unlock(&p_state->i2c_repeater_mutex);
+		//	return 0;
+		//}
+
+              deb_info(("%s:  RTL2836 Hold Stage=9\n"),__FUNCTION__);
+		if(read_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &data, LEN_1_BYTE))  goto error;
+		data &=(~BIT_0_MASK);  //reset Reg_present
+		data &=(~BIT_1_MASK);  //reset Reg_lock
+		if(write_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &data, LEN_1_BYTE))  goto error;
+
+		//3 + RTL2836 Hold Stage=9
+		data = 0x29;
+		if(write_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR,  PAGE_3,  0x4d,  &data, LEN_1_BYTE))  goto error;
+
+		data = 0xA5;
+		if(write_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR,  PAGE_3,  0x4e,  &data, LEN_1_BYTE))  goto error;
+
+		data = 0x94;
+		if(write_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR,  PAGE_3,  0x4f,  &data, LEN_1_BYTE))  goto error;
+		//3 -RTL2836 Hold Stage=9
+
+
+		// Enable demod DVBT_IIC_REPEAT.
+	       if(pDemod2832->SetRegBitsWithPage(pDemod2832,  DVBT_IIC_REPEAT, 0x1) )   goto error;
+
+		if ( p_state->pNim2836->SetParameters( p_state->pNim2836,  frequency)) 	goto error; //no bandwidth setting
+
+		// Disable demod DVBT_IIC_REPEAT.
+	       if(pDemod2832->SetRegBitsWithPage(pDemod2832, DVBT_IIC_REPEAT, 0x0))  goto error;
+
+		if(pDemod2832->SoftwareReset(pDemod2832))//2832 swreset
+			goto error;
+
+		p_state->is_frequency_valid = 1;
+		if( rtl2836_scan_procedure(p_state))  goto error;
+	}
+	else if(p_state->demod_type == SI2168) //Yann Set Freq and Bandwidth
+	{
+        deb_info(" rtl2832_set_parameters p_state->demod_type == SI2168, %d, %d, %d \n", frequency,param->bandwidth_hz, param->stream_id);
+        if( gpio2_output_enable_direction(p_state) )	goto error;
+		read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &int_data);
+        int_data &= (~BIT2); // set GPIO2 low
+        write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, int_data);
+		deb_info("  %s : Tuner :SI2148 AGC (GPIO2 low)\n", __FUNCTION__);
+		if(Si2168_Data_Update(p_state,1,frequency,param->bandwidth_hz,0,param->stream_id)==0)
+		{
+            if(Si2168_Data_Update(p_state,0,frequency,param->bandwidth_hz,0,-1)!=0)
+                p_state->is_frequency_valid = 1;
+		}
+		else
+            p_state->is_frequency_valid = 1;
+	}
+
+
+//#if(UPDATE_FUNC_ENABLE_2832 == 0)
+	//3 FC0012/E4000 update begin --
+	if(p_state->demod_type == RTL2832 && (p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012
+										|| p_state->tuner_type == RTL2832_TUNER_TYPE_E4000
+										|| p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013))
+	{
+              // Enable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error;
+
+		if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)//fc0012
+		{
+			if(rtl2832_fc0012_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)//e4000
+		{
+			if(rtl2832_e4000_UpdateTunerMode(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013) //fc0013
+		{
+			if(rtl2832_fc0013_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error;
+
+
+		deb_info("%s : fc0012/e4000 update first\n", __FUNCTION__);
+
+		msleep(50);
+
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error;
+
+		// Update tuner LNA gain with RSSI.
+		if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)//fc0012
+		{
+			if(rtl2832_fc0012_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if (p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)//e4000
+		{
+			if(rtl2832_e4000_UpdateTunerMode(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013) //fc0013
+		{
+			if(rtl2832_fc0013_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error;
+
+		deb_info("%s : fc0012/e4000 update 2nd\n", __FUNCTION__);
+	}
+	//3 FC0012/E4000 update end --
+
+//#endif
+
+	//p_state->current_frequency = frequency;
+	//p_state->current_bandwidth = p_ofdm_param->bandwidth;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	//p_state->current_frequency = 0;
+	//p_state->current_bandwidth = -1;
+	p_state->is_frequency_valid = 0;
+	deb_info(" -%s  error end\n", __FUNCTION__);
+
+	return -1;
+
+}
+
+static int
+rtl2832_set_parameters_fm(
+	struct dvb_frontend*	fe)
+{
+
+	struct dtv_frontend_properties*	param = &fe->dtv_property_cache;
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+//	struct dvb_ofdm_parameters*	p_ofdm_param= &param->u.ofdm;
+//	struct dvb_ofdm_parameters*	p_of_dm_param;
+	enum fe_bandwidth	nbandwidth=BANDWIDTH_AUTO;
+
+	unsigned long					frequency = param->frequency;
+	int							bandwidth_mode;
+	int	int_data;
+
+      //DTMB_DEMOD_MODULE *           pDemod2836;
+	//DVBT_DEMOD_MODULE *           pDemod2832;
+
+       if( p_state->pNim == NULL)
+       {
+		deb_info(" %s pNim = NULL \n", __FUNCTION__);
+		return -1;
+       }
+
+	// if(p_state->demod_type == RTL2836 && p_state->pNim2836 == NULL )
+	//{
+	//	deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+	//	return -1;
+	// }/
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	deb_info(" +%s frequency = %lu , bandwidth = %u\n", __FUNCTION__, frequency ,param->bandwidth_hz);
+
+	if(p_state->demod_type == RTL2832)
+	{
+		bandwidth_mode = DVBT_BANDWIDTH_6MHZ;
+
+		if(p_state->tuner_type ==  RTL2832_TUNER_TYPE_FC0012)
+		{
+	   		if( gpio6_output_enable_direction(p_state) )	goto error;
+
+			if (frequency > 300000000)
+			{
+
+				read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &int_data);
+				int_data |= BIT6; // set GPIO6 high
+				write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, int_data);
+				deb_info("  %s : Tuner :FC0012 V-band (GPIO6 high)\n", __FUNCTION__);
+			}
+			else
+			{
+
+				read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &int_data);
+				int_data &= (~BIT6); // set GPIO6 low
+				write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, int_data);
+				deb_info("  %s : Tuner :FC0012 U-band (GPIO6 low)\n", __FUNCTION__);
+
+			}
+
+			if(rtl2832_fc0012_SetParameters_fm( p_state->pNim,  frequency , bandwidth_mode ))
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+		{
+			if(rtl2832_mxl5007t_SetParameters_fm(p_state->pNim, frequency , bandwidth_mode ))
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+		{
+			if(rtl2832_e4000_SetParameters_fm( p_state->pNim,  frequency , bandwidth_mode ))
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013)
+		{
+			if(rtl2832_fc0013_SetParameters_fm( p_state->pNim,  frequency , bandwidth_mode ))
+				goto error;
+		}
+
+		p_state->is_frequency_valid = 1;
+
+
+	}
+	//else if(p_state->demod_type == RTL2836)
+	//{
+	//}
+
+
+//#if(UPDATE_FUNC_ENABLE_2832 == 0)
+	//3 FC0012/E4000 update begin --
+	if(p_state->demod_type == RTL2832 && (p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012 || p_state->tuner_type == RTL2832_TUNER_TYPE_E4000))
+	{
+              // Enable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error;
+
+		// Update tuner LNA gain with RSSI.
+		// if( p_state->pNim->UpdateFunction(p_state->pNim))
+		//	goto error;
+		if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)//fc0012
+		{
+			if(rtl2832_fc0012_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if (p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)//e4000
+		{
+			if(rtl2832_e4000_UpdateTunerMode(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013) //fc0013
+		{
+			if(rtl2832_fc0013_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error;
+
+
+		deb_info("%s : fc0012/e4000 update first\n", __FUNCTION__);
+
+		msleep(50);
+
+		// if( p_state->pNim->UpdateFunction(p_state->pNim)) goto error;
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+			goto error;
+
+		// Update tuner LNA gain with RSSI.
+		if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)//fc0012
+		{
+			if(rtl2832_fc0012_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if (p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)//e4000
+		{
+			if(rtl2832_e4000_UpdateTunerMode(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013) //fc0013
+		{
+			if(rtl2832_fc0013_UpdateTunerLnaGainWithRssi(p_state->pNim) != FUNCTION_SUCCESS)
+				goto error;
+		}
+
+		// Disable demod DVBT_IIC_REPEAT.
+		if(p_state->pNim->pDemod->SetRegBitsWithPage(p_state->pNim->pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+			goto error;
+
+		deb_info("%s : fc0012/e4000 update 2nd\n", __FUNCTION__);
+	}
+	//3 FC0012/E4000 update end --
+
+//#endif
+
+	//p_state->current_frequency = frequency;
+	//p_state->current_bandwidth = p_ofdm_param->bandwidth;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	//p_state->current_frequency = 0;
+	//p_state->current_bandwidth = -1;
+	p_state->is_frequency_valid = 0;
+	deb_info(" -%s  error end\n", __FUNCTION__);
+
+	return -1;
+
+}
+
+
+
+static int
+rtl2832_get_parameters(
+	struct dvb_frontend*	fe)
+{
+
+	struct dtv_frontend_properties*	param= &fe->dtv_property_cache;
+	//struct rtl2832_state* p_state = fe->demodulator_priv;
+	return 0;
+}
+
+
+static int
+rtl2832_read_status(
+	struct dvb_frontend*	fe,
+	fe_status_t*	status)
+{
+	struct rtl2832_state*	p_state = fe->demodulator_priv;
+	int	is_lock;
+	unsigned  long ber_num, ber_dem;
+	long			snr_num, snr_dem, snr;
+
+
+	//if( p_state->pNim== NULL)
+	//{
+	//	deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+	//}
+
+	*status = 0;	//3initialize "status"
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	if(p_state->demod_type == RTL2832)
+	{
+
+		if( p_state->pNim->GetBer( p_state->pNim , &ber_num , &ber_dem) ) goto error;
+
+		if (p_state->pNim->GetSnrDb(p_state->pNim, &snr_num, &snr_dem) )  goto error;
+
+		if( p_state->pNim->IsSignalLocked(p_state->pNim, &is_lock) ) goto error;
+
+		if( is_lock==YES ) *status|= (FE_HAS_CARRIER| FE_HAS_VITERBI| FE_HAS_LOCK| FE_HAS_SYNC| FE_HAS_SIGNAL);
+
+		 snr = snr_num/snr_dem;
+
+		deb_info("%s :******RTL2832 Signal Lock=%d******\n", __FUNCTION__, is_lock);
+		deb_info("%s : ber_num = %d\n", __FUNCTION__, (unsigned int)ber_num);
+		deb_info("%s : snr = %d \n", __FUNCTION__, (int)snr);
+	}
+	else if(p_state->demod_type == RTL2836)//3Need Change ?
+	{
+		unsigned char	val;
+
+		if( p_state->pNim2836 == NULL)
+		{
+			deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+
+		if(read_rtl2836_demod_register(p_state->d, RTL2836_DEMOD_ADDR, PAGE_3, 0xf8, &val, LEN_1_BYTE))
+			goto error;
+
+		if(val & BIT_1_MASK)	is_lock = YES;
+		else					is_lock = NO;
+
+              //if(p_state->pNim2836->pDemod->IsSignalLocked(p_state->pNim2836->pDemod, &is_lock))
+		//	  	goto error;
+
+		if( is_lock==YES ) *status|= (FE_HAS_CARRIER| FE_HAS_VITERBI| FE_HAS_LOCK| FE_HAS_SYNC| FE_HAS_SIGNAL);
+
+		deb_info("%s :******RTL2836 Signal Lock=%d******\n", __FUNCTION__, is_lock);
+	}
+	else if(p_state->demod_type == RTL2840)
+	{
+
+		if( p_state->pNim2840 == NULL)
+        {
+			deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+
+		if(p_state->pNim2840->IsSignalLocked(p_state->pNim2840, &is_lock) != FUNCTION_SUCCESS) goto error;
+
+		if( is_lock==YES ) *status|= (FE_HAS_CARRIER| FE_HAS_VITERBI| FE_HAS_LOCK| FE_HAS_SYNC| FE_HAS_SIGNAL);
+
+		deb_info("%s :******RTL2840 Signal Lock=%d******\n", __FUNCTION__, is_lock);
+
+	}
+	else if(p_state->demod_type == SI2168)//Yann Lock
+	{
+	    if(Si2168_Check_Lock()==1)
+            is_lock=YES;
+        else
+            is_lock=NO;
+        if(is_lock==YES)
+            *status|= (FE_HAS_CARRIER| FE_HAS_VITERBI| FE_HAS_LOCK| FE_HAS_SYNC| FE_HAS_SIGNAL);
+
+        snr=Si2168_Check_CNR();
+
+		deb_info("%s :******SI2168 Signal Lock=%d******\n", __FUNCTION__, is_lock);
+		deb_info("%s :****SI2168 Signal Strength=%d****\n", __FUNCTION__, snr);
+
+	}
+
+
+#if(UPDATE_FUNC_ENABLE_2832 == 0)
+
+	if(p_state->demod_type == RTL2832)
+	{
+		if( p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012 ||
+			p_state->tuner_type == RTL2832_TUNER_TYPE_E4000 ||
+			p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013 )
+		{
+			// Update tuner LNA gain with RSSI.
+			if( p_state->pNim->UpdateFunction(p_state->pNim))
+			goto error;
+ 		}//3
+	}
+#endif
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	return -1;
+}
+
+
+static int
+rtl2832_read_ber(
+	struct dvb_frontend*	fe,
+	u32*	ber)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+	unsigned  long ber_num, ber_dem;
+
+	//if( p_state->pNim== NULL)
+	//{
+	//	deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+	//}
+
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	if(p_state->demod_type == RTL2832)
+	{
+		if( p_state->pNim->GetBer( p_state->pNim , &ber_num , &ber_dem) )
+		{
+			*ber = 19616;
+			goto error;
+		}
+		*ber =  ber_num;
+		deb_info("  %s : ber = 0x%x \n", __FUNCTION__, *ber);
+	}
+	else if(p_state->demod_type == RTL2836)//read PER
+	{
+	       unsigned long per1, per2;
+		if( p_state->pNim2836 == NULL)
+		{
+			deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+
+		if( p_state->pNim2836->pDemod->GetPer(p_state->pNim2836->pDemod, &per1, &per2))
+		{
+			*ber = 19616;
+			goto error;
+		}
+		*ber  = per1;
+		deb_info("  %s : RTL2836 per = 0x%x \n", __FUNCTION__, *ber);
+	}
+	else if (p_state->demod_type == RTL2840)
+	{
+	       unsigned long per1, per2, ber1, ber2;
+
+		if( p_state->pNim2840 == NULL)
+		{
+			deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+		if( p_state->pNim2840->GetErrorRate(p_state->pNim2840, 5, 1000, &ber1, &ber2, &per1, &per2))
+		{
+			*ber = 19616;
+			goto error;
+		}
+
+		*ber  = ber1;
+		deb_info("  %s : RTL2840 ber = 0x%x \n", __FUNCTION__, *ber);
+	}
+	else if (p_state->demod_type == SI2168)//Yann Ber
+	{
+	    unsigned long ber1=0;
+
+		*ber = 19616;
+		*ber  = ber1;
+		deb_info("  %s : SI2168 ber = 0x%x \n", __FUNCTION__, *ber);
+	}
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	return -1;
+}
+static int fc0012_get_signal_strength(struct rtl2832_state	*p_state,unsigned long *strength)
+{
+	int intTemp=0;
+	int Power=0;
+	int intTotalAGCGain=0;
+	int intLNA=0;
+	unsigned char ReadingByte=0;
+	int LnaGain_reg=0;
+	int NumberOfLnaGainTable=0;
+	int i=0;
+	int Index=0;
+	TUNER_MODULE *pTuner=NULL;
+	DVBT_DEMOD_MODULE *pDemod = NULL;
+
+
+	if(p_state->pNim== NULL)
+	{
+		deb_info(" %s pNim = NULL \n", __FUNCTION__);
+		return -1;
+	}
+	pDemod = p_state->pNim->pDemod;
+	pTuner = p_state->pNim->pTuner;
+
+	// Enable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x1) != FUNCTION_SUCCESS)
+		goto error;
+
+	if(FC0012_Write(pTuner, 0x12, 0x00) != FUNCTION_SUCCESS)
+		goto error;
+
+	if(FC0012_Read(pTuner, 0x12, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error;
+	intTemp=(int)ReadingByte;
+
+	if(FC0012_Read(pTuner, 0x13, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error;
+	LnaGain_reg=(int)ReadingByte&0x7f;
+
+	// Disable demod DVBT_IIC_REPEAT.
+	if(pDemod->SetRegBitsWithPage(pDemod, DVBT_IIC_REPEAT, 0x0) != FUNCTION_SUCCESS)
+		goto error;
+
+	NumberOfLnaGainTable=sizeof(FC0012_LNA_GAIN_TABLE)/sizeof(FC0012_LNA_REG_MAP);
+	Index=-1;
+	for (i=0;i<NumberOfLnaGainTable;i++)
+	{
+		if (LnaGain_reg == FC0012_LNA_GAIN_TABLE[i].Lna_regValue)
+		{
+			Index=i;
+			break;
+		}
+	}
+
+	if (Index <0)
+	{
+		goto error;
+	}
+
+	intLNA=FC0012_LNA_GAIN_TABLE[Index].LnaGain;
+
+	intTotalAGCGain = ((abs((intTemp >> 5) - 7) -2) * 2 + (intTemp & 0x1F) * 2);
+
+	 Power= INPUT_ADC_LEVEL - intTotalAGCGain - (intLNA/10);
+
+	deb_info(" %s power=%d form fc0012(%x,%x,%x)\n", __FUNCTION__,Power,intTemp,LnaGain_reg,intLNA);
+
+	//Signal Strength : map power to 0~100
+
+
+	if(Power >=-45)
+	{
+		*strength=100;
+
+	}
+	else if(Power <-95)
+			*strength=0;
+	else
+			*strength = ((Power+45)*100)/50+100;
+	return 0;
+error:
+	return -1;
+}
+
+
+int
+rtl2832_read_signal_strength(
+	struct dvb_frontend*	fe,
+	u16*	strength)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+	unsigned long		_strength;
+
+	//if( p_state->pNim== NULL)
+	//{
+	//	deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+	//}
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+
+    if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)
+    {
+        if (fc0012_get_signal_strength(p_state,&_strength))
+        {
+			*strength = 0;
+			goto error;
+        }
+
+
+        *strength = (_strength<<8) | _strength;
+        deb_info("  %s : use FC0012 strength = 0x%x(%d) \n", __FUNCTION__, *strength,*strength);
+    }
+    else if(p_state->demod_type == RTL2832)
+    {
+
+		if( p_state->pNim->GetSignalStrength( p_state->pNim ,  &_strength) )
+		{
+			*strength = 0;
+			goto error;
+		}
+
+		*strength = (_strength<<8) | _strength;
+
+		deb_info("  %s : RTL2832 strength = 0x%x \n", __FUNCTION__, *strength);
+    }
+    else if(p_state->demod_type == RTL2836)
+    {
+		if(p_state->pNim2836 == NULL)
+              {
+			deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+			goto error;
+               }
+
+              if(p_state->pNim2836->pDemod->GetSignalStrength( p_state->pNim2836->pDemod ,  &_strength))// if(p_state->pNim2836->GetSignalStrength( p_state->pNim2836 ,  &_strength) )
+		{
+			*strength = 0;
+			goto error;
+		}
+
+		*strength = (_strength<<8) | _strength;
+
+		deb_info("  %s : RTL2836 strength = 0x%x \n", __FUNCTION__, *strength);
+    }
+	else if(p_state->demod_type == RTL2840)
+	{
+		if(p_state->pNim2840 == NULL)
+              {
+			deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+			goto error;
+               }
+
+              if(p_state->pNim2840->pDemod->GetSignalStrength( p_state->pNim2840->pDemod ,  &_strength))// if(p_state->pNim2836->GetSignalStrength( p_state->pNim2836 ,  &_strength) )
+		{
+			*strength = 0;
+			goto error;
+		}
+
+		*strength = (_strength<<8) | _strength;
+
+		deb_info("  %s : RTL2840 strength = 0x%x \n", __FUNCTION__, *strength);
+    }
+    else if(p_state->demod_type == SI2168)//Yann Strength
+    {
+        strength=Si2168_Check_CNR();
+
+        deb_info("  %s : SI2168 strength = 0x%x \n", __FUNCTION__, *strength);
+     }
+
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	return -1;
+}
+
+
+int
+rtl2832_read_signal_quality(
+	struct dvb_frontend*	fe,
+	u32*	quality)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+	unsigned long		_quality;
+
+	//if( p_state->pNim== NULL)
+	//{
+	//	deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+	//}
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+	if(p_state->demod_type == RTL2832)
+	{
+		if ( p_state->pNim->GetSignalQuality( p_state->pNim ,  &_quality) )
+		{
+			*quality  = 0;
+			goto error;
+		}
+	}
+	else if(p_state->demod_type == RTL2836)
+	{
+		if( p_state->pNim2836 ==  NULL)
+	       {
+	       	deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+		       goto error;
+	       }
+
+		if ( p_state->pNim2836->pDemod->GetSignalQuality( p_state->pNim2836->pDemod ,  &_quality) )//if ( p_state->pNim->GetSignalQuality( p_state->pNim ,  &_quality) )
+		{
+			*quality  = 0;
+			goto error;
+		}
+	}
+	else if(p_state->demod_type == RTL2840)
+	{
+		if( p_state->pNim2840 ==  NULL)
+	       {
+	       	deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+		       goto error;
+	       }
+
+		if ( p_state->pNim2840->pDemod->GetSignalQuality( p_state->pNim2840->pDemod ,  &_quality) )//if ( p_state->pNim->GetSignalQuality( p_state->pNim ,  &_quality) )
+		{
+			*quality  = 0;
+			goto error;
+		}
+	}
+	else if(p_state->demod_type == SI2168)// Yann Quality
+	{
+		_quality=Si2168_Check_CNR();
+	}
+
+	*quality = _quality;
+
+	deb_info("  %s : quality = 0x%x \n", __FUNCTION__, *quality);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	return -1;
+}
+
+
+
+static int
+rtl2832_read_snr(
+	struct dvb_frontend*	fe,
+	u16*	snr)
+{
+	struct rtl2832_state* p_state = fe->demodulator_priv;
+	long snr_num = 0;
+	long snr_dem = 0;
+	long _snr= 0;
+
+	//if( p_state->pNim== NULL)
+	//{
+	//	deb_info(" %s pNim = NULL \n", __FUNCTION__);
+	//	return -1;
+	//}
+
+	if( mutex_lock_interruptible(&p_state->i2c_repeater_mutex) )	goto mutex_error;
+
+    if(p_state->demod_type == RTL2832)
+    {
+		if (p_state->pNim->GetSnrDb(p_state->pNim, &snr_num, &snr_dem) )
+		{
+			*snr = 0;
+			goto error;
+		}
+
+		_snr = snr_num / snr_dem;
+
+		if( _snr < 0 ) _snr = 0;
+
+		*snr = _snr;
+    }
+    else if(p_state->demod_type == RTL2836)
+    {
+        	if( p_state->pNim2836 == NULL)
+		{
+			deb_info(" %s pNim2836 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+
+		if(p_state->pNim2836->pDemod->GetSnrDb(p_state->pNim2836->pDemod, &snr_num, &snr_dem))
+		{
+			*snr = 0;
+			goto error;
+		}
+		*snr = snr_num>>2;
+    }
+	else if(p_state->demod_type == RTL2840)
+	{
+        	if( p_state->pNim2840 == NULL)
+		{
+			deb_info(" %s pNim2840 = NULL \n", __FUNCTION__);
+			goto error;
+		}
+
+		if(p_state->pNim2840->pDemod->GetSnrDb(p_state->pNim2840->pDemod, &snr_num, &snr_dem))
+		{
+			*snr = 0;
+			goto error;
+		}
+		*snr = snr_num/snr_dem;
+	}
+	else if(p_state->demod_type == SI2168)//Yann SNR
+	{
+        *snr = 0;
+		*snr = 100;
+	}
+
+
+	deb_info("  %s : snr = %d \n", __FUNCTION__, *snr);
+
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+	return 0;
+
+error:
+	mutex_unlock(&p_state->i2c_repeater_mutex);
+
+mutex_error:
+	return -1;
+}
+
+
+
+static int
+rtl2832_get_tune_settings(
+	struct dvb_frontend*	fe,
+	struct dvb_frontend_tune_settings*	fe_tune_settings)
+{
+	deb_info("  %s : Do Nothing\n", __FUNCTION__);
+	fe_tune_settings->min_delay_ms = 1000;
+	return 0;
+}
+
+
+static int
+rtl2832_ts_bus_ctrl(
+	struct dvb_frontend*	fe,
+	int	acquire)
+{
+	deb_info("  %s : Do Nothing\n", __FUNCTION__);
+	return 0;
+}
+
+
+#if 0
+static int
+rtl2832_get_algo(struct dvb_frontend *fe)
+{
+        struct rtl2832_state* p_state = fe->demodulator_priv;
+
+	if(p_state->rtl2832_audio_video_mode == RTK_AUDIO)
+		return DVBFE_ALGO_HW;
+	else
+		return DVBFE_ALGO_SW;
+}
+
+static int
+rtl2832_tune(struct dvb_frontend *fe,
+			   struct dvb_frontend_parameters *params,
+			   unsigned int mode_flags,
+			   unsigned int *delay,
+			   fe_status_t *status)
+{
+
+	//struct dvb_frontend_private *fepriv = fe->frontend_priv;
+      //  fe_status_t s = 0;
+	int retval = 0;
+       struct rtl2832_state* p_state = fe->demodulator_priv;
+
+	if(params == NULL)
+	{
+		return 0;
+	}
+
+	if(p_state->rtl2832_audio_video_mode != RTK_AUDIO)
+	{
+		*status = 256;
+		deb_info("%s: can't set parameter now\n",__FUNCTION__);
+		return 0;
+	}
+
+      retval = rtl2832_set_parameters_fm(fe, params);
+	if(retval < 0)
+		*status = 256;//FESTATE_ERROR;
+	//else
+	//	status = 16;//FESTATE_TUNED;
+
+	*delay = 10*HZ;
+	//fepriv->quality = 0;
+
+	return 0;
+
+}
+
+#endif
+
+static struct dvb_frontend_ops rtl2832_dvbt_ops;
+static struct dvb_frontend_ops rtl2832_dvbt2_ops;
+static struct dvb_frontend_ops rtl2840_dvbc_ops;
+static struct dvb_frontend_ops rtl2836_dtmb_ops;
+
+
+struct dvb_frontend* rtl2832u_fe_attach(struct dvb_usb_device *d)
+{
+
+	struct rtl2832_state*       p_state= NULL;
+	//char			tmp_set_tuner_power_gpio4;
+
+	deb_info("+%s : chialing 2011-12-26\n", __FUNCTION__);
+
+	//3 linux fe_attach  necessary setting
+	/*allocate memory for the internal state */
+	p_state = kzalloc(sizeof(struct rtl2832_state), GFP_KERNEL);
+	if (p_state == NULL) goto error;
+	memset(p_state,0,sizeof(*p_state));
+
+	p_state->is_mt2266_nim_module_built = 0; //initialize is_mt2266_nim_module_built
+	p_state->is_mt2063_nim_module_built = 0; //initialize is_mt2063_nim_module_built
+
+	p_state->is_initial = 0;			//initialize is_initial
+	p_state->is_frequency_valid = 0;
+	p_state->d = d;
+
+	p_state->b_rtl2840_power_onoff_once = 0;
+
+	if( usb_init_setting(p_state) ) goto error;
+
+	if( gpio3_out_setting(p_state) ) goto error;			//3Set GPIO3 OUT
+
+	if( demod_ctl1_setting(p_state , 1) ) goto error;		//3	DEMOD_CTL1, resume = 1
+	if (dvb_use_rtl2832u_card_type)
+	{
+		if( set_demod_power(p_state , 1) ) goto error;
+	}
+
+	if( suspend_latch_setting(p_state , 1) ) goto error;		//3 suspend_latch_en = 0, resume = 1
+
+	if( demod_ctl_setting(p_state , 1,  1) ) goto error;		//3 DEMOD_CTL, resume =1; ADC on
+
+	//3 Auto detect Tuner Power Pin (GPIO3 or GPIO4)
+
+	if( set_tuner_power(p_state , 1 , 1) ) goto error;		//3	turn ON tuner power, 1st try GPIO4
+
+	if( check_tuner_type(p_state) )		goto error;
+
+    //3 Check if support RTL2836 DTMB.
+	p_state->demod_support_type = 0;
+	check_dtmb_support(p_state); //2836 is off in the end of check_dtmb_support()
+	check_dvbc_support(p_state);
+
+    //3Set demod_type.
+    p_state->demod_ask_type = demod_default_type;
+	if((p_state->demod_ask_type == RTL2836) && (p_state->demod_support_type & SUPPORT_DTMB_MODE))
+	{
+		p_state->demod_type = RTL2836;
+	}
+	else if((p_state->demod_ask_type == RTL2840) && (p_state->demod_support_type & SUPPORT_DVBC_MODE))
+	{
+		p_state->demod_type = RTL2840;
+	}
+	else
+	{
+        p_state->demod_type = RTL2832;
+        if(p_state->tuner_type==RTL2832_TUNER_TYPE_SI2148)
+            p_state->demod_type = SI2168;
+	}
+	deb_info("demod_type is %d\n", p_state->demod_type);
+
+	//3 Build Nim Module
+	build_nim_module(p_state);
+
+	/* setup the state */
+	switch(p_state->demod_type)
+	{
+		case RTL2832:
+			memcpy(&p_state->frontend.ops, &rtl2832_dvbt_ops, sizeof(struct dvb_frontend_ops));
+			memset(&p_state->fep, 0, sizeof(struct dtv_frontend_properties));
+		break;
+
+		case RTL2836:
+			memcpy(&p_state->frontend.ops, &rtl2836_dtmb_ops, sizeof(struct dvb_frontend_ops));
+			memset(&p_state->fep, 0, sizeof(struct dtv_frontend_properties));
+		break;
+
+		case RTL2840:
+			memcpy(&p_state->frontend.ops, &rtl2840_dvbc_ops, sizeof(struct dvb_frontend_ops));
+			memset(&p_state->fep, 0, sizeof(struct dtv_frontend_properties));
+		break;
+
+		case SI2168:
+			memcpy(&p_state->frontend.ops, &rtl2832_dvbt2_ops, sizeof(struct dvb_frontend_ops));
+			memset(&p_state->fep, 0, sizeof(struct dtv_frontend_properties));
+		break;
+	}
+
+
+ 	/* create dvb_frontend */
+	p_state->frontend.demodulator_priv = p_state;
+
+#if UPDATE_FUNC_ENABLE_2840
+	INIT_DELAYED_WORK(&(p_state->update2840_procedure_work), rtl2840_update_function);
+#endif
+
+#if UPDATE_FUNC_ENABLE_2836
+	INIT_DELAYED_WORK(&(p_state->update2836_procedure_work), rtl2836_update_function);
+#endif
+
+#if UPDATE_FUNC_ENABLE_2832
+	INIT_DELAYED_WORK(&(p_state->update2832_procedure_work), rtl2832_update_functions);
+#endif
+	mutex_init(&p_state->i2c_repeater_mutex);
+	if (dvb_use_rtl2832u_rc_mode<3){
+		deb_info(">>%s go to sleep mode(low power mode)\n", __FUNCTION__);
+			if (rtl2832_sleep_mode(p_state)){
+			deb_info("sleep mode is fail \n");
+		}
+	}
+	deb_info("-%s\n", __FUNCTION__);
+	return &p_state->frontend;
+
+error:
+	return NULL;
+
+
+}
+
+
+
+static struct dvb_frontend_ops rtl2840_dvbc_ops = {
+    .delsys = { SYS_DVBC_ANNEX_A },
+    .info = {
+        .name               = "Realtek DVB-C RTL2840 ",
+        .type               = FE_QAM,
+        .frequency_min      = 50000000,
+        .frequency_max      = 862000000,
+        .frequency_stepsize = 166667,
+        .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+            FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+            FE_CAN_FEC_AUTO |
+            FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+            FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+            FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+            FE_CAN_MUTE_TS
+    },
+
+    .init =				rtl2832_init,
+    .release =				rtl2832_release,
+
+    .sleep =				rtl2832_sleep,
+
+    .set_frontend =			rtl2840_set_parameters,
+    .get_frontend =			rtl2832_get_parameters,
+    .get_tune_settings =		rtl2832_get_tune_settings,
+
+    .read_status =			rtl2832_read_status,
+    .read_ber =				rtl2832_read_ber,
+    .read_signal_strength =		rtl2832_read_signal_strength,
+    .read_snr =				rtl2832_read_snr,
+    .read_ucblocks =			rtl2832_read_signal_quality,
+    .ts_bus_ctrl   =			rtl2832_ts_bus_ctrl,
+};
+
+
+static struct dvb_frontend_ops rtl2832_dvbt_ops = {
+    .delsys = { SYS_DVBT },
+    .info = {
+        .name               = "Realtek DVB-T RTL2832",
+        .type               = FE_OFDM,
+        .frequency_min      = 80000000,//174000000,
+        .frequency_max      = 862000000,
+        .frequency_stepsize = 166667,
+        .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+            FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+            FE_CAN_FEC_AUTO |
+            FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+            FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+            FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+            FE_CAN_MUTE_TS
+    },
+
+    .init =				rtl2832_init,
+    .release =				rtl2832_release,
+
+    .sleep =				rtl2832_sleep,
+
+    .set_frontend =			rtl2832_set_parameters,
+    .get_frontend =			rtl2832_get_parameters,
+    .get_tune_settings =		rtl2832_get_tune_settings,
+
+    .read_status =			rtl2832_read_status,
+    .read_ber =			rtl2832_read_ber,
+    .read_signal_strength =	rtl2832_read_signal_strength,
+    .read_snr =			rtl2832_read_snr,
+    .read_ucblocks =		rtl2832_read_signal_quality,
+    .ts_bus_ctrl   =			rtl2832_ts_bus_ctrl,
+
+    //.get_frontend_algo =        rtl2832_get_algo,
+    //.tune =                            rtl2832_tune,
+};
+
+static struct dvb_frontend_ops rtl2832_dvbt2_ops = {
+    .delsys = { SYS_DVBT, SYS_DVBT2 },
+    .info = {
+        .name               = "SiLabs Si2157/2168",
+        .type               = FE_OFDM,
+        .frequency_min      = 80000000,//174000000,
+        .frequency_max      = 862000000,
+        .frequency_stepsize = 166667,
+        .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+            FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+            FE_CAN_FEC_AUTO |
+            FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+            FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+            FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+            FE_CAN_MUTE_TS
+    },
+
+    .init =				rtl2832_init,
+    .release =				rtl2832_release,
+
+    .sleep =				rtl2832_sleep,
+
+    .set_frontend =			rtl2832_set_parameters,
+    .get_frontend =			rtl2832_get_parameters,
+    .get_tune_settings =		rtl2832_get_tune_settings,
+
+    .read_status =			rtl2832_read_status,
+    .read_ber =			rtl2832_read_ber,
+    .read_signal_strength =	rtl2832_read_signal_strength,
+    .read_snr =			rtl2832_read_snr,
+    .read_ucblocks =		rtl2832_read_signal_quality,
+    .ts_bus_ctrl   =			rtl2832_ts_bus_ctrl,
+
+    //.get_frontend_algo =        rtl2832_get_algo,
+    //.tune =                            rtl2832_tune,
+};
+
+static struct dvb_frontend_ops rtl2836_dtmb_ops = {
+    .delsys = { SYS_DTMB },
+    .info = {
+        .name               = "Realtek DTMB RTL2836",
+        .type               = FE_OFDM,
+        .frequency_min      = 50000000,
+        .frequency_max      = 862000000,
+        .frequency_stepsize = 166667,
+        .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+            FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+            FE_CAN_FEC_AUTO |
+            FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+            FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+            FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+            FE_CAN_MUTE_TS
+    },
+
+    .init =					rtl2832_init,
+    .release =				rtl2832_release,
+
+    .sleep =				rtl2832_sleep,
+
+    .set_frontend =			rtl2832_set_parameters,
+    .get_frontend =			rtl2832_get_parameters,
+    .get_tune_settings =		rtl2832_get_tune_settings,
+
+    .read_status =			rtl2832_read_status,
+    .read_ber =				rtl2832_read_ber,
+    .read_signal_strength =		rtl2832_read_signal_strength,
+    .read_snr =				rtl2832_read_snr,
+    .read_ucblocks =			rtl2832_read_signal_quality,
+    .ts_bus_ctrl   =			rtl2832_ts_bus_ctrl,
+};
+
+
+
+/* DTMB related */
+
+static int
+check_dtmb_support(
+		struct rtl2832_state* p_state)
+{
+
+	int status;
+	unsigned char  buf[LEN_2_BYTE];
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	set_demod_2836_power(p_state, 1); //on
+
+	status = read_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR,  PAGE_5,  0x10,  buf,  LEN_2_BYTE);
+
+	if(!status && ( buf[0]==0x04 ) && ( buf[1]==0x00 ))
+	{
+		p_state->demod_support_type |=  SUPPORT_DTMB_MODE;
+		deb_info(" -%s  RTL2836 on broad.....\n", __FUNCTION__);
+	}
+	else
+	{
+		p_state->demod_support_type &= (~SUPPORT_DTMB_MODE);
+		deb_info(" -%s  RTL2836 NOT FOUND.....\n", __FUNCTION__);
+	}
+
+    set_demod_2836_power(p_state, 0); //off
+
+	//3 Always support DVBT
+	p_state->demod_support_type |= SUPPORT_DVBT_MODE;
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+   	return 0;
+
+}
+
+
+
+/* DVB-C related */
+
+static int
+check_dvbc_support(
+		struct rtl2832_state* p_state)
+{
+
+	int status;
+	unsigned char	buf;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	set_demod_2840_power(p_state, 1);
+
+	status = read_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x04, &buf, LEN_1_BYTE);
+
+	if(!status)
+	{
+		p_state->demod_support_type |=  SUPPORT_DVBC_MODE;
+		deb_info(" -%s  RTL2840 on broad.....\n", __FUNCTION__);
+	}
+	else
+	{
+		p_state->demod_support_type &= (~SUPPORT_DVBC_MODE);
+		deb_info(" -%s  RTL2840 NOT FOUND.....\n", __FUNCTION__);
+	}
+	//if(p_state->tuner_type == RTL2832_TUNER_TYPE_SI2148)
+	//{
+	//    p_state->demod_support_type |=  SUPPORT_DVBC_MODE;
+	//	deb_info(" -%s  SI2168 on broad.....\n", __FUNCTION__);
+	//}
+
+	set_demod_2840_power(p_state, 0);
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+}
+
+
+
+static int
+set_demod_2836_power(
+		struct rtl2832_state* p_state,
+		int  onoff)
+{
+
+	int data;
+	unsigned char datachar;
+
+	deb_info(" +%s  onoff = %d\n", __FUNCTION__, onoff);
+
+	//2 First RTL2836 Power ON
+
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+		//3 a. Set GPIO 0 LOW
+	      if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+	      data &= ~(BIT0); // set GPIO0 low
+	      if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC2580)
+	{
+
+		//3 b. Set GPIO 5 LOW
+		if( gpio5_output_enable_direction(p_state))  goto error;
+
+		if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data) ) goto error;
+		data &= ~(BIT5); // set GPIO5 low
+		if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data) ) goto error;
+	}
+
+	if(onoff)
+	{
+		//3 2. RTL2836 AGC = 1
+		if ( read_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR,  PAGE_0, 0x01, &datachar,  LEN_1_BYTE)) goto error;
+		datachar |=BIT_2_MASK;
+		datachar &=(~BIT_3_MASK);
+		if(write_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR,   PAGE_0, 0x01, &datachar, LEN_1_BYTE))  goto error;
+	}
+	else
+	{
+
+		//3 2. RTL2836 AGC = 0
+
+		if ( read_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR,  PAGE_0, 0x01, &datachar,  LEN_1_BYTE)) goto error;
+		datachar &=(~BIT_2_MASK);
+		datachar &=(~BIT_3_MASK);
+		if(write_rtl2836_demod_register(p_state->d,  RTL2836_DEMOD_ADDR,   PAGE_0, 0x01, &datachar, LEN_1_BYTE))  goto error;
+
+
+ 		//3 3. RTL2836 Power OFF
+		if( p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+		{
+			//3 4.a. Set GPIO 0 HIGH
+			if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+			data |= BIT0; // set GPIO0 high
+		       if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+		}
+		else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC2580)
+		{
+
+			//3 4.b. Set GPIO 5 HIGH
+			if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+			data |= BIT5; // set GPIO5 high
+            if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+		}
+	}
+
+
+	deb_info(" -%s  onoff = %d\n", __FUNCTION__, onoff);
+	return 0;
+
+error:
+	deb_info(" -%s  onoff = %d fail\n", __FUNCTION__, onoff);
+	return 1;
+
+}
+
+static int
+set_demod_2168_power(
+		struct rtl2832_state* p_state,
+		int  onoff)
+{
+    int data;
+	deb_info(" +%s  onoff = %d\n", __FUNCTION__, onoff);
+	if(p_state->tuner_type == RTL2832_TUNER_TYPE_SI2148)
+	{
+	    if( gpio0_output_enable_direction(p_state))  goto error;
+        if( gpio5_output_enable_direction(p_state))  goto error;
+
+		if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+			data |= BIT0; // set GPIO0 high
+	    if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+
+	    if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+			data |= BIT5; // set GPIO5 high
+        if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+	}
+	deb_info(" -%s  onoff = %d\n", __FUNCTION__, onoff);
+	return 0;
+
+error:
+	deb_info(" -%s  onoff = %d fail\n", __FUNCTION__, onoff);
+	return 1;
+}
+
+static int
+rtl2840_on_hwreset(
+		struct rtl2832_state* p_state)
+{
+	unsigned char	buf;
+	int			data;
+	int			time = 0;
+
+	deb_info(" +%s \n", __FUNCTION__);
+
+	read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+	data |= BIT0; // set GPIO0 high
+	write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+
+	read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+	data |= BIT6; // set GPIO6 high
+	write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+
+	gpio6_output_enable_direction(p_state);
+
+	platform_wait(25);    //wait 25ms
+
+	read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+	data &= (~BIT6); // set GPIO6 low
+	write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+
+	platform_wait(25);    //wait 25ms
+
+	read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+	data &= (~BIT0); // set GPIO0 low
+	write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+
+	platform_wait(25);    //wait 25ms
+
+	read_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x01, &buf, LEN_1_BYTE);
+
+	while( (buf!=0xa3) && (time<2) )
+	{
+
+		// Set GPIO 6 HIGH
+		read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+		data |= BIT6; // set GPIO6 high
+		write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+		platform_wait(25);    //wait 25ms
+
+		// Set GPIO 0 HIGH
+		read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+		data |= BIT0; // set GPIO0 high
+		write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+		platform_wait(25);    //wait 25ms
+
+		// Set GPIO 6 LOW
+		read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+		data &= (~BIT6); // set GPIO6 low
+		write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+		platform_wait(25);    //wait 25ms
+
+		// Set GPIO 0 LOW
+		read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data);
+		data &= (~BIT0); // set GPIO0 low
+		write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data);
+		platform_wait(25);    //wait 25ms
+
+		read_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x01, &buf, LEN_1_BYTE);
+		deb_info(" +%s  Page 0, addr 0x01 = 0x%x\n", __FUNCTION__, buf);
+		time++;
+	}
+
+	deb_info(" -%s \n", __FUNCTION__);
+
+	return 0;
+
+}
+
+
+
+static int
+set_demod_2840_power(
+		struct rtl2832_state* p_state,
+		int  onoff)
+{
+	unsigned char		buf;
+	int				data;
+
+	deb_info(" +%s  onoff = %d\n", __FUNCTION__, onoff);
+
+	//3 1.a RTL2840 Power ON  Set GPIO 0 LOW
+	if(p_state->b_rtl2840_power_onoff_once)
+	{
+		//3 a. Set GPIO 0 LOW
+	      if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+	      data &= ~(BIT0); // set GPIO0 low
+	      if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+
+		platform_wait(50);    //wait 50ms
+	}
+	else
+	{
+		rtl2840_on_hwreset(p_state);
+		p_state->b_rtl2840_power_onoff_once = 1;
+	}
+
+	if(onoff)
+	{
+		//3 2.a RTL2840 AGC = 1
+		read_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x04, &buf, LEN_1_BYTE);
+		buf &= (~BIT_6_MASK);
+		buf |= BIT_7_MASK;
+		write_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x04, &buf, LEN_1_BYTE);
+	}
+	else
+	{
+
+		//3 2.b RTL2840 AGC = 0
+		read_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x04, &buf, LEN_1_BYTE);
+		buf &= (~BIT_6_MASK);
+		buf &= (~BIT_7_MASK);
+		write_demod_register(p_state->d, RTL2840_DEMOD_ADDR, PAGE_0, 0x04, &buf, LEN_1_BYTE);
+
+ 		//3 3.a RTL2840 Power OFF Set GPIO 0 HIGH
+	      if( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, &data)) goto error;
+	      data |=BIT0; // set GPIO0 HIGH
+	      if( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL, data)) goto error;
+	}
+
+	deb_info(" -%s  onoff = %d\n", __FUNCTION__, onoff);
+
+	return 0;
+error:
+	deb_info(" - XXX %s  onoff = %d\n", __FUNCTION__, onoff);
+	return 1;
+}
+
+
+
+static int
+demod_init_setting(
+		struct rtl2832_state * p_state
+		)
+{
+
+	unsigned char data;
+	unsigned char buf[LEN_2_BYTE];
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+	switch(p_state->demod_type)
+	{
+	case RTL2832:
+		{
+			deb_info("%s for RTL2832\n", __FUNCTION__);
+			//3 1. Set IF_AGC Internal    IF_AGC_MAN 0x0c
+		       if(read_demod_register(p_state->d,  RTL2832_DEMOD_ADDR, PAGE_1, 0x0c, &data,  LEN_1_BYTE)) goto error;
+			data &= (~BIT6);
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR, PAGE_1, 0x0c, &data, LEN_1_BYTE)) goto error;
+
+
+		      /*if(!context->DAB_AP_running)
+			{
+				//3 2. Set PID filter to reject null packet(pid = 0x1fff)
+				context->pid_filter_mode = REJECT_MODE;
+				ULONG reject_pid[1] = {0x1fff};
+				Status = PidFilterToRejectMode(context, reject_pid, 1);
+				if(!NT_SUCCESS(Status))	goto error;
+			}*/
+
+		}
+		break;
+
+	case RTL2836:
+	case RTL2840:
+	case SI2168:
+		{
+
+			deb_info("%s RTL2832P for RTL2836 and RTL2840 and SI2168\n", __FUNCTION__);
+			//3 1. Set IF_AGC Manual and Set IF_AGC MAX VAL
+			if(p_state->tuner_type!=RTL2832_TUNER_TYPE_SI2148)
+			{
+                buf[0]=0x5F;
+                buf[1]=0xFF;
+                if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_1,  0x0c,  buf, LEN_2_BYTE)) goto error;
+			}
+
+			//3 2. PIP Setting
+			data = 0xe8;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x21, &data, LEN_1_BYTE)) goto error;
+
+                     data = 0x60;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x61, &data, LEN_1_BYTE)) goto error;
+
+			data = 0x18;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0xbc, &data, LEN_1_BYTE)) goto error;
+
+			data = 0x00;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x62, &data, LEN_1_BYTE)) goto error;
+
+                     data = 0x00;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x63, &data, LEN_1_BYTE)) goto error;
+
+                     data = 0x00;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x64, &data, LEN_1_BYTE)) goto error;
+
+                     data = 0x00;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x65, &data, LEN_1_BYTE)) goto error;
+
+			//3 +PIP filter Reject = 0x1FFF
+            data = 0x01;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x22, &data, LEN_1_BYTE)) goto error;
+
+			data = 0x1f;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x26, &data, LEN_1_BYTE)) goto error;
+
+			data = 0xff;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_0, 0x27, &data, LEN_1_BYTE)) goto error;
+			//3 -PIP filter Reject = 0x1FFF
+
+			data = 0x7f;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_1, 0x92, &data, LEN_1_BYTE)) goto error;
+
+			data = 0xf7;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_1, 0x93, &data, LEN_1_BYTE)) goto error;
+
+			data = 0xff;
+			if(write_demod_register(p_state->d, RTL2832_DEMOD_ADDR,  PAGE_1, 0x94, &data, LEN_1_BYTE)) goto error;
+		}
+		break;
+	}
+
+	deb_info(" -%s\n", __FUNCTION__);
+	return 0;
+
+error:
+	deb_info(" -%s error \n", __FUNCTION__);
+	return 1;
+
+}
+
+
+static int
+rtl2836_scan_procedure(
+	struct rtl2832_state * p_state)
+{
+	unsigned char val;
+	int wait_num = 0;
+	unsigned long Per1, Per2;
+	long Data1,Data2,Snr;
+	DTMB_DEMOD_MODULE	*pDtmbDemod;
+	struct dvb_usb_device* dev;
+
+
+	pDtmbDemod = p_state->pNim2836->pDemod;
+	dev = p_state->d;
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+       //3 Check signal present
+	wait_num = 0;
+	msleep(50); // Wait 0.05s
+       if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_6, 0x53, &val, LEN_1_BYTE))  goto error;
+	deb_info("%s Signel Present = 0x %x\n", __FUNCTION__, val);
+	while((wait_num<3)&& (!(val&BIT_0_MASK)))
+	{
+		msleep(50); // Wait 0.05s
+		if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_6, 0x53, &val, LEN_1_BYTE))  goto error;
+		deb_info("%s Signel Present = 0x %x\n", __FUNCTION__, val);
+		wait_num++;
+	}
+
+	if(val&BIT_0_MASK)
+	{
+		//3  Write signal present
+		if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0xf8, &val, LEN_1_BYTE))  goto error;
+		val |= BIT_0_MASK;  //set Reg_present
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0xf8, &val, LEN_1_BYTE))  goto error;
+
+              //3+ RTL2836 Release Stage=9
+		val = 0x49;
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4d, &val, LEN_1_BYTE)) goto error;
+		val = 0x29;
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4e, &val, LEN_1_BYTE)) goto error;
+		val = 0x95;
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4f, &val, LEN_1_BYTE)) goto error;
+		//3 -RTL2836 Release Stage=9
+		deb_info("%s RTL2836 Release Stage 9\n", __FUNCTION__);
+
+
+		//3 Check signal lock
+		pDtmbDemod->GetPer(pDtmbDemod, &Per1, &Per2);
+		deb_info("%s --***GetPer = %d***\n", __FUNCTION__, (int)Per1);
+
+		pDtmbDemod->GetSnrDb(pDtmbDemod, &Data1, &Data2);
+		Snr = Data1>>2;
+		deb_info("%s --***SNR= %d***\n", __FUNCTION__, (int)Snr);
+
+		wait_num = 0;
+		while(wait_num<30 )
+		{
+			if((Per1<1) && (Snr>0) && (Snr<40) )
+			{
+				if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0xf8, &val, LEN_1_BYTE)) goto error;
+				val |= BIT_1_MASK;  //set Reg_signal
+    				if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0xf8, &val, LEN_1_BYTE)) goto error;
+
+				deb_info("%s Signal Lock................\n", __FUNCTION__);
+				break;
+			}
+
+			msleep(100); // Wait 0.1s
+			pDtmbDemod->GetPer(pDtmbDemod,&Per1,&Per2);
+			deb_info("%s --***GetPer = %d***\n", __FUNCTION__, (int)Per1);
+
+			pDtmbDemod->GetSnrDb(pDtmbDemod,&Data1,&Data2);
+			Snr = Data1>>2;
+			deb_info("%s --***SNR= %d***\n", __FUNCTION__, (int)Snr);
+			wait_num++;
+		}
+
+              if(! ((Per1<1) && (Snr>0) && (Snr<40)))
+              {
+              	if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &val, LEN_1_BYTE))  goto error;
+			val &=(~BIT_1_MASK);  //reset Reg_lock
+			if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &val, LEN_1_BYTE)) goto error;
+              }
+	}
+	else
+	{
+		if(read_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &val, LEN_1_BYTE)) goto error;
+		val &=(~BIT_0_MASK);  //reset Reg_present
+		val &=(~BIT_1_MASK);  //reset Reg_lock
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR,  PAGE_3,  0xf8,  &val, LEN_1_BYTE)) goto error;
+
+		//3 + RTL2836 Release Stage=9
+		val = 0x49;
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4d, &val, LEN_1_BYTE)) goto error;
+		val = 0x29;
+              if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4e, &val, LEN_1_BYTE)) goto error;
+		val = 0x95;
+		if(write_rtl2836_demod_register(dev, RTL2836_DEMOD_ADDR, PAGE_3, 0x4f, &val, LEN_1_BYTE)) goto error;
+		//3 -RTL2836 Release Stage=9
+
+		deb_info("%s RTL2836 Release Stage 9\n", __FUNCTION__);
+	}
+
+	deb_info(" -%s\n", __FUNCTION__);
+	return 0;
+error:
+
+	deb_info(" +%s error\n", __FUNCTION__);
+	return -1;
+}
+
+
+static int
+build_2832_nim_module(
+		struct rtl2832_state*  p_state)
+{
+
+	MT2266_EXTRA_MODULE	*p_mt2266_extra;
+	MT2063_EXTRA_MODULE	*p_mt2063_extra;
+	TUNER_MODULE 		*pTuner;
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+      //3 Buile 2832 nim module
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_MT2266)
+	{
+		//3 Build RTL2832 MT2266 NIM module.
+
+		BuildRtl2832Mt2266Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 200 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			MT2266_TUNER_ADDR				// The MT2266 I2C device address is 0xc0 in 8-bit format.
+			);
+
+		// Get MT2266 tuner extra module.
+		pTuner = p_state->pNim->pTuner;
+		p_mt2266_extra = &(pTuner->Extra.Mt2266);
+
+		// Open MT2266 handle.
+		if(p_mt2266_extra->OpenHandle(pTuner))
+			deb_info("%s : MT2266 Open Handle Failed....\n", __FUNCTION__);
+
+		p_state->is_mt2266_nim_module_built = 1;
+
+		deb_info(" %s BuildRtl2832Mt2266Module\n", __FUNCTION__);
+
+	}
+	else if( p_state->tuner_type == RTL2832_TUNER_TYPE_FC2580)
+	{
+
+		//3Build RTL2832 FC2580 NIM module.
+		BuildRtl2832Fc2580Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,					// Maximum I2C reading byte number is 9.
+			2,					// Maximum I2C writing byte number is 8.
+			custom_i2c_read,			// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,			// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,				// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,			// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,		// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,			// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,		// The RTL2832 application mode is DONGLE mode.
+			200,					// The RTL2832 update function reference period is 200 millisecond
+			OFF,					// The RTL2832 Function 1 enabling status is YES.
+
+			FC2580_TUNER_ADDR,			// The FC2580 I2C device address is 0xac in 8-bit format.
+			CRYSTAL_FREQ_16384000HZ,		// The FC2580 crystal frequency is 16.384 MHz.
+			FC2580_AGC_INTERNAL			// The FC2580 AGC mode is external AGC mode.
+			);
+		deb_info(" %s BuildRtl2832Fc2580Module\n", __FUNCTION__);
+
+	}
+	else if( p_state->tuner_type == RTL2832_TUNER_TYPE_TUA9001)
+	{
+
+		//3Build RTL2832 TUA9001 NIM module.
+		BuildRtl2832Tua9001Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			NULL,						// Employ CustomI2cRead() as basic I2C reading function.
+			NULL,						// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 50 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			TUA9001_TUNER_ADDR				// The TUA9001 I2C device address is 0xc0 in 8-bit format.
+			);
+		deb_info(" %s BuildRtl2832Tua9001Module\n", __FUNCTION__);
+
+	}
+	else if( p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+
+		//3Build RTL2832 MXL5007 NIM module.
+		BuildRtl2832Mxl5007tModule(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function..
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 200 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			MXL5007T_BASE_ADDRESS,				// The MxL5007T I2C device address is 0xc0 in 8-bit format.
+			CRYSTAL_FREQ_16000000HZ,			// The MxL5007T Crystal frequency is 16.0 MHz.
+			MXL5007T_LOOP_THROUGH_DISABLE,			// The MxL5007T loop-through mode is disabled.
+			MXL5007T_CLK_OUT_DISABLE,			// The MxL5007T clock output mode is disabled.
+			MXL5007T_CLK_OUT_AMP_0				// The MxL5007T clock output amplitude is 0.
+			);
+		deb_info(" %s BuildRtl2832Mxl5007tModule\n", __FUNCTION__);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0012)
+	{
+		//3Build RTL2832 FC0012 NIM module.
+		BuildRtl2832Fc0012Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 200 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			FC0012_BASE_ADDRESS,				// The FC0012 I2C device address is 0xc6 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ				// The FC0012 crystal frequency is 36.0 MHz.
+			);
+		deb_info(" %s BuildRtl2832Fc0012Module\n", __FUNCTION__);
+
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_E4000)
+	{
+		//3 Build RTL2832 E4000 NIM module
+		BuildRtl2832E4000Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 50 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			E4000_BASE_ADDRESS,				// The E4000 I2C device address is 0xc8 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ				// The E4000 crystal frequency is 28.8 MHz.
+			);
+		deb_info(" %s BuildRtl2832E4000Module\n", __FUNCTION__);
+
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_MT2063)
+	{
+
+		// Build RTL2832 MT2063 NIM module.
+		BuildRtl2832Mt2063Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+			IF_FREQ_36125000HZ,				// The RTL2832 and MT2063 IF frequency is 36.125 MHz.
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARRLLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			50,						// The RTL2832 update function reference period is 50 millisecond
+			YES,						// The RTL2832 Function 1 enabling status is YES.
+
+			MT2063_TUNER_ADDR				// The MT2063 I2C device address is 0xc0 in 8-bit format.
+			);
+
+
+
+		// Get MT2063 tuner extra module.
+		pTuner = p_state->pNim->pTuner;
+		p_mt2063_extra = &(pTuner->Extra.Mt2063);
+
+		// Open MT2063 handle.
+		if(p_mt2063_extra->OpenHandle(pTuner))
+			deb_info("%s : MT2063 Open Handle Failed....\n", __FUNCTION__);
+
+		p_state->is_mt2063_nim_module_built = 1;
+
+		deb_info(" %s BuildRtl2832Mt2063Module\n", __FUNCTION__);
+
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_MAX3543)
+	{
+
+		// Build RTL2832 MAX3543 NIM module.
+		BuildRtl2832Max3543Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			50,						// The RTL2832 update function reference period is 50 millisecond
+			YES,						// The RTL2832 Function 1 enabling status is YES.
+
+			MAX3543_TUNER_ADDR,				// The MAX3543 I2C device address is 0xc0 in 8-bit format.
+			CRYSTAL_FREQ_16000000HZ				// The MAX3543 Crystal frequency is 16.0 MHz.
+			);
+
+		deb_info(" %s BuildRtl2832Max3543Module\n", __FUNCTION__);
+
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_TDA18272)
+	{
+
+		// Build RTL2832 TDA18272 NIM module.
+		BuildRtl2832Tda18272Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is serial.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is STB mode.
+			50,						// The RTL2832 update function reference period is 50 millisecond
+			YES,						// The RTL2832 Function 1 enabling status is YES.
+
+			TDA18272_TUNER_ADDR,				// The TDA18272 I2C device address is 0xc0 in 8-bit format.
+			CRYSTAL_FREQ_16000000HZ,			// The TDA18272 crystal frequency is 16.0 MHz.
+			TDA18272_UNIT_0,				// The TDA18272 unit number is 0.
+			TDA18272_IF_OUTPUT_VPP_0P7V			// The TDA18272 IF output Vp-p is 0.7 V.
+			);
+
+		deb_info(" %s BuildRtl2832Tda18272Module\n", __FUNCTION__);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_FC0013)
+	{
+		//3Build RTL2832 FC0012 NIM module.
+		BuildRtl2832Fc0013Module(
+			&p_state->pNim,
+			&p_state->DvbtNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2832_DEMOD_ADDR,				// The RTL2832 I2C device address is 0x20 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2832 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_PARALLEL,				// The RTL2832 TS interface mode is PARALLEL.
+			RTL2832_APPLICATION_DONGLE,			// The RTL2832 application mode is DONGLE mode.
+			200,						// The RTL2832 update function reference period is 200 millisecond
+			OFF,						// The RTL2832 Function 1 enabling status is YES.
+
+			FC0013_BASE_ADDRESS,				// The FC0012 I2C device address is 0xc6 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ				// The FC0012 crystal frequency is 36.0 MHz.
+			);
+		deb_info(" %s BuildRtl2832Fc0013Module\n", __FUNCTION__);
+
+	}
+	else
+	{
+		deb_info(" -%s : RTL 2832 Unknown tuner on board...\n", __FUNCTION__);
+		goto error;
+	}
+	//Set user defined data pointer of base interface structure for custom basic functions.
+       p_state->pNim->pBaseInterface->SetUserDefinedDataPointer(p_state->pNim->pBaseInterface, p_state->d );
+
+	deb_info(" -%s\n", __FUNCTION__);
+
+	return 0;
+
+error:
+	return 1;
+
+}
+
+
+
+static int
+build_2836_nim_module(
+		struct rtl2832_state*  p_state)
+{
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_FC2580)
+       {
+       		//3Build RTL2836 FC2580 NIM module.
+		BuildRtl2836Fc2580Module(
+		      	&p_state->pNim2836,
+		      	&p_state->DtmbNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2836_DEMOD_ADDR,				// The RTL2836 I2C device address is 0x3e in 8-bit format.
+			CRYSTAL_FREQ_27000000HZ,			// The RTL2836 crystal frequency is 27.0 MHz.
+			TS_INTERFACE_SERIAL,				// The RTL2836 TS interface mode is serial.
+			50,						// The RTL2836 update function reference period is 50 millisecond
+			YES,						// The RTL2836 Function 1 enabling status is YES.
+			YES,						// The RTL2836 Function 2 enabling status is YES.
+
+			FC2580_TUNER_ADDR,				// The FC2580 I2C device address is 0xac in 8-bit format.
+			CRYSTAL_FREQ_16384000HZ,			// The FC2580 crystal frequency is 16.384 MHz.
+			FC2580_AGC_INTERNAL				// The FC2580 AGC mode is internal AGC mode.
+			);
+	}
+	else if(p_state->tuner_type == RTL2832_TUNER_TYPE_MXL5007T)
+	{
+		//3 Build RTL2836 MXL5007T NIM module
+		BuildRtl2836Mxl5007tModule(
+			&p_state->pNim2836,
+			&p_state->DtmbNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2836_DEMOD_ADDR,				// The RTL2836 I2C device address is 0x3e in 8-bit format.
+			CRYSTAL_FREQ_27000000HZ,			// The RTL2836 crystal frequency is 27.0 MHz.
+			TS_INTERFACE_SERIAL,				// The RTL2836 TS interface mode is serial.
+			50,						// The RTL2836 update function reference period is 50 millisecond
+			YES,						// The RTL2836 Function 1 enabling status is YES.
+			YES,						// The RTL2836 Function 2 enabling status is YES.
+
+			MXL5007T_BASE_ADDRESS,				// The MxL5007T I2C device address is 0xc0 in 8-bit format.
+			CRYSTAL_FREQ_16000000HZ,			// The MxL5007T Crystal frequency is 16.0 MHz.
+			MXL5007T_LOOP_THROUGH_DISABLE,			// The MxL5007T loop-through mode is disabled.
+			MXL5007T_CLK_OUT_DISABLE,			// The MxL5007T clock output mode is disabled.
+			MXL5007T_CLK_OUT_AMP_0				// The MxL5007T clock output amplitude is 0.
+			);
+	}
+	else
+	{
+		deb_info(" -%s : RTL2836 Unknown tuner on board...\n", __FUNCTION__);
+	       goto error;
+	}
+
+	//Set user defined data pointer of base interface structure for custom basic functions.
+	p_state->pNim2836->pBaseInterface->SetUserDefinedDataPointer(p_state->pNim2836->pBaseInterface, p_state->d );
+
+	deb_info(" -%s\n", __FUNCTION__);
+
+	return 0;
+
+error:
+	return 1;
+
+}
+
+
+static int
+build_2840_nim_module(
+		struct rtl2832_state*  p_state)
+{
+
+	MT2063_EXTRA_MODULE	*p_mt2063_extra;
+	TUNER_MODULE *pTuner;
+
+	deb_info(" +%s\n", __FUNCTION__);
+
+	if( p_state->tuner_type == RTL2832_TUNER_TYPE_MT2063)
+	{
+
+		BuildRtl2840Mt2063Module(
+			&p_state->pNim2840,
+			&p_state->QamNimModuleMemory,
+			IF_FREQ_36125000HZ,				// The RTL2840 and MT2063 IF frequency is 36.125 MHz.
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2840_DEMOD_ADDR,				// The RTL2840 I2C device address is 0x44 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2840 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_SERIAL,				// The RTL2840 TS interface mode is serial.
+			QAM_DEMOD_EN_AM_HUM,				// Use AM-hum enhancement mode.
+
+			MT2063_TUNER_ADDR				// The MT2063 I2C device address is 0xc0 in 8-bit format.
+			);
+
+		// Get MT2063 tuner extra module.
+		pTuner = p_state->pNim2840->pTuner;
+		p_mt2063_extra = &(pTuner->Extra.Mt2063);
+
+		if(p_mt2063_extra->OpenHandle(pTuner))
+			deb_info("%s : MT2063 Open Handle Failed....\n", __FUNCTION__);
+
+		p_state->is_mt2063_nim_module_built = 1;
+
+		deb_info(" %s BuildRtl2840Mt2063Module\n", __FUNCTION__);
+	}
+	else if ( p_state->tuner_type == RTL2832_TUNER_TYPE_MAX3543)
+	{
+		// Build RTL2840 MAX3543 NIM module.
+		BuildRtl2840Max3543Module(
+			&p_state->pNim2840,
+			&p_state->QamNimModuleMemory,
+
+			2,						// Maximum I2C reading byte number is 2.
+			2,						// Maximum I2C writing byte number is 2.
+			custom_i2c_read,				// Employ CustomI2cRead() as basic I2C reading function.
+			custom_i2c_write,				// Employ CustomI2cWrite() as basic I2C writing function.
+			custom_wait_ms,					// Employ CustomWaitMs() as basic waiting function.
+
+			RTL2840_DEMOD_ADDR,				// The RTL2840 I2C device address is 0x44 in 8-bit format.
+			CRYSTAL_FREQ_28800000HZ,			// The RTL2840 crystal frequency is 28.8 MHz.
+			TS_INTERFACE_SERIAL,				// The RTL2840 TS interface mode is serial.
+			QAM_DEMOD_EN_AM_HUM,				// Use AM-hum enhancement mode.
+
+			MAX3543_TUNER_ADDR,				// The MAX3543 I2C device address is 0xc0 in 8-bit format.
+			CRYSTAL_FREQ_16000000HZ				// The MAX3543 Crystal frequency is 16.0 MHz.
+			);
+		deb_info(" %s BuildRtl2840Max3543Module\n", __FUNCTION__);
+	}
+	else
+	{
+		deb_info(" -%s : RTL2840 Unknown tuner on board...\n", __FUNCTION__);
+	       goto error;
+	}
+
+	//Set user defined data pointer of base interface structure for custom basic functions.
+	p_state->pNim2840->pBaseInterface->SetUserDefinedDataPointer(p_state->pNim2840->pBaseInterface, p_state->d );
+
+	deb_info(" -%s\n", __FUNCTION__);
+	return 0;
+
+error:
+	return 1;
+}
+
+static int
+build_2168_nim_module(
+		struct rtl2832_state*  p_state)
+{
+	deb_info(" +%s\n", __FUNCTION__);
+    if(p_state->tuner_type == RTL2832_TUNER_TYPE_SI2148)//Yann Build Tuner
+	{
+	    printk("build si2148 module\n");
+	    Si2168_Initial();
+	}
+	deb_info(" -%s\n", __FUNCTION__);
+	return 0;
+}
+
+
+static int
+build_nim_module(
+		struct rtl2832_state*  p_state)
+{
+      deb_info(" +%s\n", __FUNCTION__);
+
+	switch(p_state->demod_type)
+	{
+		case RTL2832:
+		// Build 2832 nim module
+		build_2832_nim_module(p_state);
+		break;
+
+		case RTL2836:
+		// Build 2836 nim module
+		build_2832_nim_module(p_state);
+		build_2836_nim_module(p_state);
+		break;
+
+		case RTL2840:
+		//Build 2840 nim module
+		build_2832_nim_module(p_state);
+		build_2840_nim_module(p_state);
+		break;
+
+		case SI2168:
+		build_2832_nim_module(p_state);
+		build_2168_nim_module(p_state);
+		break;
+	}
+
+    deb_info(" -%s\n", __FUNCTION__);
+	return 0;
+}
+
+
+
+
+
+
+int  rtl2832_hw_reset(struct rtl2832_state *p_state)
+{
+		int					data;
+	unsigned char			tmp;
+
+      		// Demod  H/W Reset
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+				data &= (~BIT5);	//set bit5 to 0
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		if ( read_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL, &data) ) goto error;
+			      data |= BIT5;		//set bit5 to 1
+		if ( write_usb_sys_register(p_state, RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,data) ) goto error;
+
+		//3 reset page chache to 0
+		if ( read_demod_register(p_state->d, RTL2832_DEMOD_ADDR, 0, 1, &tmp, 1 ) ) goto error;
+
+		// delay 5ms
+		platform_wait(5);
+		return 0;
+
+error:
+	return -1;
+}
+
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_fe.h b/drivers/media/usb/rtl2832u/rtl2832u_fe.h
new file mode 100644
index 00000000..ccee038e
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_fe.h
@@ -0,0 +1,333 @@
+
+#ifndef __RTL2832U_FE_H__
+#define __RTL2832U_FE_H__
+
+#include "nim_rtl2832_tua9001.h"
+#include "nim_rtl2832_mt2266.h"
+#include "nim_rtl2832_fc2580.h"
+#include "nim_rtl2832_mxl5007t.h"
+#include "nim_rtl2832_fc0012.h"
+#include "nim_rtl2832_e4000.h"
+#include "nim_rtl2832_mt2063.h"
+#include "nim_rtl2832_max3543.h"
+#include "nim_rtl2832_tda18272.h"
+#include "nim_rtl2832_fc0013.h"
+
+#include "nim_rtl2836_fc2580.h"
+#include "nim_rtl2836_mxl5007t.h"
+
+#include "nim_rtl2840_mt2063.h"
+#include "nim_rtl2840_max3543.h"
+
+#include "rtl2832u_io.h"
+#include <linux/param.h>
+#include "dvb_frontend.h"
+//#include <linux/jiffies.h>
+
+#define  UPDATE_FUNC_ENABLE_2840      0
+#define  UPDATE_FUNC_ENABLE_2836      1
+#define  UPDATE_FUNC_ENABLE_2832      1
+
+#define UPDATE_PROCEDURE_PERIOD_2836	       (HZ/5) //200ms = jiffies*1000/HZ
+#define UPDATE_PROCEDURE_PERIOD_2832       (HZ/5)  //200ms
+
+typedef enum{
+      RTL2832_TUNER_TYPE_UNKNOWN = 0,
+	RTL2832_TUNER_TYPE_MT2266,
+	RTL2832_TUNER_TYPE_FC2580,
+	RTL2832_TUNER_TYPE_TUA9001,
+	RTL2832_TUNER_TYPE_MXL5007T,
+	RTL2832_TUNER_TYPE_E4000,
+	RTL2832_TUNER_TYPE_FC0012,
+	RTL2832_TUNER_TYPE_FC0013,
+	RTL2832_TUNER_TYPE_MT2063,
+	RTL2832_TUNER_TYPE_MAX3543,
+	RTL2832_TUNER_TYPE_TDA18272,
+	RTL2832_TUNER_TYPE_SI2148,
+}RTL2832_TUNER_TYPE;
+
+typedef enum{
+	RTK_UNKNOWN = 0,
+	RTK_VIDEO,
+	RTK_AUDIO,
+}RTL2832_WORK_TYPE;
+
+
+typedef enum fe_bandwidth {
+	BANDWIDTH_8_MHZ,
+	BANDWIDTH_7_MHZ,
+	BANDWIDTH_6_MHZ,
+	BANDWIDTH_AUTO,
+	BANDWIDTH_5_MHZ,
+	BANDWIDTH_10_MHZ,
+	BANDWIDTH_1_712_MHZ,
+} fe_bandwidth_t;
+
+//3  state of total device
+struct rtl2832_state {
+	struct dvb_frontend			frontend;
+	//struct dvb_frontend_parameters	fep;
+	struct dtv_frontend_properties	fep;
+	struct dvb_usb_device*		d;
+
+	struct mutex					i2c_repeater_mutex;
+
+       unsigned long					current_frequency;
+	enum fe_bandwidth			current_bandwidth;
+
+	RTL2832_TUNER_TYPE			tuner_type;
+	unsigned char					is_mt2266_nim_module_built;  //3 For close MT handle
+	unsigned char					is_mt2063_nim_module_built;  //3 For close MT handle
+
+
+	//3 DTMB related begin ---
+	unsigned int                                demod_support_type;
+	unsigned int                                demod_type;
+	unsigned int                                demod_ask_type;
+	//3 DTMB related end end ---
+
+
+	//3 DVBC related begin ---
+	unsigned char					b_rtl2840_power_onoff_once;
+
+	//3 DVBC related end end ---
+
+
+	//3if init() is called, is_initial is true ->check it to see if need to flush work queue
+	unsigned short				is_initial;
+	unsigned char                             is_frequency_valid;
+
+	unsigned char                             rtl2832_audio_video_mode;
+
+
+#if  UPDATE_FUNC_ENABLE_2840
+	struct delayed_work                  update2840_procedure_work;
+#endif
+
+#if  UPDATE_FUNC_ENABLE_2836
+	struct delayed_work                  update2836_procedure_work;
+#endif
+
+#if  UPDATE_FUNC_ENABLE_2832
+    struct delayed_work			update2832_procedure_work;
+#endif
+	DVBT_NIM_MODULE*			pNim;//Nim of 2832
+	DVBT_NIM_MODULE			DvbtNimModuleMemory;
+
+	//3  DTMB related begin ---
+       DTMB_NIM_MODULE*                 pNim2836;//Nim of 2836
+	DTMB_NIM_MODULE                   DtmbNimModuleMemory;
+	//3DTMB related end ---
+
+	//3  DVBC related begin ---
+       QAM_NIM_MODULE*			pNim2840;//Nim of 2840
+	QAM_NIM_MODULE				QamNimModuleMemory;
+	//3DVBC related end ---
+
+};
+
+
+
+
+#define MT2266_TUNER_ADDR		0xc0
+#define FC2580_TUNER_ADDR		0xac
+#define TUA9001_TUNER_ADDR	0xc0
+
+#define MT2266_OFFSET			0x00
+#define MT2266_CHECK_VAL		0x85
+
+#define FC2580_OFFSET			0x01
+#define FC2580_CHECK_VAL		0x56
+
+#define TUA9001_OFFSET			0x7e
+#define TUA9001_CHECK_VAL		0x2328
+
+#define MXL5007T_BASE_ADDRESS	0xc0
+#define MXL5007T_CHECK_ADDRESS	0xD9
+#define MXL5007T_CHECK_VALUE	0x14
+
+#define FC0012_BASE_ADDRESS		0xc6
+#define FC0012_CHECK_ADDRESS	0x00
+#define FC0012_CHECK_VALUE		0xa1
+
+#define E4000_BASE_ADDRESS     0xc8
+#define E4000_CHECK_ADDRESS   0x02
+#define E4000_CHECK_VALUE       0x40
+
+
+#define MT2063_TUNER_ADDR		0xc0
+#define MT2063_CHECK_OFFSET		0x00
+#define MT2063_CHECK_VALUE		0x9e
+#define MT2063_CHECK_VALUE_2		0x9c
+
+
+#define MAX3543_TUNER_ADDR		0xc0
+#define MAX3543_CHECK_OFFSET		0x00
+#define MAX3543_CHECK_VALUE		0x38
+#define MAX3543_SHUTDOWN_OFFSET	0x08
+
+
+#define TDA18272_TUNER_ADDR		0xc0
+#define TDA18272_CHECK_OFFSET		0x00
+#define TDA18272_CHECK_VALUE1		0xc7
+#define TDA18272_CHECK_VALUE2		0x60
+
+
+#define FC0013_BASE_ADDRESS		0xc6
+#define FC0013_CHECK_ADDRESS		0x00
+#define FC0013_CHECK_VALUE			0xa3
+#define FC0013_STANDBY_ADDRESS	0x06
+
+
+
+
+struct rtl2832_reg_addr{
+	RegType			reg_type;
+	unsigned short	reg_addr;
+	int				bit_low;
+	int				bit_high;
+};
+
+
+
+typedef enum{
+	RTD2831_RMAP_INDEX_USB_CTRL_BIT5 =0,
+	RTD2831_RMAP_INDEX_USB_STAT,
+	RTD2831_RMAP_INDEX_USB_EPA_CTL,
+	RTD2831_RMAP_INDEX_USB_SYSCTL,
+	RTD2831_RMAP_INDEX_USB_EPA_CFG,
+	RTD2831_RMAP_INDEX_USB_EPA_MAXPKT,
+	RTD2831_RMAP_INDEX_USB_EPA_FIFO_CFG,
+
+	RTD2831_RMAP_INDEX_SYS_DEMOD_CTL,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_VAL,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT3,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT3,
+	RTD2831_RMAP_INDEX_SYS_GPIO_CFG0_BIT67,
+	RTD2831_RMAP_INDEX_SYS_DEMOD_CTL1,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT1,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT1,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT6,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT6,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT5,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT5,
+    RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT2,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT2,
+	RTD2831_RMAP_INDEX_SYS_GPIO_OUTPUT_EN_BIT0,
+	RTD2831_RMAP_INDEX_SYS_GPIO_DIR_BIT0,
+#if 0
+    RTD2831_RMAP_INDEX_SYS_GPD,
+    RTD2831_RMAP_INDEX_SYS_GPOE,
+    RTD2831_RMAP_INDEX_SYS_GPO,
+    RTD2831_RMAP_INDEX_SYS_SYS_0,
+#endif
+
+} rtl2832_reg_map_index;
+
+
+
+#define USB_SYSCTL				0x0000
+#define USB_CTRL				0x0010
+#define USB_STAT				0x0014
+#define USB_EPA_CTL				0x0148
+#define USB_EPA_CFG				0x0144
+#define USB_EPA_MAXPKT			0x0158
+#define USB_EPA_FIFO_CFG		0x0160
+
+#define DEMOD_CTL				0x0000
+#define GPIO_OUTPUT_VAL		0x0001
+#define GPIO_OUTPUT_EN			0x0003
+#define GPIO_DIR					0x0004
+#define GPIO_CFG0				0x0007
+#define GPIO_CFG1				0x0008
+#define DEMOD_CTL1				0x000b
+
+
+
+
+
+
+#define BIT0		0x00000001
+#define BIT1		0x00000002
+#define BIT2		0x00000004
+#define BIT3		0x00000008
+#define BIT4		0x00000010
+#define BIT5		0x00000020
+#define BIT6		0x00000040
+#define BIT7		0x00000080
+#define BIT8		0x00000100
+#define BIT9		0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+/* DTMB related
+
+typedef enum {
+	PAGE_0 = 0,
+	PAGE_1 = 1,
+	PAGE_2 = 2,
+	PAGE_3 = 3,
+	PAGE_4 = 4,
+	PAGE_5 = 5,
+	PAGE_6 = 6,
+	PAGE_7 = 7,
+	PAGE_8 = 8,
+	PAGE_9 = 9,
+};*/
+
+
+#define	SUPPORT_DVBT_MODE	0x01
+#define	SUPPORT_DTMB_MODE	0x02
+#define	SUPPORT_DVBC_MODE	0x04
+
+#define INPUT_ADC_LEVEL 	-8
+typedef enum {
+	RTL2832 = 0,
+	RTL2836,
+	RTL2840,
+	SI2168
+}DEMOD_TYPE;
+
+
+
+static int
+build_nim_module(
+		struct rtl2832_state*  p_state);
+
+
+int  rtl2832_hw_reset(struct rtl2832_state *p_state);
+
+
+
+
+int rtl2832_read_signal_quality(
+	struct dvb_frontend*	fe,
+	u32*	quality);
+int
+rtl2832_read_signal_strength(
+	struct dvb_frontend*	fe,
+	u16*	strength);
+#endif // __RTD2830_PRIV_H__
+
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_io.c b/drivers/media/usb/rtl2832u/rtl2832u_io.c
new file mode 100644
index 00000000..c242c496
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_io.c
@@ -0,0 +1,912 @@
+
+
+#include "rtl2832u_io.h"
+#include <linux/time.h>
+
+#define ERROR_TRY_MAX_NUM		4
+
+
+#define	DUMMY_PAGE		0x0a
+#define	DUMMY_ADDR		0x01
+
+
+
+void
+platform_wait(
+	unsigned long nMinDelayTime)
+{
+	// The unit of Sleep() waiting time is millisecond.
+	unsigned long usec;
+	do {
+		usec = (nMinDelayTime > 8000) ? 8000 : nMinDelayTime;
+		msleep(usec);
+		nMinDelayTime -= usec;
+		} while (nMinDelayTime > 0);
+
+	return;
+	
+}
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//		remote control 
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static int 
+read_rc_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{
+	int ret = -ENOMEM;
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),					/* pipe to control endpoint */
+                0,											/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                offset,											/* USB message value */
+                0x0201,											/* USB message index value */
+                data,											/* pointer to the receive buffer */
+                bytelength,										/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+ 	
+        if (ret != bytelength)
+	{
+		deb_info(" error try rc read register %s: offset=0x%x, error code=0x%x !\n", __FUNCTION__, offset, ret);
+		return 1;
+       	}
+
+	return 0; 
+}
+
+
+
+static int 
+write_rc_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{
+	int ret = -ENOMEM;
+	unsigned char try_num;
+
+	try_num = 0;	
+error_write_again:
+	try_num++;	
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),					/* pipe to control endpoint */
+                0,											/* USB message request value */
+                SKEL_VENDOR_OUT,									/* USB message request type value */
+                offset,											/* USB message value */
+                0x0211,											/* USB message index value */
+                data,											/* pointer to the receive buffer */
+                bytelength,										/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+        if (ret != bytelength)
+	{
+		deb_info("error try rc write register  = %d, %s: offset=0x%x, error code=0x%x !\n",try_num ,__FUNCTION__, offset, ret);
+
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;
+       }
+
+	return 0;
+error:
+	return 1;
+ }
+
+
+int
+read_rc_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num)
+{
+	int ret = 1;
+
+	if( byte_num != 1 && byte_num !=2 && byte_num !=4 && byte_num != 0x80)
+	{
+		deb_info("error!! %s: length = %d \n", __FUNCTION__, byte_num);
+		return 1;
+	}
+
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	return 1;
+	
+	if (type == RTD2832U_RC )	
+		ret = read_rc_register( dib , byte_addr , buf , byte_num);
+	else
+	{
+		deb_info("error!! %s: erroe register type \n", __FUNCTION__);
+		return 1;
+	}				
+	mutex_unlock(&dib->usb_mutex);
+
+	return ret;
+	
+}
+
+
+
+int
+write_rc_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num)
+{
+	int ret = 1;
+
+	if( byte_num != 1 && byte_num !=2 && byte_num !=4 && byte_num !=0x80)
+	{
+		deb_info("error!! %s: length = %d \n", __FUNCTION__, byte_num);
+		return 1;
+	}
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	return 1;
+	
+	if (type == RTD2832U_RC )	
+		ret = write_rc_register( dib , byte_addr , buf , byte_num);
+	else
+	{
+		deb_info("error!! %s: erroe register type \n", __FUNCTION__);
+		ret=1;
+	}	
+	mutex_unlock(&dib->usb_mutex);	
+
+	return ret;
+
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static int 
+read_usb_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{
+	int ret = -ENOMEM;
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                (USB_BASE_ADDRESS<<8) + offset,						/* USB message value */
+                0x0100,													/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+ 	
+        if (ret != bytelength)
+	{
+		deb_info(" %s: offset=0x%x, error code=0x%x !\n", __FUNCTION__, offset, ret);
+		return 1;
+       }
+
+	return 0; 
+}
+
+
+
+static int 
+write_usb_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{
+	int ret = -ENOMEM;
+	unsigned char try_num;
+
+	try_num = 0;	
+error_write_again:
+	try_num++;	
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),		/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_OUT,										/* USB message request type value */
+                (USB_BASE_ADDRESS<<8) + offset,						/* USB message value */
+                0x0110,													/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+        if (ret != bytelength)
+	{
+		deb_info("error try = %d, %s: offset=0x%x, error code=0x%x !\n",try_num ,__FUNCTION__, offset, ret);
+
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;
+       }
+
+	return 0;
+error:
+	return 1;
+ }
+
+
+
+
+static int 
+read_sys_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{
+	int ret = -ENOMEM;
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),		/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                (SYS_BASE_ADDRESS<<8) + offset,						/* USB message value */
+                0x0200,													/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+			
+        if (ret != bytelength)
+	{
+		deb_info(" %s: offset=0x%x, error code=0x%x !\n", __FUNCTION__, offset, ret);
+		return 1;
+       }
+
+	return 0; 
+
+  }
+
+
+static int 
+write_sys_register(
+	struct dvb_usb_device*	dib,
+	unsigned short	offset,
+	unsigned char*	data,
+	unsigned short	bytelength)
+{ 
+	int ret = -ENOMEM;
+	unsigned char try_num;
+
+	try_num = 0;	
+error_write_again:	
+	try_num++;	
+
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),		/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_OUT,										/* USB message request type value */
+                (SYS_BASE_ADDRESS<<8) + offset,						/* USB message value */
+                0x0210,													/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+		
+        if (ret != bytelength)
+	{
+		deb_info(" error try= %d, %s: offset=0x%x, error code=0x%x !\n",try_num, __FUNCTION__, offset, ret);
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;	
+        }
+
+	return 0;
+error:
+	return 1;
+ }
+
+
+
+
+int 
+read_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,	
+	unsigned char 		page,
+	unsigned char 		offset,
+	unsigned char*		data,
+	unsigned short		bytelength)
+{
+	int ret = -ENOMEM;
+	int i;
+	unsigned char	tmp;
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                demod_device_addr + (offset<<8),						/* USB message value */
+                (0x0000 + page),										/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+
+	usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                RTL2832_DEMOD_ADDR + (DUMMY_ADDR<<8),						/* USB message value */
+                (0x0000 + DUMMY_PAGE),										/* USB message index value */
+                &tmp,													/* pointer to the receive buffer */
+                LEN_1_BYTE,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+	mutex_unlock(&dib->usb_mutex);
+
+	
+	//	deb_info("%s[1345]: ret=%d, DA=0x%x, len=%d, page=%d, offset=0x%x, data=(", __FUNCTION__, ret, demod_device_addr, bytelength,page, offset);
+//		for(i = 0; i < bytelength; i++)
+//			deb_info("0x%x,", data[i]);
+//		deb_info(")\n");
+			
+        if (ret != bytelength)
+	{
+		deb_info("error!! %s: ret=%d, DA=0x%x, len=%d, page=%d, offset=0x%x, data=(", __FUNCTION__, ret, demod_device_addr, bytelength,page, offset);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data[i]);
+		deb_info(")\n");
+		
+		goto error;
+       }
+
+	return 0;  
+
+error:
+	return 1;
+}
+
+
+
+
+int
+write_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,		
+	unsigned char			page,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength)
+{
+	int ret = -ENOMEM;
+	unsigned char  i, try_num;
+	unsigned char	tmp;	
+
+	try_num = 0;	
+error_write_again:	
+	try_num++;
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+	
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),		/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_OUT,										/* USB message request type value */
+                demod_device_addr + (offset<<8),						/* USB message value */
+                (0x0010 + page),										/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+
+	usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                RTL2832_DEMOD_ADDR + (DUMMY_ADDR<<8),						/* USB message value */
+                (0x0000 + DUMMY_PAGE),										/* USB message index value */
+                &tmp,													/* pointer to the receive buffer */
+                LEN_1_BYTE,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+
+	mutex_unlock(&dib->usb_mutex);
+
+//		deb_info("%s: ret=%d, DA=0x%x, len=%d, page=%d, offset=0x%x, data=(", __FUNCTION__, ret, demod_device_addr, bytelength, page,offset);
+//		for(i = 0; i < bytelength; i++)
+//			deb_info("0x%x,", data[i]);
+//		deb_info(")\n");
+
+
+        if (ret != bytelength)
+	{
+		deb_info("error try = %d!! %s: ret=%d, DA=0x%x, len=%d, page=%d, offset=0x%x, data=(",try_num , __FUNCTION__, ret, demod_device_addr, bytelength,page,offset);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data[i]);
+		deb_info(")\n");
+	
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;
+        }
+
+	return 0;
+
+error:
+	return 1;
+ }
+
+
+
+
+
+
+int 
+read_rtl2832_tuner_register(
+	struct dvb_usb_device	*dib,
+	unsigned char			device_address,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength)
+{
+	int ret = -ENOMEM;
+ 	int i;
+	unsigned char data_tmp[128];	
+
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+	
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_IN,										/* USB message request type value */
+                device_address+(offset<<8),							/* USB message value */
+                0x0300,													/* USB message index value */
+                data_tmp,												/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+	mutex_unlock(&dib->usb_mutex);
+
+//		deb_info("%s: ret=%d, DA=0x%x, len=%d, offset=0x%x, data=(", __FUNCTION__, ret, device_address, bytelength,offset);
+//		for(i = 0; i < bytelength; i++)
+//			deb_info("0x%x,", data_tmp[i]);
+//		deb_info(")\n");
+			
+        if (ret != bytelength)
+ 	{
+		deb_info("error!! %s: ret=%d, DA=0x%x, len=%d, offset=0x%x, data=(", __FUNCTION__, ret, device_address, bytelength,offset);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data_tmp[i]);
+		deb_info(")\n");
+		
+		goto error;
+        }
+
+	memcpy(data,data_tmp,bytelength);
+
+	return 0;
+	
+error:
+	return 1;   
+	
+ 
+}
+
+int write_rtl2832_tuner_register(
+	struct dvb_usb_device *dib,
+	unsigned char			device_address,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength)
+{
+	int ret = -ENOMEM;
+	unsigned char  i, try_num;
+
+	try_num = 0;	
+error_write_again:	
+	try_num++;
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+ 
+        ret = usb_control_msg(dib->udev,								/* pointer to device */
+                usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),		/* pipe to control endpoint */
+                0,														/* USB message request value */
+                SKEL_VENDOR_OUT,										/* USB message request type value */
+                device_address+(offset<<8),							/* USB message value */
+                0x0310,													/* USB message index value */
+                data,													/* pointer to the receive buffer */
+                bytelength,												/* length of the buffer */
+                DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+	mutex_unlock(&dib->usb_mutex);
+
+//		deb_info("%s: ret=%d, DA=0x%x, len=%d, offset=0x%x, data=(", __FUNCTION__, ret, device_address, bytelength, offset);
+//		for(i = 0; i < bytelength; i++)
+//			deb_info("0x%x,", data[i]);
+//		deb_info(")\n");
+
+			
+        if (ret != bytelength)
+	{
+		deb_info("error try= %d!! %s: ret=%d, DA=0x%x, len=%d, offset=0x%x, data=(",try_num, __FUNCTION__, ret, device_address, bytelength, offset);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data[i]);
+		deb_info(")\n");
+		
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;
+       }
+
+	return 0;
+
+error:
+	return 1;
+ }
+
+
+
+
+int
+read_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength)
+{
+	int i;
+	int ret = -ENOMEM;
+	unsigned char  try_num;
+	unsigned char data_tmp[128];	
+
+	try_num = 0;	
+error_write_again:		
+	try_num ++;	
+        
+
+	if(bytelength >= 128)
+	{
+		deb_info("%s error bytelength >=128  \n", __FUNCTION__);
+		goto error;
+	}
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+	
+	ret = usb_control_msg(dib->udev,								/* pointer to device */
+		usb_rcvctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+		0,														/* USB message request value */
+		SKEL_VENDOR_IN,											/* USB message request type value */
+		dev_i2c_addr,											/* USB message value */
+		0x0600,													/* USB message index value */
+		data_tmp,												/* pointer to the receive buffer */
+		bytelength,												/* length of the buffer */
+		DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+	mutex_unlock(&dib->usb_mutex);
+ 
+	if (ret != bytelength)
+	{
+		deb_info("error try= %d!! %s: ret=%d, DA=0x%x, len=%d, data=(",try_num, __FUNCTION__, ret, dev_i2c_addr, bytelength);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data_tmp[i]);
+		deb_info(")\n");
+		
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;
+	}
+
+ 	memcpy(data,data_tmp,bytelength);
+
+	return 0;  
+error: 
+	return 1;
+
+}
+
+
+
+int 
+write_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength)
+{
+	int i;
+	int ret = -ENOMEM;  
+	unsigned char  try_num;
+
+	try_num = 0;	
+error_write_again:		
+	try_num ++;	
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	goto error;
+
+	ret = usb_control_msg(dib->udev,								/* pointer to device */
+		usb_sndctrlpipe( dib->udev,RTL2832_CTRL_ENDPOINT),			/* pipe to control endpoint */
+		0,														/* USB message request value */
+		SKEL_VENDOR_OUT,										/* USB message request type value */
+		dev_i2c_addr,											/* USB message value */
+		0x0610,													/* USB message index value */
+		data,													/* pointer to the receive buffer */
+		bytelength,												/* length of the buffer */
+		DIBUSB_I2C_TIMEOUT);									/* time to wait for the message to complete before timing out */
+
+	mutex_unlock(&dib->usb_mutex);
+ 
+	if (ret != bytelength)
+	{
+		deb_info("error try= %d!! %s: ret=%d, DA=0x%x, len=%d, data=(",try_num, __FUNCTION__, ret, dev_i2c_addr, bytelength);
+		for(i = 0; i < bytelength; i++)
+			deb_info("0x%x,", data[i]);
+		deb_info(")\n");
+		
+		if( try_num > ERROR_TRY_MAX_NUM )	goto error;
+		else				goto error_write_again;		
+
+	}
+ 
+	return 0;
+	
+error:
+	return 1;  
+	
+}
+
+
+
+
+
+
+//3for return PUCHAR value
+
+int
+read_usb_sys_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num)
+{
+	int ret = 1;
+
+	if( byte_num != 1 && byte_num !=2 && byte_num !=4)
+	{
+		deb_info("error!! %s: length = %d \n", __FUNCTION__, byte_num);
+		return 1;
+	}
+
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	return 1;
+		
+	if( type == RTD2832U_USB )
+	{
+		ret = read_usb_register( dib , byte_addr , buf , byte_num);
+	}
+	else if ( type == RTD2832U_SYS )
+	{
+		ret = read_sys_register( dib , byte_addr , buf , byte_num);
+	}
+	
+	mutex_unlock(&dib->usb_mutex);
+
+	return ret;
+	
+}
+
+
+
+int
+write_usb_sys_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num)
+{
+	int ret = 1;
+
+	if( byte_num != 1 && byte_num !=2 && byte_num !=4)
+	{
+		deb_info("error!! %s: length = %d \n", __FUNCTION__, byte_num);
+		return 1;
+	}
+
+	if( mutex_lock_interruptible(&dib->usb_mutex) )	return 1;	
+	
+	if( type == RTD2832U_USB )
+	{
+		ret = write_usb_register( dib , byte_addr , buf , byte_num);
+	}
+	else if ( type == RTD2832U_SYS )
+	{
+		ret = write_sys_register( dib , byte_addr , buf , byte_num);
+	}
+	
+	mutex_unlock(&dib->usb_mutex);	
+	
+	return ret;
+	
+}
+
+
+//3for return INT value
+int
+read_usb_sys_int_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned short	n_bytes,
+	int*	p_val)
+{
+	int	i;
+	u8	val[LEN_4_BYTE];
+	int	nbit_shift; 
+
+	*p_val= 0;
+
+	if (read_usb_sys_char_bytes( dib, type, byte_addr, val , n_bytes)) goto error;
+
+	for (i= 0; i< n_bytes; i++)
+	{				
+		nbit_shift = i<<3 ;
+		*p_val = *p_val + (val[i]<<nbit_shift );
+       }
+
+	return 0;
+error:
+	return 1;
+			
+}
+
+
+
+int
+write_usb_sys_int_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned short	n_bytes,
+	int	val)
+{
+	int	i;
+	int	nbit_shift;
+	u8	u8_val[LEN_4_BYTE];		
+
+	for (i= n_bytes- 1; i>= 0; i--)
+	{
+		nbit_shift= i << 3;		
+		u8_val[i] = (val>> nbit_shift) & 0xff;
+    	}
+
+	if( write_usb_sys_char_bytes( dib , type , byte_addr, u8_val , n_bytes) ) goto error;			
+
+	return 0;
+error:
+	return 1;
+}
+
+
+
+int
+write_rtl2836_demod_register(
+	struct dvb_usb_device* dib,
+	unsigned char			demod_device_addr,		
+	unsigned char			page,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength)
+{
+	int i;
+	unsigned char           datatmp;
+	int                            try_num;
+	switch(page)
+	{
+		//3 R/W regitser Once R/W "ONE BYTE"
+		case PAGE_0:
+		case PAGE_1:
+		case PAGE_2:
+		case PAGE_3:
+		case PAGE_4:
+			for(i=0; i<bytelength; i++)
+			{
+				try_num = 0;
+
+label_write:
+				if(write_demod_register(dib, demod_device_addr, page,  offset+i,  data+i, LEN_1_BYTE))
+					goto error;
+
+label_read:
+				if(try_num >= 4)
+					goto error;
+
+				if(read_demod_register(dib, demod_device_addr, page,  offset+i,  &datatmp, LEN_1_BYTE))
+				{
+					try_num++;
+					deb_info("%s fail read\n", __FUNCTION__);
+					goto label_read;
+				}
+				
+				if(datatmp != data[i])
+				{
+				       try_num++;
+					deb_info("%s read != write\n", __FUNCTION__);   
+					goto label_write;
+				}								
+			}
+			break;
+
+		default:
+			goto error;
+			break;
+	}
+
+	return 0;
+	
+error:
+	return 1;
+}
+
+
+
+int 
+read_rtl2836_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,	
+	unsigned char 		page,
+	unsigned char 		offset,
+	unsigned char*		data,
+	unsigned short		bytelength)
+{
+
+       int i;
+	unsigned char  tmp;
+		
+	switch(page)
+	{
+		//3 R/W regitser Once R/W "ONE BYTE"
+		case PAGE_0:
+		case PAGE_1:
+		case PAGE_2:
+		case PAGE_3:
+		case PAGE_4:
+			for(i=0; i<bytelength; i++)
+			{
+				if(read_demod_register(dib, demod_device_addr, page,  offset+i,  data+i, LEN_1_BYTE))
+					goto error;
+			}
+			break;
+				
+       	case PAGE_6:
+		case PAGE_7:
+		case PAGE_8:
+		case PAGE_9:
+			if(read_demod_register(dib, demod_device_addr, page,  offset,  data, bytelength)) 
+				goto error;
+			break;	
+
+              case PAGE_5:
+		       if(read_demod_register(dib, demod_device_addr, page,  offset,  data, bytelength)) 
+				goto error;
+
+			if(read_demod_register(dib, demod_device_addr, PAGE_0, 0x00, &tmp, LEN_1_BYTE))//read page 0
+				goto error;
+			
+		       break;
+
+		default:
+			goto error;
+			break;
+	}
+
+	return 0;
+	
+error:
+	return 1;
+
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/rtl2832u_io.h b/drivers/media/usb/rtl2832u/rtl2832u_io.h
new file mode 100644
index 00000000..0b48acb6
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/rtl2832u_io.h
@@ -0,0 +1,276 @@
+
+
+
+#ifndef __USB_SYS_RTL2832_H__
+#define __USB_SYS_RTL2832_H__
+
+#include "dvb-usb.h"
+
+extern int dvb_usb_rtl2832u_debug;
+#define deb_info(args...) dprintk(dvb_usb_rtl2832u_debug,0x01,args)
+#define deb_xfer(args...) dprintk(dvb_usb_rtl2832u_debug,0x02,args)
+#define deb_rc(args...)   dprintk(dvb_usb_rtl2832u_debug,0x03,args)
+#define LEN_1_BYTE					1
+#define LEN_2_BYTE					2
+#define LEN_4_BYTE					4
+
+
+#define	RTL2832_CTRL_ENDPOINT	0x00
+#define DIBUSB_I2C_TIMEOUT				5000
+
+#define SKEL_VENDOR_IN  (USB_DIR_IN|USB_TYPE_VENDOR)
+#define SKEL_VENDOR_OUT (USB_DIR_OUT|USB_TYPE_VENDOR)
+
+#define SYS_BASE_ADDRESS	0x30 //0x3000
+#define USB_BASE_ADDRESS	0x20 //0x2000 
+
+
+#define RTL2832_DEMOD_ADDR	0x20
+#define RTL2836_DEMOD_ADDR	0x3e
+#define RTL2840_DEMOD_ADDR	0x44
+
+
+
+typedef enum { RTD2832U_USB =1, 
+	       RTD2832U_SYS =2,
+	       RTD2832U_RC  =3	 
+	     } RegType;
+
+enum {
+	PAGE_0 = 0,
+	PAGE_1 = 1,
+	PAGE_2 = 2,
+	PAGE_3 = 3,
+	PAGE_4 = 4,	
+	PAGE_5 = 5,	
+	PAGE_6 = 6,	
+	PAGE_7 = 7,	
+	PAGE_8 = 8,	
+	PAGE_9 = 9,	
+};
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//		remote control 
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+int
+read_rc_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num);
+
+int
+write_rc_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num);
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+//3////////////////////////
+//3for return PUCHAR value
+//3///////////////////////
+
+int
+read_usb_sys_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num);
+
+
+
+int
+write_usb_sys_char_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned char*	buf,
+	unsigned short	byte_num);
+
+
+
+//3//////////////////
+//3for return INT value
+//3//////////////////
+
+int
+read_usb_sys_int_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned short	n_bytes,
+	int*	p_val);
+
+
+int
+write_usb_sys_int_bytes(
+	struct dvb_usb_device*	dib,
+	RegType	type,
+	unsigned short	byte_addr,
+	unsigned short	n_bytes,
+	int	val);
+
+
+/////////////////////////////////////////////////////////////////////////////////////////
+//	Remote Control
+////////////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////
+
+void
+platform_wait(
+	unsigned long nMinDelayTime);
+
+
+
+#if 0
+//3//////////////////
+//3for std i2c r/w
+//3//////////////////
+
+int
+read_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength);
+
+int 
+write_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength);
+
+#endif
+
+
+
+int 
+read_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,	
+	unsigned char 		page,
+	unsigned char 		offset,
+	unsigned char*		data,
+	unsigned short		bytelength);
+
+
+
+
+int
+write_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,		
+	unsigned char			page,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength);
+
+
+
+int 
+read_rtl2832_tuner_register(
+	struct dvb_usb_device	*dib,
+	unsigned char			device_address,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength);
+
+
+
+
+int write_rtl2832_tuner_register(
+	struct dvb_usb_device *dib,
+	unsigned char			device_address,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength);
+
+
+
+
+
+int 
+	write_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength);
+
+
+
+int
+	read_rtl2832_stdi2c(
+	struct dvb_usb_device*	dib,
+	unsigned short			dev_i2c_addr,
+	unsigned char*			data,
+	unsigned short			bytelength);
+
+
+int
+write_rtl2836_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,		
+	unsigned char			page,
+	unsigned char			offset,
+	unsigned char			*data,
+	unsigned short		bytelength);
+
+
+int 
+read_rtl2836_demod_register(
+	struct dvb_usb_device*dib,
+	unsigned char			demod_device_addr,	
+	unsigned char 		page,
+	unsigned char 		offset,
+	unsigned char*		data,
+	unsigned short		bytelength);
+
+
+
+////////////////////////////////////
+
+#define BIT0		0x00000001
+#define BIT1		0x00000002
+#define BIT2		0x00000004
+#define BIT3		0x00000008
+#define BIT4		0x00000010
+#define BIT5		0x00000020
+#define BIT6		0x00000040
+#define BIT7		0x00000080
+#define BIT8		0x00000100
+#define BIT9		0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+#endif
+
+
+
diff --git a/drivers/media/usb/rtl2832u/si2168rtl.c b/drivers/media/usb/rtl2832u/si2168rtl.c
new file mode 100644
index 00000000..8ed0026f
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/si2168rtl.c
@@ -0,0 +1,9473 @@
+#include "rtl2832u_fe.h"
+#include "si2168rtl.h"
+
+unsigned char Si2168_L1_API_Init(L1_Si2168_Context *api,unsigned char add)
+{
+	api->i2c    = &(api->i2cObj);
+	api->cmd    = &(api->cmdObj);
+	api->rsp    = &(api->rspObj);
+	api->prop   = &(api->propObj);
+	api->status = &(api->statusObj);
+	api->addr   = add;
+	return 0;
+}
+
+const char Si2146_chiprev          =  1;
+/* Last 2 digits of part number */
+const char Si2146_part             =  46; /* Change this value if using a chip other than an Si2146 */
+const char Si2146_partMajorVersion = '1';
+const char Si2146_partMinorVersion = '0';
+const char Si2146_partRomid        =  0x11;
+
+unsigned char Si2146_L1_API_Init(L1_Si2146_Context *api,unsigned char add)
+{
+	api->i2c = &(api->i2cObj);
+	api->cmd    = &(api->cmdObj);
+	api->rsp    = &(api->rspObj);
+	api->prop   = &(api->propObj);
+	api->status = &(api->statusObj);
+	api->part             = Si2146_part;
+	api->chiprev          = Si2146_chiprev;
+	api->partMajorVersion = Si2146_partMajorVersion;
+	api->partMinorVersion = Si2146_partMinorVersion;
+	api->partRomid        = Si2146_partRomid;
+	api->addr             = add;
+	return 0;
+}
+
+const char Si2148_chiprev          =  1;
+/* Last 2 digits of part number */
+const char Si2148_part             =  48; /* Change this value if using a chip other than a Si2148 */
+const char Si2148_partMajorVersion = '2';
+const char Si2148_partMinorVersion = '0';
+const char Si2148_partRomid        =  0x33;
+
+unsigned char Si2148_L1_API_Init(L1_Si2148_Context *api,unsigned char add)
+{
+	api->i2c = &(api->i2cObj);
+	api->cmd    = &(api->cmdObj);
+	api->rsp    = &(api->rspObj);
+	api->prop   = &(api->propObj);
+	api->status = &(api->statusObj);
+	api->part             = Si2148_part;
+	api->chiprev          = Si2148_chiprev;
+	api->partMajorVersion = Si2148_partMajorVersion;
+	api->partMinorVersion = Si2148_partMinorVersion;
+	api->partRomid        = Si2148_partRomid;
+	api->addr             = add;
+	return 0;
+}
+
+//Yann 2146/2148
+#if SiTuner==2146
+#define L1_RF_TER_TUNER_Init(api,add) Si2146_L1_API_Init(api, add);
+#else
+#define L1_RF_TER_TUNER_Init(api,add) Si2148_L1_API_Init(api, add);
+#endif
+int fef_selection;
+int fef_mode;
+#define Si2168_FEF_MODE_SLOW_NORMAL_AGC  0
+#define Si2168_FEF_MODE_FREEZE_PIN       1
+#define Si2168_FEF_MODE_SLOW_INITIAL_AGC 2
+#define Si2168_FEF_MODE Si2168_FEF_MODE_FREEZE_PIN
+
+#define Si2168_CLOCK_MODE_TER              Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO
+#define Si2168_REF_FREQUENCY_TER           24
+
+char Si2168_L2_SW_Init(Si2168_L2_Context *front_end,unsigned char demodAdd,unsigned char tunerAdd_Ter)
+{
+	char infoStringBuffer[1000];
+	char *infoString;
+	infoString = &(infoStringBuffer[0]);
+	// Pointers initialization
+	front_end->demod     = &(front_end->demodObj    );
+	front_end->Si2168_init_done    = 0;
+	front_end->first_init_done     = 0;
+	front_end->tuner_ter = &(front_end->tuner_terObj);
+	front_end->TER_init_done       = 0;
+	front_end->TER_tuner_init_done = 1;
+
+	// Calling underlying SW initialization functions
+	Si2168_L1_API_Init      (front_end->demod, demodAdd);
+	L1_RF_TER_TUNER_Init    (front_end->tuner_ter, tunerAdd_Ter);
+	fef_mode      = Si2168_FEF_MODE_SLOW_NORMAL_AGC;
+	fef_selection = Si2168_FEF_MODE;
+	// If the TER tuner has an AGC freeze pin and it's the selected mode, activate it
+	if (fef_selection == Si2168_FEF_MODE_FREEZE_PIN )
+		fef_mode = Si2168_FEF_MODE_SLOW_INITIAL_AGC;
+	return 1;
+}
+
+void Si2168_L2_HW_Connect(Si2168_L2_Context *front_end,CONNECTION_TYPE mode)
+{
+}
+
+char SiLabs_API_HW_Connect(SILABS_FE_Context *front_end,CONNECTION_TYPE connection_mode)
+{
+	if(front_end->chip==2168)
+		Si2168_L2_HW_Connect(front_end->Si2168_FE,connection_mode);
+	return 1;
+}
+
+int Silabs_init_done=0;
+L0_Context* WrapperI2C;
+L0_Context  WrapperI2C_context;
+SILABS_FE_Context FrontEnd_Table[1];
+SILABS_FE_Context *front_end;
+CUSTOM_Status_Struct FE_Status;
+CUSTOM_Status_Struct *custom_status;
+CONNECTION_TYPE mode;
+int last_standard;
+int last_freq;
+int last_bandwidth_Hz;
+int last_stream;
+int last_symbol_rate_bps;
+int last_constellation;
+
+char SiLabs_API_SW_Init(SILABS_FE_Context *front_end,unsigned char demodAdd,unsigned char tunerAdd_Ter)
+{
+	int chip;
+	chip=2168;
+	front_end->standard=-1;
+	WrapperI2C=&WrapperI2C_context;
+	WrapperI2C->indexSize=0;
+	WrapperI2C->mustReadWithoutStop=0;
+	if(chip==2168)
+	{
+		front_end->Si2168_FE=&(front_end->Si2168_FE_Obj);
+		if(Si2168_L2_SW_Init(front_end->Si2168_FE,demodAdd,tunerAdd_Ter))
+		{
+			front_end->chip=chip;
+			Silabs_init_done=1;
+			return 1;
+		}
+		else
+			return 0;
+	}
+	return 0;
+}
+
+//DEVICE_CONTROL_STRUCT *g_pContext=NULL;
+struct rtl2832_state* g_p_state=NULL;
+
+void WriteI2C(unsigned char addr,int nSize,unsigned char* pBuffer)
+{
+	//printk("Write:%x,%x\n",addr,*pBuffer);
+	//STDI2CWrite(g_pContext,addr,pBuffer,nSize);
+	write_rtl2832_stdi2c(g_p_state->d, addr , pBuffer, nSize);
+}
+
+void ReadI2C(unsigned char addr,int nSize,unsigned char* pBuffer)
+{
+	//STDI2CRead(g_pContext,addr,pBuffer,nSize);
+	read_rtl2832_stdi2c(g_p_state->d, addr, pBuffer, nSize);
+}
+
+unsigned char Si2168_CurrentResponseStatus(L1_Si2168_Context *api,unsigned char ptDataBuffer)
+{
+	api->status->ddint   = ((ptDataBuffer >> 0 ) & 0x01);
+	api->status->scanint = ((ptDataBuffer >> 1 ) & 0x01);
+	api->status->err     = ((ptDataBuffer >> 6 ) & 0x01);
+	api->status->cts     = ((ptDataBuffer >> 7 ) & 0x01);
+	return (api->status->err ? 5 : 0);
+}
+
+unsigned char Si2168_pollForResponse(L1_Si2168_Context *api,unsigned int nbBytes,unsigned char *pByteBuffer)
+{
+	int i;
+	for(i=0;i<100;i++)
+	{ // wait a maximum of 1000ms
+		ReadI2C(api->addr,nbBytes,pByteBuffer);
+		//printk("%x,%d,%x\n",api->addr,nbBytes,pByteBuffer[0]);
+		// return response err flag if CTS set
+		if(pByteBuffer[0] & 0x80)
+			return Si2168_CurrentResponseStatus(api, pByteBuffer[0]);
+		MyDelay(10);
+	}
+	return 4;
+}
+
+unsigned char Si2168_L1_I2C_PASSTHROUGH(L1_Si2168_Context *api,unsigned char subcode,unsigned char i2c_passthru,unsigned char reserved)
+{
+	//unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[3];
+	api->rsp->i2c_passthrough.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_I2C_PASSTHROUGH_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode      & Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MASK      ) << Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_LSB     );
+	cmdByteBuffer[2] = (unsigned char) ( ( i2c_passthru & Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK ) << Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB|
+										( reserved     & Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MASK     ) << Si2168_I2C_PASSTHROUGH_CMD_RESERVED_LSB    );
+	WriteI2C(api->addr,3,cmdByteBuffer);
+	return 0;
+}
+
+unsigned char Si2168_L2_Tuner_I2C_Enable(Si2168_L2_Context *front_end)
+{
+	return Si2168_L1_I2C_PASSTHROUGH(front_end->demod,Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE,Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN,Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+	//return Si2168_L1_I2C_PASSTHROUGH(front_end->demod,Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE,Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE,Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+
+unsigned char Si2168_L2_Tuner_I2C_Disable(Si2168_L2_Context *front_end)
+{
+	return Si2168_L1_I2C_PASSTHROUGH(front_end->demod,Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE,Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN,Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+
+unsigned char Si2168_L1_POWER_DOWN(L1_Si2168_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[1];
+	api->rsp->power_down.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_POWER_DOWN_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2168_STANDBY(L1_Si2168_Context *api)
+{
+	return Si2168_L1_POWER_DOWN(api);
+}
+
+int Si2168_Media(L1_Si2168_Context *api,int modulation)
+{
+	switch(modulation)
+	{
+		default:
+		case Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT:
+		{
+			switch (api->prop->dd_mode.auto_detect)
+			{
+				default:
+				case Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2:
+					return Si2168_TERRESTRIAL;
+					break;
+			}
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC :
+			return Si2168_TERRESTRIAL;
+			break;
+	}
+	return 0;
+}
+
+unsigned char Si2168_L1_START_CLK(L1_Si2168_Context *api,unsigned char subcode,unsigned char reserved1,unsigned char tune_cap,unsigned char reserved2,unsigned int clk_mode,unsigned char reserved3,unsigned char reserved4,unsigned char start_clk)
+{
+	//unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[13];
+	api->rsp->start_clk.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_START_CLK_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode   & Si2168_START_CLK_CMD_SUBCODE_MASK   ) << Si2168_START_CLK_CMD_SUBCODE_LSB  );
+	cmdByteBuffer[2] = (unsigned char) ( ( reserved1 & Si2168_START_CLK_CMD_RESERVED1_MASK ) << Si2168_START_CLK_CMD_RESERVED1_LSB);
+	cmdByteBuffer[3] = (unsigned char) ( ( tune_cap  & Si2168_START_CLK_CMD_TUNE_CAP_MASK  ) << Si2168_START_CLK_CMD_TUNE_CAP_LSB |
+										 ( reserved2 & Si2168_START_CLK_CMD_RESERVED2_MASK ) << Si2168_START_CLK_CMD_RESERVED2_LSB);
+	cmdByteBuffer[4] = (unsigned char) ( ( clk_mode  & Si2168_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168_START_CLK_CMD_CLK_MODE_LSB );
+	cmdByteBuffer[5] = (unsigned char) ((( clk_mode  & Si2168_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168_START_CLK_CMD_CLK_MODE_LSB )>>8);
+	cmdByteBuffer[6] = (unsigned char) ( ( reserved3 & Si2168_START_CLK_CMD_RESERVED3_MASK ) << Si2168_START_CLK_CMD_RESERVED3_LSB);
+	cmdByteBuffer[7] = (unsigned char) ( ( reserved4 & Si2168_START_CLK_CMD_RESERVED4_MASK ) << Si2168_START_CLK_CMD_RESERVED4_LSB);
+	cmdByteBuffer[8] = (unsigned char)0x00;
+	cmdByteBuffer[9] = (unsigned char)0x00;
+	cmdByteBuffer[10] = (unsigned char)0x00;
+	cmdByteBuffer[11] = (unsigned char)0x00;
+	cmdByteBuffer[12] = (unsigned char) ( ( start_clk & Si2168_START_CLK_CMD_START_CLK_MASK ) << Si2168_START_CLK_CMD_START_CLK_LSB);
+	WriteI2C(api->addr,13,cmdByteBuffer);
+	return 0;
+}
+
+unsigned char Si2168_L1_POWER_UP(L1_Si2168_Context *api,unsigned char subcode,unsigned char reset,unsigned char reserved2,unsigned char reserved4,unsigned char reserved1,unsigned char addr_mode,unsigned char reserved5,unsigned char func,unsigned char clock_freq,unsigned char ctsien,unsigned char wake_up)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[8];
+	unsigned char rspByteBuffer[1];
+	api->rsp->power_up.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_POWER_UP_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2168_POWER_UP_CMD_SUBCODE_MASK    ) << Si2168_POWER_UP_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (unsigned char) ( ( reset      & Si2168_POWER_UP_CMD_RESET_MASK      ) << Si2168_POWER_UP_CMD_RESET_LSB     );
+	cmdByteBuffer[3] = (unsigned char) ( ( reserved2  & Si2168_POWER_UP_CMD_RESERVED2_MASK  ) << Si2168_POWER_UP_CMD_RESERVED2_LSB );
+	cmdByteBuffer[4] = (unsigned char) ( ( reserved4  & Si2168_POWER_UP_CMD_RESERVED4_MASK  ) << Si2168_POWER_UP_CMD_RESERVED4_LSB );
+	cmdByteBuffer[5] = (unsigned char) ( ( reserved1  & Si2168_POWER_UP_CMD_RESERVED1_MASK  ) << Si2168_POWER_UP_CMD_RESERVED1_LSB |
+										 ( addr_mode  & Si2168_POWER_UP_CMD_ADDR_MODE_MASK  ) << Si2168_POWER_UP_CMD_ADDR_MODE_LSB |
+										 ( reserved5  & Si2168_POWER_UP_CMD_RESERVED5_MASK  ) << Si2168_POWER_UP_CMD_RESERVED5_LSB );
+	cmdByteBuffer[6] = (unsigned char) ( ( func       & Si2168_POWER_UP_CMD_FUNC_MASK       ) << Si2168_POWER_UP_CMD_FUNC_LSB      |
+										 ( clock_freq & Si2168_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2168_POWER_UP_CMD_CLOCK_FREQ_LSB|
+										 ( ctsien     & Si2168_POWER_UP_CMD_CTSIEN_MASK     ) << Si2168_POWER_UP_CMD_CTSIEN_LSB    );
+	cmdByteBuffer[7] = (unsigned char) ( ( wake_up    & Si2168_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2168_POWER_UP_CMD_WAKE_UP_LSB   );
+	WriteI2C(api->addr,8,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2168_WAKEUP(L1_Si2168_Context *api)
+{
+	int return_code;
+	int media;
+	return_code = 0;
+	media=Si2168_Media(api,api->standard);
+	// Clock source selection
+	switch (media)
+	{
+		default:
+		case Si2168_TERRESTRIAL:
+			api->cmd->start_clk.clk_mode = Si2168_CLOCK_MODE_TER;
+			break;
+	}
+	Si2168_L1_START_CLK(api,Si2168_START_CLK_CMD_SUBCODE_CODE,Si2168_START_CLK_CMD_RESERVED1_RESERVED,Si2168_START_CLK_CMD_TUNE_CAP_15P6,Si2168_START_CLK_CMD_RESERVED2_RESERVED,api->cmd->start_clk.clk_mode,Si2168_START_CLK_CMD_RESERVED3_RESERVED,Si2168_START_CLK_CMD_RESERVED4_RESERVED,Si2168_START_CLK_CMD_START_CLK_START_CLK);
+	// Reference frequency selection
+	switch(media)
+	{
+		default:
+		case Si2168_TERRESTRIAL:
+			api->cmd->power_up.clock_freq = Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ;
+			break;
+	}
+	return_code=Si2168_L1_POWER_UP(api,Si2168_POWER_UP_CMD_SUBCODE_CODE,api->cmd->power_up.reset,Si2168_POWER_UP_CMD_RESERVED2_RESERVED,Si2168_POWER_UP_CMD_RESERVED4_RESERVED,Si2168_POWER_UP_CMD_RESERVED1_RESERVED,Si2168_POWER_UP_CMD_ADDR_MODE_CURRENT,Si2168_POWER_UP_CMD_RESERVED5_RESERVED,api->cmd->power_up.func,api->cmd->power_up.clock_freq,Si2168_POWER_UP_CMD_CTSIEN_DISABLE,Si2168_POWER_UP_CMD_WAKE_UP_WAKE_UP);
+	// After a successful POWER_UP, set values for 'resume' only
+	api->cmd->power_up.reset = Si2168_POWER_UP_CMD_RESET_RESUME;
+	api->cmd->power_up.func  = Si2168_POWER_UP_CMD_FUNC_NORMAL;
+	return 0;
+}
+
+unsigned char Si2168_L1_PART_INFO(L1_Si2168_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[13];
+	api->rsp->part_info.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_PART_INFO_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 13, rspByteBuffer);
+	//printk("%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n",rspByteBuffer[0],rspByteBuffer[1],rspByteBuffer[2],rspByteBuffer[3],
+	//	rspByteBuffer[4],rspByteBuffer[5],rspByteBuffer[6],rspByteBuffer[7],rspByteBuffer[8],rspByteBuffer[9],rspByteBuffer[10],
+	//	rspByteBuffer[11],rspByteBuffer[12]);
+	if (error_code)
+		return error_code;
+	api->rsp->part_info.chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2168_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2168_PART_INFO_RESPONSE_CHIPREV_MASK  );
+	api->rsp->part_info.part     =   (( ( (rspByteBuffer[2]  )) >> Si2168_PART_INFO_RESPONSE_PART_LSB     ) & Si2168_PART_INFO_RESPONSE_PART_MASK     );
+	api->rsp->part_info.pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2168_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2168_PART_INFO_RESPONSE_PMAJOR_MASK   );
+	api->rsp->part_info.pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2168_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2168_PART_INFO_RESPONSE_PMINOR_MASK   );
+	api->rsp->part_info.pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2168_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2168_PART_INFO_RESPONSE_PBUILD_MASK   );
+	api->rsp->part_info.reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2168_PART_INFO_RESPONSE_RESERVED_MASK );
+	api->rsp->part_info.serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2168_PART_INFO_RESPONSE_SERIAL_MASK   );
+	api->rsp->part_info.romid    =   (( ( (rspByteBuffer[12] )) >> Si2168_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2168_PART_INFO_RESPONSE_ROMID_MASK    );
+	return 0;
+}
+
+#define Si2168_PATCH_2_0b24_PART    68
+#define Si2168_PATCH_2_0b24_ROM      2
+#define Si2168_PATCH_2_0b24_PMAJOR  '2'
+#define Si2168_PATCH_2_0b24_PMINOR  '0'
+#define Si2168_PATCH_2_0b24_PBUILD   3
+
+unsigned char Si2168_PATCH_2_0b24[] = {
+0x04,0x01,0x00,0x00,0x00,0x00,0x8A,0x21,
+0x05,0xAA,0xFE,0x96,0x5A,0x7D,0x2C,0x55,
+0x22,0xBD,0x23,0x2C,0xD3,0xC8,0x67,0xB1,
+0x05,0x99,0xFA,0x9E,0x38,0x88,0x8F,0x60,
+0x27,0x97,0xD9,0x55,0xC8,0x10,0xAD,0x16,
+0x24,0x97,0xA5,0xD8,0x29,0x84,0xA8,0xAC,
+0x05,0x2C,0xE8,0x37,0x2A,0xEB,0xDD,0xEE,
+0x27,0x43,0x56,0x67,0x35,0x36,0x21,0xED,
+0x27,0x23,0x21,0xC9,0x97,0x1F,0xDD,0xE2,
+0x05,0x6C,0x6D,0x76,0xF2,0xC4,0x79,0xEC,
+0x2F,0x15,0x45,0x75,0xDE,0x05,0x89,0x3A,
+0x21,0x1A,0x30,0x32,0xFC,0xB6,0x2B,0xA0,
+0x05,0xBE,0xE3,0xF8,0x8D,0x78,0x94,0xEE,
+0x2D,0xEE,0x26,0x2D,0xE0,0x6F,0x2E,0xC7,
+0x05,0xFD,0x26,0xE2,0x8A,0xD9,0x62,0xBA,
+0x2A,0x7E,0x48,0x9D,0x77,0xC0,0x36,0xBA,
+0x05,0x1E,0x7A,0xC6,0x7B,0x2D,0xD6,0x40,
+0x2F,0xBA,0x7E,0xB2,0xA2,0x48,0xEC,0xD4,
+0x2F,0xE8,0xF8,0x6E,0x87,0x9D,0x34,0xE3,
+0x2E,0xD4,0xAC,0x3E,0x3C,0x3E,0xAB,0xF9,
+0x05,0x71,0xE4,0x29,0x62,0xE7,0xE8,0x93,
+0x22,0xD5,0xF0,0xDF,0x4A,0xAF,0x9D,0x17,
+0x05,0xBD,0x59,0x32,0xDC,0x79,0x66,0x54,
+0x27,0xFD,0x47,0x3F,0x13,0xD6,0x57,0x02,
+0x2F,0x14,0x8C,0x5E,0xF6,0x00,0x0D,0x00,
+0x2F,0x62,0x49,0xDF,0x36,0x42,0x82,0x80,
+0x2F,0x41,0x4B,0xB3,0x98,0xF0,0xFE,0x54,
+0x27,0x8C,0xD5,0x4F,0x0E,0x54,0xF9,0x2D,
+0x23,0x43,0x01,0xFB,0x92,0xB0,0x44,0x59,
+0x05,0x24,0x27,0xCC,0x59,0xDC,0xE4,0x27,
+0x22,0xD5,0xB1,0xC3,0x70,0x73,0x24,0x6F,
+0x05,0x35,0xD2,0xDB,0xEB,0xA0,0x1D,0xD3,
+0x25,0x46,0xDD,0x8D,0x7A,0xF8,0x3E,0x55,
+0x05,0x61,0xF2,0x26,0x52,0x01,0x1E,0x17,
+0x22,0xC9,0x4D,0xA8,0x99,0x79,0xBA,0x48,
+0x05,0xDB,0xE1,0x13,0x0C,0x42,0x0C,0x54,
+0x2F,0xAF,0xF7,0xFD,0x6A,0x0B,0x75,0x28,
+0x27,0x80,0xC6,0xBC,0xEF,0xC5,0x37,0x07,
+0x27,0x89,0x05,0x88,0xCD,0x98,0xCD,0xDB,
+0x27,0x3D,0xC9,0x14,0xF7,0xB9,0x6A,0xFF,
+0x2F,0x28,0x82,0xA9,0x10,0x79,0x5B,0x6B,
+0x27,0x09,0xD9,0x1C,0xD4,0x45,0xB6,0x12,
+0x2F,0xC1,0x02,0x8B,0x05,0x66,0xCE,0x5B,
+0x2F,0x60,0x26,0xFD,0x7C,0x89,0xCD,0x1E,
+0x27,0xCC,0x4A,0x4A,0x3D,0xEC,0x3A,0x4A,
+0x2F,0x48,0x2A,0x92,0x66,0x9E,0x7C,0x42,
+0x27,0x68,0x46,0x49,0x7A,0x30,0x8D,0x81,
+0x27,0x76,0x40,0x77,0x9D,0x98,0x7A,0x55,
+0x2F,0xB4,0x0E,0x3D,0x7D,0x3A,0xB3,0x04,
+0x2F,0x3A,0x1A,0x32,0x92,0xAA,0x09,0x18,
+0x2F,0x2D,0xF3,0xFB,0xE9,0x55,0xB6,0x6E,
+0x27,0x77,0xA8,0xC8,0xA8,0x2D,0x58,0xA1,
+0x27,0xE2,0x9C,0x90,0x65,0x92,0x57,0xD9,
+0x27,0xE4,0xB1,0x5D,0x30,0xCF,0x7B,0xEE,
+0x2F,0x03,0xCC,0xA9,0x81,0xA4,0xB7,0xCF,
+0x27,0x57,0x38,0x33,0x90,0xC0,0x04,0x33,
+0x2F,0xF7,0xB1,0x71,0xEB,0x54,0xAE,0x11,
+0x27,0xC4,0x93,0x2B,0x19,0xEF,0xD4,0xA5,
+0x2F,0xB5,0x95,0xD6,0x12,0x6D,0x6A,0x04,
+0x2F,0xBA,0xAF,0x32,0xA0,0xED,0x0C,0x2D,
+0x2F,0x4D,0xB5,0x2F,0x5A,0x37,0xFE,0x88,
+0x2F,0xFE,0xB6,0x7D,0xFC,0xAE,0x96,0x72,
+0x27,0xCD,0x44,0x28,0x6D,0x10,0x4C,0xB1,
+0x27,0xCD,0xA7,0x54,0xC8,0xE7,0x93,0x4C,
+0x2F,0x8A,0xCC,0x94,0x7B,0x80,0xF4,0x7B,
+0x2F,0x93,0x77,0x1F,0x78,0xC6,0x67,0x17,
+0x2F,0x0A,0xE8,0xC2,0x0F,0xB1,0xFB,0x48,
+0x2F,0x9E,0xFF,0x07,0x0D,0x9A,0x6B,0x47,
+0x2F,0x5C,0x54,0x24,0x89,0x63,0x73,0xFF,
+0x2F,0x9B,0x0A,0x77,0xBD,0x82,0xC5,0x0F,
+0x2F,0x9D,0xA7,0x6A,0x95,0xEA,0xA6,0x0C,
+0x2F,0xE1,0xCF,0x93,0xAA,0x74,0xA3,0x6D,
+0x27,0x6B,0xAC,0x02,0x01,0x0A,0x0C,0xA4,
+0x2F,0x63,0xE5,0x30,0x29,0xE7,0xC1,0x43,
+0x27,0x8B,0x56,0xF4,0xA4,0x29,0xB5,0xD7,
+0x2F,0x5A,0xA0,0x01,0xFB,0xFB,0xBA,0xDA,
+0x27,0x1B,0x43,0x6A,0x26,0x2D,0x25,0x40,
+0x27,0x61,0xA2,0xC8,0x31,0xF0,0x28,0xAB,
+0x27,0x34,0x76,0x5E,0xC2,0xDF,0x1A,0xB0,
+0x27,0xF5,0xA9,0x30,0x34,0xC5,0x7F,0x15,
+0x27,0x1A,0x10,0x11,0x56,0xFD,0x37,0x31,
+0x2F,0xB2,0x65,0xA1,0xE8,0x22,0xCD,0x51,
+0x27,0xFE,0xB1,0xB3,0x85,0xC1,0x17,0x28,
+0x27,0xDF,0x74,0x34,0x02,0x1E,0x1D,0x21,
+0x2F,0xF7,0xFA,0xD1,0xF3,0x97,0xBB,0x55,
+0x27,0xDF,0x27,0x22,0x00,0x5E,0x6B,0x20,
+0x2F,0x01,0x10,0xB0,0xE8,0xA0,0x7C,0xF8,
+0x27,0xC8,0x61,0x06,0x96,0x51,0xAE,0x42,
+0x2F,0x98,0x07,0x34,0xA9,0x1F,0xFE,0xC6,
+0x2F,0xED,0x00,0xD4,0x6B,0x5F,0x30,0xA9,
+0x2F,0x98,0x4C,0xFD,0xAD,0x47,0x69,0x80,
+0x27,0x99,0x68,0x87,0xD8,0xC2,0xD0,0xC6,
+0x27,0xDE,0xCF,0x60,0xD2,0x17,0x45,0xCF,
+0x2F,0x4C,0x45,0xF4,0x3F,0xFD,0xD2,0xCB,
+0x2F,0x57,0x54,0x40,0x82,0xAF,0x50,0xD1,
+0x2F,0x8B,0x2E,0x94,0x90,0x13,0xA2,0x1B,
+0x2F,0xA5,0x67,0xD0,0xA8,0x16,0x85,0x6A,
+0x2F,0x9E,0xD2,0x61,0xA6,0x35,0xF6,0x3F,
+0x2F,0x09,0xB0,0xEA,0x57,0x1F,0x94,0x08,
+0x27,0xB8,0xD3,0x88,0x3B,0x03,0x1C,0x27,
+0x27,0x98,0x0C,0x57,0xA7,0xDD,0x2F,0xD7,
+0x27,0x43,0x0E,0xF1,0x6D,0x8D,0xDD,0x4A,
+0x2F,0xF6,0x3C,0x17,0xF4,0x35,0x2B,0x9C,
+0x27,0x7C,0x73,0x4C,0x2E,0xD2,0x20,0xFF,
+0x2F,0xB0,0xB7,0x74,0xD9,0x3D,0xA6,0xBD,
+0x27,0x9D,0x64,0x34,0x8B,0x34,0xF0,0xC4,
+0x27,0x05,0xEB,0x70,0x17,0xDE,0xB5,0x0D,
+0x2F,0x66,0x35,0x08,0x18,0x1D,0xA0,0xDE,
+0x27,0x2F,0x20,0xAD,0xD4,0x97,0x09,0xC2,
+0x27,0x41,0x6A,0xB4,0x1D,0x67,0xBC,0xC6,
+0x2F,0x33,0x7B,0x85,0xED,0xE1,0xF9,0x85,
+0x2F,0x3E,0x69,0x08,0xEA,0x54,0x04,0xBC,
+0x2F,0xD6,0x55,0xDE,0x27,0x5D,0xE2,0xC8,
+0x2F,0xAF,0xBE,0x48,0x93,0x3F,0xFE,0x1D,
+0x27,0xBF,0xC7,0x89,0xB5,0xBF,0x5F,0x94,
+0x2F,0x2E,0x1E,0x4D,0xC8,0xD3,0x4E,0xCD,
+0x2F,0xB4,0xCD,0x60,0x43,0xD0,0x25,0xA0,
+0x27,0x56,0x3C,0x0B,0xF9,0xE0,0x29,0x96,
+0x2F,0x66,0x01,0xCB,0xFE,0x8F,0x33,0xB3,
+0x27,0x69,0xED,0xCD,0x61,0xA6,0xC6,0xC9,
+0x27,0xB0,0x5A,0xA0,0xD0,0xB3,0xAC,0xFE,
+0x27,0x51,0x68,0x31,0x4E,0x4C,0x73,0x7F,
+0x27,0x69,0x78,0xBB,0x41,0xF0,0x9F,0x50,
+0x2F,0xBB,0xC9,0xD3,0xFA,0xF4,0x00,0x22,
+0x27,0x4A,0x69,0x14,0x2E,0xF4,0x41,0x9E,
+0x2F,0x73,0xE1,0xB8,0x6F,0x4E,0xE1,0x8A,
+0x27,0xA5,0x4A,0x39,0x7A,0x2E,0x69,0x90,
+0x2F,0x13,0x67,0x0B,0x45,0x18,0xE5,0xE0,
+0x2F,0x06,0xD0,0x43,0xF2,0xE5,0x1A,0x50,
+0x2F,0x19,0xBC,0x17,0xE1,0xC7,0xE0,0xB9,
+0x27,0x8A,0xDA,0x52,0x8A,0x1C,0x32,0x6F,
+0x2F,0xBC,0xCE,0x67,0x43,0x82,0x5A,0xF7,
+0x2F,0x6B,0xD8,0x23,0x7F,0x9A,0x56,0xB8,
+0x27,0x91,0xD0,0xAD,0x11,0x04,0x99,0x39,
+0x2F,0x8A,0x9D,0x6A,0x20,0x3B,0x4E,0x81,
+0x27,0x09,0xDF,0x21,0x49,0x52,0x0B,0xF7,
+0x27,0x12,0xEC,0x17,0x87,0x6D,0x5A,0x5E,
+0x2F,0xAC,0xB7,0x41,0xC6,0x61,0xBA,0xCF,
+0x27,0x87,0xAB,0xFE,0xF4,0x16,0x2A,0xC5,
+0x27,0x59,0x06,0xF8,0x70,0x4A,0x56,0x30,
+0x2F,0x56,0x3C,0x0D,0xFB,0x3D,0xAC,0x9D,
+0x27,0x4F,0x8F,0x10,0x13,0x84,0x0F,0x38,
+0x2F,0x55,0xAF,0x3F,0x0E,0xB5,0x46,0x96,
+0x2F,0x0D,0x51,0x5E,0x4F,0xBF,0x1E,0xF2,
+0x2F,0x3E,0xED,0xAB,0x31,0xAE,0xC2,0xEB,
+0x27,0xBD,0xA1,0xE9,0xBE,0x7D,0xFF,0xFB,
+0x27,0x2E,0x88,0xA1,0x1F,0x0D,0x66,0x2A,
+0x27,0xEF,0x5A,0xE6,0xB7,0xFC,0x60,0x7D,
+0x2F,0xCD,0xA1,0xC9,0x9F,0x68,0x0E,0xA4,
+0x2F,0x9F,0x36,0x3F,0x23,0xC8,0xD2,0x0C,
+0x2F,0x72,0xE1,0x3C,0x07,0xAB,0xC8,0xE6,
+0x27,0x85,0x54,0x1E,0xF2,0xC8,0x36,0x65,
+0x27,0x70,0x5D,0x3E,0x73,0x46,0x50,0xFD,
+0x2F,0x24,0x0F,0xB0,0x3A,0xB3,0xAE,0x58,
+0x27,0x2D,0x1F,0xB6,0x65,0xA0,0x45,0x41,
+0x27,0x5C,0x19,0x56,0xEE,0x6A,0x31,0xD9,
+0x2F,0xA5,0x61,0x84,0xD3,0x02,0xB4,0x7A,
+0x27,0x29,0xDA,0x79,0xF1,0x4A,0x78,0x37,
+0x27,0x9A,0x7A,0x92,0xA8,0x49,0x52,0x96,
+0x2F,0xBE,0xD3,0x7E,0xE9,0x61,0xAF,0x5B,
+0x27,0x1F,0x07,0x68,0x35,0x73,0xBA,0x0B,
+0x2F,0xA9,0x72,0xE1,0x04,0x7A,0xDD,0x31,
+0x27,0xBD,0x06,0x1E,0xEF,0xC2,0xA3,0x17,
+0x2F,0x2E,0x67,0x79,0x0E,0xE8,0x79,0xA8,
+0x27,0x2F,0x20,0x0D,0x82,0x5D,0x8C,0xDD,
+0x27,0x01,0xE4,0x8F,0xDC,0xED,0x12,0x3D,
+0x2F,0x48,0xCB,0x3B,0x55,0x74,0xA2,0x42,
+0x27,0x05,0xCB,0x3F,0x54,0x13,0xC0,0x9B,
+0x27,0x9A,0x29,0x8F,0xD2,0x86,0x49,0x5D,
+0x27,0x0B,0xDC,0xE6,0xA5,0x81,0xE4,0xD7,
+0x27,0xF1,0x86,0xAB,0x4A,0x03,0xCE,0x56,
+0x27,0x3D,0x2E,0x05,0x53,0xF9,0x61,0xA6,
+0x2F,0xFD,0x3E,0x83,0xDD,0x5F,0x98,0x33,
+0x27,0x5B,0x7B,0x3F,0x92,0x6F,0x21,0x88,
+0x2F,0x71,0xDA,0x2B,0xC3,0xFE,0x1D,0xA2,
+0x2F,0xD6,0x1C,0x65,0x89,0x66,0x63,0x42,
+0x2F,0x27,0x49,0x84,0xB8,0x02,0xBD,0xD8,
+0x27,0x90,0xCF,0x2C,0x06,0x41,0xC5,0xC4,
+0x2F,0xEF,0xEB,0x3A,0x3D,0x6E,0x5A,0x29,
+0x2F,0x04,0x74,0x27,0xB2,0xE3,0xDA,0x10,
+0x27,0x9E,0x91,0x00,0xF2,0x28,0x87,0x06,
+0x27,0x3C,0x9A,0xEB,0xCD,0x67,0x97,0x7C,
+0x27,0x31,0x1E,0xA8,0x8E,0x66,0x65,0xF8,
+0x27,0xC2,0x07,0x95,0x28,0x47,0x33,0x88,
+0x2F,0x75,0xDF,0x5B,0x65,0xDC,0xE8,0x53,
+0x27,0xC7,0xC4,0x96,0xDD,0x1C,0x67,0x28,
+0x2F,0x88,0x05,0x95,0x8C,0xCF,0x66,0x3B,
+0x2F,0x6D,0x0C,0xE2,0xA1,0x85,0x77,0xBF,
+0x27,0x33,0xCC,0xA5,0xDD,0xE1,0x3D,0x5F,
+0x27,0x03,0x2B,0xF6,0x2B,0x7A,0xAF,0x9C,
+0x27,0x04,0xD6,0x57,0x1B,0x6C,0x42,0xBB,
+0x27,0x9C,0x44,0x84,0xA7,0x7E,0x81,0x80,
+0x27,0x48,0x59,0xFD,0xBA,0xE4,0xFE,0x67,
+0x27,0x92,0x2A,0x61,0x8D,0x07,0x19,0x9D,
+0x2F,0xD3,0xE9,0xCA,0xCA,0xC4,0x2B,0xA1,
+0x2F,0x26,0x4E,0x2C,0x62,0xB8,0x09,0xFF,
+0x27,0x55,0x4D,0x7B,0xE6,0xD9,0x7E,0x25,
+0x27,0x10,0x5C,0x6D,0x59,0x18,0x87,0xB3,
+0x2F,0x8E,0x43,0xD4,0x9B,0x88,0x58,0xCB,
+0x27,0xE4,0x74,0x11,0xEA,0x35,0x15,0xED,
+0x2F,0x45,0x14,0x6E,0x0D,0xF7,0x8E,0x51,
+0x27,0x6D,0x63,0xCC,0x80,0x3B,0x1C,0x47,
+0x27,0x73,0x79,0xD7,0xD8,0xCC,0xB1,0x44,
+0x27,0x39,0x15,0x9A,0x16,0xC1,0xF9,0xAF,
+0x2F,0x62,0x4A,0x2A,0xC4,0x3D,0x3D,0x8A,
+0x27,0xCE,0x14,0xBE,0x39,0x1D,0x2C,0x6D,
+0x2F,0x86,0xD5,0x69,0x6F,0x86,0xFB,0x03,
+0x27,0x2A,0xDD,0xB0,0xFD,0x2A,0xC7,0xD5,
+0x27,0x45,0xCC,0x7F,0xF5,0x64,0xE9,0xE9,
+0x2F,0xBC,0x80,0xE7,0xC4,0x1A,0xFB,0xFE,
+0x27,0xE0,0x79,0x59,0x99,0x77,0xBA,0xCC,
+0x27,0x61,0x0A,0x0F,0xC1,0xCA,0xC0,0xDE,
+0x2F,0xFF,0xAC,0x33,0xDB,0xC1,0x4E,0x7A,
+0x27,0x99,0x24,0xDE,0xE4,0x84,0x7B,0x36,
+0x27,0x70,0xCD,0x8D,0xE5,0x89,0xF2,0x21,
+0x2F,0x6C,0x70,0x0E,0x72,0x4E,0x48,0x8C,
+0x27,0xE9,0x66,0x20,0xAB,0xE8,0xFF,0x22,
+0x2F,0xD0,0x0B,0x36,0x10,0x35,0x01,0x98,
+0x27,0x7D,0x54,0xB1,0x0D,0xCD,0x47,0xD6,
+0x2F,0x31,0x71,0x16,0x0A,0xEF,0x63,0x17,
+0x2F,0x3E,0x0A,0x59,0xF7,0xD6,0xB9,0xD9,
+0x27,0xA2,0x55,0xC5,0x4F,0xD7,0x80,0xF0,
+0x27,0xDA,0x06,0xEA,0xE5,0xEF,0xAD,0x8F,
+0x2F,0x07,0x5A,0x98,0x2A,0x7D,0x04,0x7F,
+0x27,0xC5,0x69,0x20,0x4D,0x72,0xFD,0xB0,
+0x2F,0xB8,0x79,0xBD,0xD4,0xD9,0x94,0x6D,
+0x27,0x71,0x19,0x1A,0xE1,0xE9,0x1E,0xB3,
+0x27,0xE5,0x2F,0x18,0x5A,0x87,0xFC,0x18,
+0x2F,0xDD,0x31,0x9F,0x0B,0x83,0xFD,0x75,
+0x27,0xAA,0x0B,0xFD,0xE8,0x74,0xB8,0x24,
+0x27,0xEB,0x10,0x06,0xFF,0x85,0xE0,0xA5,
+0x27,0x18,0x1B,0xD6,0x3C,0x26,0x5F,0x65,
+0x2F,0xE9,0x23,0xAE,0x2B,0x31,0x3C,0xFE,
+0x27,0xB1,0x3A,0x70,0x1B,0x29,0x80,0x28,
+0x27,0x7A,0x1F,0x3A,0x7B,0xB4,0x6A,0x63,
+0x27,0xCE,0x97,0xF8,0xBA,0x80,0xEB,0xB1,
+0x2F,0xFB,0x3A,0x2A,0x03,0xBE,0x27,0xBF,
+0x27,0x05,0xF6,0x61,0xB9,0x5B,0x50,0x89,
+0x27,0xC3,0x6A,0x54,0x52,0x8E,0x74,0xD7,
+0x27,0xD1,0xE7,0xC4,0xB2,0x42,0x15,0xAF,
+0x2F,0x09,0xC8,0x3E,0x5C,0x6E,0x6A,0x5D,
+0x2F,0x58,0x39,0xCD,0x88,0x14,0x60,0xB7,
+0x27,0x95,0x42,0x6A,0xAC,0xF8,0xE4,0xC2,
+0x2F,0xF1,0x6A,0xB5,0xE2,0xAF,0xC5,0x2A,
+0x2F,0xDB,0xEF,0x9B,0x88,0xF2,0xD9,0x71,
+0x2F,0xF8,0x0E,0xB7,0x7A,0x34,0x5F,0x72,
+0x2F,0x49,0x72,0x09,0x6B,0x51,0xC5,0x55,
+0x27,0x9E,0xC2,0x6E,0x9A,0x84,0x26,0xB0,
+0x27,0x94,0xFC,0xEF,0x64,0x63,0xFC,0xC0,
+0x2F,0x68,0x8E,0x69,0x52,0xD3,0x55,0x78,
+0x2F,0x03,0xD3,0x7C,0x0A,0xCB,0x46,0x16,
+0x2F,0x75,0xA1,0x88,0x37,0x00,0xB1,0x07,
+0x2F,0x92,0xED,0x7D,0x62,0x9D,0x38,0x47,
+0x2F,0x1D,0x8E,0x58,0xEF,0xEA,0x69,0x4F,
+0x2F,0x82,0x41,0xA5,0x47,0x0A,0xC0,0x80,
+0x27,0x9B,0x44,0xF8,0x76,0x97,0x24,0x2B,
+0x2F,0x06,0x29,0x85,0xF8,0x2D,0xCE,0xD7,
+0x27,0x94,0x1E,0xC9,0x82,0x71,0x7D,0x74,
+0x2F,0x5C,0x0E,0x98,0xDD,0xBC,0xC5,0x85,
+0x27,0xB0,0xEF,0x96,0xAF,0x43,0xC2,0xE1,
+0x2F,0x89,0x42,0x16,0x25,0x55,0xAA,0x19,
+0x2F,0x95,0xAF,0xC2,0x56,0xA2,0x41,0x90,
+0x27,0x69,0x7C,0xEF,0x08,0x92,0x8F,0xC1,
+0x27,0x29,0x60,0x83,0x44,0x7A,0xF7,0xF0,
+0x2F,0x6B,0x11,0x13,0x12,0x25,0x3C,0xC0,
+0x27,0x91,0x57,0x66,0x16,0xFF,0x1E,0xAC,
+0x2F,0xD1,0x1C,0x53,0xF7,0xA4,0xF0,0x36,
+0x27,0x72,0x7F,0x0C,0xA9,0x7D,0x0F,0x4C,
+0x27,0x99,0x29,0xF2,0x72,0xBF,0xED,0x9B,
+0x27,0x12,0x49,0x72,0x81,0x99,0x05,0x4C,
+0x2F,0xC2,0xB2,0x1A,0x16,0xCE,0x74,0x2E,
+0x27,0x24,0xB6,0x1D,0xCB,0xB6,0x0C,0xFF,
+0x27,0xCE,0x86,0x19,0x2F,0x05,0xA0,0x73,
+0x27,0x4D,0x6F,0x3C,0x33,0x75,0x48,0x40,
+0x27,0x4D,0x03,0x11,0xBE,0x37,0x7D,0x90,
+0x27,0x40,0x89,0x85,0xDA,0x17,0x77,0x52,
+0x2F,0xCA,0xCE,0x42,0x47,0x4B,0x43,0x31,
+0x2F,0xFF,0x9D,0x21,0x9F,0x10,0xE4,0x79,
+0x2F,0x4B,0x19,0xBD,0x4A,0xC7,0x4F,0x94,
+0x27,0xE4,0xEC,0x73,0xCC,0x27,0x8D,0x1A,
+0x2F,0x5C,0xE1,0xED,0x18,0x23,0x99,0x92,
+0x27,0x86,0xFE,0x60,0x38,0x98,0xDD,0xB2,
+0x2F,0xBD,0xC3,0xD5,0xCD,0xD6,0x9D,0x19,
+0x2F,0x40,0xFA,0x9B,0xA7,0xBE,0x61,0xD6,
+0x2F,0x0B,0x69,0x40,0xE5,0xC0,0xB5,0x9C,
+0x2F,0x63,0xB5,0x1B,0x2B,0xCE,0x57,0x15,
+0x2F,0xFA,0x47,0x68,0xA7,0x0E,0xDD,0x7A,
+0x27,0xC9,0x9B,0x77,0xF2,0xB5,0xAD,0x83,
+0x27,0xDD,0x7C,0x9E,0x34,0x18,0x9F,0x32,
+0x27,0x36,0x9F,0x9D,0x75,0x6F,0xD5,0x36,
+0x27,0x25,0xE3,0x84,0x2B,0x13,0xA4,0xE4,
+0x2F,0x2C,0x1D,0xBD,0xB9,0x55,0x7A,0x17,
+0x27,0x9D,0x8B,0x98,0xDA,0x98,0x81,0xB2,
+0x27,0xD4,0x7C,0x88,0x34,0x80,0x3B,0xED,
+0x2F,0x06,0x18,0x55,0x7D,0x04,0x87,0x6D,
+0x2F,0xF8,0x53,0x78,0x3A,0xD6,0xD8,0xBD,
+0x2F,0x5B,0x16,0xA2,0xD6,0xC6,0x41,0xC2,
+0x2F,0x23,0xA4,0x85,0x12,0xAF,0x51,0x74,
+0x27,0xA2,0xD2,0x60,0x5B,0xAE,0x8B,0x41,
+0x27,0xBE,0x3E,0xB1,0x36,0x2E,0xAB,0xED,
+0x2F,0x79,0xED,0x38,0xD1,0x0F,0x11,0xE1,
+0x2F,0x5B,0xC4,0xC5,0xF1,0x58,0x63,0x7D,
+0x27,0xF7,0x2B,0x17,0x97,0xEF,0xB1,0xD2,
+0x27,0x18,0xE5,0x32,0x85,0xA1,0x85,0x4F,
+0x2F,0x58,0x63,0xC3,0x09,0x91,0x8C,0xF0,
+0x27,0x5F,0x5E,0xD7,0x67,0xFC,0x7B,0xFD,
+0x27,0x10,0x66,0xEC,0x73,0xC6,0x72,0x33,
+0x2F,0x8C,0x5B,0x65,0x1E,0x1F,0x32,0x0A,
+0x27,0x73,0x8C,0x50,0x82,0x70,0x64,0x3E,
+0x27,0xA7,0xD6,0x01,0x8A,0xAF,0x59,0x98,
+0x2F,0x90,0xAE,0x11,0xC3,0x9C,0x03,0x38,
+0x2F,0x66,0x3A,0xB6,0x66,0x88,0xE6,0xA3,
+0x2F,0x78,0x51,0x9E,0x34,0x4F,0x5A,0xB8,
+0x2F,0xD0,0x86,0x61,0xA9,0x75,0x3A,0x1A,
+0x27,0x06,0x97,0x38,0xC1,0xA8,0xA4,0xD6,
+0x2F,0xF8,0xD5,0x4F,0x2A,0xA7,0x6A,0x09,
+0x27,0x9E,0x80,0x11,0xAA,0xE5,0xC4,0xB7,
+0x2F,0x02,0x92,0x6D,0x98,0x96,0x84,0xAE,
+0x2F,0xF3,0x2E,0x1C,0xDE,0x49,0x61,0xE9,
+0x27,0xBE,0x2E,0x4C,0xFE,0x5D,0x08,0xEB,
+0x2F,0x59,0xAD,0x5A,0xF9,0xD0,0x24,0x37,
+0x27,0xD1,0x8A,0x37,0xD3,0x51,0x20,0xCC,
+0x2F,0x33,0xAE,0xD6,0xA1,0xED,0xCD,0x10,
+0x2F,0x7E,0xFC,0xC0,0xFC,0x7B,0xCA,0x92,
+0x27,0x87,0x6C,0x57,0x29,0xB1,0x1A,0xCC,
+0x2F,0xDD,0xFC,0x01,0xAC,0xC4,0x28,0x36,
+0x2F,0xD6,0x55,0x4E,0x84,0x30,0xA6,0x01,
+0x2F,0xD3,0x1C,0xEF,0xD6,0x6C,0x73,0x13,
+0x27,0xE5,0xB8,0x44,0x30,0x29,0x85,0xD6,
+0x27,0x0C,0xB1,0x77,0x67,0x21,0xBB,0x11,
+0x27,0x29,0x7D,0xCE,0x83,0x9E,0x92,0x6A,
+0x2F,0x02,0x55,0xEF,0x59,0x25,0x99,0xBD,
+0x2F,0x18,0x2D,0xCE,0x86,0x92,0x5C,0x70,
+0x2F,0x0C,0x08,0x6E,0xA5,0x16,0x73,0xEC,
+0x27,0x06,0xEA,0x0C,0x19,0xFE,0x62,0x52,
+0x2F,0x19,0x97,0xE2,0x89,0xA4,0xB3,0x79,
+0x2F,0x1D,0x65,0x7B,0x8F,0xC2,0x0D,0x39,
+0x27,0xFE,0xE0,0x4C,0xDC,0x23,0xCB,0xD7,
+0x2F,0xBE,0x8E,0x15,0x50,0x7F,0x39,0x7C,
+0x2F,0xEC,0x52,0x00,0x9A,0x5D,0xD1,0x5A,
+0x2F,0x82,0xB0,0x8F,0xEA,0x6A,0x08,0xD2,
+0x27,0xE5,0xFE,0x38,0x7E,0x3F,0x44,0xA0,
+0x27,0xA3,0x75,0x46,0x15,0x83,0xF9,0x58,
+0x2F,0x9D,0x26,0xF7,0xD2,0x13,0x63,0x52,
+0x27,0x69,0xB1,0x01,0xC6,0x5E,0xD6,0x1B,
+0x27,0xBB,0x6A,0x34,0x71,0xB1,0xEA,0x4E,
+0x27,0x45,0x76,0xE6,0x43,0xB1,0xB7,0xA9,
+0x2F,0x61,0x9B,0x9A,0xDC,0x71,0x66,0xD8,
+0x2F,0x9F,0x91,0x9D,0xA3,0x52,0x45,0xAE,
+0x2F,0xF4,0xF5,0xBF,0x3E,0xE6,0x9C,0x75,
+0x2F,0x2D,0x3B,0xAF,0x6A,0x42,0x5C,0x4F,
+0x27,0xEA,0x57,0xBB,0x88,0x72,0xC9,0x5F,
+0x27,0x37,0x90,0x6F,0x55,0xD4,0x40,0xDC,
+0x27,0x33,0x25,0xEA,0xF8,0xA8,0x3B,0xD6,
+0x2F,0x1D,0xD7,0xA6,0x15,0x63,0xF0,0x3A,
+0x27,0x6E,0x5A,0xD9,0xF4,0x93,0x45,0x58,
+0x27,0x42,0x1A,0x16,0x73,0x3D,0x25,0x5F,
+0x2F,0x16,0x5B,0xF9,0x83,0xD6,0xEE,0x79,
+0x27,0x11,0x50,0x7F,0x52,0xFE,0xBA,0x7F,
+0x27,0x7D,0x5B,0x82,0x16,0x76,0x88,0x88,
+0x27,0x15,0x0A,0x33,0x6C,0xB7,0x27,0xDE,
+0x2F,0x42,0x61,0xCB,0xEB,0xE9,0xD6,0xE0,
+0x27,0xC4,0x01,0xD7,0x9E,0x02,0x88,0x6E,
+0x27,0xED,0x74,0x02,0xAA,0xFA,0x1A,0x93,
+0x27,0xEE,0x97,0x26,0x0B,0x68,0xB9,0xBC,
+0x27,0x0D,0x4C,0x5B,0x94,0x05,0xC2,0xE4,
+0x2F,0xC8,0x39,0x01,0xCC,0xC0,0xF8,0x64,
+0x2F,0x63,0x0A,0x26,0xE6,0x47,0xE1,0xA9,
+0x2F,0xE2,0x4C,0xD8,0x70,0x9A,0xB0,0xAA,
+0x2F,0xA5,0x1F,0xC5,0x00,0x95,0x7E,0xC6,
+0x2F,0x9A,0xF5,0x7E,0x26,0x5C,0x1E,0xA9,
+0x2F,0x61,0xCC,0x52,0x65,0x87,0xA5,0xAF,
+0x27,0xF9,0xA2,0x9F,0x7B,0x1E,0x1A,0x82,
+0x27,0x76,0xB2,0x3D,0x00,0x3F,0x41,0x24,
+0x2F,0x18,0x9E,0x99,0xE9,0x82,0xA9,0x4A,
+0x2F,0x4D,0x2F,0x6C,0x37,0xDA,0x71,0x7D,
+0x2F,0x29,0x36,0x4F,0x45,0x21,0x98,0x41,
+0x2F,0xF2,0xD4,0x9E,0x3B,0xC8,0xEA,0xE9,
+0x27,0x32,0x69,0x4B,0x4D,0x36,0x29,0x14,
+0x2F,0xCD,0xAD,0x1A,0xA6,0x97,0x17,0x12,
+0x2F,0x5F,0x00,0x5B,0x8F,0x4F,0xC4,0x3A,
+0x2F,0x2F,0xAE,0x81,0x2B,0xBB,0xBB,0x15,
+0x27,0x12,0xEC,0x52,0x31,0x81,0x3C,0x44,
+0x27,0x22,0x77,0xC2,0x11,0xC5,0x8B,0xD7,
+0x27,0xF1,0xFF,0x74,0x79,0x58,0x6A,0x20,
+0x27,0xC3,0x5A,0x1E,0x7F,0x4D,0x42,0x4E,
+0x2F,0x64,0x1E,0xD4,0xA2,0x21,0x9E,0x03,
+0x2F,0x60,0x38,0x2B,0xC0,0xBA,0x67,0x47,
+0x27,0x82,0x32,0x0B,0xBA,0x6F,0x76,0xC0,
+0x2F,0xBB,0xC0,0xA0,0xAF,0xCC,0x70,0x3A,
+0x27,0xF3,0x1A,0xB7,0xE5,0xD5,0xC3,0x6E,
+0x27,0xE2,0x5D,0x34,0xC2,0xB3,0x79,0x4F,
+0x27,0x5D,0xDD,0x6E,0x9E,0xBB,0xFA,0x6B,
+0x2F,0xBA,0x67,0xB2,0x80,0x6D,0x56,0xA4,
+0x2F,0xA8,0xFE,0x5B,0xD1,0x37,0x52,0x4C,
+0x2F,0x40,0x12,0xF2,0x6E,0xAD,0xAE,0xE6,
+0x27,0x20,0xD1,0x70,0x63,0xFB,0xD4,0x50,
+0x2F,0x66,0x7C,0xAB,0xB7,0x42,0x24,0x9E,
+0x27,0x51,0x6E,0xCB,0xAC,0x77,0xC3,0x81,
+0x2F,0x83,0x35,0xE4,0x8A,0x4A,0x71,0x16,
+0x27,0xDD,0xE7,0x3D,0xE5,0x68,0xAA,0xBA,
+0x2F,0x5E,0x56,0xDD,0xE9,0x9B,0x23,0xF4,
+0x27,0xA7,0x2A,0xAE,0xDB,0xC6,0x83,0xE5,
+0x2F,0xBF,0x41,0x54,0x59,0x82,0xF4,0xCE,
+0x27,0x47,0xA0,0x62,0x63,0x19,0x42,0x5B,
+0x2F,0x42,0x72,0x2C,0xE7,0xC3,0xD8,0x8F,
+0x27,0xA2,0xB1,0xC3,0x5E,0x12,0xF8,0x0F,
+0x27,0x1A,0xC6,0x5B,0xFD,0xFF,0x38,0xDC,
+0x27,0x2D,0x76,0xC0,0x55,0x2E,0x27,0xD8,
+0x2F,0x4D,0x5C,0xD9,0x97,0x0A,0x59,0x66,
+0x2F,0xD7,0xCA,0x55,0x5E,0x73,0x9E,0x69,
+0x2F,0xC0,0xE7,0xAE,0x9C,0xD5,0xE7,0x8E,
+0x2F,0xD2,0x3E,0x28,0x7E,0x6D,0xEC,0x40,
+0x2F,0xEE,0x99,0xEC,0x55,0x12,0x5B,0xB8,
+0x27,0x07,0xF3,0xB9,0xE1,0xB5,0x83,0x96,
+0x2F,0x93,0xC2,0x05,0x10,0x9F,0x34,0x25,
+0x27,0x74,0xD9,0x42,0x5C,0x01,0x4B,0x3F,
+0x2F,0xC5,0xB1,0x6A,0x36,0x2A,0x8E,0xB1,
+0x2F,0x9E,0x30,0xE5,0xB5,0x7B,0x18,0x04,
+0x2F,0x16,0xF9,0x4E,0xB2,0xDD,0xA0,0xA0,
+0x27,0x37,0x7C,0xB6,0x01,0xC2,0x50,0x29,
+0x27,0xBE,0x26,0xBA,0xE2,0x4D,0xF4,0x40,
+0x27,0xC1,0x3E,0x6C,0x29,0xD8,0xBC,0x38,
+0x27,0x31,0xD3,0x63,0x0D,0x4D,0xB2,0xD6,
+0x27,0x72,0xD1,0x82,0x84,0x4A,0xD8,0xAF,
+0x2F,0xD4,0x2A,0x41,0x4E,0x5A,0x37,0xA2,
+0x27,0x5C,0x11,0x33,0x9F,0xFC,0xAE,0xA1,
+0x2F,0x02,0x25,0xDD,0xE6,0x8A,0x9E,0xBF,
+0x27,0xD1,0x98,0x35,0x17,0xE1,0xDF,0x25,
+0x2F,0x32,0x51,0xAD,0xC9,0xF9,0x0C,0x20,
+0x27,0x90,0x52,0xA5,0x32,0xE7,0x45,0x93,
+0x27,0x96,0x32,0xC3,0xBC,0x37,0x6A,0x24,
+0x2F,0xCF,0x18,0x67,0x16,0x41,0x92,0xE4,
+0x27,0x16,0x02,0x07,0x4D,0xC1,0x31,0x66,
+0x27,0xBE,0xE3,0x1B,0x1F,0x62,0xD1,0x1A,
+0x2F,0x56,0x35,0x86,0x09,0xD7,0x3A,0x3A,
+0x27,0xF2,0x3F,0xF9,0x80,0xE9,0xC0,0x7E,
+0x2F,0xF8,0xEB,0x41,0x0A,0x16,0x66,0x74,
+0x2F,0x08,0xF2,0x1F,0x0A,0xA7,0x8A,0x49,
+0x27,0xA5,0x7D,0x03,0x15,0x9F,0x11,0xB0,
+0x27,0xE5,0x1D,0x5D,0xA9,0x2A,0xD6,0x06,
+0x27,0xE2,0x8C,0xF0,0x5A,0x84,0x01,0x38,
+0x27,0xBB,0x60,0xAA,0x37,0x78,0xC8,0x67,
+0x2F,0x84,0xE6,0xFF,0x22,0x53,0x29,0xA9,
+0x27,0xA9,0x9E,0xCA,0xFE,0x20,0x9F,0x3D,
+0x27,0x40,0x84,0xD5,0x6F,0xCB,0x4B,0x72,
+0x2F,0xD2,0x09,0xC6,0x3E,0xF0,0x9F,0xA2,
+0x2F,0x87,0xC0,0x96,0x81,0xFC,0x3C,0x03,
+0x27,0x8D,0xC4,0xCF,0x6C,0x11,0xDF,0xA9,
+0x2F,0x04,0x82,0x7F,0xF7,0x1F,0x5E,0x69,
+0x27,0x3F,0x71,0x61,0xCB,0xE7,0xD0,0x5C,
+0x2F,0xCB,0x8D,0x67,0x6A,0x49,0xE9,0x52,
+0x27,0x15,0x9D,0x98,0x29,0xEA,0x96,0xB9,
+0x27,0xA5,0xF1,0xF7,0x15,0x89,0x6C,0x66,
+0x2F,0x33,0xF4,0x1A,0x5B,0x8E,0x62,0xE6,
+0x2F,0xB8,0x8F,0xA2,0x52,0x32,0x45,0x71,
+0x2F,0xBD,0x14,0x97,0x08,0x2F,0x21,0x56,
+0x27,0x14,0x45,0x31,0x07,0xB3,0x8C,0x40,
+0x2F,0x62,0x02,0x39,0x54,0x6A,0xFA,0xD3,
+0x2F,0x9D,0x99,0x72,0x47,0xBF,0x08,0x60,
+0x2F,0xEF,0x28,0xF3,0xE7,0x23,0xB3,0x02,
+0x27,0xF5,0xC1,0x67,0x1B,0x62,0x08,0x8C,
+0x27,0x94,0x59,0x5D,0x9E,0x7A,0x0A,0xFE,
+0x27,0x44,0x1E,0xE2,0x01,0xE9,0x74,0x3D,
+0x2F,0x9E,0x92,0xC5,0xBF,0xB4,0x82,0x40,
+0x2F,0x80,0x5F,0xD5,0x43,0x8D,0x12,0xAC,
+0x27,0xE1,0x17,0xC0,0xF8,0x3A,0xB3,0x9A,
+0x2F,0xBE,0xC6,0xF2,0xD5,0x8B,0x29,0x5E,
+0x27,0xAE,0x70,0x47,0x61,0x7F,0x37,0x1C,
+0x27,0x5B,0xD7,0x08,0x4B,0x77,0xC8,0x8A,
+0x2F,0x98,0x10,0xD5,0xA9,0xE4,0xBA,0x82,
+0x2F,0x85,0x51,0x51,0x9E,0xE3,0xE6,0xFE,
+0x2F,0xD6,0x0C,0x78,0xC8,0x52,0x90,0xD1,
+0x2F,0xE0,0x0D,0xE2,0x10,0x4A,0x63,0xD3,
+0x27,0xCF,0x00,0x0F,0x4B,0xC1,0xFF,0x94,
+0x27,0x19,0x5C,0x45,0x5C,0x8D,0x1E,0x01,
+0x27,0x01,0xAF,0x30,0xF2,0xC6,0xDC,0xB6,
+0x27,0xE4,0x2E,0x9F,0xBF,0x6B,0x51,0x2B,
+0x2F,0xA3,0x3B,0x7B,0x16,0x27,0x18,0x38,
+0x2F,0x34,0x69,0xB2,0xF0,0x93,0xA0,0x59,
+0x27,0x43,0xB5,0x50,0x85,0x35,0x55,0xF0,
+0x27,0x61,0x9B,0x3A,0x1C,0x3E,0xA9,0x0A,
+0x2F,0x56,0x5C,0x7B,0x77,0xA7,0xF3,0xD8,
+0x27,0x29,0xFC,0xEA,0x17,0xA3,0x11,0xE4,
+0x2F,0xD9,0x85,0x25,0x9C,0x7E,0x8D,0xD9,
+0x2F,0x40,0xBF,0x2E,0x88,0x57,0xB2,0xC0,
+0x2F,0x64,0xF0,0x62,0x7A,0x77,0xC0,0x33,
+0x27,0x90,0x9B,0x4E,0xCA,0x63,0xD0,0x97,
+0x27,0x2B,0xE3,0xAB,0x25,0x54,0x2E,0xAC,
+0x2F,0x78,0xF4,0x77,0x1A,0x26,0x64,0xC8,
+0x27,0xC2,0x44,0x1D,0x3F,0xD5,0xC3,0x21,
+0x2F,0xD0,0x48,0x09,0x61,0x02,0x21,0x87,
+0x2F,0x1B,0x1D,0x0D,0x0A,0x44,0x3C,0x85,
+0x2F,0x7B,0x3C,0xB7,0x9B,0x6C,0x0F,0x38,
+0x2F,0x51,0x8D,0xC8,0x29,0x11,0x0C,0xC7,
+0x27,0x1C,0x56,0x04,0xB0,0x9E,0x41,0x16,
+0x2F,0x88,0xA8,0x28,0xA1,0x5E,0x8D,0xB8,
+0x2F,0x79,0xC0,0xBB,0x96,0x42,0x2B,0x2E,
+0x2F,0x9A,0x4B,0x58,0xAB,0x20,0xC5,0x71,
+0x2F,0x80,0xEC,0x18,0xE5,0x76,0xA9,0x3D,
+0x27,0xAF,0x6D,0x38,0x09,0x58,0x96,0x0A,
+0x27,0xBF,0xEB,0x8C,0xE3,0x7F,0xD6,0x14,
+0x27,0x5C,0x52,0xB7,0xD8,0xFC,0xDD,0x01,
+0x2F,0x60,0x84,0xAA,0xBE,0xA0,0xEF,0x9F,
+0x27,0x71,0x5F,0x96,0x59,0x6E,0x79,0xCF,
+0x27,0x3F,0x99,0x2F,0x5A,0xC4,0x40,0xBB,
+0x2F,0xE2,0x30,0xF4,0x09,0x88,0xAF,0x8A,
+0x2F,0xB3,0xC5,0x9F,0xFD,0x16,0x32,0xE2,
+0x27,0xDD,0x6E,0x2A,0x4B,0x0D,0xB9,0xF6,
+0x2F,0x17,0xAF,0x35,0x40,0xAF,0xCC,0x80,
+0x2F,0x92,0xAA,0x5C,0x76,0x2B,0x81,0x71,
+0x27,0x07,0x8D,0x08,0xED,0x97,0x95,0x75,
+0x27,0x14,0x56,0x77,0xD8,0x8C,0xD5,0x65,
+0x2F,0x07,0x4F,0xB2,0x23,0xC8,0xE9,0x38,
+0x27,0x79,0xFC,0x9D,0x0D,0x42,0xA4,0x3E,
+0x2F,0x19,0xCD,0x09,0xCC,0x9D,0x7A,0xA1,
+0x2F,0xAD,0xB9,0x08,0xCE,0x7D,0xE4,0x4A,
+0x2F,0x7D,0xE4,0xA5,0xCB,0x2F,0xE2,0xA1,
+0x27,0xD8,0x00,0x3D,0x45,0x1B,0x3F,0xF1,
+0x27,0xBC,0x1E,0x31,0x56,0x0E,0xA9,0x4D,
+0x27,0xC4,0xA6,0x9E,0x1F,0xF2,0x3E,0x1C,
+0x27,0xF9,0x6A,0x0E,0x91,0xF3,0xA6,0x30,
+0x27,0x28,0x12,0x78,0x8B,0x7B,0x20,0xCD,
+0x2F,0xA9,0xC8,0xE6,0xB3,0x28,0x0B,0x40,
+0x27,0x4D,0xE5,0xF2,0x9C,0xD8,0x6D,0x8B,
+0x27,0x3C,0x31,0xF4,0x30,0x37,0x3B,0x1C,
+0x27,0x30,0xFB,0x01,0xC7,0x45,0x88,0xB4,
+0x27,0xFD,0x08,0xCE,0x83,0x48,0x0E,0x17,
+0x27,0xD9,0x80,0x54,0x44,0xA2,0xDD,0xD6,
+0x2F,0xFA,0xD6,0x6E,0x5D,0x95,0x45,0x6C,
+0x27,0x39,0xB1,0xF8,0x71,0x12,0x17,0x79,
+0x2F,0xF7,0x8B,0x70,0x0E,0xCD,0xEE,0x07,
+0x27,0xA8,0x51,0x19,0x2C,0xB5,0x23,0x9A,
+0x2F,0xEF,0xDA,0x0B,0xE3,0x21,0xC3,0xE7,
+0x2F,0x9D,0x5F,0x1F,0xD6,0xD6,0x0B,0x4F,
+0x05,0xC1,0x12,0x78,0xC6,0x3C,0xE7,0xD9,
+0x2A,0x0B,0x03,0x5D,0x58,0xB7,0x1E,0xA4,
+0x05,0x68,0x10,0xE2,0x6C,0xEB,0x97,0xAB,
+0x2C,0xB1,0xF0,0x51,0xA1,0x05,0x94,0xE6,
+0x05,0xC7,0xAE,0xEA,0x73,0x50,0xD2,0x1A,
+0x2A,0xBE,0xE1,0x22,0x28,0xCC,0x42,0x5D,
+0x05,0x5A,0xB5,0x2C,0x5A,0x7D,0x93,0x6D,
+0x2F,0x70,0x10,0xA4,0xD2,0x27,0x28,0x80,
+0x2F,0x26,0x29,0x57,0x7A,0xF9,0x77,0xCF,
+0x2F,0x22,0x43,0xC1,0xF3,0xBB,0x77,0x0F,
+0x2F,0x7B,0x35,0x4B,0x72,0x17,0x36,0x2C,
+0x2F,0xA9,0x4B,0xD4,0xE3,0x88,0x28,0x4B,
+0x2F,0x84,0x52,0x21,0x47,0xF3,0xF0,0x5F,
+0x2F,0x73,0x0E,0x17,0x9B,0x7A,0xB7,0xBB,
+0x2F,0xBD,0x68,0x25,0xFE,0xD8,0x1E,0xE6,
+0x29,0xEF,0x50,0x0A,0x4A,0x82,0xF8,0xE2,
+0x05,0x9C,0xE3,0xC9,0x21,0x37,0xF6,0x38,
+0x22,0x63,0x3A,0x93,0xAB,0x6A,0x20,0x57,
+0x05,0x92,0x62,0xAA,0x58,0xF1,0x71,0x1B,
+0x21,0xEE,0x4B,0xC9,0x9A,0xDB,0xC0,0x95,
+0x05,0xAE,0x88,0xC6,0x83,0xCB,0x8F,0xFC,
+0x2F,0x5C,0x06,0xCA,0x77,0xF3,0x05,0xB0,
+0x2F,0xEE,0x26,0x33,0x1B,0xBC,0xA6,0xD5,
+0x27,0x88,0xC3,0x21,0x43,0xBF,0x14,0x7B,
+0x05,0x80,0xEB,0x65,0xD4,0x92,0xF2,0xD5,
+0x2F,0xCA,0x4C,0xD5,0xE1,0x43,0xD3,0x70,
+0x05,0x2B,0x3F,0x54,0x8C,0xED,0xE3,0xFD,
+0x23,0xD6,0x6A,0x4D,0xFB,0xD2,0x4B,0x2B,
+0x05,0x56,0xAA,0x4B,0x09,0xFB,0x7F,0xD9,
+0x2F,0x06,0x39,0xEA,0x33,0x0B,0x25,0x8D,
+0x2F,0xB9,0x44,0xEF,0xC0,0x74,0x6A,0x6A,
+0x2F,0x69,0x6A,0xA4,0x0A,0x2D,0xBB,0x39,
+0x2F,0xFE,0xA3,0x2E,0x85,0x24,0x49,0x39,
+0x27,0x95,0x1B,0x45,0x6C,0x5D,0x38,0x21,
+0x2F,0x4C,0x19,0x52,0xA6,0xA5,0x3A,0x10,
+0x2A,0x01,0xCD,0x9E,0x97,0x18,0xFE,0x36,
+0x05,0xD7,0x6C,0x07,0x31,0x30,0xC3,0xDB,
+0x27,0x92,0x17,0xD7,0x26,0x17,0xFF,0x8D,
+0x2F,0x2D,0xD1,0x31,0x03,0x4F,0x50,0xBB,
+0x22,0x71,0xB5,0xB4,0x9D,0x6D,0xE3,0xED,
+0x05,0x98,0x3B,0x2C,0x31,0xE7,0x4B,0x6A,
+0x27,0x56,0xAF,0x35,0xF3,0xD1,0x3A,0x31,
+0x29,0xB4,0x70,0xC2,0xBF,0xBE,0x19,0x04,
+0x05,0xD5,0x16,0x1F,0x9F,0xE1,0xF2,0x09,
+0x24,0xA7,0xB0,0x3F,0xCD,0x39,0x6A,0x79,
+0x05,0x56,0xD1,0xB9,0x42,0x1A,0x86,0x0E,
+0x24,0x3B,0x66,0x68,0x1E,0x10,0xEE,0xAD,
+0x05,0xB8,0x47,0x2D,0xA8,0xFA,0x2E,0x9A,
+0x2C,0x98,0xCB,0xCC,0xAA,0x17,0x20,0xB5,
+0x05,0xAE,0x38,0x9B,0x49,0x2F,0xEA,0xEF,
+0x2C,0x8E,0xE9,0xB1,0x19,0xD2,0xFA,0xEF,
+0x05,0x51,0x49,0x4B,0xA1,0x51,0x3D,0x10,
+0x2C,0x73,0xEA,0x19,0x19,0xAC,0x59,0x11,
+0x05,0x89,0x01,0x6F,0xC5,0xC9,0x46,0x90,
+0x2F,0xFD,0x08,0xD1,0x90,0x7C,0x27,0x5E,
+0x25,0x44,0xEA,0x8D,0x7C,0x9B,0x2B,0x74,
+0x05,0x1D,0x83,0x8A,0x49,0xA4,0xF5,0x97,
+0x2F,0x73,0x75,0xE1,0x34,0xFE,0x89,0xDB,
+0x2F,0x39,0x78,0x3C,0xC1,0x4B,0x1E,0x7E,
+0x22,0x59,0x8D,0xC0,0xA5,0x58,0xBA,0x71,
+0x05,0xE3,0x24,0x06,0xF6,0x52,0x7D,0x3B,
+0x27,0x82,0xAF,0x18,0x84,0x8B,0x95,0x66,
+0x2F,0x83,0xC2,0xC7,0x8E,0x7E,0x3E,0xDA,
+0x27,0x89,0x30,0x21,0x97,0xAC,0xF8,0xBC,
+0x2F,0xA4,0x4D,0x5D,0xC4,0xFF,0x52,0x65,
+0x2F,0xD9,0x07,0x29,0xA7,0x87,0xEE,0x57,
+0x29,0x6D,0xDD,0xB3,0x68,0x14,0xF9,0x5A,
+0x05,0x9F,0x44,0xCE,0xD7,0x6D,0x85,0x20,
+0x2F,0x51,0xFB,0x2F,0x7B,0xD7,0x6C,0xB7,
+0x2F,0x23,0x4D,0xE7,0x3F,0xA8,0x8B,0x2C,
+0x27,0xA0,0x39,0xCF,0xDB,0x1D,0xA3,0xC1,
+0x2B,0x09,0x70,0x37,0x4D,0xD1,0x62,0x6C,
+0x05,0x9B,0xED,0x7B,0xE7,0x79,0x18,0x20,
+0x24,0x39,0xE2,0xD7,0xF8,0xD8,0x99,0xAF,
+0x05,0xCB,0xF4,0x61,0x40,0x37,0xE9,0x52,
+0x2C,0x3B,0x5C,0xEC,0x31,0xF4,0x1F,0x02,
+0x05,0xA9,0xB0,0xA3,0xED,0xFA,0x64,0x08,
+0x2F,0x73,0xB5,0x4F,0x3B,0xE4,0x6C,0x29,
+0x2F,0x53,0xBB,0xEF,0x1D,0x7E,0x6D,0x4B,
+0x2F,0x19,0x45,0x3A,0x08,0x59,0xD1,0xDB,
+0x23,0x14,0x44,0xFF,0xEB,0x82,0xAF,0x05,
+0x05,0x3D,0x63,0xD4,0xD1,0xE8,0x82,0xF3,
+0x2F,0x47,0x00,0x0C,0xF8,0xA4,0x0E,0x76,
+0x27,0x97,0xAB,0x02,0x6A,0x9D,0xDC,0xF2,
+0x2F,0x72,0x35,0x27,0xC0,0x04,0x09,0xE5,
+0x27,0x21,0x75,0x81,0xA0,0xE6,0x1C,0x8C,
+0x05,0x45,0x57,0x5F,0x58,0x0F,0x80,0xCE,
+0x2F,0x82,0x53,0x05,0xD2,0x4F,0xB2,0x70,
+0x2F,0x6D,0x22,0x36,0xBD,0x6B,0x99,0xE7,
+0x27,0x90,0x07,0x89,0xDA,0xB3,0xCE,0xE7,
+0x2B,0x88,0x38,0x22,0x7F,0x08,0xB4,0xD6,
+0x05,0x91,0xE5,0x24,0x0F,0x60,0x73,0xB8,
+0x2C,0x0E,0x12,0x9D,0xFE,0x8C,0x69,0x37,
+0x05,0xA7,0xB7,0x9E,0xDE,0x4E,0xCC,0x4C,
+0x24,0x79,0xA7,0xC9,0xF9,0x03,0x6C,0x36,
+0x05,0x5A,0x34,0xA7,0x2C,0x6B,0x5F,0xCC,
+0x2F,0x6D,0x55,0x7A,0x77,0x62,0x0F,0x4F,
+0x27,0x60,0xEB,0x1D,0xAC,0xC6,0x2D,0xD1,
+0x2F,0xF7,0xD6,0x69,0xD3,0x76,0x26,0x1B,
+0x2F,0xE8,0xE2,0x1F,0x96,0xB6,0x2B,0x6F,
+0x2F,0x7F,0x12,0x81,0xB6,0x1F,0x59,0xF9,
+0x27,0xB6,0xD4,0x92,0xCD,0x10,0x10,0x47,
+0x27,0x76,0x3A,0xE5,0xBF,0xDC,0xC0,0x89,
+0x27,0x2F,0xD8,0xF4,0x51,0x4D,0xEE,0x29,
+0x05,0xF2,0x96,0x57,0x45,0x4A,0xEB,0xBF,
+0x2F,0x91,0x5E,0xCA,0xAA,0x5F,0xEC,0xF8,
+0x27,0x97,0x04,0x4F,0x1E,0x88,0xC0,0x1C,
+0x2A,0xC6,0xB4,0x53,0x25,0x30,0x3F,0xD7,
+0x05,0x7C,0x56,0x17,0x19,0x90,0xD8,0xA2,
+0x24,0x14,0x24,0xBA,0xDB,0x03,0x12,0x46,
+0x05,0xC3,0x1F,0x44,0x76,0x08,0x7D,0xD8,
+0x2C,0x70,0x46,0xD1,0x57,0xD0,0xDA,0xEB,
+0x05,0x0D,0x12,0x5D,0x5A,0x55,0x41,0x5C,
+0x2C,0xB2,0xC1,0xFE,0x0B,0x1D,0x96,0x1D,
+0x05,0x57,0x67,0x3F,0x04,0xF3,0xBB,0x30,
+0x2C,0x0E,0xDE,0xC4,0x8C,0x21,0xE8,0x08,
+0x05,0x46,0x0A,0x2C,0xE6,0x16,0xB3,0xF3,
+0x24,0x54,0x44,0xBF,0xA3,0x40,0x27,0xAB,
+0x05,0xAE,0x3C,0x64,0x8E,0x29,0xFD,0xAC,
+0x2C,0xEA,0xDC,0x4C,0x64,0xBB,0x39,0x0D,
+0x05,0x65,0x47,0xCD,0x8F,0x20,0x51,0xB9,
+0x2C,0x30,0xAB,0x91,0x11,0x0E,0xFD,0x70,
+0x05,0x0B,0xEE,0x72,0xCC,0x48,0x3D,0xB6,
+0x2F,0x4B,0x78,0xA0,0x3C,0xA6,0xCB,0x28,
+0x2F,0x7C,0x8C,0x19,0x9D,0xDA,0x3B,0x53,
+0x27,0xA3,0x93,0x99,0xC6,0x8D,0xAB,0x9C,
+0x2F,0x96,0x86,0xCD,0x17,0xB5,0xF5,0x25,
+0x27,0xE4,0x9C,0xA4,0xD4,0xE3,0x15,0x25,
+0x2F,0xDF,0xE3,0x9E,0xD1,0x50,0x84,0xA3,
+0x27,0x6E,0x85,0xCE,0x91,0xB5,0xAA,0xE5,
+0x27,0xCD,0xAD,0x8C,0x32,0x73,0x29,0x29,
+0x2F,0xB5,0x1E,0x97,0x8E,0x11,0x50,0x0D,
+0x27,0xAE,0x47,0xDC,0x4A,0xA9,0x87,0x4D,
+0x27,0x98,0x81,0x1D,0xA0,0xDB,0x90,0xA4,
+0x2F,0x9F,0xCF,0x7B,0x9A,0x2B,0xF4,0x52,
+0x27,0x91,0xC7,0x3F,0x75,0xB6,0x5C,0x33,
+0x27,0xF9,0xC1,0x5E,0xD8,0x38,0x1F,0x1F,
+0x27,0xDE,0x3C,0x95,0xEA,0xD6,0x18,0x7E,
+0x2F,0x96,0xF8,0xF1,0x03,0x0D,0x5C,0xD5,
+0x2F,0x3F,0x0A,0x89,0x61,0xA7,0x70,0x8C,
+0x27,0x19,0x32,0xEE,0xE1,0xB5,0xBF,0xE0,
+0x27,0x91,0x32,0x57,0x95,0xC3,0x6B,0xD6,
+0x27,0xCA,0x00,0xB7,0x43,0x4A,0x52,0x1C,
+0x2F,0xAB,0xCB,0x57,0x19,0x55,0xAA,0xA8,
+0x27,0xC5,0x7E,0x73,0xDB,0xF0,0x62,0x83,
+0x27,0xE1,0x45,0xFA,0x8A,0x72,0x58,0x5D,
+0x2F,0x84,0x07,0xC5,0xA2,0x1A,0xD6,0x06,
+0x27,0xE1,0x7F,0xBB,0xF5,0x30,0xD1,0xAE,
+0x27,0x09,0x4E,0xF9,0x90,0xE1,0xB8,0x16,
+0x2F,0xFF,0xEE,0x83,0xCD,0x47,0x89,0x28,
+0x27,0xF1,0xB1,0x86,0xA7,0xBC,0x42,0xEC,
+0x2F,0xF9,0x61,0x2A,0xCE,0x01,0x50,0xD7,
+0x2F,0xD8,0x40,0x48,0x5D,0x26,0x24,0x5E,
+0x27,0x56,0x4F,0xA3,0x81,0x4E,0x76,0xD1,
+0x2F,0x66,0x04,0xCC,0xA3,0xE6,0x90,0x22,
+0x2F,0x2F,0x57,0x04,0x12,0x27,0xA7,0x4C,
+0x2F,0x30,0x9F,0xED,0x76,0xF6,0xC9,0xCC,
+0x27,0x34,0xA5,0x27,0xF2,0x5C,0xB0,0x85,
+0x2F,0x5B,0xD8,0xF2,0x60,0x4E,0x49,0xA9,
+0x2F,0x17,0x63,0xAF,0xA0,0xFB,0xF2,0x99,
+0x2F,0xE6,0xCF,0x70,0x72,0x56,0x8B,0xBC,
+0x2F,0xFF,0x3B,0xF2,0x36,0x94,0xD8,0x30,
+0x27,0xC7,0xB2,0x13,0x9A,0xD6,0x2B,0xBC,
+0x27,0x1E,0xDC,0x52,0x3A,0xCC,0xB8,0xB7,
+0x27,0x4F,0xFB,0xFA,0x13,0x07,0xAD,0x53,
+0x27,0x2A,0x1A,0x8E,0x7A,0x37,0xFA,0xBA,
+0x2F,0xA0,0x91,0x38,0x20,0x6F,0x3A,0x92,
+0x2F,0xF7,0xBD,0x73,0x4C,0x0F,0x12,0x3B,
+0x2F,0x42,0x50,0x9A,0xA1,0x64,0xE7,0x6E,
+0x27,0x5C,0xDF,0x3C,0x7E,0x3D,0x2B,0x4F,
+0x2F,0x4E,0x3A,0x49,0xBB,0xF8,0xBB,0xEC,
+0x2F,0x31,0x80,0x8C,0x60,0xA7,0x0B,0x39,
+0x2F,0x8F,0xF6,0x45,0x35,0x61,0x60,0xE6,
+0x2F,0x2E,0xDB,0xAF,0xCB,0xAD,0xB7,0x46,
+0x2F,0xCD,0x82,0xD1,0xFC,0xDE,0xC1,0xD8,
+0x2F,0x56,0x64,0x43,0xDA,0xFE,0xE1,0x15,
+0x2F,0x6B,0x68,0xF3,0x9D,0x82,0x90,0x27,
+0x27,0x1E,0x22,0x40,0x43,0x32,0xE7,0x01,
+0x27,0x8F,0x36,0x33,0x4E,0xC2,0xDA,0xA9,
+0x27,0xD6,0x7F,0xDD,0x0F,0x27,0x7C,0x22,
+0x2F,0x09,0x79,0x59,0xB9,0x05,0x43,0xF2,
+0x2F,0x4F,0x8F,0x3F,0x57,0x6E,0x55,0x31,
+0x27,0x62,0x93,0x09,0xD4,0x11,0x1F,0x48,
+0x27,0x36,0x83,0xB2,0x39,0xC0,0xE6,0x0E,
+0x27,0x84,0x22,0x66,0xE4,0xAD,0x6D,0xD7,
+0x2F,0x35,0x64,0x4F,0xE8,0x55,0x6F,0x1C,
+0x27,0x91,0x7E,0x13,0x5A,0x98,0xBC,0xAA,
+0x27,0x0E,0xFB,0x8B,0x4B,0xE6,0x8D,0x02,
+0x27,0xDD,0x85,0x7B,0xCE,0xEB,0xE3,0xD1,
+0x2F,0x7B,0xF0,0xC4,0x92,0x46,0x30,0x95,
+0x2F,0x17,0x54,0x26,0x98,0x71,0x59,0x30,
+0x27,0xD2,0x4E,0xE5,0xF6,0xA9,0x0C,0x02,
+0x2F,0x0D,0xEE,0x8F,0xEF,0x70,0x9E,0xC3,
+0x27,0xF6,0x52,0x52,0x5A,0x62,0xDD,0xD7,
+0x27,0x9E,0xEC,0x51,0x8E,0x15,0x26,0x2C,
+0x27,0x9C,0xF1,0x6A,0x35,0x26,0x8D,0xE9,
+0x27,0x76,0x5E,0xE8,0x57,0xA6,0x1E,0xB7,
+0x2F,0x6E,0x70,0xA8,0xC0,0x30,0x9C,0xD5,
+0x27,0x03,0xF6,0x06,0x0B,0xDC,0xDE,0x4B,
+0x2F,0xA3,0x39,0x8F,0x6E,0x20,0x1E,0x13,
+0x27,0x7D,0xB3,0xB1,0x8E,0x8F,0x94,0x5F,
+0x2F,0xCD,0x1E,0xD5,0x9C,0xE7,0x20,0xE7,
+0x2F,0xDB,0x94,0xBD,0x77,0x6C,0xBC,0xE5,
+0x27,0xCA,0xDE,0x33,0xE9,0xAB,0x8F,0x62,
+0x27,0x73,0x6A,0xAF,0xB7,0x83,0x87,0x79,
+0x27,0x38,0x0B,0xA4,0x75,0x7F,0xE5,0x5A,
+0x2F,0x6E,0x4B,0xDA,0x12,0x2A,0x99,0xA5,
+0x2F,0x6A,0x22,0x66,0xF4,0xA2,0x9F,0x90,
+0x2F,0x5F,0xFC,0x09,0x36,0xBF,0xC9,0x23,
+0x2F,0x18,0x60,0x3B,0x3C,0xCB,0xF2,0xEF,
+0x2F,0x52,0xAE,0x87,0x88,0x90,0x09,0x3E,
+0x2F,0xE9,0x80,0x1B,0xD9,0x87,0xAC,0x22,
+0x27,0xA4,0xB6,0xB6,0x83,0xC1,0x7E,0xB1,
+0x2F,0x4D,0x98,0x7E,0x14,0x8F,0x39,0x61,
+0x2F,0x70,0xF8,0xCB,0x6D,0x6F,0xAD,0x19,
+0x27,0xAE,0x77,0x6E,0x44,0xFB,0x73,0x8E,
+0x27,0x07,0x6A,0xC7,0x97,0xD1,0x25,0x8C,
+0x27,0x4D,0xE7,0x35,0xCF,0x4F,0xB3,0xC8,
+0x2F,0x93,0x98,0xD5,0xF9,0x22,0xC0,0x6C,
+0x2F,0x33,0xC4,0xB1,0xDD,0x9D,0xD6,0x09,
+0x27,0x7C,0x57,0xAD,0x6E,0x73,0xCC,0x4D,
+0x27,0xCC,0x61,0x70,0xEB,0x2B,0xBE,0xE8,
+0x27,0xE3,0x41,0x51,0x83,0x1B,0x0A,0xD3,
+0x27,0x1E,0x69,0xE6,0xF3,0x65,0xC4,0x3C,
+0x2F,0x67,0xEB,0x16,0xC0,0x32,0xC3,0x71,
+0x2F,0xB7,0x70,0xFF,0x5B,0x30,0x6F,0x0D,
+0x2F,0x9A,0x44,0x5C,0x10,0xCC,0x7C,0x04,
+0x27,0x0D,0xCA,0xCA,0xCD,0x0D,0xFD,0xDB,
+0x27,0x2F,0x05,0xB6,0x07,0x65,0x55,0xE0,
+0x27,0x7D,0x14,0x60,0xC5,0x70,0x40,0xEB,
+0x27,0xD0,0x32,0x0B,0x1A,0xD0,0x46,0xE9,
+0x2F,0xBA,0x7B,0x0A,0xC5,0xED,0x29,0x05,
+0x2F,0xBC,0xE1,0x2D,0xD0,0x74,0x8B,0x6A,
+0x27,0x43,0x46,0x80,0x00,0x7A,0xDA,0x56,
+0x2F,0xCC,0x13,0xDD,0xDB,0xE6,0xEA,0x5F,
+0x27,0xD5,0xF7,0x0D,0xA4,0xCF,0x0A,0x3C,
+0x2F,0x3A,0x4E,0x31,0x6E,0x41,0x1C,0x0C,
+0x2F,0x2D,0x13,0xD7,0xB5,0x9D,0xE1,0xC2,
+0x2F,0xCD,0x81,0x8F,0x87,0xFC,0x73,0x25,
+0x2F,0xE1,0x0C,0x86,0x7A,0x17,0x77,0x02,
+0x27,0x01,0x22,0x52,0x40,0x85,0x81,0x73,
+0x2F,0xAE,0xF2,0x3D,0x5F,0x4B,0x28,0x6E,
+0x2F,0x47,0x57,0xC8,0xF4,0x8D,0xC7,0x16,
+0x2F,0xD1,0xB4,0xA6,0xFD,0x9F,0x28,0xDC,
+0x27,0x2B,0x00,0x22,0x7A,0x7F,0xC6,0xAF,
+0x27,0x86,0x67,0xF3,0x5D,0xDA,0x14,0xBB,
+0x2F,0x93,0x70,0xC8,0xE8,0x06,0x19,0xB4,
+0x27,0xF5,0x2B,0xE9,0x76,0x14,0x4D,0x0E,
+0x27,0x5F,0x38,0xB6,0x7B,0xAB,0x91,0x1A,
+0x27,0x1F,0x87,0x42,0x2E,0xCC,0x6A,0x55,
+0x27,0xC1,0x0B,0x9A,0x84,0xE4,0xCF,0xE6,
+0x2F,0x3C,0x7B,0x1F,0x4F,0xA1,0x74,0x28,
+0x27,0x5B,0x16,0x28,0x2C,0x44,0x8C,0x66,
+0x2F,0x9C,0x87,0x74,0x8D,0x74,0x9D,0x37,
+0x27,0xFD,0x3F,0x6F,0xBB,0x05,0xCE,0xEF,
+0x2F,0x0A,0x82,0xD4,0xCF,0x15,0x39,0x47,
+0x27,0x8F,0xD0,0x14,0xBA,0x91,0x3E,0x9A,
+0x2F,0x5D,0x37,0x27,0x7F,0xEF,0xB2,0xAC,
+0x2F,0x9F,0x9B,0xE3,0xD6,0xDB,0xB8,0x43,
+0x27,0x40,0x70,0x9F,0xFB,0x05,0x54,0xCC,
+0x27,0xDD,0x71,0xDD,0x57,0x39,0x29,0x6F,
+0x2F,0x4A,0xBC,0xEC,0xDC,0xBD,0xA7,0xCD,
+0x2F,0xA0,0x79,0xF2,0x00,0xCD,0x18,0x5F,
+0x2F,0xA6,0x7F,0x48,0x02,0x11,0xCF,0x1A,
+0x27,0x17,0x60,0xC9,0x59,0xC5,0xD8,0xE4,
+0x2F,0xFA,0x1E,0xFF,0x1C,0x1F,0x8B,0x51,
+0x27,0xA7,0x17,0x26,0x57,0xAC,0x5A,0xF1,
+0x2F,0x57,0x99,0xCF,0x4B,0xC5,0x90,0xCB,
+0x27,0xF7,0x4A,0x50,0xA4,0xC4,0x75,0x50,
+0x2F,0xED,0xAE,0x00,0xF3,0xA5,0x31,0xF4,
+0x2F,0xE2,0x57,0xEB,0x66,0xA9,0x55,0x5D,
+0x2F,0xBD,0xC6,0xFC,0x3E,0x1C,0x06,0xF6,
+0x2F,0xCD,0xDC,0x0F,0x24,0xB4,0x5D,0x41,
+0x27,0x6C,0x30,0xD4,0x22,0x24,0xB9,0x36,
+0x27,0x74,0xE5,0x18,0xF4,0x3D,0xB9,0x89,
+0x2F,0x78,0x2B,0xE8,0xF0,0xD5,0xBD,0x9A,
+0x27,0xD6,0x3D,0xED,0x5C,0x3E,0xB3,0xED,
+0x27,0xFC,0x9D,0x81,0x7D,0x52,0x96,0x56,
+0x2F,0x60,0x86,0x9F,0x7C,0x86,0x45,0x47,
+0x27,0x8D,0x26,0xC6,0xA0,0x2E,0xCE,0x1B,
+0x2F,0x36,0xE2,0x67,0xD7,0x92,0x45,0x79,
+0x2F,0x2C,0x7F,0xC8,0x71,0x0E,0x75,0x63,
+0x27,0xBF,0x67,0xC0,0xC6,0x91,0x9D,0x26,
+0x27,0xE3,0x64,0x16,0xC3,0xFD,0x0C,0xD6,
+0x27,0xC6,0x18,0x2B,0xCA,0xBA,0xDA,0xE9,
+0x27,0x2F,0x9D,0xB3,0x70,0x25,0xE7,0xB2,
+0x2F,0x86,0x1C,0xAF,0x2F,0xFD,0x71,0xFD,
+0x2F,0xC2,0xB6,0x84,0x12,0x1E,0x43,0x93,
+0x27,0x38,0xD4,0x8C,0xE1,0xB5,0x7A,0x59,
+0x27,0x64,0x2D,0x04,0x06,0x31,0xFB,0xB5,
+0x27,0x80,0x6F,0x8D,0x28,0x02,0x93,0x1D,
+0x27,0x2E,0x30,0xE0,0x5C,0x5C,0xDC,0xF2,
+0x2F,0x92,0x92,0x94,0xB0,0x44,0xEF,0xD8,
+0x2F,0x41,0x7D,0x1D,0x96,0xC1,0x8B,0xBE,
+0x2F,0x6C,0x06,0xFA,0x0C,0x52,0x9A,0xED,
+0x2F,0xE7,0x73,0x7A,0x85,0x13,0x41,0xC7,
+0x27,0xDA,0x89,0x38,0xC4,0xB8,0xAE,0xBA,
+0x27,0xB1,0xCC,0xB2,0x11,0x33,0x87,0xEA,
+0x27,0x2B,0x13,0x2D,0x4C,0x4C,0x02,0xC1,
+0x2F,0xE4,0x1F,0x22,0x63,0xF8,0xB3,0x43,
+0x27,0x77,0xA6,0x98,0x73,0x93,0x21,0xA7,
+0x2F,0x6F,0xDC,0x5F,0xB6,0xBF,0x2A,0x33,
+0x2F,0xB1,0xBD,0xC7,0xBF,0x62,0x12,0x0F,
+0x27,0x28,0x78,0x74,0xDD,0x01,0xF3,0x3B,
+0x27,0xBC,0x2D,0xE3,0x70,0x37,0x29,0xD1,
+0x27,0xE2,0xBA,0x84,0x30,0x8B,0x16,0x28,
+0x2F,0x24,0xBA,0x82,0x4F,0x12,0x90,0x94,
+0x2F,0xE1,0x21,0xC9,0x76,0x60,0xFF,0x14,
+0x2F,0x5F,0xE0,0x84,0x48,0x2F,0x8A,0x44,
+0x2F,0x2C,0xF3,0x71,0x90,0xEA,0x73,0x1E,
+0x2F,0xBC,0x9F,0x03,0x18,0x92,0x9E,0xA3,
+0x2F,0x85,0x80,0xB6,0x8F,0x17,0x0A,0xAE,
+0x27,0x95,0xE5,0x71,0xB2,0x32,0x54,0xDB,
+0x27,0x28,0xC1,0x64,0x02,0x27,0xB9,0x58,
+0x27,0xC0,0x24,0xB9,0xE4,0x55,0x71,0x3E,
+0x27,0x70,0x0F,0x68,0x7F,0x55,0x0C,0xEF,
+0x27,0xF4,0x27,0xAE,0xC0,0xD8,0x28,0xB4,
+0x2F,0x5A,0x45,0x54,0xF7,0xBF,0x0C,0x8B,
+0x27,0xC2,0x81,0xB4,0x0A,0x5C,0x5C,0x3E,
+0x27,0x0C,0x95,0xE7,0xDB,0xFD,0xCC,0xB6,
+0x2F,0x20,0x45,0x3B,0xA6,0x5E,0xFD,0x1E,
+0x27,0x77,0x7C,0x9B,0xCE,0x36,0x11,0x8C,
+0x2F,0xC1,0x8A,0x91,0xD0,0x62,0x2F,0x70,
+0x27,0x58,0xC5,0x21,0x9C,0x57,0x39,0xC0,
+0x2F,0x3D,0x3C,0x6D,0xC5,0x1E,0xFA,0x2B,
+0x27,0x3C,0x6E,0xAA,0x78,0xA4,0x79,0x57,
+0x2F,0x43,0x39,0x45,0xD6,0x3C,0xDE,0x62,
+0x2F,0x97,0x8A,0x52,0x6C,0x4F,0xF3,0x78,
+0x2F,0x64,0x97,0x81,0x63,0x4B,0xEE,0x3E,
+0x2F,0x48,0x6B,0xFC,0x59,0x67,0x19,0x8E,
+0x27,0x01,0x72,0x8B,0x76,0x0C,0xC0,0x32,
+0x2F,0x35,0x21,0x5E,0x06,0x0F,0x15,0x4F,
+0x2F,0xB0,0xBA,0xD5,0xE9,0xCB,0xCE,0x6C,
+0x27,0x3B,0xE5,0xE4,0x5E,0xD9,0xD2,0x7B,
+0x27,0x01,0x0C,0x9F,0x87,0x90,0xA5,0x21,
+0x27,0xF4,0x96,0xBA,0x64,0xCF,0x35,0xB1,
+0x27,0x9E,0xB8,0x7E,0x55,0xF0,0x92,0xC8,
+0x27,0x69,0x66,0x24,0xB5,0x82,0x18,0x21,
+0x27,0xCC,0xBB,0x8D,0xAE,0x63,0x3F,0x32,
+0x2F,0x60,0x7D,0x52,0xCF,0x48,0x5F,0x2F,
+0x27,0xCA,0x8F,0x1B,0x81,0xAD,0xFB,0xDC,
+0x27,0x95,0xD0,0x1B,0x02,0xEA,0xCC,0x69,
+0x27,0x1E,0x53,0x9A,0x31,0x02,0xD2,0x76,
+0x2F,0x7A,0x4D,0x5A,0xF2,0xF7,0xB7,0x45,
+0x27,0xFD,0x06,0x27,0xB7,0x55,0x80,0x90,
+0x2F,0xF6,0xAA,0xDB,0x41,0xE3,0x4D,0x32,
+0x2F,0x6C,0xE0,0x55,0xFF,0x02,0xC9,0xC3,
+0x2F,0x4D,0xA2,0xE6,0xCE,0xE9,0x80,0x9C,
+0x27,0xFE,0x1F,0x56,0x4C,0x18,0xE0,0xB5,
+0x27,0xCC,0x50,0x27,0x7A,0x97,0x1D,0xA0,
+0x2F,0x43,0x5B,0x95,0xB0,0x94,0x6E,0x54,
+0x27,0x0E,0x13,0x19,0x0A,0xB3,0x32,0xE2,
+0x27,0xD2,0x0E,0x58,0x4F,0x2C,0xB2,0x6D,
+0x2F,0x10,0x0F,0x89,0x98,0xEA,0x0B,0x91,
+0x2F,0x69,0xE8,0xE6,0xF2,0x38,0xCD,0x27,
+0x2F,0x43,0x0A,0xF1,0x5D,0x4B,0x2E,0xAB,
+0x27,0xF8,0x7A,0x93,0xB6,0x9F,0xB3,0xEA,
+0x2F,0x1E,0xA0,0xCF,0x55,0x88,0x55,0x74,
+0x2F,0xAC,0x06,0x02,0xD0,0x07,0x28,0xCF,
+0x27,0xBC,0xB6,0x45,0xAE,0xFE,0xDC,0x1B,
+0x27,0x8F,0x26,0x98,0xE9,0x0A,0x98,0x40,
+0x27,0x34,0xED,0x0F,0x76,0xB0,0xC3,0x00,
+0x27,0x20,0xF4,0x3C,0x70,0xB1,0x27,0xAC,
+0x27,0xF8,0xBE,0x14,0xFD,0xAB,0x3E,0xCB,
+0x27,0x06,0x58,0xD4,0x92,0x9D,0xB3,0x25,
+0x27,0xA2,0x28,0x02,0x68,0x71,0x40,0xB2,
+0x2F,0xE2,0x70,0xC5,0x7B,0x3E,0x3D,0xFA,
+0x27,0x53,0xC1,0x84,0xBE,0xC0,0xD6,0xF5,
+0x2F,0xA9,0x90,0xFB,0x66,0x5E,0x9E,0x46,
+0x2F,0xF9,0x8F,0xD2,0x3F,0x98,0x86,0x59,
+0x27,0x2A,0x71,0xDC,0xFC,0x60,0xB9,0x18,
+0x2F,0xA8,0xA0,0xE6,0x2D,0x80,0xD4,0x55,
+0x27,0x7A,0xD5,0xC3,0xFF,0xDB,0xD1,0xCA,
+0x2F,0x81,0x38,0xB9,0x12,0xE7,0x31,0x7D,
+0x2F,0x53,0xC0,0xBC,0x5F,0x32,0xBC,0x8E,
+0x2F,0x81,0x05,0x87,0xAE,0xF0,0x5F,0xE9,
+0x2F,0x18,0xBB,0xEA,0xCA,0x54,0xFC,0x01,
+0x2F,0xC6,0xB2,0xCB,0x89,0x02,0x48,0x80,
+0x2F,0xF4,0x2A,0xC7,0x81,0xD0,0x5E,0x45,
+0x27,0x3C,0x9F,0x63,0xC4,0x56,0xAE,0x06,
+0x27,0x60,0xCA,0x32,0x32,0xF2,0x27,0xB6,
+0x2F,0x6A,0x44,0x84,0x03,0x34,0xAC,0x61,
+0x27,0x0C,0x6F,0xE5,0xFB,0x59,0x6D,0xEB,
+0x27,0xAE,0x86,0x63,0x9A,0xD0,0x85,0xFA,
+0x27,0x2B,0x67,0x8A,0xF2,0x29,0x4C,0x01,
+0x2F,0xEC,0x50,0x7B,0x7B,0x43,0x21,0x8E,
+0x27,0xC6,0xD6,0xE6,0x04,0xC2,0xAD,0xEF,
+0x2F,0x29,0x1E,0xAB,0xEC,0x9A,0x87,0xC7,
+0x27,0x0D,0xF0,0xC9,0x9E,0x68,0xB9,0x3B,
+0x2F,0xE9,0xA8,0x41,0x80,0xB0,0x8D,0x34,
+0x27,0x85,0x40,0x49,0x10,0xD7,0xD3,0xDF,
+0x27,0xFA,0x8E,0x47,0x61,0x32,0x98,0x61,
+0x27,0x4A,0x4F,0x70,0xA8,0x80,0xA4,0x0A,
+0x2F,0x66,0x4B,0x73,0x02,0x93,0x09,0xE2,
+0x2F,0x1E,0xEC,0xC9,0x97,0x76,0xE6,0x78,
+0x2F,0x5A,0x92,0x98,0x65,0x1C,0xC3,0x45,
+0x27,0x3C,0x6B,0xD2,0x6A,0x95,0x18,0x71,
+0x2F,0xC8,0x64,0xDE,0xB8,0xB6,0xCC,0x97,
+0x2F,0xEF,0x6A,0x99,0x9A,0xFF,0x39,0x23,
+0x27,0x6D,0x53,0x5D,0x07,0x36,0x8D,0x49,
+0x2F,0xB1,0x83,0xC7,0x96,0x59,0xD1,0x75,
+0x2F,0x01,0x1D,0x57,0x31,0xF7,0x03,0x9C,
+0x27,0xF0,0x98,0xFE,0xEE,0x20,0x2E,0x2B,
+0x2F,0x09,0x17,0x6C,0x3E,0x8D,0xE8,0x41,
+0x27,0x87,0x58,0x4F,0xD1,0x8A,0xE3,0x72,
+0x2F,0xD7,0x9D,0xD1,0x4F,0x6F,0x51,0x51,
+0x2F,0x36,0x13,0x85,0x6B,0xFB,0x85,0x38,
+0x27,0x8E,0x01,0xFF,0x76,0x77,0x66,0x21,
+0x2F,0x08,0x82,0x41,0x04,0xA9,0xFB,0x27,
+0x2F,0x17,0x1C,0xE5,0x7C,0x79,0x59,0x23,
+0x2F,0xAD,0x0A,0x92,0x1A,0xEC,0xFE,0x8D,
+0x2F,0xE8,0x89,0x57,0x67,0x53,0xDF,0x4D,
+0x2F,0x23,0xF2,0x61,0xA5,0x6C,0xB0,0xCD,
+0x2F,0xDE,0x8B,0x59,0x05,0x1A,0x75,0xE1,
+0x27,0x61,0x07,0x59,0xA2,0x56,0x2D,0xE7,
+0x27,0x70,0xD2,0x34,0xE6,0x99,0x46,0x03,
+0x2F,0x65,0xE9,0xF0,0x99,0x43,0x2B,0xD1,
+0x2F,0x22,0x87,0x2D,0x4D,0x97,0x4D,0x6B,
+0x27,0x4E,0x0C,0x57,0x36,0x7B,0x21,0x9B,
+0x27,0xDF,0x2B,0x7D,0xD1,0xF6,0x29,0xA8,
+0x2F,0x39,0x87,0xC2,0xD9,0x0A,0xCB,0x86,
+0x27,0xF9,0x67,0x8A,0xBC,0x40,0x50,0x4F,
+0x27,0x9B,0x32,0x54,0xB9,0x47,0x43,0x47,
+0x27,0xCA,0xB7,0x41,0x6F,0x3F,0x3A,0xB6,
+0x27,0xB9,0x3F,0x0D,0xB4,0xAD,0x5C,0xDF,
+0x2F,0xCB,0xB6,0xA8,0xC9,0xE0,0xB5,0xB0,
+0x27,0xA1,0x2B,0x72,0xE8,0x5E,0xF6,0x0B,
+0x2F,0x20,0xE9,0xE4,0x38,0x52,0xED,0xA2,
+0x2F,0x21,0x0C,0xD0,0xA8,0x9F,0xD0,0x9A,
+0x2F,0x7C,0x32,0x6B,0xD2,0x8A,0x79,0x20,
+0x27,0x21,0x31,0x10,0x7F,0x11,0xBA,0xEB,
+0x27,0x5D,0x15,0x64,0xD2,0xBD,0xF5,0x0D,
+0x2F,0x9A,0x63,0x68,0x20,0x62,0x8A,0x15,
+0x27,0x09,0x24,0x99,0xCA,0x4A,0x75,0x08,
+0x2F,0xF8,0x96,0x71,0x46,0x0F,0xB7,0xD5,
+0x2F,0xFA,0x5B,0xB7,0x1A,0xD8,0x97,0x7A,
+0x27,0x1A,0x69,0xD2,0x9E,0x70,0x7B,0x7A,
+0x2F,0x1E,0xB3,0x1F,0x2E,0x76,0x00,0x50,
+0x2F,0x76,0x4A,0xD3,0x62,0xDB,0xF1,0xEC,
+0x2F,0xEB,0x7A,0x44,0xC5,0xA3,0xF7,0xEA,
+0x27,0xDE,0xAA,0xA6,0x41,0xCF,0x34,0x1D,
+0x2F,0x8D,0xA3,0x6F,0x33,0xCA,0xCA,0x45,
+0x27,0x91,0x3E,0xC4,0x62,0x3D,0x5D,0xDC,
+0x2F,0xB2,0x92,0xB9,0x34,0x05,0xD6,0x38,
+0x27,0xE0,0x6F,0xC5,0x23,0x90,0x6E,0x8C,
+0x27,0xB8,0x41,0x66,0x5A,0x0C,0x40,0x75,
+0x27,0xB1,0x67,0xC7,0x42,0xE0,0xD4,0x3C,
+0x2F,0x22,0x14,0xB3,0x4C,0x2E,0x99,0x60,
+0x2F,0x69,0x3D,0x4C,0x48,0x70,0x17,0x5D,
+0x2F,0x10,0x49,0xF9,0x8C,0x96,0x8C,0xFD,
+0x27,0xEF,0xA7,0x14,0xE4,0xBE,0x29,0x0A,
+0x27,0x0B,0x7C,0xA0,0x84,0x3C,0x66,0x3E,
+0x2F,0xF6,0x22,0xE4,0xF3,0x53,0xEB,0x26,
+0x2F,0x36,0x6A,0xF0,0x1A,0xD3,0x06,0xF7,
+0x27,0xF7,0x02,0x56,0xAA,0x3E,0x2C,0x7E,
+0x27,0x93,0x9C,0x6E,0x6B,0x91,0x8D,0x11,
+0x2F,0xCA,0xA9,0x26,0xF9,0x2A,0x23,0xCF,
+0x2F,0x89,0xDA,0xCC,0xC1,0x0F,0x90,0x12,
+0x27,0x2A,0xD7,0xCB,0x00,0xCA,0xC7,0x93,
+0x27,0x42,0x5C,0xDE,0x81,0x94,0x93,0x0F,
+0x27,0x31,0x45,0x4E,0x5A,0xCA,0xA1,0x7A,
+0x27,0x9A,0xF7,0xBC,0x72,0x04,0x5A,0xD5,
+0x27,0xA2,0xA1,0x9F,0x97,0x19,0x83,0x82,
+0x27,0x1E,0xC9,0xCD,0x6A,0xCB,0x74,0xAB,
+0x2F,0xA1,0x51,0x83,0xD4,0x23,0x1B,0xF0,
+0x27,0xB4,0x80,0x8D,0x3A,0xC3,0x02,0xFB,
+0x27,0x7D,0xE9,0x78,0xB6,0xF1,0x4F,0xD9,
+0x2F,0x0F,0x9F,0x7E,0xCA,0xB8,0xCB,0x4C,
+0x27,0xD1,0x19,0x7D,0x9E,0x03,0x11,0x98,
+0x2F,0xE0,0xCD,0x0F,0xE3,0xF5,0x11,0x37,
+0x2F,0x76,0x08,0x4F,0x0C,0x2E,0xFB,0x33,
+0x27,0x8A,0x50,0x04,0xEC,0xED,0xC0,0x1E,
+0x2F,0x49,0x30,0x48,0x98,0x0A,0xDA,0xD4,
+0x27,0x17,0x43,0x69,0xE4,0xFD,0x90,0x93,
+0x2F,0x3F,0x62,0xC3,0x44,0xDA,0xC5,0xBF,
+0x2F,0x45,0x67,0xA4,0xBD,0xF7,0x9A,0x52,
+0x2F,0x82,0x29,0xE9,0x4B,0x5A,0x1E,0x0F,
+0x2F,0xFB,0xEB,0x4E,0xB0,0xE6,0x13,0xBD,
+0x27,0x93,0x3B,0x45,0xBA,0x0F,0xCA,0x56,
+0x27,0xDD,0x09,0x08,0x66,0x7D,0x3E,0x84,
+0x27,0x45,0x58,0x06,0x8B,0xBD,0x88,0x72,
+0x27,0xC3,0x08,0x2E,0xA2,0xB9,0x92,0x47,
+0x27,0x82,0x52,0xCD,0x48,0x91,0x64,0x05,
+0x2F,0x3F,0x02,0x63,0xC6,0xE4,0x5D,0x49,
+0x2F,0x9B,0xB9,0x8D,0x2F,0x4F,0xAA,0xD1,
+0x27,0x8F,0xA9,0x91,0xD6,0xFF,0x38,0x52,
+0x27,0xED,0xE0,0x6F,0x69,0x21,0x63,0xC9,
+0x27,0xF2,0xF1,0xAD,0xDB,0x04,0xB9,0x01,
+0x27,0xF1,0xBA,0xD3,0xD9,0x9E,0x56,0x43,
+0x2F,0x5D,0xC4,0x9A,0xFA,0x75,0x6C,0x98,
+0x2F,0xA6,0xB6,0x55,0xA9,0x0D,0x49,0x8C,
+0x2F,0x89,0x64,0x65,0x6B,0x86,0xAB,0xAD,
+0x27,0x6C,0xE3,0xCF,0x2F,0xC6,0x1A,0xE6,
+0x27,0x80,0x5F,0xAA,0xDF,0x7D,0xE0,0xDE,
+0x2F,0x88,0xCF,0xB9,0xCA,0x9A,0xC0,0xBB,
+0x2F,0xD7,0xDC,0x8E,0xFD,0x78,0xD7,0xDB,
+0x27,0xDD,0x02,0x5A,0x13,0xEB,0xF0,0x29,
+0x27,0xB2,0x34,0x1A,0x36,0x83,0x97,0x1D,
+0x2F,0x83,0x20,0x32,0xBD,0x61,0xC2,0x41,
+0x27,0x26,0xF1,0xB2,0x52,0xEA,0x27,0xA4,
+0x27,0xE6,0x7E,0x17,0x41,0x26,0x84,0x04,
+0x27,0xDA,0x70,0xEB,0xA3,0x68,0x7E,0x7A,
+0x2F,0x2D,0xE3,0x92,0xEC,0xDD,0xBA,0x54,
+0x2F,0x44,0xE9,0xD7,0x8B,0xCE,0x13,0xB0,
+0x27,0x95,0xB6,0xB5,0xFA,0x33,0xF7,0x85,
+0x2F,0xD0,0x18,0xC3,0x7F,0xA6,0xC8,0x71,
+0x27,0x89,0x3C,0xAA,0x1F,0xAC,0x8C,0xD5,
+0x2F,0x25,0xF5,0xF7,0xB3,0x30,0x40,0x5B,
+0x27,0x07,0xBA,0xD3,0x47,0x7D,0xDF,0xDD,
+0x27,0x18,0xAE,0x6C,0x00,0xE6,0x13,0xE6,
+0x27,0xDD,0xD1,0x46,0x28,0xA4,0x15,0x1F,
+0x2F,0x15,0x2D,0x29,0xF5,0xF8,0x9F,0x11,
+0x27,0x43,0x30,0x45,0x17,0x54,0x23,0xFB,
+0x27,0xA9,0x68,0xC7,0x4E,0x28,0x27,0xDF,
+0x2F,0xB4,0xAE,0x25,0xDA,0x52,0x0A,0x83,
+0x27,0xC6,0xE1,0x5C,0x2B,0x28,0x0D,0x7C,
+0x27,0x1D,0x1D,0x6C,0x0D,0xBF,0x99,0x63,
+0x27,0x1E,0xCD,0xE3,0x46,0x9A,0x20,0x81,
+0x2F,0x32,0x23,0xC8,0x3F,0x94,0xAF,0x96,
+0x2F,0xB8,0x02,0x09,0x0C,0x55,0x8E,0x98,
+0x27,0xEA,0x45,0xFB,0x83,0x21,0xA6,0xE8,
+0x27,0xB4,0x6E,0x03,0xB4,0x54,0x7D,0xCE,
+0x27,0xD5,0x0E,0x9A,0xE8,0x29,0xD4,0xF0,
+0x2F,0x26,0x90,0x6F,0x8D,0xD5,0x4F,0x70,
+0x27,0x39,0x23,0xB0,0xBD,0xDC,0xA4,0xEB,
+0x27,0x11,0xA7,0xD1,0xB9,0x75,0xAE,0x39,
+0x27,0xD1,0xD2,0x0C,0x42,0x7E,0x24,0x44,
+0x27,0x07,0x95,0x7E,0x4A,0x29,0xED,0xB8,
+0x27,0x22,0xE1,0x95,0x9D,0xAA,0x22,0x4F,
+0x2F,0x52,0x9A,0x55,0x00,0xC6,0x12,0xB4,
+0x2F,0xB0,0xEC,0x22,0xE9,0x82,0xBE,0x3B,
+0x2F,0xEA,0x2A,0x3B,0x05,0x70,0x18,0xD5,
+0x27,0xB3,0x4D,0x63,0x7A,0x72,0x55,0x77,
+0x27,0x88,0x48,0x1A,0x37,0x1D,0xCE,0x71,
+0x27,0x68,0x93,0xAC,0x29,0xBC,0x8D,0x1F,
+0x27,0x64,0xFC,0x70,0x5E,0x1C,0x94,0xF5,
+0x27,0x27,0xE0,0x28,0x33,0xE7,0xA3,0xE8,
+0x27,0xF3,0x4C,0xC7,0xAE,0x25,0x29,0x8A,
+0x2F,0xD6,0xDC,0x1F,0x41,0x7D,0x82,0x42,
+0x2F,0xC4,0xFA,0x1C,0x6E,0x4E,0x1D,0x92,
+0x2F,0x6F,0x54,0x3B,0x2A,0x8C,0x2F,0xCE,
+0x2F,0x48,0x9F,0x28,0x5A,0xEE,0x80,0xDC,
+0x2F,0xD0,0xE5,0xDB,0xF3,0xFA,0x95,0xBA,
+0x27,0x98,0x74,0xD5,0x16,0xEB,0x9A,0x9F,
+0x2F,0xFD,0xDD,0x17,0xE4,0xF4,0x52,0x4A,
+0x2F,0xA9,0x93,0x37,0xEB,0x9F,0xCA,0x1B,
+0x2F,0xB7,0x98,0x70,0x98,0xA0,0x62,0x0A,
+0x2F,0xDF,0x88,0x92,0x30,0xEA,0xC6,0xB6,
+0x2F,0x1C,0xC8,0x41,0x45,0x2A,0xDF,0xE5,
+0x2F,0x2D,0xDE,0xBF,0x3C,0x9B,0x80,0xAA,
+0x27,0x68,0x05,0x06,0xCC,0xD6,0x73,0x2D,
+0x27,0xB6,0xCE,0xBB,0xD3,0x73,0x9E,0xD1,
+0x2F,0xFC,0x53,0xDC,0x41,0xAF,0x31,0xC8,
+0x2F,0xC0,0xD4,0xB6,0x0E,0x51,0x54,0x5F,
+0x2F,0x7E,0x6A,0x21,0x78,0x64,0x0F,0x48,
+0x2F,0x86,0x67,0xB4,0x07,0x81,0x88,0xE4,
+0x2F,0xF0,0x08,0xE2,0x37,0x6F,0x82,0x46,
+0x2F,0xBA,0x5E,0xAA,0xC8,0xBB,0xFF,0xA3,
+0x27,0x01,0x0A,0x84,0x44,0xD9,0x19,0x7A,
+0x2F,0x26,0xBD,0x1E,0xB5,0xBF,0x56,0xBC,
+0x27,0x85,0x2A,0x44,0x0F,0x67,0x3C,0xDE,
+0x27,0x3C,0x67,0x5D,0xF2,0xF2,0xD7,0x07,
+0x27,0xCC,0x19,0x23,0x7E,0x66,0x63,0x0D,
+0x27,0xFD,0x5D,0x8C,0xB1,0x13,0xC6,0x88,
+0x27,0x09,0x4D,0xD8,0x64,0x31,0x75,0xCC,
+0x2F,0x43,0xD2,0xEC,0x93,0xB4,0xB9,0x96,
+0x27,0x97,0xF1,0x68,0xA8,0xFB,0x8E,0x91,
+0x2F,0x61,0xA4,0x3C,0x6B,0xCD,0x04,0xFC,
+0x2F,0xC6,0xE6,0xFA,0x3D,0x2E,0x48,0xBC,
+0x2F,0x94,0xF8,0x6C,0x9B,0xB0,0x44,0x58,
+0x2F,0x62,0xBB,0x89,0xE1,0x45,0x96,0x7B,
+0x27,0x33,0x6C,0x72,0x6F,0x08,0x96,0x90,
+0x2F,0xDE,0x06,0x3A,0x40,0x23,0x61,0xFE,
+0x2F,0xEE,0x8C,0xC9,0xC2,0xB8,0xBE,0x17,
+0x27,0x36,0x15,0x91,0x1E,0x92,0x44,0x72,
+0x2F,0x02,0x4A,0xF2,0x77,0xC4,0x93,0x32,
+0x27,0x2E,0x40,0xB1,0x9F,0x55,0x6B,0xBC,
+0x27,0x20,0xB9,0x20,0x83,0xBA,0x4C,0x03,
+0x2F,0x1C,0x8D,0xEB,0x15,0xF2,0x16,0x46,
+0x27,0x87,0x07,0x63,0x6D,0xDB,0xB6,0x91,
+0x27,0xDA,0xAF,0x7B,0xC9,0xE2,0xB1,0xE3,
+0x2F,0xD7,0x5E,0x92,0x98,0x4E,0x4B,0x75,
+0x27,0x66,0x73,0xC6,0x07,0x93,0xFF,0xC8,
+0x2F,0x0A,0xFF,0x18,0xAD,0x84,0x39,0x34,
+0x2F,0x18,0x5E,0x23,0xE2,0x87,0xC7,0x9F,
+0x2F,0x8A,0xF3,0xB3,0x8E,0x19,0x05,0x10,
+0x27,0x06,0xE8,0x01,0x08,0x91,0x2E,0xAF,
+0x27,0x69,0x89,0xB4,0xA5,0x7A,0xEA,0xD8,
+0x2F,0xE1,0xC3,0x5D,0x9F,0x24,0x67,0x4F,
+0x2F,0x95,0xA1,0x68,0x29,0x69,0x2F,0xAA,
+0x27,0x11,0xEF,0xA5,0x86,0x6F,0xE2,0xDB,
+0x2F,0xB3,0x49,0xAE,0xF1,0x75,0xFD,0xAE,
+0x27,0x6D,0x31,0x3F,0x6D,0x46,0xEA,0xD4,
+0x27,0x75,0xF6,0x5E,0x5A,0x65,0x9E,0xC2,
+0x27,0x17,0x04,0x3A,0x03,0x0E,0x0F,0x0A,
+0x2F,0x3E,0x5F,0x0F,0xCD,0x5A,0xE1,0x18,
+0x2F,0x01,0x77,0x43,0x9B,0x44,0x82,0xB4,
+0x2F,0x4E,0x0F,0x08,0x79,0x35,0x53,0x1B,
+0x2F,0xF1,0xD9,0x3F,0x46,0xEF,0xB2,0xA3,
+0x27,0x59,0x09,0x0E,0x51,0x01,0x33,0xD0,
+0x27,0xA8,0x4F,0xD5,0x1D,0xC3,0x84,0x57,
+0x27,0x5A,0x1F,0xD8,0x60,0x73,0x29,0x34,
+0x2F,0x9D,0x46,0x09,0x9B,0x0F,0xE4,0x90,
+0x2F,0x70,0xA9,0x49,0xEA,0x70,0xD1,0x29,
+0x27,0xE3,0x3A,0x7A,0xC4,0x3A,0xCD,0x5A,
+0x2F,0x3C,0xC6,0x91,0x35,0x84,0xB9,0x3D,
+0x27,0xA7,0x71,0xEE,0xCB,0x31,0x58,0x3B,
+0x2F,0x83,0x4A,0x91,0x29,0xBC,0x43,0x15,
+0x2F,0x41,0x01,0xAD,0x90,0xA3,0xDE,0x62,
+0x27,0x71,0xC4,0xF1,0xA5,0xB5,0x98,0x6B,
+0x27,0x6E,0xD7,0x23,0x06,0xC0,0x17,0xEB,
+0x27,0x73,0xB2,0x87,0x31,0x8F,0xE8,0x2C,
+0x27,0xFD,0x5D,0xA1,0x1E,0x85,0xF5,0xCB,
+0x27,0x49,0x11,0x4B,0x10,0x3D,0xDC,0x2C,
+0x2F,0xA5,0xAA,0x0F,0xC5,0x96,0xD8,0xFA,
+0x27,0xCB,0xDF,0x4B,0xF5,0xA0,0xAF,0x8D,
+0x2F,0xD0,0xD1,0xE8,0x81,0x23,0xE0,0xF9,
+0x27,0x71,0x19,0x6E,0x71,0xB7,0x4D,0x35,
+0x2F,0xFE,0xD0,0x98,0x16,0xB9,0xAA,0xA9,
+0x2F,0xE6,0xCE,0x6C,0xE8,0x09,0xC8,0xF0,
+0x2F,0xB7,0x56,0x8D,0x6C,0x62,0xCD,0xD6,
+0x27,0xDD,0x18,0x13,0xF7,0x73,0x60,0x88,
+0x27,0x39,0xE4,0xA6,0x82,0xE7,0x49,0x33,
+0x27,0xFD,0x7B,0x38,0x22,0x11,0xB0,0x50,
+0x2F,0xBD,0x78,0xE5,0xED,0x09,0xE4,0x51,
+0x2F,0xD7,0x14,0xB0,0x4E,0x3F,0x6C,0x1F,
+0x2F,0xA1,0xDA,0xBC,0x60,0x7E,0xE7,0xFD,
+0x2F,0xC0,0xB8,0x68,0xE7,0xCE,0xED,0xFD,
+0x27,0xCE,0x42,0x55,0x24,0x86,0x58,0x2E,
+0x2F,0x8B,0xDB,0x62,0x13,0xD7,0xC0,0x33,
+0x2F,0x1A,0x71,0x12,0xC6,0x11,0x57,0xD6,
+0x27,0xE1,0x20,0x65,0xD6,0xAE,0x76,0x0B,
+0x2F,0xFB,0xB5,0xF1,0xB7,0x0B,0x68,0xE7,
+0x2F,0x52,0x5A,0x07,0x1C,0x45,0x34,0x56,
+0x27,0xBE,0x31,0xDF,0x2C,0xDC,0x73,0x9A,
+0x2F,0xD5,0x78,0x02,0xF2,0xAE,0x56,0x2F,
+0x2F,0x5F,0x6D,0xCB,0x4A,0x0F,0x31,0x46,
+0x2F,0xDF,0xA4,0xC9,0x43,0xEC,0x41,0x96,
+0x27,0x30,0x13,0xC2,0x49,0x52,0x7C,0xF8,
+0x27,0x56,0xC5,0xBD,0xD5,0x16,0x2B,0x65,
+0x27,0x46,0x38,0xD5,0x1E,0x4B,0x18,0xD3,
+0x27,0xE1,0x54,0x17,0x41,0x8F,0xE9,0xF8,
+0x27,0xF2,0xD0,0xE6,0x4B,0x56,0x6A,0xAE,
+0x27,0x00,0x50,0x7B,0x5E,0x0E,0x05,0x4B,
+0x27,0x9E,0xDD,0xDA,0x42,0x11,0xD5,0xDB,
+0x27,0xDF,0xAA,0x7B,0x60,0x6F,0xE9,0xC4,
+0x27,0xE5,0x12,0x58,0xE5,0xEB,0xA5,0x6E,
+0x2F,0x86,0x2E,0xC1,0xDC,0x68,0x67,0xEE,
+0x27,0xE2,0x5A,0x2C,0x69,0xCD,0x8D,0x9D,
+0x27,0x5D,0xAE,0x9D,0xCA,0x79,0xB0,0x9C,
+0x2F,0x40,0xC4,0x22,0xC0,0xA2,0xBD,0xE1,
+0x27,0xF8,0xFC,0xD9,0xC9,0x1C,0xA6,0xAB,
+0x2F,0x86,0x42,0xEB,0xF6,0xD6,0xBD,0x5E,
+0x2F,0x6E,0xAB,0xA5,0x56,0xF0,0x49,0x04,
+0x2F,0xBD,0xED,0x65,0x1B,0xD4,0xC2,0x65,
+0x27,0xCD,0x1B,0x11,0x67,0x9C,0xF4,0x07,
+0x2F,0x2B,0x03,0x9A,0xE7,0x81,0x11,0xDE,
+0x2F,0x7E,0x8C,0x5D,0x4C,0xC6,0xC2,0xAD,
+0x2F,0xB4,0xCF,0x91,0x1B,0xE1,0x55,0x39,
+0x27,0x6F,0xFC,0x43,0xD2,0x44,0x95,0x10,
+0x2F,0xE3,0x74,0x10,0x5D,0x14,0x4F,0x58,
+0x27,0xB1,0x2E,0xCD,0x5C,0xEB,0x93,0x0A,
+0x27,0x5A,0x47,0xE2,0x0A,0x46,0x38,0x0E,
+0x27,0x88,0xDE,0x0E,0x80,0x15,0x48,0x90,
+0x2F,0xE7,0x99,0xD0,0x9A,0x76,0x00,0x2B,
+0x2F,0x0F,0xC0,0x41,0xD7,0xBD,0x98,0x83,
+0x27,0xEA,0x31,0x38,0x65,0xF9,0x39,0x25,
+0x27,0x90,0x58,0x36,0x1B,0x37,0x80,0x01,
+0x27,0xF3,0x5E,0x4C,0x53,0x15,0x44,0x0E,
+0x2F,0x34,0x9B,0x86,0x30,0x77,0xE3,0x2E,
+0x27,0xB2,0x29,0x08,0x81,0x57,0x8E,0x56,
+0x27,0x9E,0x29,0xDE,0xD2,0x7E,0x8F,0x5A,
+0x27,0x84,0x6E,0x77,0xD1,0x86,0x69,0xE0,
+0x27,0x9E,0x00,0x48,0xB8,0x33,0x0E,0xE2,
+0x27,0x4A,0x91,0xB1,0xEE,0x4A,0xFE,0x32,
+0x2F,0x25,0xB4,0xDB,0x83,0x69,0x0A,0x73,
+0x2F,0x72,0x23,0x3E,0xBD,0x30,0x91,0xCD,
+0x2F,0xC3,0xA3,0x6B,0x2F,0xE5,0x60,0xC4,
+0x2F,0x9C,0x13,0xB8,0xED,0xC9,0xB8,0x4E,
+0x2F,0x78,0x77,0x7D,0xDF,0xAD,0xA7,0xA8,
+0x27,0x4F,0x8A,0x2C,0x4F,0x7F,0xB0,0xD2,
+0x27,0xB8,0xE6,0x28,0x7D,0x50,0x9E,0x82,
+0x2F,0x0F,0x52,0x01,0x5E,0xD7,0x69,0xC0,
+0x2F,0xE0,0xF0,0xD6,0x7D,0x39,0xF2,0xAA,
+0x27,0x3A,0x21,0x2F,0xE2,0x91,0x2B,0xBC,
+0x2F,0x4D,0x62,0xBA,0x2F,0xBA,0x30,0x35,
+0x2F,0xF8,0x22,0xBA,0xB0,0x00,0xF5,0x6F,
+0x27,0x20,0x0C,0x5D,0x7F,0x11,0x9F,0xCA,
+0x27,0x49,0x20,0x6B,0xB6,0x0E,0x33,0xDD,
+0x2F,0xF8,0x78,0x0A,0x66,0x99,0x78,0xE5,
+0x27,0x9A,0x1A,0x0B,0x35,0x4B,0x1B,0xD9,
+0x27,0x28,0xF2,0xE3,0x16,0x7C,0xC4,0xF5,
+0x27,0x4B,0xBE,0xF8,0xE2,0xD2,0xB1,0x45,
+0x2F,0x7A,0x22,0x67,0x44,0x75,0xBD,0x3E,
+0x2F,0x35,0x9D,0x49,0x9E,0x2C,0x93,0xED,
+0x2F,0x19,0x63,0xA6,0xCC,0x37,0x37,0x1F,
+0x2F,0xB3,0x25,0xFF,0x58,0xF3,0xE2,0x40,
+0x2F,0xD1,0x88,0x93,0x77,0x42,0x2A,0x0F,
+0x2F,0x19,0x84,0xD8,0x63,0x85,0x70,0xBD,
+0x27,0xB2,0xD2,0x09,0x05,0x6E,0xDC,0xAC,
+0x2F,0x61,0x3F,0xBE,0x66,0x9E,0xAD,0x9C,
+0x2F,0xF7,0xE8,0xCE,0xF1,0x4A,0xE9,0x9F,
+0x2F,0xFE,0x5D,0x6E,0xC0,0xCF,0xE4,0x37,
+0x27,0x61,0xB1,0xD1,0x1A,0xF8,0xE4,0xB2,
+0x2F,0x39,0x40,0x1D,0x8B,0x33,0xBD,0xCC,
+0x27,0x79,0x73,0xCB,0xDB,0x24,0x92,0x0A,
+0x2F,0xA5,0x45,0x60,0xC0,0x67,0x30,0xCA,
+0x2F,0xDD,0x50,0xF5,0x7D,0x0E,0x1B,0x4F,
+0x2F,0x33,0xA0,0x8D,0xF0,0x21,0x45,0x16,
+0x2F,0x94,0xB5,0x71,0x85,0x23,0x17,0xE5,
+0x2F,0x94,0xB4,0x3D,0x04,0x8B,0xF2,0xFC,
+0x27,0x57,0xA9,0xE7,0x78,0xFD,0xD9,0xC4,
+0x2F,0xAF,0xB7,0x17,0x81,0x72,0x6C,0xC1,
+0x2F,0xAF,0x1D,0xF9,0x5D,0x2B,0x50,0x7F,
+0x2F,0xF4,0x33,0x5A,0xDD,0x29,0x57,0x28,
+0x2F,0x7E,0x39,0x91,0x8B,0x38,0x9C,0xF1,
+0x27,0x84,0x49,0xB2,0xB9,0x5C,0x96,0x92,
+0x2F,0x59,0xAE,0xBC,0xAD,0x3A,0x6B,0x64,
+0x27,0x48,0x49,0x6B,0xEC,0x53,0x67,0x77,
+0x2F,0x0E,0x47,0x0D,0x38,0x32,0x9D,0x10,
+0x27,0x9B,0xE4,0x6D,0x60,0xC7,0xCB,0x04,
+0x2F,0xA6,0x00,0x1E,0x2A,0x6D,0x88,0xFE,
+0x2F,0x25,0xDA,0x4B,0x95,0x33,0x76,0x48,
+0x2F,0x68,0x59,0xA7,0x4A,0xA5,0xD3,0xD4,
+0x2F,0x6F,0x3E,0x4A,0xB0,0x76,0xF3,0x05,
+0x27,0x47,0x04,0x18,0x8D,0x9D,0xF5,0xD5,
+0x2F,0xC3,0xC5,0xC9,0x7E,0x24,0x1D,0xF3,
+0x27,0xAA,0x98,0x75,0xF5,0xD7,0x17,0x3F,
+0x27,0xB4,0xF8,0xC1,0x3F,0x38,0x35,0x31,
+0x2F,0xA5,0xA6,0xF5,0x4C,0xE9,0x36,0xDB,
+0x27,0xF0,0xF7,0x43,0xC3,0xEC,0xFE,0x8F,
+0x27,0x44,0x36,0x5D,0x18,0xBE,0x72,0xBA,
+0x2F,0x68,0x86,0xCB,0xF3,0xA3,0xD5,0xCA,
+0x27,0x91,0x6A,0x31,0x81,0x5F,0x12,0xE9,
+0x27,0x0D,0x84,0x50,0x6B,0x0C,0x48,0xC1,
+0x2F,0xFE,0x4F,0xC0,0x29,0x04,0xD6,0x0C,
+0x27,0x69,0x46,0x97,0xE8,0x8D,0x1B,0xD4,
+0x27,0xE8,0x1D,0xB2,0x86,0x57,0xD5,0x0A,
+0x2F,0x1A,0xC8,0x2D,0x78,0x76,0x73,0x6D,
+0x27,0x41,0x6A,0xDB,0x09,0x15,0x1E,0x22,
+0x2F,0x8A,0x50,0x9A,0x41,0x0E,0x15,0x88,
+0x27,0x1B,0x90,0xBB,0x6E,0xBA,0x16,0x7D,
+0x2F,0x46,0xC3,0x9B,0x5C,0x8B,0x2E,0x19,
+0x27,0x1A,0xE9,0xF4,0x39,0x78,0x16,0x95,
+0x2F,0x00,0x33,0x5B,0x8C,0x04,0x01,0x32,
+0x2F,0x48,0x38,0x31,0x4B,0xA7,0xE0,0x38,
+0x27,0x3D,0x2C,0x76,0xB0,0xE2,0x8A,0x14,
+0x2F,0x4E,0x9B,0x8A,0xE4,0x2D,0x03,0x41,
+0x2F,0xE0,0xB7,0x51,0x9D,0xE2,0x65,0x0E,
+0x27,0xEF,0xEF,0x5A,0xA7,0x7C,0xCB,0xA4,
+0x2F,0xC8,0xBE,0x82,0x77,0xE3,0xDF,0x8D,
+0x27,0xE1,0x8D,0x93,0x5B,0xD5,0xD1,0x0D,
+0x27,0x20,0x65,0x8A,0x66,0x09,0x0A,0x36,
+0x2F,0x3D,0x81,0x65,0x37,0x44,0x5D,0xC2,
+0x27,0x9A,0xBD,0x8A,0xAD,0x5C,0x5F,0xE6,
+0x27,0xF8,0x82,0x92,0x01,0x13,0x12,0xBC,
+0x27,0xAC,0x02,0x9F,0xF3,0x5F,0x2C,0x1F,
+0x2F,0xE8,0x24,0x3D,0x81,0xAD,0x7F,0x91,
+0x2F,0x83,0x22,0x0F,0x03,0x2C,0x2D,0x8E,
+0x27,0xAB,0xDE,0x24,0x9B,0x4A,0x29,0xD4,
+0x2F,0x78,0x56,0xFD,0xF1,0xD9,0x81,0x86,
+0x2F,0x69,0x6B,0x7C,0x4D,0x72,0xC1,0xBF,
+0x27,0x05,0x8C,0xC6,0xCE,0x4D,0x4B,0xB6,
+0x27,0x3F,0x0F,0xB5,0x73,0x0C,0x09,0xC5,
+0x2F,0x3A,0x73,0x47,0xA4,0xC9,0x55,0xEB,
+0x27,0x69,0x21,0xE8,0x28,0xA6,0x29,0xB6,
+0x2F,0xC8,0x84,0xC0,0x0B,0xAC,0xFD,0x72,
+0x27,0x1F,0xA1,0x55,0xE7,0x0E,0x93,0xE5,
+0x2F,0xD9,0x1C,0xB5,0x6A,0x69,0xDF,0xB0,
+0x27,0x41,0xE1,0x8A,0x62,0xFC,0xA3,0x96,
+0x2F,0x2E,0x6A,0x61,0xC9,0x92,0x25,0x0B,
+0x2F,0xEE,0xA8,0x0D,0xCE,0x4D,0xBA,0xAA,
+0x2F,0xE7,0xEE,0xF2,0x72,0x59,0xA6,0x21,
+0x2F,0x35,0x8E,0x6B,0x45,0x10,0xFF,0xB1,
+0x2F,0x75,0xE6,0x9C,0x8C,0xF0,0x19,0xCA,
+0x2F,0xA3,0x22,0xB3,0xE8,0x00,0x26,0x29,
+0x27,0x67,0xDD,0xE1,0x66,0xA0,0x3A,0x4F,
+0x2F,0x52,0x0D,0x62,0x58,0x98,0x74,0xBE,
+0x27,0x3C,0x14,0xF8,0xB4,0x01,0x4F,0xB5,
+0x27,0x08,0x72,0x52,0xC9,0xCC,0x11,0xA9,
+0x2F,0x43,0xBA,0x53,0xA4,0x8A,0xCF,0xE1,
+0x2F,0x33,0xB4,0x99,0xC1,0xBB,0x3C,0x67,
+0x27,0x74,0x3E,0x72,0x9B,0x60,0xB7,0x58,
+0x27,0x5B,0x5B,0xF1,0x60,0xB6,0xB5,0x34,
+0x2F,0x51,0x6C,0x6C,0x60,0x19,0x51,0xCB,
+0x2F,0xEC,0x53,0xCA,0x84,0x6D,0x5D,0x26,
+0x2F,0x06,0x80,0x42,0x7F,0x08,0x71,0x0F,
+0x27,0xA5,0xC6,0x48,0x99,0x21,0xDC,0xAE,
+0x2F,0xFE,0xF8,0xFF,0xAE,0xBA,0xFA,0xBC,
+0x2F,0xF3,0x87,0xFA,0x6E,0x8C,0x7A,0xD4,
+0x2F,0xA5,0x7D,0x52,0x8D,0xBF,0xDA,0xF2,
+0x27,0xE6,0x1F,0x95,0xCF,0x17,0x2C,0xB6,
+0x27,0x79,0xC3,0x93,0xEA,0x76,0x24,0xA0,
+0x27,0xD1,0x04,0xE1,0xED,0x78,0xD4,0x93,
+0x27,0x2B,0xDC,0x11,0x17,0xD4,0xE4,0xDE,
+0x2F,0xDA,0x2F,0x6A,0x6D,0x58,0x7D,0xFF,
+0x27,0xE7,0x53,0xD8,0x24,0x59,0xFF,0x55,
+0x2F,0xEB,0x88,0x20,0x7A,0x68,0xE8,0x6C,
+0x27,0x6B,0x3F,0x94,0x05,0xF0,0xE0,0x3B,
+0x2F,0x17,0x20,0xAA,0x88,0x28,0x46,0x74,
+0x2F,0xF4,0xE6,0xB6,0x95,0xCF,0xBE,0x1B,
+0x2F,0x0C,0x93,0x23,0x54,0xCE,0xD9,0xCB,
+0x27,0xDE,0x1C,0xBB,0x9F,0x1E,0x8B,0xB7,
+0x27,0x41,0x24,0xD9,0x68,0x1D,0x6B,0xAA,
+0x27,0x57,0xB5,0x2B,0x52,0xDB,0x2F,0x62,
+0x2F,0xD8,0xF7,0x1C,0xC5,0x85,0x1E,0x9D,
+0x2F,0x31,0x1A,0x70,0xD3,0x13,0xB7,0x16,
+0x27,0xD5,0xBC,0xBA,0xD0,0x6F,0x1C,0x90,
+0x27,0xD4,0x7C,0x92,0x4C,0xE4,0xA1,0x0B,
+0x27,0xD1,0x28,0xD2,0x9B,0xBA,0x49,0xFA,
+0x2F,0x84,0x1E,0xD3,0x3B,0x31,0x0F,0xEA,
+0x27,0xD4,0x80,0x19,0x88,0x31,0x00,0x19,
+0x2F,0x58,0xA3,0xEB,0xA2,0xCA,0xD0,0xD6,
+0x27,0x92,0x7B,0xF4,0x56,0x41,0xE1,0x87,
+0x27,0xD5,0xB9,0x0B,0x86,0x38,0x9C,0x9A,
+0x27,0x84,0xED,0x9A,0x14,0x3B,0xF3,0x03,
+0x27,0x2C,0x14,0x17,0xE3,0xCE,0xC8,0xF3,
+0x2F,0x94,0x85,0xD8,0xA4,0xE4,0xAB,0x57,
+0x27,0x57,0x78,0x19,0xB9,0x0F,0xBB,0xC3,
+0x2F,0x91,0x4D,0x65,0x7D,0xAF,0xC5,0x43,
+0x2F,0xA1,0xF6,0x34,0x52,0xB7,0xE3,0xB4,
+0x2F,0x08,0x4F,0x17,0x70,0xB7,0x10,0xFF,
+0x27,0xB7,0xD0,0xDC,0x5A,0xD4,0x64,0xB4,
+0x27,0x4B,0x13,0x72,0x59,0x81,0x90,0xCE,
+0x27,0xED,0x08,0x23,0xB7,0xFC,0x8A,0x1E,
+0x2F,0x6C,0x48,0xC4,0xC8,0x0B,0xC6,0x43,
+0x2F,0x01,0x7F,0x5C,0x2E,0xF6,0xDD,0xD0,
+0x27,0x7C,0x2F,0x28,0x18,0x49,0x4C,0xB6,
+0x2F,0x31,0xAE,0xD9,0x63,0x07,0xA2,0xFB,
+0x2F,0xA2,0x80,0x11,0xFE,0x99,0xF4,0xC7,
+0x2F,0x30,0x0D,0x79,0x27,0x4C,0xE0,0x5C,
+0x27,0x14,0x09,0x22,0xAC,0xCC,0x8C,0xED,
+0x27,0xD2,0xDA,0x08,0x3F,0xE5,0x1E,0xA5,
+0x2F,0x31,0x85,0x5D,0x86,0xB9,0xBE,0xC3,
+0x27,0x95,0x0E,0xBC,0x52,0x75,0xD3,0x0F,
+0x27,0xDD,0x0A,0xE6,0x13,0xA0,0x24,0x4E,
+0x2F,0xA5,0x16,0xC5,0xE5,0x94,0x49,0x94,
+0x27,0x8B,0x20,0x53,0x30,0xCA,0xDB,0x5F,
+0x27,0x96,0xF7,0x40,0x53,0x01,0x53,0x90,
+0x27,0xC7,0x65,0x6F,0xED,0xB1,0x93,0x2A,
+0x2F,0x48,0x55,0xAC,0x58,0x3C,0x02,0x00,
+0x27,0x76,0xE3,0x34,0xE7,0x3E,0x7B,0x07,
+0x2F,0x75,0x68,0xAC,0x9C,0xE1,0x83,0xAE,
+0x27,0x97,0x6B,0xEA,0x0D,0xCA,0x8A,0xB2,
+0x2F,0xA5,0xA5,0xDA,0x08,0x31,0x78,0x98,
+0x27,0x06,0xBE,0xB8,0x15,0xA7,0x8A,0x46,
+0x27,0xE2,0x03,0x15,0x2F,0x06,0xE2,0x97,
+0x27,0xB7,0x0F,0xAA,0xAC,0x78,0x0B,0x33,
+0x27,0x6A,0x99,0x8E,0x51,0x3D,0x84,0x28,
+0x27,0x95,0xDC,0x89,0xD7,0xBF,0x8F,0xFA,
+0x2F,0x42,0x1A,0x31,0x50,0x9D,0x4E,0xF5,
+0x2F,0x0F,0xA9,0x23,0xC4,0xAF,0xD2,0xD4,
+0x2F,0xE7,0x31,0x0B,0x67,0x83,0x50,0x38,
+0x27,0x15,0x91,0x77,0x32,0xAC,0xFD,0xE8,
+0x2F,0x2F,0x69,0x6D,0xCA,0x43,0x1C,0x59,
+0x27,0xD8,0x9D,0x9D,0x89,0xE2,0xF0,0x78,
+0x27,0x0F,0x11,0xE7,0x41,0x0A,0x5D,0xBF,
+0x2F,0xA7,0x7C,0x61,0x76,0x6B,0x6E,0xFB,
+0x2F,0x3E,0x58,0x27,0x88,0xE6,0x36,0x13,
+0x27,0xAA,0x02,0xAC,0x6B,0xCA,0x05,0xBF,
+0x2F,0x2D,0x13,0x18,0x49,0x76,0xC6,0x99,
+0x2F,0xA1,0x89,0x7E,0xB8,0xCE,0x3E,0x9A,
+0x2F,0x3A,0xAB,0x69,0x58,0x2A,0x06,0x91,
+0x2F,0x74,0xD3,0x06,0x49,0xD2,0x0D,0x1D,
+0x2F,0x0C,0x47,0xFF,0xD8,0x95,0x12,0x63,
+0x27,0xCD,0x1C,0x73,0x0B,0xCB,0x9D,0x1E,
+0x27,0x64,0xB8,0x06,0xB8,0xB9,0xD7,0x7B,
+0x27,0x05,0x52,0xF3,0x22,0x22,0x1B,0xB8,
+0x2F,0xA6,0x9E,0x5B,0xEA,0x6E,0x8D,0x88,
+0x27,0x00,0x37,0x94,0xD9,0x6A,0xAB,0xBD,
+0x2F,0xB9,0xA8,0x7E,0x7A,0xF0,0x3C,0x7D,
+0x27,0x33,0x95,0x83,0x72,0xC3,0x5D,0x83,
+0x27,0x08,0x18,0x3B,0xFF,0xC5,0x8D,0x3B,
+0x27,0xAB,0x94,0x26,0xE0,0x35,0xDF,0x09,
+0x2F,0x4C,0x3D,0x69,0x59,0x84,0x09,0x11,
+0x27,0xCD,0xFE,0xAC,0x05,0x77,0xE3,0x33,
+0x2F,0x41,0x88,0x2F,0xB3,0x6A,0xF9,0xE0,
+0x2F,0x9D,0x99,0xC2,0xF8,0x50,0xB7,0x71,
+0x2F,0x90,0x1E,0x73,0x10,0xC0,0xC6,0x49,
+0x2F,0x7C,0x98,0x24,0x0C,0x08,0x88,0x9C,
+0x27,0x6D,0x60,0x6A,0x25,0xCE,0x74,0xEA,
+0x27,0xD0,0x76,0xDF,0xD3,0xAA,0xB9,0x57,
+0x27,0xAA,0x33,0x32,0x04,0xD5,0xA4,0xCF,
+0x2F,0x67,0xCF,0xE8,0xA8,0x6B,0xDA,0x6D,
+0x27,0x1C,0xCE,0xAB,0x32,0x8B,0x79,0x61,
+0x27,0x43,0x8F,0x55,0x0A,0xB7,0x69,0xCB,
+0x27,0xA0,0x09,0x92,0x83,0xAD,0x20,0xD2,
+0x2F,0x3A,0x70,0xE3,0x52,0x11,0xD4,0x08,
+0x2F,0xF4,0xF3,0x19,0xFC,0x49,0xBF,0xBA,
+0x27,0x70,0x9F,0x50,0xB9,0x54,0xE0,0x9D,
+0x27,0x43,0x4A,0x51,0x35,0x68,0x17,0x39,
+0x27,0x4D,0xF5,0xB6,0x59,0xCA,0x06,0xD2,
+0x27,0xE0,0x7E,0xBA,0xFA,0xEE,0x63,0x06,
+0x27,0x6A,0x72,0x74,0x6F,0x36,0xD1,0x73,
+0x2F,0x30,0xF1,0x4B,0xFF,0x62,0xC7,0x89,
+0x27,0xC2,0x73,0xD9,0xFD,0x18,0x36,0x26,
+0x2F,0x08,0x09,0xC5,0x3A,0xF0,0xA5,0xD4,
+0x27,0x33,0x86,0xBA,0x9E,0xAB,0xCA,0x03,
+0x2F,0xDE,0x79,0xDD,0x97,0x35,0x9D,0x61,
+0x27,0x7B,0xFA,0x3D,0x98,0x0E,0x8C,0x87,
+0x27,0xC8,0xF4,0x31,0xEF,0x1F,0xD0,0x3F,
+0x2F,0xA9,0x70,0x62,0x0E,0x3B,0x75,0x3D,
+0x2F,0xEE,0x1D,0xE8,0xD6,0x74,0xAC,0x0D,
+0x2F,0xC9,0x8B,0xC1,0xB9,0x44,0x1F,0xD4,
+0x27,0x51,0xCF,0x26,0xD5,0x77,0x83,0xB7,
+0x2F,0xB9,0xB9,0x4B,0xA9,0x49,0xC7,0x12,
+0x27,0x6C,0xDD,0xFF,0x8D,0x22,0xEB,0xF7,
+0x27,0xCE,0x19,0x7B,0x9A,0x41,0x09,0x28,
+0x2F,0xA1,0x2C,0xE7,0x2A,0x0A,0x14,0xA0,
+0x27,0x1B,0x34,0x46,0x70,0x6D,0xA4,0x24,
+0x27,0x61,0xEB,0x42,0xA8,0x7D,0x5B,0x5C,
+0x27,0x3A,0xA3,0xAE,0xBB,0x7C,0x07,0xCA,
+0x27,0xBD,0xD2,0x91,0x12,0x63,0x9D,0xDD,
+0x27,0xA8,0x3F,0xA6,0xD6,0x6B,0x20,0x45,
+0x2F,0x9D,0xE8,0x30,0x0D,0x67,0x08,0x79,
+0x27,0xA4,0x92,0xD3,0x13,0x13,0xE7,0x0C,
+0x2F,0x65,0xC2,0xD6,0xA7,0xC1,0x38,0x3A,
+0x2F,0x59,0xFB,0xD3,0x5C,0xCD,0xDC,0xF0,
+0x2F,0xC4,0xD4,0xB4,0x9C,0xDC,0x23,0x39,
+0x2F,0x50,0x05,0xE8,0x09,0x51,0xED,0x78,
+0x27,0x9A,0x1C,0xFE,0x41,0x1F,0xEC,0x24,
+0x2F,0x41,0x1B,0x19,0x17,0x31,0xFF,0xE2,
+0x27,0x08,0xDD,0x2D,0xD2,0x65,0xEF,0xA5,
+0x27,0x8D,0xD7,0xD4,0x40,0xCC,0xDE,0x2D,
+0x2F,0xD2,0x1B,0x16,0x9B,0x65,0x0C,0x28,
+0x27,0x2A,0xBC,0xDD,0xB9,0x08,0xD7,0x46,
+0x27,0x9D,0x56,0x26,0xCB,0x9B,0xB6,0x15,
+0x27,0xDA,0xAC,0x3A,0x73,0x1E,0xEA,0x5C,
+0x2F,0x1B,0x63,0x46,0xA3,0xB8,0x66,0xF6,
+0x27,0x2F,0xB1,0xAC,0xA8,0xB2,0x74,0x4A,
+0x2F,0xFA,0xC4,0x6A,0x3E,0xBD,0x19,0x58,
+0x27,0x08,0x8C,0xA0,0x2D,0x05,0x6D,0x1A,
+0x27,0x1D,0xC1,0x0F,0x6A,0xF7,0xD4,0x8B,
+0x27,0xD4,0xB4,0x73,0x7B,0xD5,0xA7,0xCA,
+0x27,0xBC,0x49,0xD4,0x56,0xF9,0x82,0x5B,
+0x2F,0x18,0x31,0x02,0x3C,0x49,0x4A,0x8F,
+0x27,0xB3,0x70,0xE3,0x80,0x6B,0x55,0x2F,
+0x2F,0x12,0x22,0x25,0x78,0xA5,0x20,0xD5,
+0x2F,0xC2,0x9C,0x23,0x06,0xF6,0xA7,0x17,
+0x27,0x38,0x2C,0x1B,0xAC,0x32,0xEA,0x02,
+0x27,0x40,0xA3,0xAB,0x57,0x56,0xC4,0x8A,
+0x2F,0xCE,0xAD,0xC3,0x6F,0xAE,0x82,0x1B,
+0x27,0x7F,0x1C,0x42,0x05,0x89,0x53,0xB4,
+0x27,0x98,0x41,0x46,0xBB,0x23,0xD6,0xF9,
+0x2F,0x60,0x19,0x76,0x17,0x36,0x37,0x79,
+0x27,0x93,0x9A,0xBA,0x78,0xE6,0x0C,0x9D,
+0x27,0xBD,0x33,0xD2,0xFF,0x37,0xBE,0x39,
+0x2F,0x99,0xC8,0x2B,0xB4,0x7F,0xAA,0x28,
+0x27,0x2A,0x1F,0xE3,0x3E,0xB8,0x75,0x12,
+0x27,0x73,0xE5,0x12,0xA3,0x51,0xA4,0x55,
+0x2F,0x01,0x28,0x5A,0x69,0xC6,0x7C,0xF8,
+0x2F,0x70,0xE1,0x6B,0x90,0xB1,0x53,0xF4,
+0x27,0x55,0x8C,0xB8,0x7C,0x67,0x01,0x76,
+0x2F,0xFD,0x57,0xCF,0x64,0xEA,0x21,0x3C,
+0x27,0xC5,0x61,0x90,0x9C,0x16,0xE9,0x34,
+0x27,0x68,0xBD,0xC6,0x4F,0x56,0x62,0xBC,
+0x2F,0x34,0x0B,0xE0,0xC9,0xCE,0x2D,0x4C,
+0x27,0x79,0x93,0x24,0xDB,0x8F,0x1C,0xF3,
+0x2F,0x52,0xE7,0x4C,0x3B,0x46,0x84,0x74,
+0x2F,0x1E,0x78,0x61,0x77,0xF3,0x13,0xD8,
+0x27,0xE5,0xAC,0xE7,0x4D,0x7B,0x25,0xDF,
+0x2F,0x98,0x92,0x39,0x9F,0x96,0x52,0x65,
+0x27,0x1F,0xC9,0x05,0xF3,0xEC,0xC2,0xAF,
+0x2F,0x73,0x08,0xD0,0x34,0x23,0x0A,0x58,
+0x27,0x95,0x1A,0x3A,0xAD,0x55,0xD5,0x9F,
+0x27,0xEC,0x70,0x5F,0x20,0x9F,0x72,0xD8,
+0x2F,0x3B,0x74,0xEE,0xE4,0xC5,0x53,0xC1,
+0x2F,0x25,0x51,0xFD,0x54,0x47,0xEF,0xF3,
+0x27,0x65,0x79,0x07,0x64,0xB5,0x2C,0x71,
+0x27,0x47,0x58,0x59,0xD1,0x75,0x95,0xAA,
+0x2F,0xE1,0xAD,0x28,0xC6,0x8D,0x08,0x78,
+0x2F,0xF0,0xC3,0xC9,0xED,0xB1,0x61,0xBC,
+0x27,0x3C,0x3A,0xFF,0x2D,0x8B,0x02,0x11,
+0x27,0x2D,0xA3,0xB2,0x42,0x46,0xB5,0x3A,
+0x2F,0xF7,0x6D,0x13,0x48,0x98,0x10,0x81,
+0x27,0x70,0x1F,0xE6,0x10,0x38,0xDF,0xED,
+0x2F,0xCA,0xB9,0xF6,0x7C,0x77,0x24,0x3D,
+0x2F,0x1D,0x59,0xA2,0x45,0x74,0xA4,0x3F,
+0x2F,0x91,0x89,0x48,0xCE,0x20,0xC1,0x22,
+0x27,0x06,0x1D,0x8E,0x21,0x99,0xCC,0x90,
+0x27,0xB7,0xF2,0xCD,0x63,0x01,0x80,0x10,
+0x27,0xC1,0x7D,0x53,0xC6,0xB3,0xD7,0xC6,
+0x27,0x76,0x82,0x37,0xDE,0x21,0x96,0xE8,
+0x2F,0xA2,0xF2,0x1E,0xA1,0x4F,0x4C,0xDC,
+0x2F,0xE5,0xC2,0x59,0x9C,0xF6,0x37,0xEA,
+0x2F,0x3A,0x9C,0xC3,0x4A,0x41,0xF3,0x23,
+0x27,0xDD,0xE9,0xD0,0x46,0x30,0x53,0x25,
+0x27,0x64,0x86,0x87,0x9E,0x54,0xDC,0x50,
+0x27,0xC5,0x6E,0x20,0x1A,0x9D,0xDE,0x3B,
+0x27,0xC1,0xDE,0x92,0xCA,0xF4,0x64,0x5B,
+0x27,0xE7,0x69,0xFC,0x74,0x9E,0x35,0xC7,
+0x27,0x6E,0x9B,0xA9,0xE2,0x6A,0xE7,0x0A,
+0x2F,0x4D,0xCC,0x3E,0x04,0x48,0x60,0x14,
+0x27,0xAF,0x66,0xC7,0x0C,0x56,0xB6,0xAE,
+0x27,0x0B,0x3E,0x96,0x6F,0xEB,0xE6,0xA7,
+0x2F,0x1E,0x99,0x5B,0xFA,0xF1,0x55,0x60,
+0x2F,0xA0,0x4E,0x2E,0xB8,0x2F,0x0C,0xE4,
+0x2F,0x31,0xAA,0x38,0x21,0x0C,0x6E,0x22,
+0x27,0x2D,0x27,0xF0,0xF8,0x7A,0x5B,0xB1,
+0x27,0x7A,0xAF,0x35,0x2D,0x39,0x24,0x0B,
+0x2F,0x1F,0xE9,0x90,0x4E,0x4A,0x5B,0xEF,
+0x2F,0x7B,0xE1,0xC5,0x60,0x4B,0x4F,0xBF,
+0x2F,0xBD,0x53,0x31,0xD4,0xC4,0x07,0x59,
+0x2F,0x9D,0xD1,0xD8,0x2C,0x79,0x98,0xDA,
+0x27,0x7A,0x6C,0x1B,0x45,0x9D,0x8A,0x07,
+0x27,0x20,0xCD,0xB1,0x01,0xE5,0x96,0x74,
+0x2F,0x29,0x7A,0xF4,0x6F,0xD9,0xEF,0xC2,
+0x27,0xA9,0xE4,0xDA,0xFB,0x04,0x6B,0xAF,
+0x2F,0xF7,0x0E,0x79,0x73,0xB7,0x7A,0xC9,
+0x27,0x6C,0xD9,0xEE,0x75,0xC2,0xF9,0x64,
+0x27,0x33,0x8D,0x07,0x43,0x81,0xB8,0xB5,
+0x27,0xB1,0xCF,0x33,0x8A,0x17,0x2C,0xD3,
+0x27,0x65,0x3B,0x87,0xA8,0x7A,0xF6,0xD8,
+0x2F,0x91,0xD8,0x32,0x89,0xC9,0x55,0x52,
+0x2F,0x11,0xF5,0xBA,0x2F,0x89,0x12,0x4D,
+0x27,0xB3,0x4E,0x5D,0xD2,0x0C,0x71,0xD5,
+0x2F,0xB7,0x89,0x91,0xDF,0x9D,0x8B,0xF8,
+0x2F,0x98,0x95,0xC1,0x09,0xC9,0xB1,0xE0,
+0x27,0x5F,0x21,0x24,0x61,0x28,0xD3,0x88,
+0x2F,0x3C,0xD0,0xA7,0xD2,0x69,0xBF,0xF7,
+0x27,0x0F,0x97,0x4E,0xB9,0x18,0x05,0x88,
+0x2F,0x52,0xB3,0x09,0x2F,0x63,0x82,0x41,
+0x27,0x7E,0x4F,0xF4,0x0A,0x46,0x84,0x29,
+0x2F,0x3B,0xF3,0xB9,0x54,0x57,0xE8,0xAB,
+0x2F,0xBD,0xC4,0xD1,0xCA,0x73,0xAF,0xC9,
+0x27,0x45,0x97,0x92,0x47,0x41,0xA3,0xDD,
+0x2F,0x4E,0xCA,0x1E,0xB6,0xC2,0xB8,0x1B,
+0x2F,0x2C,0xAD,0x1F,0xBD,0xE8,0x0F,0x46,
+0x27,0x18,0x06,0xAF,0x4D,0xEA,0x59,0x1D,
+0x27,0x37,0x72,0x93,0xA0,0xE6,0x19,0x98,
+0x27,0x07,0x2F,0x86,0xCF,0xAA,0x25,0xF0,
+0x2F,0x19,0x79,0xFF,0xB9,0x53,0x02,0x01,
+0x27,0xAD,0xAA,0xBD,0x32,0x78,0x50,0xFA,
+0x2F,0x5B,0xC4,0xFC,0xF3,0x13,0xDE,0x0D,
+0x2F,0xF2,0x57,0x1A,0xF9,0x91,0x12,0x78,
+0x27,0x6B,0x92,0x87,0xAF,0x72,0xA4,0x30,
+0x27,0x38,0xB5,0xA9,0xF1,0x5E,0x29,0x89,
+0x27,0x4F,0x0D,0xD3,0x32,0x1A,0xA7,0x1D,
+0x2F,0xCF,0xDB,0x06,0xEB,0x3B,0xE6,0x3A,
+0x27,0x66,0xC9,0x30,0x12,0xE8,0x9C,0xE5,
+0x27,0x74,0x46,0xA0,0x97,0xAD,0x31,0x49,
+0x27,0x60,0xBE,0xFA,0x46,0xF1,0x29,0xF4,
+0x2F,0x5B,0xAD,0xFC,0x6E,0xBF,0xF9,0x53,
+0x2F,0x22,0x68,0x89,0xB3,0x6B,0x7A,0xCE,
+0x2F,0x17,0xA5,0x39,0x31,0xE8,0x60,0xA0,
+0x27,0x62,0xEB,0x28,0x25,0x9B,0xBF,0xA3,
+0x27,0x8F,0xC8,0x1F,0xF2,0x10,0xFA,0x48,
+0x27,0xBB,0x72,0x72,0xC1,0x06,0x38,0x81,
+0x2F,0x9F,0xE6,0xB8,0x92,0x70,0x8A,0x25,
+0x27,0xFC,0x5B,0x2F,0xAB,0xDC,0xD5,0xE2,
+0x27,0x21,0xE5,0x9C,0xD3,0x07,0x80,0x01,
+0x27,0xDC,0x88,0xC3,0x27,0xCC,0x86,0xEF,
+0x2F,0x09,0x2C,0x18,0x29,0xF4,0x74,0x04,
+0x27,0x6E,0x98,0x71,0x4E,0xD5,0x11,0x92,
+0x27,0x23,0x11,0xEF,0xB5,0x22,0xD7,0x80,
+0x27,0x3C,0xCA,0x82,0xB2,0x7F,0xAA,0xFD,
+0x27,0xF5,0x20,0xAA,0x5C,0xB7,0xDD,0xC5,
+0x2F,0x4B,0x40,0xFA,0x35,0x5B,0x9A,0x26,
+0x2F,0x2D,0x67,0x8F,0x93,0xA9,0x60,0xE1,
+0x2F,0xBE,0xE3,0x41,0x7F,0xB5,0x9C,0x94,
+0x2F,0xA5,0x85,0x5C,0x36,0x09,0xA8,0x13,
+0x27,0x82,0xC3,0xCD,0xF0,0x37,0x5E,0x3D,
+0x27,0xDF,0x75,0x23,0x5A,0xB6,0xE1,0xA9,
+0x2F,0xB7,0x98,0xBC,0xFB,0x57,0x54,0x5C,
+0x2F,0x47,0xC8,0xB2,0x80,0x89,0xB3,0x3A,
+0x27,0xD1,0x61,0x46,0xA1,0xC8,0xE9,0xEF,
+0x27,0x50,0x7F,0x89,0x5A,0x05,0x2C,0xAC,
+0x27,0xF8,0x0D,0x84,0xE8,0x90,0x41,0x9D,
+0x27,0xB0,0x0D,0xDE,0x72,0xA3,0xEB,0xEF,
+0x27,0x9B,0x9E,0x87,0xD0,0x1C,0xD3,0xF8,
+0x27,0xC3,0x1A,0x51,0xB2,0x33,0x02,0x72,
+0x27,0xDF,0x34,0x98,0x4C,0xBA,0xE8,0x4A,
+0x2F,0xED,0xB6,0xEF,0x0D,0x42,0x97,0x6D,
+0x2F,0x9E,0xC6,0x41,0xD1,0xC9,0xA6,0x07,
+0x27,0xED,0x22,0x2C,0x89,0x96,0xAF,0x43,
+0x27,0x80,0x3D,0x05,0xDC,0x9D,0xF8,0xFB,
+0x2F,0xD8,0xD5,0x6B,0xE7,0x61,0xB8,0x95,
+0x27,0x67,0x8D,0xE8,0x6F,0x21,0x93,0xF0,
+0x2F,0x51,0xA2,0x31,0x0C,0x4F,0xCB,0x6A,
+0x27,0x92,0x9D,0x3F,0x06,0x57,0x4B,0x71,
+0x27,0x39,0x43,0xCB,0x6E,0x2D,0xD8,0x08,
+0x2F,0x92,0x6B,0xE2,0xA6,0x1E,0x09,0x09,
+0x27,0x0D,0x49,0xF5,0x12,0xB8,0x8E,0x4C,
+0x2F,0x5F,0x6F,0xF8,0xCB,0x57,0xB3,0xBC,
+0x2F,0x9C,0x80,0x90,0x03,0xA3,0x59,0xDB,
+0x2F,0xB6,0xEB,0x00,0x10,0x62,0xC4,0x89,
+0x27,0x9E,0xA6,0x5C,0xF8,0xC1,0x38,0x03,
+0x2F,0x9E,0x8D,0xF7,0x65,0x28,0x50,0x97,
+0x2F,0x6A,0xCB,0xC2,0x08,0xCF,0x6C,0x23,
+0x27,0x43,0xE4,0xAB,0x9B,0x20,0xCF,0x08,
+0x27,0x8C,0xE0,0x51,0xAC,0xDC,0x56,0x05,
+0x2F,0xCC,0x87,0x30,0x74,0x3D,0x2A,0x20,
+0x27,0xBB,0xF9,0x5A,0xD5,0xA2,0x21,0x62,
+0x2F,0x23,0xEE,0x83,0x0B,0x20,0x51,0xAA,
+0x2F,0xCA,0xB1,0xAD,0x76,0xAA,0x44,0xA1,
+0x2F,0xC5,0xF6,0x8D,0xEA,0x05,0xB1,0x76,
+0x2F,0x5D,0x15,0x8C,0x76,0x10,0x8C,0xD1,
+0x2F,0x2A,0x9D,0x7A,0xEA,0x07,0xB4,0xDE,
+0x2F,0x4F,0x6C,0x23,0x75,0x4E,0x23,0xC1,
+0x27,0x80,0xD6,0xC4,0xBF,0x59,0x3C,0x15,
+0x2F,0x07,0x51,0x65,0xB8,0x3A,0xB1,0xC3,
+0x2F,0xDB,0x91,0x75,0xE9,0x84,0x51,0x37,
+0x2F,0xBC,0xCC,0x3C,0x7C,0x0E,0xD4,0x57,
+0x27,0x83,0x89,0x42,0xE9,0x3E,0x09,0xD9,
+0x27,0x90,0xEF,0xFB,0xED,0x81,0x7C,0xC8,
+0x2F,0x5D,0x45,0xBE,0xF4,0x94,0x97,0x70,
+0x27,0x9A,0x12,0xB5,0x5E,0x63,0x74,0x39,
+0x27,0x29,0xDC,0x52,0xE4,0x41,0x00,0x6D,
+0x27,0xAF,0xA8,0xC2,0x31,0x2D,0xD3,0xAF,
+0x27,0x3B,0xD1,0xEC,0xA3,0x6D,0xC4,0xB2,
+0x2F,0x75,0xD1,0x4F,0x1A,0xFA,0x75,0x23,
+0x27,0x94,0xF0,0x47,0xCB,0x6D,0xDD,0x92,
+0x27,0x20,0xD0,0x7F,0x25,0x08,0xFD,0xC2,
+0x27,0xBB,0x5C,0xC8,0x1B,0xE4,0x19,0x2D,
+0x27,0x70,0xF6,0x98,0xFD,0xA3,0x5A,0xF3,
+0x2F,0x99,0x69,0x10,0xFD,0x81,0x6C,0xA5,
+0x27,0xC8,0x8F,0x00,0xC0,0x87,0x5D,0xFC,
+0x2F,0xFE,0x12,0x7D,0x51,0xD6,0xB0,0xC2,
+0x27,0x33,0xA1,0xC8,0x7A,0xF8,0xC1,0x72,
+0x2F,0xEB,0x16,0x52,0x5E,0x69,0x5E,0x88,
+0x2F,0x3C,0xF8,0x0F,0xA6,0x89,0x8B,0xEB,
+0x27,0xFA,0x68,0xE9,0xB3,0x88,0xCD,0x91,
+0x27,0x22,0xC6,0x28,0x8C,0x4E,0x8F,0x4A,
+0x27,0x40,0x76,0x53,0x0C,0x9F,0x3C,0x51,
+0x27,0xA3,0xD0,0xA5,0x88,0xAF,0x8A,0xE8,
+0x2F,0x28,0xA6,0x84,0x81,0x72,0xE0,0x8B,
+0x2F,0x84,0x3F,0x49,0x08,0xE4,0x77,0xBE,
+0x27,0x0C,0xC7,0x52,0x98,0xD1,0x5B,0xC6,
+0x2F,0x16,0xC4,0xE1,0xA3,0x43,0xE3,0xBC,
+0x27,0x5D,0x95,0x69,0x14,0xE8,0xC9,0x19,
+0x2F,0x9F,0xAC,0xF3,0x5E,0x9D,0x96,0x74,
+0x2F,0xBF,0x2B,0x3E,0xFB,0x84,0x46,0x07,
+0x2F,0xC1,0x95,0xAD,0x22,0x74,0xD8,0xE2,
+0x2F,0x20,0xEB,0xAA,0xFD,0x58,0xAE,0x47,
+0x27,0xDF,0x82,0x6E,0xA6,0x40,0x93,0xBF,
+0x27,0x09,0xD1,0x07,0x39,0x6F,0x3C,0x19,
+0x27,0x21,0x05,0x5A,0x49,0xEB,0xA1,0x44,
+0x27,0x12,0xFF,0x98,0xFF,0xED,0x89,0xA4,
+0x27,0x5E,0xAD,0x7E,0xDD,0x9E,0x28,0x00,
+0x2F,0x00,0x1D,0xB5,0xEE,0xAD,0xE3,0x0F,
+0x27,0x83,0x9B,0x9C,0x16,0xD0,0x74,0x48,
+0x27,0x28,0x5D,0x87,0x59,0x7C,0x8D,0xAB,
+0x2F,0x0C,0xDC,0x59,0x84,0xC1,0x95,0xCA,
+0x27,0x3E,0x5F,0x3B,0x47,0xBE,0xBF,0x84,
+0x27,0x80,0x28,0xBA,0xFA,0xFF,0x77,0x18,
+0x27,0x0F,0xF4,0xDA,0x24,0x1C,0x82,0x02,
+0x2F,0xBB,0x35,0x15,0x71,0x70,0x7C,0xF0,
+0x27,0x57,0x67,0x73,0x7B,0x90,0xA6,0x4B,
+0x27,0xDB,0xB3,0xA7,0x25,0x6D,0x2D,0xBC,
+0x27,0x2C,0x68,0x07,0xE2,0x07,0x52,0xF8,
+0x2F,0x32,0x9A,0x58,0x8D,0x9C,0xEA,0x6F,
+0x27,0x9B,0x92,0xBA,0xC9,0xB4,0x5A,0xEA,
+0x27,0x42,0x5E,0xEB,0xAF,0x20,0x3E,0x9D,
+0x2F,0x12,0x49,0xAA,0x2F,0xE7,0x44,0x41,
+0x27,0xBD,0x57,0xEC,0xE5,0x94,0x1F,0x73,
+0x27,0x8A,0xB0,0x93,0x94,0x60,0xCC,0xD5,
+0x2F,0xFB,0x34,0x55,0x30,0x96,0xC6,0xB8,
+0x2F,0x13,0xD5,0x9D,0xDF,0x3E,0xC3,0x03,
+0x2F,0x4B,0xB5,0xC1,0xC6,0xA9,0xE4,0x22,
+0x2F,0xC7,0xFE,0xA4,0xE8,0xD9,0xF8,0x4E,
+0x2F,0x42,0x4B,0x7E,0x30,0x5A,0xF5,0x2D,
+0x27,0xBC,0x89,0x5B,0x8C,0x10,0x5E,0xD5,
+0x2F,0xF4,0x49,0x1A,0xD9,0xC9,0x2D,0x6A,
+0x2F,0x05,0xDD,0xD7,0xF3,0x26,0x94,0xE8,
+0x2F,0x84,0x32,0x9A,0xC6,0xC2,0x3F,0xCE,
+0x2F,0xB3,0x1E,0x5B,0x8C,0x7E,0xF6,0x16,
+0x27,0xFE,0xFB,0xF3,0x0F,0x2B,0xB8,0xED,
+0x27,0x47,0x80,0x6E,0x8B,0x48,0x90,0xA7,
+0x2F,0x51,0x56,0xC7,0x02,0x84,0x4D,0xFD,
+0x27,0x66,0xD8,0x22,0x74,0x22,0xEE,0x31,
+0x27,0x82,0x7F,0x27,0x95,0x0D,0x18,0xA0,
+0x27,0xE8,0xD1,0xC4,0x97,0x87,0x26,0xBA,
+0x2F,0xA8,0xC4,0x94,0x3A,0xD1,0x71,0xB8,
+0x27,0xC5,0xD7,0xA0,0x8A,0x87,0x0C,0x15,
+0x27,0x22,0x6A,0xE9,0xB5,0x88,0x04,0xC9,
+0x2F,0x4A,0xBE,0x53,0xEB,0x03,0x10,0x96,
+0x2F,0x92,0x0C,0x15,0x6A,0xD6,0x8D,0x9F,
+0x2F,0x2C,0x53,0x52,0x6F,0x76,0xC7,0x4E,
+0x27,0xCC,0xFE,0xA6,0x5E,0xDB,0xCC,0xD5,
+0x27,0x42,0x1D,0x84,0xF4,0x04,0x2B,0x4E,
+0x27,0x94,0x9C,0x50,0xD8,0x25,0x84,0x97,
+0x27,0xD0,0xE4,0xA0,0xA8,0xB6,0x7A,0x15,
+0x27,0x08,0x00,0x34,0x86,0x2F,0x2B,0xED,
+0x27,0x53,0x19,0x25,0x36,0x2E,0xF3,0xF1,
+0x27,0xD1,0xBD,0xC0,0xCE,0x71,0x58,0x3B,
+0x27,0xBC,0x33,0x92,0x1D,0xC3,0xE2,0x11,
+0x2F,0x95,0x19,0xE4,0x79,0x14,0x17,0xC7,
+0x27,0x47,0xFA,0xD9,0x07,0x76,0xD7,0x37,
+0x27,0x94,0x27,0xBC,0xE8,0x3C,0x7B,0x59,
+0x2F,0xBA,0x3E,0x01,0x74,0xEF,0xA0,0x08,
+0x2F,0xD5,0x10,0xE8,0x9B,0x64,0x24,0x93,
+0x2F,0xDB,0x52,0xC7,0x3D,0x5B,0x94,0xB3,
+0x27,0x46,0x76,0xD9,0x12,0x03,0xF5,0x34,
+0x27,0x21,0xCB,0xB2,0xE0,0x33,0x67,0x45,
+0x2F,0x5A,0xAB,0x0C,0x1A,0x11,0xB5,0xBE,
+0x27,0xB2,0x2B,0xA9,0xF9,0xF1,0x2A,0x87,
+0x27,0x00,0x58,0x72,0x60,0xDA,0x3E,0xFF,
+0x2F,0x73,0x61,0x07,0x50,0xC0,0x9E,0x43,
+0x2F,0xCE,0x48,0x3D,0x1D,0xCA,0x51,0x4B,
+0x2F,0xE5,0x93,0x53,0x99,0xBB,0xAC,0x34,
+0x2F,0x74,0xE3,0xD2,0x3E,0x6A,0x78,0xCA,
+0x27,0xBB,0xC3,0x99,0x55,0x4A,0xFE,0xBE,
+0x27,0xAF,0x81,0x50,0x06,0xF5,0x5C,0x40,
+0x2F,0xF2,0x30,0xB2,0xEC,0x01,0x54,0xCA,
+0x27,0x09,0xC6,0x49,0xA2,0x97,0x06,0x40,
+0x27,0x8A,0x31,0xD3,0x6C,0x9D,0x5E,0xB7,
+0x27,0xE0,0x34,0x22,0xAC,0xDF,0xFA,0xEA,
+0x27,0x2B,0x73,0x86,0xD7,0x31,0xEA,0x3A,
+0x2F,0x33,0xDF,0x29,0xF7,0x4B,0xA7,0xEA,
+0x2F,0xA2,0xE7,0x5E,0xFE,0xCE,0x58,0x41,
+0x27,0xEE,0x81,0x9C,0x7B,0x2E,0x8A,0x90,
+0x27,0x79,0x73,0x6D,0x7A,0x6B,0x1B,0x89,
+0x2F,0x14,0x4E,0xC6,0x27,0xB8,0xDF,0xA3,
+0x27,0xC1,0x94,0xF0,0x60,0x2D,0x6A,0xC5,
+0x27,0x19,0x68,0x1A,0xE0,0x71,0xFD,0x37,
+0x2F,0xD6,0x50,0xDD,0x7E,0x56,0x0E,0xF6,
+0x27,0x2E,0x40,0xF5,0x4A,0x6A,0x8B,0xC2,
+0x2F,0x43,0x31,0x53,0x14,0x9D,0xDF,0xB4,
+0x27,0x88,0x03,0x52,0x22,0xBE,0xAA,0x56,
+0x27,0xCA,0x8B,0x1B,0x46,0x2C,0x55,0xDE,
+0x27,0x15,0x1F,0xED,0x88,0xF8,0x5E,0x6E,
+0x2F,0x20,0xAE,0x09,0x08,0x0F,0x91,0x75,
+0x27,0x02,0xCC,0x14,0x83,0x57,0x2C,0xC2,
+0x27,0xD1,0x81,0xD3,0x54,0xEF,0x86,0x60,
+0x2F,0xE8,0x5B,0xD1,0x65,0xD7,0x0F,0xDA,
+0x2F,0x3C,0x56,0x8F,0xE1,0x60,0xCE,0x31,
+0x2F,0x5E,0x14,0x0A,0xBC,0x40,0x8F,0x57,
+0x27,0xE5,0x85,0xA9,0xBE,0x23,0x94,0xCC,
+0x2F,0x75,0xB9,0xB4,0x82,0xD3,0x03,0x7D,
+0x27,0xE7,0x66,0x98,0xC8,0x82,0xEA,0xA7,
+0x2F,0x85,0xF3,0xAD,0x8B,0xB9,0x21,0x7A,
+0x2F,0x0D,0x6F,0x23,0x1F,0xFB,0x2E,0xBF,
+0x27,0xBA,0x84,0xC1,0x6E,0xD1,0x54,0xBF,
+0x2F,0x5E,0xB6,0x27,0x39,0xD8,0xAA,0x4B,
+0x2F,0x23,0xB6,0x72,0xE8,0x5D,0x8B,0xB2,
+0x2F,0xB0,0x00,0xE3,0x02,0x92,0xC8,0xB7,
+0x27,0x65,0x8D,0x5B,0x0A,0x05,0x9E,0xAE,
+0x27,0x1B,0x62,0xAD,0x84,0xB9,0xD2,0x74,
+0x27,0x5E,0xA6,0x16,0x11,0xF8,0x60,0x63,
+0x27,0x29,0x5D,0x5C,0x4C,0x09,0xAC,0x9D,
+0x27,0xFE,0x4A,0x6B,0x88,0x27,0x1E,0xBF,
+0x2F,0x28,0xC7,0xF5,0xBC,0x35,0x66,0xE2,
+0x2F,0xDC,0xB3,0xDD,0x22,0x34,0xAC,0x58,
+0x2F,0xE7,0x57,0x70,0x30,0x69,0xC7,0xA6,
+0x2F,0x4B,0x5F,0xDF,0x35,0xD6,0xF1,0x03,
+0x27,0x09,0xCB,0x55,0xAD,0x2C,0xE4,0xE7,
+0x2F,0x68,0xAF,0x8E,0xD9,0xD0,0x03,0x77,
+0x2F,0x72,0x26,0x3B,0x98,0x51,0xE6,0xAF,
+0x27,0x77,0x5F,0xA8,0xB1,0x63,0xF0,0xFD,
+0x2F,0x59,0xA7,0x0F,0x5D,0x7D,0x5F,0xC6,
+0x27,0x74,0x72,0xAF,0x61,0x2D,0x2F,0x29,
+0x27,0xD7,0xFD,0x2C,0xEB,0xF1,0x56,0x5E,
+0x2F,0xD4,0x94,0x76,0x0A,0x9C,0x4B,0xB2,
+0x2F,0x80,0xDB,0x30,0x28,0xB1,0x29,0x1D,
+0x2F,0xFE,0xF8,0xF6,0x3C,0x62,0x18,0xE8,
+0x2F,0xE7,0x76,0x3F,0xEF,0x40,0x9E,0x65,
+0x27,0x10,0xE3,0x00,0xB3,0xF0,0x84,0xB2,
+0x27,0x2D,0x8C,0xBE,0xE2,0x2B,0xAF,0x34,
+0x27,0x2F,0x97,0x51,0x5A,0xD9,0xE6,0x16,
+0x2F,0xBE,0x81,0x39,0x79,0x68,0x98,0x92,
+0x2F,0x42,0xFF,0xFA,0xDB,0x35,0x77,0x3E,
+0x2F,0x84,0xA2,0x8D,0xB2,0xAC,0xC3,0x88,
+0x27,0x28,0xB8,0x41,0x74,0xA5,0x59,0xFC,
+0x2F,0x50,0xDE,0x3B,0x67,0x93,0x45,0x4E,
+0x27,0x52,0x89,0x0B,0xF6,0x02,0xB1,0x54,
+0x2F,0x2F,0xDC,0x27,0xA2,0xB5,0x79,0xC2,
+0x2F,0xFB,0x32,0x22,0x06,0x6D,0x7E,0xAB,
+0x27,0xE3,0xB2,0xCD,0xAD,0x23,0x30,0xC8,
+0x2F,0x0E,0x6F,0x2D,0x86,0xC4,0xFD,0x2A,
+0x2F,0xC4,0x5C,0x43,0x10,0x11,0x3F,0x03,
+0x27,0x20,0xF1,0x26,0x08,0x55,0xB8,0xDD,
+0x2F,0x1B,0xD4,0x83,0xB9,0xFF,0x6F,0xAA,
+0x27,0x51,0xF2,0x95,0xE4,0x09,0x04,0x93,
+0x2F,0xE3,0xF3,0x6F,0xDB,0x3C,0xA7,0xAA,
+0x2F,0x4B,0x09,0x38,0x44,0x32,0x07,0xAB,
+0x2F,0x72,0xCC,0xB7,0xDA,0xA7,0x0D,0xD0,
+0x27,0xA9,0xFE,0xC2,0x73,0x30,0x0C,0xEA,
+0x27,0xA0,0xB2,0xA1,0x92,0xCF,0xCF,0x02,
+0x2F,0x5F,0xFA,0x72,0xA9,0xFD,0x2D,0xCD,
+0x2F,0x72,0x9A,0x49,0xB7,0xD5,0xB6,0x39,
+0x27,0x06,0xF7,0x81,0x86,0xED,0x66,0x65,
+0x2F,0x03,0x0A,0xC5,0xE7,0xF3,0x90,0x1E,
+0x2F,0x55,0xB5,0x2E,0xCE,0x57,0x60,0x6E,
+0x27,0xFE,0x60,0xF1,0xC6,0xCF,0x15,0x9B,
+0x2F,0xA7,0x86,0xF0,0x6E,0xA8,0x02,0x9E,
+0x2F,0x8C,0x4F,0x4F,0xE5,0x76,0xAF,0x4E,
+0x27,0x60,0x19,0xF8,0xD9,0xBE,0x01,0x23,
+0x2F,0x72,0x1F,0xD1,0xAF,0xFF,0x93,0x78,
+0x27,0x04,0xB1,0xB9,0xEF,0xDB,0x4D,0xF1,
+0x2F,0x07,0xE6,0xC8,0x89,0xFE,0xE2,0x39,
+0x2F,0x6F,0x7B,0xA7,0xAE,0x52,0x4A,0x17,
+0x27,0x1B,0x6E,0x77,0x2B,0x87,0xFE,0xCD,
+0x2F,0xBF,0x43,0xAC,0x69,0xE1,0x51,0x1C,
+0x27,0x3C,0x2C,0xBE,0x67,0x4A,0xF2,0x42,
+0x27,0x4B,0x27,0x17,0x74,0xF7,0xC1,0x08,
+0x2F,0x15,0xB9,0x6D,0x8B,0x69,0xD7,0xE7,
+0x2F,0x1C,0x74,0x01,0x52,0x55,0xEA,0x0B,
+0x2F,0x53,0x0C,0x19,0x9B,0x2D,0x8A,0x8B,
+0x2F,0x60,0xFF,0x2E,0x4E,0x2C,0x73,0x75,
+0x27,0x25,0xAE,0xD2,0x8B,0xC8,0xDE,0x33,
+0x2F,0x9B,0x00,0xF1,0xE3,0x72,0xC6,0x13,
+0x27,0x8E,0xB8,0x7F,0xB1,0x2C,0x65,0x29,
+0x27,0x95,0x8F,0x55,0x7E,0x93,0x4E,0x24,
+0x27,0x06,0x4D,0x53,0x8E,0xF4,0xC4,0x07,
+0x27,0xF2,0x3C,0x27,0x57,0x97,0x2B,0xDD,
+0x27,0x3F,0x99,0xE8,0x51,0x3C,0xA5,0xE7,
+0x2F,0xC0,0x0E,0xF8,0x8A,0xBB,0xBA,0x30,
+0x2F,0x09,0x95,0xF2,0x8C,0xA9,0x3B,0x88,
+0x2F,0x97,0x71,0xF9,0x0F,0x7C,0x10,0x2E,
+0x2F,0x07,0x25,0x74,0x77,0x0B,0x95,0xA3,
+0x27,0x77,0x03,0x9C,0x78,0x91,0x71,0xD6,
+0x2F,0x63,0x14,0xBF,0x1D,0x00,0x43,0x07,
+0x27,0x57,0xAD,0x88,0xC3,0xD7,0xE3,0x5B,
+0x27,0xBA,0xD4,0x50,0xED,0xD4,0xB3,0x9E,
+0x2F,0xAB,0x28,0xDE,0x3B,0x50,0xD4,0xFD,
+0x27,0x8E,0x3D,0x77,0x70,0xC8,0xE6,0x15,
+0x2F,0x3E,0xE3,0x08,0xD2,0x2A,0x74,0x81,
+0x2F,0x6B,0xAC,0x32,0xC3,0x06,0x65,0xAD,
+0x27,0x7A,0x31,0x68,0x8C,0x1A,0x16,0xF4,
+0x2F,0x1E,0xF0,0xFC,0x65,0x7F,0x27,0x62,
+0x2F,0xB2,0xC0,0x1B,0x7E,0x99,0x9C,0x8F,
+0x2F,0x6A,0x2E,0x64,0xE9,0xF0,0xE8,0xFC,
+0x27,0xA8,0x34,0xE1,0x5E,0x3B,0xCF,0x63,
+0x27,0x4D,0x72,0xE3,0x3F,0x3E,0x1F,0x01,
+0x27,0xB2,0x30,0xB8,0xE4,0xC1,0x8E,0x5F,
+0x27,0x21,0xAF,0x75,0x30,0x30,0x28,0xC3,
+0x27,0xB1,0x75,0x63,0xF4,0x86,0x8B,0x75,
+0x2F,0x11,0xB3,0x09,0xC9,0xFF,0x38,0xA2,
+0x27,0xB3,0x19,0xF0,0xA6,0x1B,0x67,0xF6,
+0x2F,0x27,0x9D,0xFD,0x67,0xB1,0x85,0x1A,
+0x27,0xE1,0xD4,0xE3,0x30,0x50,0xFF,0x9D,
+0x2F,0xBE,0x4A,0xE3,0x7C,0x52,0x6F,0xD2,
+0x27,0x54,0xCD,0x28,0xB8,0xDD,0xED,0x93,
+0x27,0xF5,0xCC,0xF9,0x05,0x2D,0xEB,0x9A,
+0x27,0x91,0x96,0x19,0xB0,0x38,0xFF,0xCE,
+0x2F,0x28,0xA1,0xC9,0x54,0xB7,0xE2,0xE6,
+0x2F,0x5D,0x43,0xD3,0x1A,0xC3,0xDC,0x63,
+0x27,0x5F,0x3E,0xDC,0xCA,0xC6,0xC7,0xA1,
+0x2F,0xE0,0x53,0x83,0x04,0x56,0x97,0x42,
+0x2F,0xBE,0x30,0x84,0x84,0xA5,0x0A,0xE5,
+0x2F,0x77,0x64,0x11,0x49,0x3C,0x9A,0x54,
+0x2F,0xBC,0xE3,0x5F,0x52,0xE6,0x59,0xC2,
+0x27,0xDA,0xA3,0xE9,0x40,0xC9,0x5F,0xCA,
+0x27,0xDE,0xC4,0x68,0xF9,0x3F,0x3D,0x79,
+0x2F,0x10,0x9A,0x18,0xCD,0xD5,0x66,0x2E,
+0x2F,0x90,0x83,0x0E,0xE2,0xEA,0x67,0xB5,
+0x27,0x9F,0x94,0x00,0x0C,0xE4,0x64,0xB7,
+0x27,0x11,0x6A,0x8B,0x7D,0x63,0xE8,0x55,
+0x2F,0x01,0x13,0x43,0xBB,0x33,0x88,0x5F,
+0x27,0xBF,0xB2,0x00,0xE6,0xD8,0x6B,0x57,
+0x2F,0x08,0xF6,0x36,0xEB,0x84,0x9A,0xC1,
+0x2F,0xC4,0x2D,0xDD,0x1E,0x31,0x1D,0xFB,
+0x2F,0x01,0x89,0x8D,0x20,0x16,0x2B,0x72,
+0x27,0xD7,0x69,0x21,0x85,0xFF,0xFD,0x4D,
+0x2F,0xAA,0x2D,0xE9,0x30,0x06,0xFC,0xCA,
+0x2F,0x83,0x30,0x7F,0x36,0x8C,0xAE,0xB2,
+0x27,0xD5,0xA9,0x6D,0x69,0xCF,0x73,0xEB,
+0x27,0xEB,0xEF,0xA6,0x3A,0x2A,0x7D,0xD8,
+0x27,0x05,0x4D,0x24,0xB0,0x96,0xC1,0xBD,
+0x2F,0x21,0x88,0x18,0xBE,0x39,0x06,0x90,
+0x2F,0xCC,0x7F,0x84,0x4A,0x2E,0x1E,0x10,
+0x27,0xE8,0x4F,0x1A,0xB4,0x60,0x56,0x7E,
+0x27,0xA5,0x34,0x16,0x46,0x2E,0xFD,0x83,
+0x2F,0xEF,0x76,0xDD,0x8A,0xDF,0x33,0x30,
+0x27,0xC8,0xB9,0x88,0x6A,0x15,0xCB,0x54,
+0x2F,0xCE,0x45,0x19,0xB0,0x33,0x2A,0x33,
+0x27,0xA1,0x00,0xAA,0x31,0x4D,0x6A,0x7F,
+0x2F,0xFF,0x54,0xBE,0x22,0x75,0xF8,0xEF,
+0x27,0x2F,0xD9,0x3F,0x3D,0xCD,0x91,0xEB,
+0x27,0xE1,0xD2,0xB8,0xD3,0x52,0x8B,0x96,
+0x27,0x1A,0x9A,0x11,0xD6,0xD0,0x10,0x37,
+0x2F,0x3F,0x0F,0xCD,0x13,0x2E,0x23,0x68,
+0x27,0xC8,0xE2,0x19,0x71,0x82,0x16,0xC8,
+0x2F,0x50,0xA0,0x70,0x18,0x90,0x4F,0xD2,
+0x27,0x8E,0x59,0x71,0xA9,0x3B,0x1D,0x3E,
+0x2F,0xDF,0x3B,0x6D,0x6A,0x7C,0x6A,0xB2,
+0x2F,0x9F,0x92,0x2A,0x03,0x40,0x54,0x6E,
+0x27,0x2F,0x27,0xE4,0x34,0xD0,0x57,0x40,
+0x2F,0xE7,0x1C,0x68,0xD5,0xFA,0x79,0x4F,
+0x27,0x0E,0xAD,0x0C,0x4D,0x10,0x52,0xED,
+0x27,0x42,0xDD,0x6B,0xFA,0x4C,0x96,0xFC,
+0x27,0x21,0x92,0x5D,0x76,0xCE,0x06,0x96,
+0x2F,0x28,0x6B,0x77,0xC0,0x7C,0x6A,0x16,
+0x2F,0xCB,0xA5,0x2C,0xD4,0xE7,0x19,0x69,
+0x2F,0xE4,0x75,0xF8,0x0B,0x63,0xAB,0xE8,
+0x27,0x95,0x06,0xC3,0xF1,0xE5,0x09,0x6F,
+0x2F,0x8B,0xC6,0x66,0xF5,0xC5,0xCB,0x98,
+0x27,0x4F,0x4C,0xDB,0x81,0x21,0x70,0x4F,
+0x27,0xED,0x89,0x38,0x87,0x0D,0x90,0xBF,
+0x27,0xD9,0x84,0x42,0x7F,0x50,0x03,0xF8,
+0x27,0x11,0x06,0x7C,0x64,0x20,0x38,0xD4,
+0x2F,0x98,0xE3,0xD7,0xF9,0x36,0x78,0xB3,
+0x27,0x73,0xC4,0xC7,0x50,0xD8,0x2D,0xB7,
+0x27,0xE2,0x21,0xD4,0xEA,0x20,0x8E,0x87,
+0x2F,0xD3,0xD0,0xF0,0x88,0xDB,0xF8,0xAA,
+0x2F,0xCE,0x2B,0x86,0xDD,0xE1,0xA1,0x03,
+0x27,0x27,0xA2,0xCA,0x91,0xCD,0x58,0xE7,
+0x27,0xA8,0x2C,0x64,0x5D,0xC9,0x40,0xAA,
+0x2F,0xAA,0x99,0x47,0x60,0xC3,0x19,0x54,
+0x27,0x2A,0x98,0x7B,0x20,0x11,0x45,0xEB,
+0x2F,0x5B,0x11,0x35,0xEB,0x96,0x78,0x90,
+0x2F,0xE9,0xA8,0x82,0x6C,0xA4,0x25,0xEF,
+0x27,0x38,0x28,0x86,0x37,0x4B,0xF6,0xA0,
+0x2F,0x41,0xC6,0x4E,0x84,0x6D,0xC6,0x6C,
+0x2F,0x70,0xDF,0xB5,0x5A,0x0F,0x17,0x6A,
+0x27,0x1D,0x12,0xA9,0x19,0xAB,0x09,0xE0,
+0x2F,0x0F,0x34,0x7F,0x22,0xCD,0x68,0xAD,
+0x27,0x9F,0xEC,0xFB,0x26,0xD7,0x6C,0xB7,
+0x27,0x98,0x97,0xD1,0x9C,0x5D,0x89,0x7F,
+0x27,0x2A,0x17,0x96,0x7F,0xC1,0x0C,0x55,
+0x27,0x8E,0x5A,0x81,0x90,0x15,0x81,0x00,
+0x2F,0xA9,0x13,0x1A,0xB2,0xB0,0x90,0x40,
+0x27,0xBC,0x71,0xDA,0x40,0xA3,0xDE,0x3F,
+0x27,0x2B,0x2B,0x67,0x87,0xF1,0xB7,0x17,
+0x27,0x94,0xA6,0xEC,0xD8,0x43,0x05,0x4D,
+0x27,0xC8,0x12,0xAB,0xFF,0x61,0xAE,0xFC,
+0x27,0xA3,0x35,0xA8,0x59,0x20,0x39,0x6A,
+0x27,0xE5,0x5E,0xA5,0x36,0x6D,0x99,0x76,
+0x2F,0x2B,0x59,0xE4,0x63,0x82,0x1F,0xFC,
+0x27,0x4A,0x78,0x18,0x2B,0xF7,0x46,0x36,
+0x27,0x3A,0x34,0x66,0xBA,0x24,0x9D,0x8E,
+0x27,0x8A,0xF9,0x14,0xE1,0xD6,0xF2,0xFF,
+0x2F,0x9F,0xCB,0xC1,0xE7,0xA5,0xA0,0x10,
+0x27,0x75,0x78,0x79,0xCC,0x1E,0xF4,0xC6,
+0x27,0xB9,0xD9,0x05,0x71,0x5B,0xC7,0x46,
+0x27,0x0B,0x19,0x38,0x98,0x87,0xB3,0xD8,
+0x2F,0x6B,0x2F,0x8B,0xC1,0x10,0x2E,0xD6,
+0x27,0xAB,0x3B,0x84,0x8F,0x3B,0x06,0xA4,
+0x27,0x28,0x8C,0x5C,0x41,0xF6,0x33,0x18,
+0x2F,0x3F,0x8E,0x08,0x73,0x9D,0xAA,0x22,
+0x27,0xB1,0xEE,0xA0,0x10,0x5E,0xDD,0x9A,
+0x2F,0xD1,0x56,0x16,0x1E,0xEB,0xD1,0xCE,
+0x27,0xB0,0x49,0xE8,0x7B,0x65,0x05,0xFB,
+0x27,0x8B,0x36,0xE6,0x18,0x57,0x75,0x06,
+0x2F,0x82,0x36,0x0A,0x74,0xD4,0x88,0xE9,
+0x2F,0xD1,0x8A,0xA8,0xC0,0xC3,0x9A,0x94,
+0x27,0x3F,0xC6,0x6D,0x9B,0x1C,0xC3,0x8D,
+0x27,0x78,0x87,0xE9,0x13,0x95,0xD5,0x56,
+0x2F,0x7E,0x37,0x3C,0xA7,0x5F,0xC2,0x67,
+0x2F,0xAE,0xD3,0x18,0x99,0x06,0x75,0x5B,
+0x2F,0x42,0xB5,0xC2,0x42,0xF2,0x6D,0x57,
+0x2F,0x5E,0x22,0x75,0xE6,0x56,0x74,0x7F,
+0x27,0xEB,0x11,0xCC,0x53,0x83,0x0E,0x0E,
+0x27,0xEC,0xE2,0xE1,0xC0,0xAB,0x9D,0x8F,
+0x2F,0x9E,0xE1,0x23,0xE0,0x93,0xEE,0x45,
+0x27,0xD4,0xC8,0xC2,0x16,0x1F,0x0F,0x54,
+0x2F,0x20,0x92,0x8D,0xC2,0xA9,0x78,0x35,
+0x27,0xA0,0x49,0xA1,0x2E,0xE3,0x65,0x73,
+0x2F,0x21,0xFF,0x88,0x40,0x7D,0xFE,0x31,
+0x27,0x79,0x80,0x30,0x4E,0xD3,0xBB,0x04,
+0x27,0x46,0xCC,0x2E,0xDC,0xC5,0xF6,0x9B,
+0x27,0x51,0xF7,0xA1,0x66,0x1A,0x21,0x14,
+0x27,0x31,0x9C,0x1E,0xC1,0x43,0xD1,0x46,
+0x2F,0xAE,0xA9,0x20,0xE4,0x41,0x81,0x7B,
+0x2F,0x55,0xD9,0x57,0xF5,0x5C,0x5F,0xFC,
+0x2F,0x5A,0xBD,0xE8,0x12,0xA0,0x5C,0x91,
+0x27,0x61,0x82,0xA1,0x79,0xCC,0x5F,0x2B,
+0x2F,0x95,0x5A,0xA6,0xF3,0x83,0x7C,0x69,
+0x2F,0x19,0x36,0xB9,0xDA,0x11,0x73,0xDF,
+0x27,0x24,0x75,0xE3,0x52,0x82,0xC8,0xFF,
+0x27,0xBF,0xD7,0x58,0x53,0x7F,0xBB,0x98,
+0x2F,0xF9,0xF2,0xB7,0xD9,0x64,0xF9,0x9F,
+0x27,0x4B,0xF3,0xBD,0x9D,0x0B,0x35,0x83,
+0x27,0x4D,0xBB,0xBC,0xF7,0x5C,0xAC,0x97,
+0x27,0x1F,0x7B,0xDC,0x2F,0x19,0xD5,0xC7,
+0x2F,0x5D,0x3C,0x43,0x8D,0x82,0xAB,0x3D,
+0x2F,0xA2,0x80,0x4C,0x4D,0xF7,0xB6,0x4F,
+0x2F,0xF1,0x48,0xBA,0xEF,0xEE,0xE6,0x35,
+0x27,0x57,0x74,0xD5,0xAE,0x6B,0x5B,0x01,
+0x27,0x3A,0xC9,0xDC,0x80,0x96,0xF2,0x7D,
+0x2F,0x45,0x9D,0x1A,0x36,0x60,0x9C,0xFB,
+0x2F,0xC4,0x7B,0x42,0x56,0x42,0x73,0x99,
+0x27,0xB5,0xB2,0xA6,0xE9,0x32,0x1C,0x23,
+0x27,0xD9,0xFF,0x78,0xCD,0xFB,0x8C,0xC5,
+0x2F,0x90,0x14,0x01,0xDD,0x35,0xE6,0xDF,
+0x2F,0xFD,0xF1,0x20,0x94,0x1E,0x59,0x79,
+0x2F,0x01,0x18,0xB5,0xBD,0x62,0x0E,0x82,
+0x2F,0x03,0x74,0xE5,0x8A,0x12,0xD4,0xDD,
+0x27,0xFB,0xD8,0x51,0xA0,0x0B,0x74,0xE6,
+0x27,0x18,0xA9,0xBB,0x07,0x69,0x20,0xFE,
+0x27,0x8F,0x40,0x03,0x37,0x21,0xF1,0xEA,
+0x2F,0xC5,0xDB,0xBB,0x94,0xCA,0x42,0x3E,
+0x27,0xA6,0x51,0x36,0x3C,0x4E,0x6D,0x70,
+0x27,0x0D,0xE1,0x5E,0xD2,0xAC,0xA5,0xA8,
+0x27,0x14,0x47,0xB5,0xF3,0xCA,0xAF,0x5E,
+0x2F,0xD7,0xDD,0xEC,0x40,0xCE,0x03,0x42,
+0x27,0xBF,0x9E,0x1E,0x4C,0x2A,0xF6,0xE3,
+0x2F,0x2C,0xC0,0x38,0xD5,0x0A,0x49,0x32,
+0x27,0x58,0xD5,0x01,0x95,0x64,0xE9,0x4A,
+0x2F,0x08,0x58,0x2E,0x5F,0x03,0x48,0x31,
+0x2F,0x32,0xE0,0x3D,0x2E,0x59,0x3B,0x54,
+0x2F,0x5A,0x50,0xBD,0x7B,0x9F,0x3B,0x95,
+0x2F,0xB2,0x74,0x69,0x68,0x22,0x71,0x05,
+0x2F,0x18,0xAE,0xD4,0xF8,0x76,0xF2,0xA7,
+0x2F,0x73,0xCB,0xA0,0x72,0x69,0xD7,0xB1,
+0x2F,0x7F,0xC2,0xDD,0x1C,0x6E,0x24,0xB4,
+0x27,0xD9,0x09,0xEA,0x04,0x38,0x17,0x3D,
+0x27,0x3E,0x03,0x40,0x62,0xAC,0x45,0xE6,
+0x27,0xB8,0xB9,0x2F,0x66,0x35,0x26,0x79,
+0x2F,0x6F,0xEA,0xC8,0xD3,0xAC,0x97,0x75,
+0x27,0x6C,0x3A,0x52,0x92,0x33,0x43,0xBB,
+0x2F,0x52,0xA0,0xD9,0x91,0x80,0x3A,0x6A,
+0x2F,0xD0,0xC0,0xA2,0xEF,0xD4,0xD7,0xBF,
+0x2F,0xB0,0xA8,0x91,0xEF,0x46,0x71,0xB8,
+0x2F,0x49,0xC6,0xB4,0x89,0x87,0xA2,0x2D,
+0x2F,0x08,0xC1,0x6E,0x3C,0xBA,0xAF,0x6A,
+0x27,0x66,0x80,0x71,0xB3,0x97,0x90,0x11,
+0x27,0x29,0xF7,0xFA,0x33,0x0F,0x43,0xBA,
+0x27,0x1D,0x52,0xED,0xCA,0xDB,0xD7,0x67,
+0x2F,0x1B,0x80,0xCA,0xBF,0xD4,0xE3,0x6B,
+0x27,0xC8,0x94,0x08,0x45,0xD3,0x4D,0x12,
+0x27,0x52,0x65,0xE0,0x9B,0x43,0x39,0xDC,
+0x2F,0xBA,0x54,0x38,0x58,0xFB,0x3D,0x18,
+0x27,0x9D,0x66,0xB8,0x1E,0x99,0x83,0xB1,
+0x27,0x15,0x4C,0x0F,0xDD,0xC6,0xB4,0x3B,
+0x2F,0xA2,0x05,0xDF,0xB2,0xB5,0x94,0xF6,
+0x27,0x0D,0xE7,0x37,0x37,0x14,0xDD,0xDC,
+0x27,0x1F,0x2D,0x5A,0xC7,0xFB,0x6A,0x73,
+0x2F,0xC6,0xD3,0x5D,0x69,0xFB,0xC2,0x46,
+0x2F,0xF1,0x71,0xDD,0x17,0x43,0xE5,0x52,
+0x27,0xC1,0x74,0xFA,0x18,0xE6,0x14,0xE6,
+0x2F,0x55,0xB0,0xD7,0xE2,0x1C,0x85,0x86,
+0x2F,0x6C,0x2A,0x64,0xB6,0x53,0xD4,0xF9,
+0x2F,0x24,0x23,0xBA,0x31,0xD0,0x76,0x1D,
+0x27,0x24,0xF9,0x6C,0x15,0xE5,0x46,0xE7,
+0x2F,0xD6,0xAA,0x93,0x92,0xEA,0x22,0x59,
+0x2F,0x79,0x9C,0xF8,0x2A,0x19,0x8D,0x1C,
+0x27,0x4B,0xD4,0xC9,0x6B,0xD1,0x8D,0x98,
+0x27,0x61,0x76,0xD3,0x76,0xE1,0x3A,0xFB,
+0x2F,0xB4,0x0B,0x2A,0x6F,0x3C,0x0B,0x11,
+0x27,0x20,0x45,0xD4,0xF3,0xE1,0xC2,0x0B,
+0x2F,0x20,0xE8,0xA4,0xD0,0x0B,0xBE,0x6A,
+0x2F,0x7D,0x68,0xDC,0xB6,0x38,0xF7,0x58,
+0x2F,0xAA,0x8F,0x05,0xFA,0xDF,0x86,0x8A,
+0x27,0xB4,0x33,0x4C,0x50,0x32,0xE6,0x45,
+0x27,0x89,0x60,0xF7,0x3A,0xC6,0x50,0xB0,
+0x2F,0x65,0x4F,0x0A,0xDC,0x8F,0xC7,0xF0,
+0x27,0x1B,0xA7,0x49,0x1F,0x69,0xF9,0x1B,
+0x27,0x1A,0x5B,0xDC,0xA1,0xB5,0x33,0x04,
+0x2F,0x84,0xC7,0xF8,0x52,0xED,0x81,0xF8,
+0x27,0x08,0x0C,0x0F,0x01,0x75,0x14,0xEF,
+0x27,0x87,0x13,0x2F,0xD7,0x97,0x64,0xAF,
+0x27,0xF9,0x4E,0xF1,0x4D,0x1B,0x41,0xB5,
+0x27,0x0B,0x62,0xB3,0xCF,0xD5,0xFD,0x36,
+0x27,0xFB,0x83,0x60,0xCE,0x75,0x33,0x5A,
+0x2F,0xC5,0x48,0xC6,0xDE,0x88,0xBA,0x21,
+0x2F,0x27,0xAA,0x0C,0xEF,0x5A,0xB7,0x04,
+0x2F,0x3C,0x93,0x8E,0x04,0x14,0xD9,0xD0,
+0x2F,0xEC,0xE2,0xC9,0xC9,0x6F,0x0C,0x9D,
+0x27,0xCE,0x32,0xD4,0xC2,0xD7,0xBB,0xF6,
+0x2F,0xE8,0x0A,0xC3,0x0F,0x6E,0xEF,0xED,
+0x27,0x51,0x2C,0x39,0x5E,0x3C,0xFB,0x66,
+0x27,0x73,0xA2,0xC4,0x87,0x8A,0xD3,0x7A,
+0x27,0x37,0xCD,0x7E,0x76,0x6C,0x4B,0xF3,
+0x27,0xEC,0x34,0x14,0xDD,0x4A,0x0A,0xD0,
+0x27,0x1C,0x52,0x1A,0x6A,0x0D,0xE8,0x05,
+0x2F,0x46,0xFD,0xDC,0x57,0xED,0x60,0x35,
+0x2F,0x54,0x32,0x1D,0x6C,0x36,0x14,0x80,
+0x2F,0x91,0x0C,0x99,0x1E,0xCD,0x64,0x93,
+0x27,0x55,0xF7,0x59,0xC0,0x57,0x9E,0x54,
+0x27,0xE0,0x25,0xE3,0xCC,0x1C,0x75,0x10,
+0x27,0xA1,0x1E,0x40,0xF6,0xF0,0x9F,0x5B,
+0x27,0x62,0x42,0x86,0xAD,0x23,0x09,0x58,
+0x27,0x20,0x66,0xCE,0xBE,0x0E,0xEA,0x79,
+0x27,0x6B,0xE9,0xEA,0x32,0x30,0xD5,0xB7,
+0x2F,0x47,0x2D,0xB0,0x08,0x86,0x39,0xF4,
+0x27,0x45,0x30,0xF6,0xC5,0xAD,0xDF,0xBF,
+0x2F,0xDE,0x65,0x99,0x5C,0xD5,0x4E,0x59,
+0x27,0x0E,0x75,0x24,0x35,0x42,0x35,0x84,
+0x27,0x42,0xEB,0xB5,0xED,0x41,0xF1,0x09,
+0x2F,0xF4,0x37,0xED,0x54,0x94,0x1D,0xC3,
+0x2F,0xB2,0xEB,0x28,0x0B,0xE4,0x43,0x2D,
+0x27,0xCD,0x4E,0x72,0xDC,0x14,0x4B,0xD9,
+0x27,0x5D,0xA6,0xD3,0x87,0xCF,0x1A,0xC2,
+0x27,0x32,0x18,0x07,0x3A,0x81,0x6A,0x59,
+0x27,0x9F,0xCC,0xBA,0x6F,0xBB,0x95,0x85,
+0x2F,0x1D,0x91,0x94,0xF7,0x6C,0x4D,0xE5,
+0x27,0xF6,0x99,0x8A,0x26,0x6D,0xC8,0x8E,
+0x2F,0x6A,0x57,0x2F,0xCC,0xCB,0xD3,0x25,
+0x27,0xB3,0xD7,0x20,0xF9,0x0E,0xCC,0x5B,
+0x2F,0x77,0x80,0x61,0x4D,0xF9,0x89,0x2E,
+0x2F,0xAE,0xE2,0x7A,0xA6,0x3F,0x84,0x2B,
+0x27,0x21,0x99,0xB0,0x12,0xE2,0xF1,0xC2,
+0x27,0x35,0x51,0xF4,0xFF,0xD0,0x3D,0x31,
+0x2F,0xB4,0x7F,0x4B,0x8B,0xB5,0x94,0xD8,
+0x2F,0x9A,0x6E,0xC1,0x1D,0x7E,0xBA,0x42,
+0x27,0xAE,0x63,0xE6,0xE5,0xCD,0x86,0x2C,
+0x27,0xEE,0x7E,0x4E,0x37,0x68,0xD2,0x43,
+0x2F,0x81,0x12,0x84,0x82,0x9F,0x2F,0xAB,
+0x2F,0x35,0xEA,0xE1,0x3B,0x5A,0x00,0x60,
+0x27,0xB3,0x3A,0x97,0x3B,0x0E,0x78,0x04,
+0x27,0xE9,0x30,0xE8,0x8F,0x5D,0x45,0x63,
+0x2F,0xB8,0x75,0x02,0x22,0xC9,0x40,0xDB,
+0x2F,0xBE,0x64,0xB6,0x5B,0xBC,0x9D,0x4E,
+0x2F,0x3D,0x8A,0xD6,0xE7,0x09,0xFC,0x76,
+0x2F,0xAE,0x3D,0x7E,0x34,0x71,0x68,0xC5,
+0x27,0xD2,0x88,0xDE,0xB4,0x2D,0x7B,0xA0,
+0x27,0xA3,0x1C,0x80,0xB8,0xC0,0xEA,0x26,
+0x27,0xE6,0xB1,0x06,0x18,0xB2,0x14,0xEC,
+0x27,0xF5,0xD6,0xC0,0x6E,0x67,0x1D,0xA3,
+0x2F,0x37,0x34,0xFA,0xF6,0x79,0x38,0x01,
+0x27,0x55,0xFC,0xF5,0x85,0xF1,0x64,0xA2,
+0x27,0x21,0x8B,0x3D,0x98,0x24,0x21,0xF3,
+0x2F,0x82,0xEC,0xFC,0xB1,0xAF,0xF8,0xAA,
+0x27,0x0E,0x83,0xD9,0xCD,0xA5,0x3E,0x2E,
+0x2F,0xE6,0x7D,0xAF,0x27,0x5C,0x68,0x5D,
+0x2F,0xE5,0xFF,0xB7,0xF3,0xDE,0x74,0x41,
+0x2F,0x7D,0xE9,0xC5,0x2C,0x76,0x96,0xBA,
+0x2F,0x83,0xA9,0xE1,0xE3,0x6B,0x98,0x47,
+0x27,0xAF,0x59,0xFD,0x0B,0xCF,0xBF,0xF1,
+0x27,0xBD,0xBC,0x0D,0x17,0x09,0x12,0xCE,
+0x27,0x4F,0x2A,0x6D,0x2D,0x8E,0x40,0xD0,
+0x27,0x14,0xC5,0x9D,0x28,0x3A,0x6D,0x8F,
+0x2F,0x16,0x03,0x74,0x35,0x21,0xA4,0x20,
+0x2F,0xAB,0xC7,0x1C,0x3B,0xE6,0x21,0xD8,
+0x27,0xE4,0xCC,0x18,0x0A,0xF2,0xCD,0xFA,
+0x27,0x0C,0x8D,0x70,0x98,0x49,0xA0,0x63,
+0x2F,0x91,0xAD,0x95,0xA4,0xA4,0x88,0x10,
+0x2F,0xBB,0xC4,0x55,0xF4,0xD1,0x48,0xE9,
+0x2F,0x78,0x57,0x79,0x06,0xC1,0xBD,0x99,
+0x2F,0x1A,0xA6,0x77,0x00,0xB8,0x0F,0x4E,
+0x27,0x49,0x42,0x69,0x56,0xD9,0xA4,0xB5,
+0x2F,0xD8,0x41,0xC8,0x2A,0xDB,0x49,0xB9,
+0x2F,0xE6,0x05,0x26,0xFD,0x44,0x7E,0x6F,
+0x2F,0x9E,0x71,0x99,0xFB,0x82,0x80,0x67,
+0x27,0x2E,0x5D,0x93,0x31,0xD7,0x13,0xDA,
+0x27,0x18,0x2E,0x9C,0xB6,0xD5,0xC6,0xF4,
+0x2F,0x05,0x8A,0x9B,0xB9,0xAB,0x0C,0xC6,
+0x27,0xBB,0x6E,0x62,0x6F,0x18,0xB8,0xA1,
+0x2F,0xB9,0xDB,0x17,0xFD,0xE6,0xDA,0x07,
+0x2F,0xFE,0x4A,0xF8,0x24,0x3B,0xEC,0xA2,
+0x2F,0xC3,0x65,0x9E,0x2D,0xE1,0xA9,0x55,
+0x27,0xC6,0x2D,0x92,0xAC,0x6B,0x0F,0xAD,
+0x2F,0xF7,0x71,0x0A,0xB9,0x7A,0xF5,0xAD,
+0x27,0x30,0x71,0x9E,0xC3,0xFE,0x5F,0xDF,
+0x2F,0x2F,0x20,0x67,0x50,0x6F,0x62,0x44,
+0x2F,0xC2,0xFA,0x8E,0x51,0x26,0xF9,0x43,
+0x27,0xD5,0x6D,0xB1,0xD0,0x4E,0x85,0x7B,
+0x2F,0xCD,0xE5,0x30,0xEE,0xA3,0x42,0x5B,
+0x27,0xA9,0xA1,0x89,0x5E,0xC0,0x3D,0x2D,
+0x27,0x1D,0xD9,0xD3,0xFD,0x1B,0xAC,0xF5,
+0x27,0x9E,0x65,0x2B,0x64,0xB6,0xFA,0x10,
+0x2F,0x89,0x1B,0xF5,0xB8,0xA5,0xEB,0x78,
+0x2F,0x30,0xAC,0xB5,0xC3,0xA7,0x8C,0x69,
+0x2F,0xDA,0x48,0x66,0x6A,0x0F,0xCF,0x5E,
+0x2F,0x15,0x32,0x6C,0x2E,0x4A,0x5D,0xF1,
+0x2F,0x77,0xFF,0xFD,0xD4,0xD3,0xFA,0x40,
+0x2F,0x37,0x32,0x4D,0xA5,0x05,0x6A,0x41,
+0x2F,0x16,0xEC,0xC0,0x74,0x8D,0x2A,0x4C,
+0x27,0x12,0xDF,0x2E,0x0F,0x8D,0xC6,0x39,
+0x2F,0x5B,0x0E,0x05,0x66,0xCD,0x3C,0x9E,
+0x2F,0x1E,0x92,0xCD,0x53,0x02,0x01,0xB2,
+0x27,0x7C,0x47,0x17,0x0D,0x55,0x58,0xFA,
+0x27,0x89,0xCD,0x14,0xD9,0x4A,0x09,0x7D,
+0x27,0x03,0xD3,0x21,0xBE,0x89,0x4B,0x1E,
+0x27,0x16,0xB9,0xB0,0x7D,0x3F,0x50,0x26,
+0x2F,0x5B,0x55,0x74,0x60,0xD3,0x47,0x1D,
+0x27,0xC0,0x58,0x72,0x5D,0x44,0x0C,0xA0,
+0x27,0x3F,0xB9,0x78,0xEF,0xBA,0x4B,0xA9,
+0x27,0x80,0xFA,0xC8,0xA3,0xAA,0x99,0xE4,
+0x27,0xB2,0xC3,0x44,0x4B,0x3B,0xA0,0xD0,
+0x2F,0x4E,0xC8,0x38,0xA4,0x5C,0x58,0xD5,
+0x27,0xA4,0x29,0xF2,0xAA,0xDF,0x64,0xCF,
+0x2F,0x58,0x15,0xE4,0xE1,0x0D,0x93,0x0C,
+0x27,0xF4,0x8A,0xD4,0xE3,0x3E,0x40,0x7B,
+0x2F,0xBD,0xE0,0x86,0xE0,0x02,0x2B,0x10,
+0x27,0x20,0x1C,0xC6,0x08,0x18,0x51,0x59,
+0x27,0xF0,0x39,0x45,0x09,0x81,0xD6,0xEE,
+0x2F,0x59,0xF2,0x83,0x8C,0xAA,0xD9,0xDD,
+0x2F,0x34,0x3B,0x45,0xB1,0xD4,0xDF,0x89,
+0x27,0xF5,0x04,0x61,0x88,0xF0,0x80,0xEF,
+0x27,0x30,0xC5,0x47,0x07,0xAB,0xC3,0xEE,
+0x2F,0x8C,0x29,0xCD,0x8F,0x8F,0x99,0xB9,
+0x2F,0x2F,0xD9,0xB3,0x03,0x47,0x9B,0xFC,
+0x27,0x8C,0x66,0x1C,0xD4,0x8B,0x6B,0xBB,
+0x27,0x81,0xFE,0xB0,0x92,0xA0,0xFA,0xB6,
+0x2F,0x96,0x43,0xCB,0x99,0x48,0xD4,0xCB,
+0x2F,0xC7,0x32,0x1E,0xB4,0xF4,0xE6,0x0A,
+0x2F,0xB9,0x0A,0x88,0xBF,0x9F,0xE8,0xE9,
+0x27,0x7E,0x74,0x39,0x3E,0x06,0x16,0x6C,
+0x2F,0xFE,0x5D,0x2B,0xAC,0xC3,0xC5,0x80,
+0x2F,0xA2,0x11,0x78,0xCE,0x1C,0x53,0x02,
+0x27,0xDF,0xC0,0x78,0xEE,0xB5,0x0D,0x20,
+0x2F,0x31,0xB4,0xB3,0x51,0x25,0xC2,0x75,
+0x2F,0x62,0xDD,0x65,0x3A,0x5F,0x6B,0xCC,
+0x27,0x38,0x83,0x5C,0x51,0x93,0x57,0x32,
+0x27,0xA7,0xC1,0xF2,0x0A,0x2E,0x60,0xB2,
+0x27,0x26,0x94,0x46,0xA7,0x41,0x15,0x99,
+0x27,0xF3,0xAF,0xA8,0x3E,0x78,0xDF,0x6B,
+0x27,0xE6,0x60,0x2A,0x4F,0x92,0x57,0x49,
+0x27,0x1C,0x7B,0xF8,0x0F,0x2F,0x78,0x75,
+0x2F,0x24,0x68,0x6A,0x85,0x72,0xA9,0x88,
+0x2F,0x72,0xBC,0xFC,0x80,0x98,0xAA,0xEB,
+0x2F,0x36,0xDB,0xCB,0x6E,0x6C,0xFC,0x3E,
+0x2F,0xBF,0xFC,0xD7,0xB3,0xDF,0xA4,0xED,
+0x2F,0x8F,0x4E,0x80,0xA2,0x0E,0x5B,0xEE,
+0x27,0xB8,0x33,0x8C,0x01,0xDF,0xEE,0x54,
+0x2F,0x18,0x15,0x78,0x8E,0x4D,0xAD,0x70,
+0x2F,0xEE,0xA0,0xEC,0x2B,0x57,0x82,0x0A,
+0x27,0xB5,0x21,0xB5,0xF4,0xE8,0x78,0x95,
+0x27,0xB4,0xE1,0x9F,0x50,0x21,0xE9,0xA2,
+0x2F,0xFD,0x19,0x7D,0xEA,0x55,0xD2,0xBA,
+0x27,0x38,0xFF,0x31,0xD8,0xC2,0xDF,0xA1,
+0x2F,0x3F,0xF3,0x12,0x38,0x1E,0xF8,0xE8,
+0x2F,0x38,0x87,0x91,0xFE,0x48,0xD1,0xCE,
+0x2F,0x1B,0xA3,0xA8,0x2E,0xDA,0x57,0x45,
+0x2F,0x8C,0x2F,0x2D,0x96,0x45,0x0D,0x12,
+0x2F,0xE9,0x3C,0xC8,0xFD,0x2D,0xFA,0xA6,
+0x27,0x2A,0x85,0x5D,0xC4,0x2E,0x8C,0x29,
+0x27,0x4B,0x93,0x2B,0x2A,0xBC,0xC3,0x14,
+0x27,0x8D,0x82,0xE6,0xC6,0xBC,0x94,0x0D,
+0x27,0x8E,0x67,0x52,0xA6,0xB2,0x04,0x8D,
+0x2F,0x35,0xB8,0xB2,0xB2,0xF5,0x32,0x04,
+0x2F,0x2C,0x69,0x50,0xD1,0x2A,0xDA,0x63,
+0x2F,0xB9,0xB8,0x8E,0x68,0x4E,0x9A,0x8E,
+0x27,0x99,0xDC,0x4B,0xE7,0xAC,0xCB,0x0E,
+0x27,0xDB,0x50,0x91,0x4A,0x66,0x62,0x72,
+0x27,0xD3,0x9F,0x0E,0x6C,0x3B,0x6C,0x4A,
+0x27,0x0B,0xED,0x6E,0x12,0x72,0xD5,0xC2,
+0x27,0x03,0x04,0xA4,0x20,0xA1,0x94,0x32,
+0x2F,0x1A,0xC5,0x6A,0x3C,0xB8,0xFB,0x4C,
+0x27,0xBD,0x40,0x85,0xB7,0x22,0x8C,0x6A,
+0x2F,0xD1,0x6D,0x9A,0xF4,0xE4,0x4D,0xDF,
+0x2F,0xE3,0xE5,0x92,0xFD,0xF8,0x20,0xAB,
+0x2F,0x93,0x9B,0x0C,0xD0,0xDB,0x74,0xFC,
+0x27,0x20,0xF4,0x42,0x36,0x8A,0xC1,0xA8,
+0x27,0x37,0xEC,0xD2,0x5B,0xB9,0x88,0x62,
+0x2F,0x13,0x0D,0x8B,0xFF,0x1B,0xA1,0xC6,
+0x27,0xEE,0x84,0xC5,0x7E,0x55,0x4E,0xF1,
+0x27,0x8F,0x59,0x8C,0x29,0x1C,0x77,0xE1,
+0x27,0x88,0xD7,0x4A,0x67,0xCD,0x08,0xB0,
+0x27,0x52,0xDA,0xE4,0x55,0xCA,0x3A,0x40,
+0x2F,0xBA,0xA9,0x38,0xDF,0x47,0x2E,0xA3,
+0x2F,0x7C,0xDB,0x8B,0xC4,0x68,0x5D,0xBF,
+0x27,0xD3,0xA3,0x0F,0x93,0xF3,0x06,0x54,
+0x2F,0x89,0x05,0x45,0x8F,0x04,0x57,0x0A,
+0x2F,0xB5,0x06,0x9A,0xA7,0x26,0x4A,0xF5,
+0x2F,0x74,0xF1,0x3F,0xA3,0xCE,0x2E,0x9E,
+0x27,0x98,0xBE,0x5D,0xB8,0x86,0x0D,0xFE,
+0x27,0x10,0x19,0x34,0xCE,0xB2,0xF3,0x9A,
+0x2F,0xFF,0xDC,0x70,0xB8,0x1A,0x51,0x52,
+0x27,0xB3,0xED,0x21,0x9A,0x05,0xF7,0xB0,
+0x2F,0xF5,0xA1,0x3D,0x68,0x4E,0xB4,0x33,
+0x2F,0x5B,0x55,0x62,0x63,0xFA,0x3B,0x6C,
+0x27,0x92,0xDE,0x64,0xB0,0x92,0x16,0xE5,
+0x2F,0xFF,0xEA,0x14,0xB7,0x16,0xC2,0x58,
+0x2F,0x81,0x21,0x1B,0xF2,0x48,0x46,0xCB,
+0x27,0x8F,0x41,0x4E,0x9C,0x28,0xCB,0x0E,
+0x27,0x4B,0x1A,0x7F,0xF6,0xA5,0x06,0x51,
+0x2F,0x5C,0xF1,0x40,0x29,0xBB,0x58,0x7D,
+0x2F,0x6F,0x3E,0x48,0xF0,0x56,0x18,0xDF,
+0x27,0x44,0xE3,0x16,0x54,0xB3,0x1D,0x21,
+0x27,0x15,0xEE,0x6C,0x82,0xF8,0x98,0x99,
+0x27,0x87,0xDD,0x55,0x27,0x40,0xF3,0xB9,
+0x2F,0xEC,0xED,0x84,0x0C,0xF3,0xDB,0x61,
+0x2F,0xBC,0x32,0x5E,0x4D,0x5E,0x1E,0xC0,
+0x27,0x6C,0x87,0x68,0x33,0xDC,0xF0,0x56,
+0x2F,0x89,0x25,0x5C,0xEE,0x0C,0x62,0x7E,
+0x2F,0x5A,0x19,0x63,0x27,0x2F,0xB4,0x54,
+0x27,0x69,0x21,0xA4,0x13,0x6F,0x61,0x16,
+0x27,0x9B,0x16,0x8A,0x88,0x17,0xAB,0x66,
+0x27,0x58,0x30,0xA7,0x40,0x25,0x32,0x98,
+0x27,0xF1,0x60,0xA6,0xA4,0x30,0x2E,0x2C,
+0x2F,0xC0,0xA7,0xF0,0x9A,0xC2,0x0F,0xA7,
+0x27,0xFD,0xAB,0x60,0xF8,0xC8,0xFA,0x6E,
+0x27,0xEB,0x39,0x7D,0xDD,0xE4,0xD8,0x8E,
+0x2F,0x9D,0xDC,0xD5,0xE0,0x80,0x55,0xB9,
+0x27,0xF2,0xBD,0x24,0xB4,0x05,0x99,0x3F,
+0x27,0xD0,0x87,0xF9,0x82,0x65,0x16,0x23,
+0x27,0xB4,0x77,0x35,0x5D,0xF0,0xDB,0x5F,
+0x2F,0xED,0x86,0x0F,0x87,0xD6,0x59,0x8C,
+0x27,0xF4,0x1E,0x55,0xD2,0x20,0xAE,0x86,
+0x27,0x80,0x39,0xD2,0x79,0xAE,0x2C,0xB1,
+0x2F,0x40,0xEC,0x69,0x80,0xC4,0x94,0xAF,
+0x27,0x8C,0x83,0xE9,0xC6,0x3C,0x32,0xC0,
+0x27,0x6B,0x08,0xE1,0x69,0xD2,0x90,0xEC,
+0x2F,0x5B,0x4F,0xAE,0x71,0x94,0xD5,0xA1,
+0x27,0x7A,0x55,0x3F,0x96,0x86,0xEE,0xA4,
+0x27,0xE6,0xA4,0xDB,0x25,0x2B,0xFB,0xCA,
+0x27,0x2B,0x83,0x5D,0x16,0x64,0x53,0x07,
+0x27,0xA2,0xB2,0xF2,0x97,0xD4,0x08,0xAC,
+0x27,0xA3,0x33,0x39,0x5E,0x36,0xE2,0x29,
+0x2F,0x2F,0x1C,0x4D,0x0C,0x4C,0x59,0xC3,
+0x2F,0x40,0x72,0x2F,0x03,0x34,0x3F,0x52,
+0x2F,0x76,0xB4,0xCB,0x71,0x10,0xE2,0xE5,
+0x2F,0x7E,0xD7,0x99,0xA3,0x02,0x30,0x0F,
+0x2F,0x0F,0xA1,0x0B,0xE3,0x9D,0x37,0xED,
+0x2F,0x61,0x00,0x81,0xD0,0xCF,0xBD,0x91,
+0x2F,0x52,0x65,0x62,0xCA,0xC3,0x8A,0xCD,
+0x2F,0x15,0xC8,0xAA,0x40,0x94,0x86,0xDF,
+0x27,0x67,0xCA,0x60,0xB9,0x09,0x35,0xB1,
+0x27,0x47,0x68,0x61,0x0F,0x0A,0x61,0x14,
+0x2F,0xE7,0xF8,0x7A,0x96,0x42,0x80,0x1F,
+0x2F,0xCB,0x4E,0xB1,0x99,0x87,0xEB,0x1B,
+0x27,0xC4,0xF0,0x40,0xA9,0x81,0x97,0x2A,
+0x2F,0x97,0x46,0xD0,0xE2,0x2E,0x31,0xB8,
+0x2F,0x87,0xCC,0x91,0x37,0xF0,0x7C,0xD3,
+0x27,0xAF,0xC8,0x01,0x70,0x4E,0x4C,0x8A,
+0x2F,0xF4,0x82,0x5D,0x41,0xB1,0x21,0x30,
+0x27,0x30,0x58,0x63,0x52,0xE8,0x83,0xB2,
+0x2F,0xBD,0x1B,0x8D,0x3C,0xEF,0x1D,0x73,
+0x27,0x2B,0x8D,0x40,0x1A,0x8C,0xEF,0xA0,
+0x2F,0x7C,0xCE,0xDF,0xC4,0xA3,0xC1,0x50,
+0x2F,0x0E,0x00,0x9C,0x71,0x86,0x7D,0x6C,
+0x27,0x7D,0x04,0xB9,0x96,0x62,0x3C,0x5B,
+0x27,0x11,0x1D,0x13,0x89,0x0E,0xFB,0x4A,
+0x2F,0x1E,0xF7,0x07,0x47,0xBC,0xF9,0x54,
+0x2F,0x5F,0xC2,0x37,0x23,0x74,0x86,0x32,
+0x2F,0x03,0x2C,0xD1,0xED,0xEB,0xEB,0x4E,
+0x2F,0x29,0x90,0x8F,0x94,0x44,0x35,0x89,
+0x27,0xAF,0x39,0x3B,0x40,0x24,0x6A,0x20,
+0x27,0x26,0x97,0xAF,0xFA,0xAB,0x30,0xE3,
+0x27,0x42,0xA6,0x34,0x5C,0x77,0x05,0xF8,
+0x2F,0x10,0xFE,0x90,0xEA,0xC3,0x86,0x73,
+0x2F,0x5C,0x77,0x8D,0xE4,0x9F,0xEE,0xDB,
+0x2F,0x8F,0x22,0x40,0x1D,0x97,0x48,0x1B,
+0x2F,0xA8,0x4E,0x0F,0x4E,0xC6,0x87,0x65,
+0x2F,0x1C,0x4F,0x58,0x4A,0x78,0xE2,0xCA,
+0x27,0x4E,0x96,0x25,0x26,0xB0,0xAA,0xA7,
+0x27,0x41,0xF2,0x8F,0xC4,0xA2,0x14,0xEE,
+0x27,0x08,0xBF,0x8D,0x08,0x44,0xB8,0x05,
+0x27,0xBF,0x06,0x18,0xEC,0x79,0x54,0xBE,
+0x27,0x38,0x79,0x37,0x7C,0xEF,0xAD,0xCC,
+0x27,0x17,0x6E,0xBF,0xC3,0xD4,0x63,0x7F,
+0x2F,0x42,0xF9,0xEC,0xE4,0xE1,0xAE,0xA4,
+0x27,0xEF,0x60,0x09,0xCB,0x60,0x86,0x4F,
+0x2F,0xDB,0xE1,0xF1,0x31,0x95,0x5C,0x26,
+0x27,0xDC,0xF5,0x65,0x6D,0x80,0xE9,0xAB,
+0x2F,0xE2,0x5B,0xD2,0x15,0xDF,0xC7,0x68,
+0x27,0x3A,0x91,0xA2,0xEB,0xBF,0x75,0xF9,
+0x2F,0xC2,0x73,0xCC,0xE6,0xF5,0x28,0x3A,
+0x27,0x68,0xF6,0x1C,0x4B,0xDD,0xFA,0xF4,
+0x2F,0xE3,0xC8,0x83,0xEE,0x4A,0x6F,0x05,
+0x27,0x6C,0xF7,0xE2,0x09,0xCE,0x5C,0x6E,
+0x2F,0xD1,0x26,0xD8,0x8C,0x22,0xC3,0x06,
+0x27,0xA9,0xDA,0x03,0x3D,0xF7,0x8E,0xFD,
+0x2F,0x2E,0xB2,0x74,0xA1,0x52,0x3D,0xB3,
+0x27,0xE9,0x83,0x8E,0xAF,0xE3,0x34,0x49,
+0x2F,0xBD,0x80,0xDA,0xE7,0xE2,0xF2,0x92,
+0x27,0x66,0x15,0xC3,0xFA,0x84,0x85,0xE6,
+0x2F,0xAC,0xC9,0x86,0x7B,0xFE,0x74,0xCA,
+0x2F,0xA5,0x0A,0xAF,0xCA,0x96,0xC4,0x2B,
+0x27,0x6D,0x54,0x62,0x39,0x25,0x3B,0x67,
+0x27,0x44,0xA4,0x03,0x24,0x8C,0xD7,0x7A,
+0x2F,0xB0,0x23,0xC8,0x23,0x36,0x1F,0xFE,
+0x2F,0x8D,0x81,0x08,0xF8,0x7C,0x83,0xC4,
+0x27,0x36,0x05,0xBC,0x9C,0x73,0x6E,0x00,
+0x27,0x38,0x97,0x92,0x6C,0x5C,0xD4,0x9C,
+0x2F,0x02,0x0C,0x09,0x51,0xCA,0xA4,0xA0,
+0x27,0xA5,0xEF,0xFB,0x4B,0x5D,0xF0,0xFB,
+0x27,0x7C,0x69,0x18,0x4E,0x74,0xC6,0xE9,
+0x27,0x6A,0xB9,0xCE,0x26,0x3A,0xF6,0xE8,
+0x2F,0x9B,0xC2,0xCB,0xB0,0x76,0xE4,0xBE,
+0x2F,0x69,0x91,0x3D,0x85,0xBC,0x42,0xC1,
+0x2F,0xA0,0x70,0xCA,0xE8,0xAC,0x30,0x86,
+0x2F,0x2E,0xD4,0x68,0x5A,0xC2,0x08,0xBB,
+0x2F,0xE1,0x73,0xC7,0x82,0xD1,0x9E,0x9C,
+0x27,0x40,0x70,0xA0,0x27,0x53,0xD3,0x7D,
+0x2F,0xFA,0x23,0xCA,0x46,0x4B,0x4B,0xAE,
+0x2F,0x20,0x04,0x2F,0x3A,0xD1,0xC5,0x90,
+0x27,0xB5,0xF5,0x86,0x55,0xBB,0x4B,0xD8,
+0x2F,0xB4,0x03,0x15,0xCC,0x18,0xDA,0xA1,
+0x27,0x11,0x37,0x98,0x5D,0xC5,0x9E,0x88,
+0x2F,0xD6,0x2F,0x7B,0xEA,0xA5,0xC3,0x74,
+0x27,0x9C,0x4E,0xE4,0x42,0x23,0xB0,0x75,
+0x2F,0x50,0x06,0xA0,0x84,0xD7,0x28,0x54,
+0x2F,0x90,0xDA,0xA7,0xD9,0x2D,0x01,0x34,
+0x2F,0x35,0xA2,0x47,0x75,0xAD,0x19,0x4A,
+0x27,0x7F,0x38,0xAC,0x9B,0xBB,0x4C,0xFA,
+0x2F,0x77,0x52,0x7D,0x59,0x4D,0xE5,0x40,
+0x2F,0x7E,0x96,0x56,0x95,0xCC,0x63,0xA0,
+0x27,0x78,0x4F,0xE7,0x42,0x18,0x99,0xBB,
+0x27,0x8A,0xFB,0x65,0x32,0x7E,0x2B,0xF9,
+0x27,0x95,0x84,0x07,0x17,0x31,0x92,0x45,
+0x27,0xFE,0x5C,0xE7,0x84,0x31,0x32,0x8D,
+0x2F,0xFE,0x8B,0xE9,0x1A,0x53,0xA2,0xD0,
+0x27,0xA3,0xC8,0x71,0xFD,0x6D,0x70,0xF3,
+0x27,0xD2,0xBB,0xB8,0x22,0xC8,0x7B,0x0B,
+0x27,0xDE,0x3D,0xEA,0xD2,0x45,0x33,0xB9,
+0x2F,0x62,0x2D,0x7B,0x26,0x68,0x8B,0x2F,
+0x27,0xD2,0x39,0x97,0xC6,0xA7,0x99,0x17,
+0x2F,0xE2,0x15,0x9C,0x22,0x1D,0xE6,0x38,
+0x27,0xAE,0x5E,0xCA,0x65,0xFC,0x06,0xE8,
+0x27,0x13,0x7C,0x34,0xD2,0x7E,0x04,0xEB,
+0x2F,0x7A,0xEF,0xAD,0x6B,0x11,0x40,0x33,
+0x27,0xB0,0x77,0xE5,0x5E,0x0C,0x16,0xEF,
+0x27,0xB1,0xCE,0xE2,0x9B,0xDE,0x4B,0x5F,
+0x27,0xB2,0x58,0x0C,0xB8,0xFA,0xB0,0xFD,
+0x27,0x5B,0xD0,0x15,0x08,0xF3,0x1E,0x03,
+0x2F,0x2F,0x9D,0xC3,0x94,0x8A,0xCF,0x76,
+0x27,0x8F,0x5A,0xE8,0xBE,0x50,0xF1,0x17,
+0x27,0x8D,0x53,0x26,0xB3,0xD3,0x75,0x17,
+0x2F,0xDC,0x20,0xCB,0xAB,0x53,0xE6,0xF4,
+0x2F,0x49,0x3E,0x71,0x1F,0xF6,0xF4,0x70,
+0x27,0x44,0x75,0x9F,0x02,0x32,0x9B,0x0E,
+0x2F,0xF0,0x2E,0x91,0xDC,0x11,0x14,0x34,
+0x27,0x45,0x14,0x1B,0x3F,0xF3,0x65,0x5D,
+0x2F,0x62,0xFB,0x37,0x11,0xF1,0x05,0x05,
+0x2F,0xB0,0xAA,0x5D,0x54,0xAD,0xC2,0x1B,
+0x27,0x21,0x4C,0x1E,0xD8,0x34,0xAD,0x42,
+0x27,0xCE,0x9E,0x91,0x44,0x8D,0x10,0xDA,
+0x2F,0xEA,0xF7,0x96,0x22,0xBA,0x38,0xE0,
+0x27,0x04,0xF8,0x78,0xC2,0x0D,0xC0,0xDB,
+0x27,0x0A,0xC1,0xBD,0xC7,0x83,0x28,0xF9,
+0x2F,0x4B,0xD1,0x03,0x02,0x51,0x6A,0xAA,
+0x27,0xEB,0x09,0x8D,0xE7,0x59,0x7E,0xDB,
+0x2F,0xA3,0x9E,0xF3,0x93,0x1F,0xF2,0x7D,
+0x2F,0x91,0x35,0xD8,0x50,0xE5,0xDE,0x52,
+0x2F,0x78,0x63,0x4A,0x95,0x52,0x76,0xA9,
+0x2F,0x4A,0x2E,0x66,0x38,0xFF,0x4F,0x00,
+0x27,0xF8,0xAD,0xA8,0xF9,0x0A,0x1B,0x5F,
+0x2F,0x2B,0xCC,0x38,0x09,0xDB,0x71,0x46,
+0x2F,0xD4,0x67,0x47,0x52,0x0E,0x89,0x4F,
+0x2F,0xA0,0x9C,0xAD,0x1C,0x37,0x1C,0xB3,
+0x27,0xD8,0x28,0x73,0xA7,0x53,0xE7,0xA9,
+0x2F,0x61,0x28,0x1C,0x4C,0x2F,0xAD,0x90,
+0x27,0xE4,0x8E,0x12,0xE5,0x8E,0xF5,0xCA,
+0x2F,0xA5,0x3A,0x18,0x36,0xB4,0x6F,0x87,
+0x2F,0x2A,0x3A,0xF9,0xCD,0x12,0xAE,0x5B,
+0x2F,0xD6,0xE7,0x5E,0xF1,0x9C,0x73,0xFF,
+0x27,0x60,0x59,0x4E,0x59,0xDF,0x14,0xA0,
+0x2F,0x3E,0x89,0x2B,0x06,0x46,0x9C,0xB3,
+0x2F,0x20,0xF6,0xCB,0xED,0x66,0x9D,0x80,
+0x2F,0xA2,0x7E,0x38,0x77,0x7F,0x21,0xBD,
+0x27,0xBF,0xB1,0x73,0xCD,0x41,0x03,0xF0,
+0x2F,0xE8,0xB3,0x19,0xC1,0xF0,0x51,0x14,
+0x2F,0xD6,0x77,0x74,0x24,0xAC,0xBE,0x53,
+0x2F,0xD4,0x6E,0xA6,0xE9,0x53,0x3C,0xD7,
+0x27,0x4C,0xBF,0x45,0x89,0x60,0x94,0xC5,
+0x2F,0x5C,0xE6,0x51,0xFB,0xB3,0x56,0x36,
+0x27,0xB1,0xD6,0x84,0xFB,0x15,0xB1,0x97,
+0x27,0x7A,0xDA,0x95,0x1D,0x0B,0x99,0x34,
+0x27,0xD8,0x6B,0x86,0x2D,0x3D,0xC5,0x1C,
+0x2F,0x62,0x25,0x5B,0xB2,0xDF,0xB4,0x8B,
+0x2F,0x52,0xD2,0x38,0x7B,0xFB,0x5B,0xE1,
+0x27,0x16,0x35,0x37,0xB3,0xF5,0x27,0x95,
+0x27,0x7A,0xF5,0x1A,0x4B,0xA1,0x59,0xF9,
+0x2F,0x5C,0x86,0x0D,0x4A,0x5F,0x1A,0xD1,
+0x27,0x9C,0xBD,0x5B,0x03,0xA2,0x57,0x0D,
+0x2F,0x9F,0xB7,0x66,0x19,0x74,0x7B,0x4A,
+0x27,0x74,0xA0,0xA2,0xBF,0x1B,0xAD,0xD0,
+0x2F,0x32,0xA4,0x52,0x99,0xD9,0xC8,0xB0,
+0x2F,0x6A,0x4B,0x69,0x0C,0xED,0x17,0xA2,
+0x27,0xF8,0x21,0x76,0xD1,0xFB,0xAD,0xC0,
+0x2F,0x6F,0x33,0x7C,0x9D,0x24,0x88,0x9E,
+0x27,0x80,0x98,0x4E,0x78,0xD5,0x62,0x74,
+0x27,0xE3,0x08,0x23,0x21,0x73,0x15,0xAE,
+0x2F,0x78,0x71,0x80,0xC7,0x23,0xA1,0xD1,
+0x2F,0x98,0xD5,0xE8,0xA3,0x26,0xEE,0xCF,
+0x27,0xC4,0x4E,0xA4,0x37,0x6D,0xDE,0xB2,
+0x2F,0x3D,0xD9,0x6F,0xD8,0x46,0x11,0x17,
+0x2F,0x5D,0x9C,0x33,0xF5,0x95,0xF1,0xD3,
+0x27,0x2B,0x96,0x5C,0xA0,0xC9,0xF0,0x6D,
+0x27,0xFB,0xDE,0xAA,0x62,0xA5,0xAF,0xFC,
+0x27,0xB6,0xD9,0x7A,0x4B,0x4B,0x7B,0xF4,
+0x2F,0xC2,0xDD,0x3C,0xCC,0x84,0xAD,0xE3,
+0x2F,0xD3,0x81,0xBB,0xF8,0xE7,0x1E,0x6D,
+0x27,0x7B,0xD5,0x27,0x7E,0xA0,0x21,0x32,
+0x27,0x17,0x2C,0x5F,0x9C,0x8B,0xD5,0x3F,
+0x2F,0x93,0x10,0x5F,0x1E,0x01,0x86,0xAB,
+0x27,0x48,0x40,0x46,0xCC,0x22,0xD9,0xE9,
+0x27,0xF1,0xA7,0x0B,0x2B,0xAC,0xD8,0xED,
+0x27,0x75,0x7C,0xF7,0x70,0x8D,0x8D,0xA0,
+0x2F,0x17,0x48,0x02,0xD1,0x7F,0x65,0x6F,
+0x27,0x8E,0x0F,0x21,0x80,0x3B,0x6E,0xBE,
+0x2F,0x06,0xFD,0xDF,0x38,0x0B,0x72,0xA6,
+0x27,0xB5,0x01,0xF5,0x39,0x91,0xF3,0x01,
+0x2F,0x52,0xAA,0x06,0x4D,0xB7,0x62,0xE1,
+0x27,0xFA,0x7B,0x52,0xB5,0x28,0xEF,0x46,
+0x27,0x25,0xCA,0xA4,0x6C,0x85,0xEB,0xF6,
+0x2F,0x22,0xF0,0x22,0xE9,0xB8,0x6B,0x44,
+0x2F,0xDF,0x1D,0x12,0xD7,0x91,0xD9,0x38,
+0x27,0xD2,0xF1,0x9D,0xCC,0xA8,0x82,0x67,
+0x27,0x66,0xFF,0x14,0xE1,0x50,0xEB,0x57,
+0x2F,0xFC,0xB5,0x22,0x3C,0xF2,0x6C,0x43,
+0x27,0x0D,0xB2,0x47,0x30,0x42,0xE0,0xC1,
+0x2F,0x4F,0xAF,0xD1,0x1A,0x31,0xE6,0x2C,
+0x2F,0x45,0xFE,0x3B,0x10,0xBD,0xEB,0xE1,
+0x27,0xA8,0xD5,0x8E,0xC0,0x0C,0x89,0x51,
+0x27,0xED,0x07,0x68,0xE0,0xEF,0x7A,0x04,
+0x2F,0x83,0x4D,0x71,0xEB,0x97,0x9B,0x10,
+0x27,0x57,0xF1,0xD1,0xD4,0x04,0x0A,0xB9,
+0x2F,0x67,0x37,0x2C,0xDE,0xBD,0xF9,0x19,
+0x2F,0x58,0x74,0x34,0x6D,0x70,0x4E,0x41,
+0x27,0x1C,0x30,0x30,0xF4,0x5C,0xFB,0x49,
+0x27,0x93,0xCD,0x36,0xC3,0x68,0x0C,0x43,
+0x2F,0x35,0xCA,0x71,0x2E,0x50,0xCC,0x3C,
+0x27,0x84,0xF4,0x67,0x4B,0x27,0x32,0x93,
+0x2F,0xD7,0xE2,0xFC,0x20,0x1E,0x1D,0x06,
+0x27,0x51,0x39,0x13,0xFC,0xCF,0x55,0x85,
+0x2F,0xB9,0xCD,0xA0,0xB4,0xC6,0x6A,0x78,
+0x2F,0xD5,0x00,0x94,0x31,0xB5,0x84,0x57,
+0x2F,0x69,0xB9,0x63,0x72,0x7E,0x88,0xD9,
+0x2F,0xEC,0x03,0xAE,0xB1,0x72,0x2D,0xEC,
+0x27,0x83,0xB4,0x79,0xD0,0x21,0x35,0x5C,
+0x2F,0xC5,0xFD,0xA7,0xD6,0x76,0xFA,0x57,
+0x2F,0x4B,0x1B,0x04,0x61,0xBD,0x7B,0xE4,
+0x2F,0x44,0xA6,0xA9,0xD8,0x03,0x1F,0x59,
+0x2F,0x91,0x22,0x17,0x29,0x0A,0xB6,0x1F,
+0x2F,0xFC,0xA9,0x05,0x94,0xD1,0xF1,0x9C,
+0x2F,0x07,0xF0,0x52,0x77,0x52,0xB6,0x3F,
+0x2F,0x3C,0x7A,0xC7,0x2D,0x48,0x7E,0x4E,
+0x2F,0x02,0xAC,0x53,0x65,0xE3,0x50,0x0E,
+0x27,0xF3,0x2D,0x29,0xD6,0x38,0x8E,0x9B,
+0x27,0x63,0x68,0x20,0xA2,0x88,0xCE,0x6E,
+0x27,0x51,0x4A,0xF0,0xDA,0x03,0x6A,0xFD,
+0x27,0x7E,0x5E,0xAE,0xDD,0x20,0x11,0xB6,
+0x2F,0x97,0x39,0xF1,0xD4,0xF3,0xF4,0xE0,
+0x27,0x2B,0x36,0x95,0xB0,0x96,0x45,0x39,
+0x27,0x80,0xA4,0x4A,0x15,0x5C,0x96,0x8A,
+0x2F,0x62,0x70,0xFB,0xE0,0xEF,0x8A,0xE2,
+0x27,0x47,0xB7,0x16,0xED,0xDC,0x2F,0x56,
+0x2F,0xE6,0x6E,0xCB,0x50,0x4B,0xA7,0x08,
+0x27,0x77,0x53,0xA1,0xBC,0x53,0x2F,0x22,
+0x2F,0x1D,0x4F,0xD8,0xCB,0xB6,0xA9,0x87,
+0x27,0xF0,0xCF,0x65,0x5C,0x00,0x93,0xCA,
+0x2F,0xC7,0x78,0x61,0xA9,0xAB,0x81,0xBF,
+0x2F,0x5D,0xAA,0x79,0x67,0xD1,0x27,0x1D,
+0x2F,0x95,0x4D,0x93,0x30,0x02,0x1B,0x30,
+0x27,0x32,0x21,0xDD,0x31,0xD4,0x1F,0x08,
+0x2F,0x18,0xF3,0x32,0x0F,0xF1,0x81,0x6B,
+0x2F,0xF9,0xC5,0x96,0x6F,0x1B,0x5B,0xD5,
+0x27,0xA1,0x62,0xB6,0xE5,0xF3,0xCA,0x5F,
+0x27,0x8E,0xE1,0x66,0x42,0x4E,0xA2,0xBC,
+0x27,0xAD,0x16,0x22,0x62,0x73,0x7A,0x53,
+0x27,0xFA,0xE0,0xA8,0x4F,0x91,0x27,0xFD,
+0x27,0x5A,0xA1,0x16,0xAA,0x1B,0xBA,0x4D,
+0x27,0xC6,0xF7,0x70,0x72,0x29,0x1E,0xF6,
+0x2F,0x63,0x93,0x0E,0x28,0xE8,0x5A,0xA1,
+0x2F,0x17,0xE1,0x49,0x8C,0xD6,0xE4,0xE6,
+0x27,0xE6,0x8B,0x5D,0xC5,0xDC,0x19,0x1E,
+0x2F,0x04,0xE1,0x66,0x20,0x80,0x4E,0xBB,
+0x2F,0x66,0x80,0x07,0x11,0x45,0xB8,0xC1,
+0x2F,0xBA,0xBC,0x2C,0x93,0x4B,0xDB,0x83,
+0x2F,0x6F,0x21,0xD5,0x38,0xE2,0x02,0xFD,
+0x27,0xEC,0x40,0xC1,0x9F,0x29,0x9D,0x00,
+0x2F,0xB8,0x4D,0xE5,0xF0,0x50,0x63,0x69,
+0x27,0xD2,0x7E,0xA9,0xFC,0x7F,0xB9,0x40,
+0x2F,0x33,0xC8,0x71,0x6A,0xE5,0x5B,0x71,
+0x2F,0xDC,0x7E,0x8B,0x79,0x21,0xB5,0xBA,
+0x27,0x26,0x46,0x70,0x0D,0x68,0xD4,0x94,
+0x2F,0x8D,0x2D,0x97,0x7A,0x0B,0x82,0xB5,
+0x2F,0x3D,0x6B,0x64,0x69,0x18,0x38,0xAC,
+0x27,0x99,0xBC,0x72,0x5C,0x41,0x0D,0x56,
+0x2F,0x35,0x07,0x7A,0x36,0x45,0x3C,0x2F,
+0x2F,0x55,0x13,0xC7,0xFC,0x9D,0x62,0xC0,
+0x2F,0xD3,0x7B,0x03,0x8E,0x08,0x0D,0x0C,
+0x2F,0xD6,0x9E,0xF7,0x68,0xE9,0xA7,0xFB,
+0x27,0x8B,0xD2,0xCC,0x10,0x5E,0x0D,0xF1,
+0x27,0x11,0xA9,0xA8,0x4B,0x76,0xC6,0x02,
+0x27,0xB2,0x29,0xC4,0xF0,0x15,0x6B,0xAA,
+0x2F,0x6F,0x51,0xA9,0x4B,0x15,0x3B,0xA8,
+0x2F,0x5B,0xE5,0xF6,0x04,0xC4,0x00,0x35,
+0x27,0xA9,0x80,0x99,0xD0,0x1F,0xE8,0x26,
+0x27,0xCE,0x22,0xB6,0xD9,0x2A,0x41,0xA2,
+0x2F,0x04,0x86,0x0D,0xC4,0x14,0x0C,0x05,
+0x27,0xE0,0x55,0xB0,0x97,0x6E,0xD2,0x3B,
+0x27,0xE9,0x8B,0x38,0x84,0x71,0x16,0x43,
+0x2F,0x67,0x12,0x36,0x53,0x9C,0x77,0x4A,
+0x2F,0x32,0x18,0x5F,0x1C,0xA1,0xFC,0x22,
+0x27,0x3D,0xC2,0x60,0xC9,0xB8,0x1E,0x99,
+0x2F,0xC2,0x27,0x5B,0xEA,0xC3,0x1E,0x88,
+0x2F,0x5D,0x41,0x74,0x40,0xDF,0xF5,0xE1,
+0x2F,0x3F,0x77,0x82,0x66,0xE8,0x45,0x2D,
+0x2F,0xF3,0x2C,0x02,0x51,0x43,0x70,0xB5,
+0x2F,0x70,0x78,0xE8,0x04,0x01,0x6E,0x7C,
+0x2F,0x1E,0x3E,0x3A,0xD6,0xC4,0xAC,0x90,
+0x27,0x07,0x69,0x25,0x6B,0x38,0x3E,0x20,
+0x27,0x4C,0x8E,0xDA,0xD2,0x62,0x65,0x1F,
+0x2F,0x26,0xAA,0xCD,0xE8,0x9B,0x17,0x8D,
+0x2F,0x45,0xD1,0x06,0x21,0x72,0xAE,0x2C,
+0x27,0x23,0xD1,0x3A,0x08,0xD9,0x68,0xAD,
+0x2F,0x49,0x8E,0x1D,0xE8,0x43,0x6F,0x75,
+0x27,0x27,0x6C,0xE9,0x05,0xDC,0x0A,0x52,
+0x27,0x4C,0x4E,0x70,0x13,0xE4,0xA0,0xD0,
+0x27,0xF2,0x12,0xCD,0x58,0x21,0xDC,0xB7,
+0x2F,0xBB,0x85,0xBB,0xFA,0xBA,0x99,0x8B,
+0x27,0x42,0x72,0x65,0x9A,0xF8,0xAA,0xDF,
+0x2F,0x7A,0x08,0x64,0xAA,0xC5,0x78,0xE0,
+0x27,0x88,0x66,0x6B,0x9B,0x41,0xA3,0x04,
+0x2F,0x9D,0x3F,0x24,0x1E,0x94,0x04,0x41,
+0x27,0x81,0x9F,0x83,0x04,0x83,0x74,0xBF,
+0x27,0x94,0x3B,0x33,0x2E,0x5A,0x13,0x8F,
+0x2F,0xA7,0xE8,0x11,0xB7,0xCD,0x63,0x3C,
+0x27,0x2D,0x17,0xA6,0xE4,0x35,0xBF,0x08,
+0x2F,0xF2,0x97,0xC3,0x22,0x28,0xEC,0xCF,
+0x27,0xF8,0xBA,0xD5,0x1C,0xC3,0xFC,0x76,
+0x2F,0xCE,0xB8,0xC0,0x43,0xA3,0x63,0xC6,
+0x2F,0x1E,0x2D,0x65,0xE8,0xD1,0xC9,0x2B,
+0x2F,0x35,0xF3,0x77,0x8F,0x72,0x34,0xE7,
+0x27,0x31,0x80,0x43,0xF9,0x24,0x4E,0xDF,
+0x2F,0x23,0xA1,0x44,0x04,0x87,0x13,0x59,
+0x2F,0x39,0xC3,0x3F,0x6A,0xCB,0x65,0x02,
+0x27,0x82,0x46,0x6A,0x9C,0x56,0xCA,0x92,
+0x27,0x18,0xA8,0x78,0xA8,0x5D,0x54,0xFE,
+0x2F,0x13,0xEB,0xA9,0x71,0x0A,0xF4,0xD3,
+0x27,0x8C,0x4A,0xA8,0x2A,0x90,0xAE,0x42,
+0x27,0x68,0x81,0x30,0x33,0xD7,0x99,0x44,
+0x27,0xC4,0x48,0xD1,0x31,0x08,0x06,0x3C,
+0x2F,0x52,0x18,0xA3,0x06,0x49,0xE4,0x55,
+0x2F,0xEB,0x07,0xBD,0x5A,0xAE,0xD9,0x3E,
+0x27,0x5F,0xAF,0x35,0x15,0x1E,0x45,0x0C,
+0x2F,0xC3,0x83,0x16,0x5F,0x29,0x88,0x38,
+0x2F,0xAC,0x2F,0xDE,0x0A,0x5D,0x4C,0xE1,
+0x2F,0x94,0x7C,0x63,0x10,0xA1,0x97,0x0C,
+0x2F,0xFE,0x86,0x38,0xEF,0xD8,0xE6,0xE2,
+0x2F,0x94,0x3A,0x1A,0xF6,0x71,0x88,0x4F,
+0x2F,0x8F,0x4C,0x00,0x26,0x75,0x80,0xB5,
+0x27,0x23,0x5E,0x57,0x16,0xDF,0x55,0xC4,
+0x2F,0xBA,0xA9,0x17,0x61,0xF7,0x1F,0x40,
+0x27,0xF9,0xCA,0x3C,0xD9,0x10,0x86,0x16,
+0x2F,0x4A,0x31,0xD6,0xBF,0xA7,0xD5,0x65,
+0x27,0x6A,0xED,0x40,0x0E,0xEC,0x02,0x41,
+0x2F,0x89,0xFE,0xFC,0x26,0x8B,0x97,0x8C,
+0x2F,0x62,0xE3,0x29,0x79,0x52,0x40,0xD2,
+0x27,0xB3,0x25,0x3F,0x9A,0xE4,0x91,0x27,
+0x2F,0x69,0x33,0xEA,0x60,0x17,0x1B,0xE4,
+0x27,0xB2,0xAD,0x5D,0x7B,0x65,0x08,0xBB,
+0x27,0xD6,0xB8,0x3D,0x26,0x04,0x27,0x05,
+0x27,0x7B,0xC2,0x2F,0xDA,0x67,0x12,0x4F,
+0x2F,0x68,0x98,0x8F,0x6D,0x18,0xE2,0xF0,
+0x2F,0x91,0x44,0xCF,0xFF,0xF4,0x1F,0x91,
+0x27,0x9B,0x00,0xE8,0xAF,0x5D,0x3C,0xA7,
+0x27,0x1C,0xB8,0xC2,0x5F,0xC1,0x7E,0xF7,
+0x2F,0x3A,0x7F,0x28,0x68,0xCD,0x30,0x12,
+0x27,0x77,0x87,0x7B,0xA9,0x86,0x8A,0xD2,
+0x27,0x7F,0x39,0x0E,0xF5,0x95,0x40,0x50,
+0x27,0xDC,0xDA,0xB3,0x58,0x0D,0xF5,0xE0,
+0x27,0xA1,0x6D,0xDF,0x61,0x0D,0x7A,0xD0,
+0x27,0xC5,0xA9,0xF4,0x5B,0x18,0x44,0xAE,
+0x27,0x22,0x49,0xD3,0x16,0xA6,0xC6,0x2C,
+0x2C,0xAB,0x8B,0xA6,0x8A,0x48,0x0C,0x40,
+0x05,0x0F,0xD1,0x65,0x28,0xC8,0x88,0x48,
+0x27,0xEA,0x6A,0xA1,0xC7,0x7F,0x3A,0x66,
+0x25,0x48,0x9A,0x7A,0xF6,0xA9,0x6B,0x77,
+0x05,0xC9,0xD3,0x04,0x9C,0xE9,0x6A,0xCF
+};
+
+#define Si2168_PATCH_2_0b24_LINES (sizeof(Si2168_PATCH_2_0b24)/(8*sizeof(unsigned char)))
+
+#define Si2168_PATCH_3_0b6_PART    68
+#define Si2168_PATCH_3_0b6_ROM      3
+#define Si2168_PATCH_3_0b6_PMAJOR  '3'
+#define Si2168_PATCH_3_0b6_PMINOR  '0'
+#define Si2168_PATCH_3_0b6_PBUILD   2
+
+unsigned char Si2168_PATCH_3_0b6[] = {
+0x04,0x01,0x01,0x00,0x73,0xDF,0x08,0x1D,
+0x05,0xF4,0xBE,0x7A,0x2F,0x2B,0xB0,0x16,
+0x2A,0x4C,0x44,0xBE,0x6B,0xC1,0x09,0x67,
+0x05,0x62,0x97,0x40,0x20,0x8F,0x56,0xBE,
+0x2F,0xA9,0x06,0x9B,0x0F,0x51,0xB0,0xEE,
+0x29,0x78,0x5F,0x6D,0x5E,0xE4,0xF7,0x28,
+0x05,0x73,0x4D,0xDE,0xAA,0xDC,0xF2,0xA4,
+0x27,0x85,0x8F,0xA5,0x68,0xDA,0x50,0xA8,
+0x2F,0xDF,0xD2,0xC9,0x2C,0x8E,0xFE,0xB7,
+0x21,0x3A,0xC6,0xAF,0xA9,0x95,0xCA,0x4F,
+0x07,0xC6,0x1A,0x00,0x3B,0xF9,0x6C,0x7E,
+0x2F,0x61,0x35,0x3D,0x3B,0xE6,0x55,0xA3,
+0x2F,0xAF,0x71,0xF0,0x7D,0xF5,0xD5,0x95,
+0x21,0x95,0xE1,0x1C,0xC8,0x08,0x80,0x78,
+0x07,0xBE,0x12,0x27,0xEB,0xB9,0x06,0xD5,
+0x27,0xAA,0x96,0x67,0xC7,0xE0,0x99,0x75,
+0x23,0x74,0xFA,0xA2,0x30,0x19,0x09,0xE6,
+0x07,0xE5,0xBB,0x8C,0x40,0xFA,0xFD,0x6D,
+0x27,0x7B,0x21,0x1E,0x2B,0xF3,0x5C,0x0F,
+0x23,0x0A,0x20,0x4F,0xE6,0xFC,0xCE,0xC1,
+0x07,0x52,0xD2,0xEF,0x44,0xFC,0x17,0xEC,
+0x05,0x8D,0xDB,0x59,0xE6,0x77,0x52,0x23,
+0x22,0x34,0x88,0xBC,0xE1,0x39,0xAA,0xC9,
+0x07,0x4E,0x10,0x1E,0xAD,0x4C,0xF6,0x91,
+0x05,0x70,0xDF,0xB0,0x89,0x72,0xFB,0x95,
+0x24,0x4A,0x24,0xC4,0x9D,0x4A,0x07,0x39,
+0x05,0x0C,0x68,0x8B,0x7B,0x4A,0x11,0xD2,
+0x2C,0xC7,0x29,0x96,0x7E,0x6B,0xE7,0x6F,
+0x05,0xCA,0x40,0xEF,0xB2,0x38,0xE6,0xF0,
+0x2C,0x2F,0x23,0x8E,0xC1,0x03,0xBE,0x51,
+0x05,0xC3,0x59,0x80,0x29,0x38,0x8F,0x91,
+0x2C,0x3B,0x7F,0x00,0xBE,0x17,0x2E,0xB0,
+0x05,0x9F,0x34,0x33,0x28,0x07,0x4D,0xFA,
+0x2C,0x1F,0x35,0x99,0x32,0x33,0xFF,0xCC,
+0x05,0x5A,0xAF,0x69,0xA5,0x41,0xAC,0xAA,
+0x24,0x89,0x3B,0x74,0x44,0x35,0x54,0x07,
+0x05,0x32,0xC6,0x8F,0x7C,0xAB,0x65,0x12,
+0x2C,0x30,0x0B,0x4B,0x00,0x22,0x65,0xF2,
+0x05,0x49,0x98,0xE8,0x21,0xBB,0x7D,0x18,
+0x2C,0x15,0xED,0xD8,0x5D,0x5E,0x1D,0xFE,
+0x05,0xE1,0x4A,0xA9,0xB8,0x2C,0xBA,0xFC,
+0x2C,0x7C,0x34,0x5E,0x65,0x28,0xC3,0xE1,
+0x05,0xCB,0xDA,0xB9,0xE4,0x30,0x86,0x7D,
+0x24,0x38,0x36,0x10,0x33,0x67,0xBF,0x1B,
+0x05,0xB1,0x2D,0x74,0x1B,0x3E,0xAC,0xFD,
+0x24,0x3A,0xEF,0x57,0x30,0xBE,0x60,0xA3,
+0x05,0x6D,0xD9,0x35,0x2D,0x38,0xF0,0x3F,
+0x2C,0xA2,0x33,0xD9,0x15,0x95,0x78,0x4E,
+0x05,0xCA,0x52,0x64,0x2A,0x7E,0xE4,0x5F,
+0x27,0x47,0x24,0x24,0xA9,0xBA,0x0A,0xE7,
+0x29,0xC8,0xDB,0xA5,0x43,0xEE,0x57,0x95,
+0x05,0xFC,0x49,0x19,0x60,0xA7,0x2B,0x26,
+0x2C,0x9F,0xCB,0x1B,0x2B,0xF5,0x94,0x9C,
+0x05,0x70,0x9E,0x03,0x5B,0xCB,0x3C,0x19,
+0x27,0x69,0x1F,0x2D,0x89,0x3A,0x76,0x17,
+0x2D,0xCE,0x8D,0x69,0x36,0x74,0x70,0x33,
+0x05,0x7E,0x82,0xE0,0x03,0x1F,0xFB,0x3D,
+0x2C,0x7E,0x88,0x45,0xAC,0x1F,0x71,0x9F,
+0x05,0xF8,0x6A,0xFA,0x0F,0xF0,0x4B,0x44,
+0x27,0x23,0x6F,0x02,0x15,0x4D,0xB8,0x1C,
+0x25,0x15,0x1A,0x5D,0xAA,0x17,0xAA,0x4F,
+0x05,0xE7,0x73,0x5B,0x68,0xBC,0xC0,0x7C,
+0x24,0x55,0x50,0x08,0xA2,0xAB,0x3A,0xF6,
+0x05,0x24,0x83,0x99,0x1E,0x06,0x93,0x6F,
+0x2C,0x90,0x64,0xF7,0x81,0x8D,0xDE,0x08,
+0x05,0xD9,0x28,0xD0,0x23,0x28,0x15,0xBF,
+0x2C,0x58,0x13,0x61,0xB0,0x77,0x53,0x4B,
+0x05,0xC6,0xD4,0xF8,0x09,0x4F,0x37,0x6D,
+0x24,0x74,0xCC,0x73,0xE1,0x33,0x1D,0xF3,
+0x05,0x90,0xAD,0x73,0xBB,0xC4,0x44,0x99,
+0x2C,0x7A,0xD6,0x90,0xC3,0xB6,0xBE,0x1A,
+0x05,0x09,0x6E,0xA3,0x0C,0x7F,0x5F,0x9F,
+0x27,0xE4,0x25,0xCD,0xF6,0x4C,0x00,0x85,
+0x29,0x05,0xA2,0x2B,0xFB,0xBE,0xF6,0xE3,
+0x0F,0xE3,0xD8,0xD6,0xA2,0xB6,0x85,0x50,
+0x27,0xFC,0xCF,0xD5,0xB0,0x28,0xF2,0xF5,
+0x27,0x9C,0x8F,0xA0,0x7B,0xB8,0xC4,0x21,
+0x2F,0x4F,0x34,0x77,0xA7,0xBF,0x0C,0x2B,
+0x2F,0x3C,0xBC,0xB3,0x17,0xE7,0x9D,0x8D,
+0x07,0x78,0x36,0x02,0x9D,0xE0,0xAA,0x28,
+0x24,0xCC,0xA1,0x12,0x64,0x84,0x95,0x7A,
+0x0F,0xB2,0x05,0xF0,0xAC,0xBD,0xA8,0x9F,
+0x2F,0xCB,0x1D,0xCF,0x7F,0x65,0x47,0xF9,
+0x29,0x6B,0xCE,0xBB,0x84,0x45,0x46,0xA5,
+0x07,0x36,0x29,0xDB,0x97,0x26,0xF5,0x30,
+0x24,0xC2,0xF9,0xA4,0x82,0x9E,0xF5,0x18,
+0x0F,0x09,0xD9,0x25,0x8B,0x25,0xC7,0xA6,
+0x2F,0x5A,0xC9,0xB9,0xF6,0x0F,0x37,0xFE,
+0x2F,0xDB,0x98,0xFF,0xE9,0x97,0x11,0x50,
+0x2F,0xD4,0xE9,0xAE,0xFA,0xAA,0x03,0x02,
+0x27,0x68,0x95,0xAB,0x64,0xEA,0x06,0xA6,
+0x2F,0x27,0x1D,0xFD,0x25,0x45,0x67,0x6B,
+0x2F,0x9B,0xB7,0xD8,0xB3,0xBA,0xB6,0xF8,
+0x27,0x04,0x1F,0xF4,0x6D,0xAE,0xDF,0x70,
+0x2F,0xD0,0xC3,0x04,0x01,0x10,0x86,0x36,
+0x2F,0x75,0xC6,0x63,0xDE,0xA4,0xA0,0x95,
+0x27,0x76,0x37,0x46,0x4B,0xFD,0xC7,0x9C,
+0x2A,0x91,0x88,0x64,0x13,0x3C,0x8E,0xBF,
+0x07,0x05,0x73,0x68,0xD2,0x0C,0x48,0x3C,
+0x2F,0xDC,0xC0,0x2F,0x2F,0x57,0xE5,0x5C,
+0x21,0x7A,0xE4,0x73,0xBE,0xAA,0xEB,0x5F,
+0x07,0x6E,0x61,0x35,0xA7,0x26,0xF5,0x11,
+0x2F,0x70,0x6C,0x71,0x5A,0xEA,0xDB,0x81,
+0x27,0xE2,0x36,0xF4,0x52,0x07,0xF2,0xAD,
+0x22,0x26,0x6D,0xC0,0xBF,0x1C,0x08,0xE4,
+0x07,0xDB,0x10,0x1D,0xFA,0x12,0xDF,0xC4,
+0x2F,0x80,0x4E,0x06,0x67,0x68,0xA3,0xE6,
+0x27,0x37,0xE2,0xA3,0x82,0xC5,0xD4,0xE2,
+0x27,0x04,0x7E,0x40,0x9B,0x80,0x96,0x54,
+0x23,0xE0,0x7D,0x47,0x5F,0x6E,0x85,0x5D,
+0x07,0x7E,0x38,0xE3,0xEA,0x06,0xAC,0x02,
+0x2F,0xA8,0x96,0xB7,0xCE,0x4C,0x94,0xEA,
+0x2F,0x14,0x78,0x69,0xEA,0x11,0x04,0x02,
+0x27,0x10,0x04,0xDA,0x7D,0xA5,0x67,0x05,
+0x27,0xA8,0x88,0xF9,0x77,0x7B,0x1B,0x6D,
+0x0F,0xB2,0x8E,0x5A,0x7C,0xD2,0xAD,0x2D,
+0x2F,0xCE,0xD8,0xEA,0x23,0x8A,0x9D,0x62,
+0x27,0xED,0xEE,0x50,0x2C,0xF3,0xCA,0xC6,
+0x2F,0xF7,0x57,0x8B,0x87,0xAE,0x6A,0xC7,
+0x2F,0x77,0x40,0xD2,0xE7,0xC1,0xCE,0xDA,
+0x2F,0x1F,0x07,0x64,0x8D,0xD6,0xFC,0x5A,
+0x27,0x72,0xCC,0x2D,0x55,0xC9,0xBB,0x52,
+0x22,0xBC,0x37,0xB8,0xB8,0x0C,0xA7,0xDD,
+0x0F,0xC5,0xBD,0xD7,0xFC,0xE7,0x08,0xB9,
+0x2F,0xB8,0x47,0x71,0x0C,0x3B,0x24,0xC3,
+0x27,0xEA,0x58,0x3A,0xF4,0x6F,0xD4,0x78,
+0x2F,0x2A,0x63,0xF6,0xAC,0x45,0x9C,0xD0,
+0x2F,0xC2,0x08,0x0C,0xEF,0x81,0x78,0x4E,
+0x24,0x27,0xD9,0x3F,0xD3,0x3D,0x80,0xE8,
+0x0F,0x3C,0x78,0x81,0x03,0x19,0xA4,0x5E,
+0x27,0x2D,0x9A,0x6F,0x04,0x34,0x42,0x04,
+0x27,0x82,0x62,0x4B,0x02,0x51,0xA8,0xD1,
+0x27,0x3F,0xB1,0x83,0x74,0x51,0x76,0xBF,
+0x2F,0x11,0x65,0xB2,0x8D,0x93,0xE6,0x47,
+0x24,0x87,0x14,0xCC,0x2E,0xC0,0x4F,0x8F,
+0x07,0x43,0xBB,0x95,0xAF,0x71,0x2F,0x5D,
+0x0F,0xD0,0xA9,0x77,0x11,0xE0,0x16,0x33,
+0x27,0x84,0xB8,0x84,0xC9,0x6A,0xC7,0xE3,
+0x2F,0x19,0x3B,0xB6,0x21,0xA8,0x8F,0xD9,
+0x2F,0x0A,0x5C,0xF5,0x67,0x19,0x21,0x49,
+0x27,0xBC,0x11,0x7C,0xC3,0x41,0xF1,0xD3,
+0x2F,0x2C,0x38,0x54,0xC6,0xBE,0x3C,0xA1,
+0x21,0x98,0xA0,0xAE,0x01,0x6A,0x51,0xBA,
+0x0F,0xFE,0x04,0x6B,0xDB,0x94,0x17,0x31,
+0x0F,0x76,0x10,0x00,0x92,0x11,0x0A,0xE5,
+0x0F,0xB0,0x04,0xC5,0x9A,0x42,0xD1,0xD4,
+0x27,0x90,0xCA,0x42,0x2A,0xC5,0x1C,0xDD,
+0x27,0xDE,0x9B,0x4F,0xB0,0x71,0x82,0x5D,
+0x2A,0x9A,0xD8,0xA6,0x88,0x10,0x46,0xDC,
+0x0F,0x0F,0x80,0x59,0xD4,0x70,0x42,0xF6,
+0x2F,0xA2,0x9A,0x6A,0xFA,0xBD,0xCD,0x1E,
+0x25,0xF1,0xFD,0x1D,0x8A,0x07,0xEC,0xD0,
+0x0F,0x05,0x5A,0x4F,0x02,0x80,0x35,0x5D,
+0x27,0x35,0x5E,0x71,0x9F,0x46,0xB0,0x81,
+0x2F,0x5D,0x24,0x0B,0x26,0x8F,0xE3,0x92,
+0x2E,0xED,0x74,0x57,0xEB,0xCA,0x73,0xF9,
+0x0F,0x2E,0xD0,0x34,0x09,0x13,0xD4,0x0D,
+0x07,0xA3,0xA5,0x09,0xF0,0x55,0x82,0xB9,
+0x07,0x75,0x0E,0xCD,0xAB,0x72,0xE0,0xCE,
+0x0F,0x0B,0xD7,0x5A,0x3B,0x09,0x5E,0xC4,
+0x07,0xF6,0x7C,0x02,0x14,0xA1,0xE0,0xDA,
+0x2F,0x51,0xDC,0xA9,0x12,0x1F,0x28,0xEB,
+0x21,0x88,0xC0,0xDC,0xC8,0x24,0xFB,0x35,
+0x0F,0x15,0xAA,0x41,0x07,0x39,0x58,0x45,
+0x2F,0xDF,0xFC,0x09,0xC5,0x11,0x54,0xFD,
+0x25,0x1A,0x28,0xD8,0x06,0x2D,0x2B,0x90,
+0x0F,0x90,0x97,0xCD,0x72,0x2B,0xD7,0xB1,
+0x27,0xE8,0x36,0xBC,0x18,0x8F,0x98,0x54,
+0x21,0x20,0xEE,0x55,0x6D,0xAF,0x15,0x9C,
+0x07,0xAF,0x5D,0xF0,0x19,0xFF,0xD6,0x1C,
+0x2F,0xD5,0x71,0x92,0x61,0xB4,0x7B,0xB3,
+0x2D,0x22,0x60,0xA0,0x62,0xC9,0x7D,0x1E,
+0x07,0x31,0x1C,0x36,0xD4,0x0E,0x7A,0xAE,
+0x27,0xFF,0x43,0x95,0xC2,0x4B,0xF4,0x70,
+0x2F,0x88,0x59,0xCE,0xCF,0x76,0x96,0xF6,
+0x22,0xBC,0xBB,0xC8,0x91,0xCF,0xBB,0x3E,
+0x07,0x93,0xE5,0x9B,0x66,0xFB,0x01,0xF6,
+0x0F,0x5B,0x09,0xAC,0x08,0x40,0xE8,0x0C,
+0x27,0xF8,0x8E,0x2D,0x1C,0x5C,0xFB,0x39,
+0x2F,0x05,0x32,0x17,0xD7,0xB7,0x32,0x09,
+0x2F,0x46,0xD5,0x86,0x62,0xED,0xD5,0xC2,
+0x2F,0xDD,0x0C,0x3C,0x51,0xC6,0xC3,0xAD,
+0x2F,0x96,0x08,0xBF,0xEE,0x36,0x50,0xEC,
+0x27,0x02,0xB2,0x02,0x9F,0x2B,0x6A,0xFD,
+0x2F,0x63,0x78,0xD8,0xB1,0x03,0xD5,0x33,
+0x2F,0x27,0xF9,0x9E,0x2D,0x86,0xB5,0x0D,
+0x0F,0x27,0x14,0xD4,0x5B,0x3B,0x77,0xF6,
+0x2F,0x3C,0x7A,0xAF,0x86,0xB7,0x8D,0xF3,
+0x21,0x80,0xD2,0xD7,0xD7,0xFA,0x07,0x96,
+0x0F,0x66,0xB4,0x2C,0x55,0x4B,0x9B,0x58,
+0x2C,0x02,0xEB,0xAA,0x8D,0xE6,0x4A,0x9A,
+0x07,0x2E,0x28,0xB5,0x8A,0x57,0x37,0x1F,
+0x2F,0xD8,0x05,0x37,0xB0,0x47,0x29,0x7B,
+0x29,0x79,0x48,0xE0,0x70,0x2A,0xDB,0xFA,
+0x0F,0x70,0xC5,0xD4,0xB9,0xD5,0x81,0x9D,
+0x2F,0x36,0x8E,0xCC,0x01,0xA1,0xC1,0x00,
+0x27,0xB3,0x89,0xFE,0x08,0xF2,0x69,0x89,
+0x27,0xAD,0x1F,0xA9,0xF4,0x16,0x30,0xCB,
+0x2F,0x09,0xCD,0x4B,0x16,0x4B,0x68,0x2B,
+0x2F,0xE5,0xE2,0x3A,0x71,0x45,0x75,0xB4,
+0x27,0x64,0x95,0x15,0x0A,0xC6,0x08,0x00,
+0x2F,0x84,0xB9,0x98,0x03,0xF6,0xC0,0x38,
+0x2B,0x27,0xC0,0x65,0x5C,0xA5,0x44,0x3B,
+0x07,0x9D,0x08,0x52,0xF0,0x7E,0xC7,0xAA,
+0x27,0x3C,0x28,0x5D,0x6E,0x2E,0xF5,0xC1,
+0x27,0x06,0x45,0x03,0xBD,0x37,0x55,0x17,
+0x2F,0x64,0x1B,0xE7,0x68,0xEA,0x33,0xFA,
+0x2B,0x58,0x2A,0x1F,0x66,0xD5,0x39,0x1E,
+0x0F,0x72,0x37,0x58,0xA4,0x42,0xE4,0x80,
+0x2F,0x2A,0x5D,0x29,0x1A,0x9C,0x25,0xA8,
+0x29,0x50,0x1B,0x47,0xB2,0x2E,0x0C,0xD8,
+0x0F,0x0D,0x4C,0x06,0x66,0xC4,0xC8,0x66,
+0x2F,0x9E,0x74,0x5A,0xA0,0xFB,0x9B,0xCE,
+0x27,0x76,0x38,0x8F,0x9F,0x29,0x43,0xE5,
+0x27,0x07,0xD0,0xC9,0x45,0xC7,0xB0,0x39,
+0x2F,0x05,0x67,0xA7,0xD2,0xC7,0x9B,0xDE,
+0x27,0xFC,0xB4,0x95,0x22,0x3C,0x42,0x47,
+0x2F,0xA6,0x81,0x35,0xA9,0xA9,0x58,0xA5,
+0x2F,0x75,0x70,0xF8,0x85,0x29,0xE5,0xC4,
+0x2F,0x96,0xFD,0x7E,0x09,0xCE,0x6E,0x4D,
+0x24,0xC8,0x06,0x8D,0x82,0xD0,0x3F,0x4D,
+0x0F,0xF0,0x11,0xE4,0xD1,0x65,0xC1,0xD6,
+0x2F,0xC1,0x9C,0x5E,0xC1,0x87,0xA5,0x58,
+0x27,0x31,0x29,0x45,0x44,0x0B,0x9D,0xF3,
+0x26,0x8A,0x6E,0xC0,0x5D,0x85,0xF5,0x85,
+0x07,0x2B,0x8F,0x65,0x92,0xB3,0xF8,0x7D,
+0x2F,0x2B,0x04,0xB1,0xB9,0xEE,0x3C,0x62,
+0x25,0x88,0xB0,0xA4,0x68,0x12,0x1A,0x88,
+0x0F,0xFB,0xB1,0xDD,0xD3,0xFF,0x6A,0x08,
+0x07,0xD3,0xA8,0x13,0x65,0x47,0x78,0x61,
+0x0F,0xC1,0x56,0x21,0x35,0x5B,0xC3,0x81,
+0x2C,0x84,0x0A,0x37,0x9C,0xCA,0x24,0x23,
+0x07,0xC6,0x7E,0x5D,0xAD,0xE8,0x80,0x68,
+0x07,0xBD,0xCD,0x67,0xA2,0x9E,0xB6,0xE9,
+0x07,0x92,0xDA,0x4B,0xD7,0xF5,0xDB,0x1B,
+0x2F,0x40,0x99,0x62,0xEE,0x60,0x1D,0xB5,
+0x27,0x35,0x4C,0x89,0xB3,0xFC,0x97,0x15,
+0x2F,0xB8,0x63,0x9E,0xDF,0x45,0x6D,0x39,
+0x2F,0x35,0x93,0xAE,0x1F,0x5F,0xC3,0x2D,
+0x2F,0x46,0xD9,0xD7,0x0F,0xAA,0x55,0xE9,
+0x2F,0x38,0xE2,0x67,0x82,0xB8,0x2C,0x8E,
+0x27,0x92,0x78,0x98,0xB8,0xF0,0xAD,0x2D,
+0x2F,0x5C,0xA4,0x53,0xEE,0xAC,0x0F,0xE8,
+0x27,0x7B,0x1A,0x18,0xBB,0xFA,0xB0,0x7C,
+0x27,0x22,0x4C,0xBC,0x97,0x71,0xB2,0x59,
+0x2F,0x3F,0xC1,0x89,0xAD,0xC6,0xA4,0x33,
+0x27,0xA4,0xCC,0x61,0xFF,0x3B,0x58,0x02,
+0x2F,0x31,0xFB,0xAB,0x4E,0xE8,0x76,0xA7,
+0x27,0xF3,0x46,0xC9,0xC3,0x7F,0xBA,0x95,
+0x27,0xA7,0x52,0xD6,0xB3,0x75,0xC1,0xAB,
+0x27,0xC9,0x69,0x06,0x3D,0x0B,0xDF,0xE3,
+0x27,0x05,0x78,0x6F,0xCA,0x6B,0x65,0xC7,
+0x2F,0xE7,0xEF,0x61,0x45,0xBA,0xBD,0x8B,
+0x27,0x3D,0xF1,0x4E,0x6B,0xFB,0xA5,0xF5,
+0x27,0x01,0xDD,0x9F,0x30,0x64,0xB7,0xB3,
+0x07,0x84,0xDD,0x92,0xA9,0x76,0xE8,0x86,
+0x07,0x5E,0xB8,0xCD,0x7A,0x02,0x3C,0x04,
+0x2F,0x41,0x4A,0xF4,0xA6,0xFF,0xEE,0xCF,
+0x27,0xF0,0x40,0x79,0x46,0xC4,0xDE,0x90,
+0x2F,0x8D,0x89,0x71,0x84,0x8F,0xA7,0xC5,
+0x2F,0xED,0x03,0x81,0x7A,0x30,0xC4,0x25,
+0x27,0xDE,0x3F,0x2D,0x9E,0xEA,0x6A,0x57,
+0x2F,0x10,0x8B,0x31,0x05,0x14,0x61,0x2B,
+0x2F,0xCD,0x61,0x1C,0x7B,0x19,0xF1,0x3E,
+0x2F,0xA9,0xDB,0x27,0x22,0xC3,0x05,0x86,
+0x27,0xBA,0xC2,0x85,0x3C,0xB3,0x14,0xF1,
+0x2F,0x8C,0x09,0xC2,0xF2,0xD9,0x5E,0x00,
+0x2F,0xB8,0x94,0x8F,0xF3,0x2B,0x1F,0xBB,
+0x23,0x11,0xBF,0xF2,0xF3,0xEF,0xE8,0x34,
+0x07,0x31,0xD7,0xB9,0x61,0x5E,0x52,0x1A,
+0x27,0x90,0x76,0xB9,0x13,0x03,0x39,0xDB,
+0x2F,0xC5,0xD7,0x2C,0x62,0xB6,0x4D,0xAE,
+0x27,0xBA,0x48,0x85,0x0E,0xDD,0x87,0xC0,
+0x2F,0x7E,0xDB,0xD3,0xE7,0xD2,0xF2,0x58,
+0x24,0xA5,0xCD,0x0A,0xFA,0x7D,0xF5,0x50,
+0x07,0x6C,0xE7,0xB4,0xB9,0xEE,0x0F,0x59,
+0x27,0x18,0x47,0x75,0xCC,0x8C,0x0E,0xA5,
+0x2F,0xF4,0x57,0x09,0x8D,0xDD,0x46,0x4A,
+0x2F,0x2F,0x70,0xA6,0x64,0xE8,0x95,0xDC,
+0x2F,0x2F,0xC6,0x86,0x45,0xA9,0xBA,0x8B,
+0x27,0xF1,0xB1,0x5F,0xD9,0x14,0x3D,0x11,
+0x21,0xA7,0x4D,0xAD,0xA9,0x0B,0x72,0xC4,
+0x0F,0x47,0x93,0xF5,0x36,0x58,0xFC,0x4F,
+0x07,0xF9,0xB1,0x19,0x93,0x18,0xDD,0x0E,
+0x2C,0x83,0x9B,0x1E,0x76,0xE6,0x0C,0x87,
+0x0F,0x4E,0x89,0xFF,0xEC,0xB0,0x6E,0x82,
+0x27,0x0E,0xDC,0x99,0x64,0xE3,0x10,0x67,
+0x27,0xB0,0x2A,0xD8,0x53,0xFB,0x11,0xA4,
+0x2F,0x69,0x57,0x0D,0xD7,0xE6,0x9C,0x5C,
+0x2F,0xED,0x6A,0xBC,0xB6,0x8A,0x34,0xD0,
+0x2F,0x0B,0x10,0x29,0x7F,0x3B,0x7E,0x45,
+0x21,0xC7,0x30,0xC5,0x63,0x7D,0xAD,0x62,
+0x07,0x9A,0xB0,0x92,0x5C,0x60,0xE2,0x3C,
+0x0F,0x2F,0xF8,0xC6,0x07,0x75,0xAD,0x49,
+0x2F,0x59,0x42,0xF5,0x79,0xD8,0xCF,0x1D,
+0x27,0x6F,0xB1,0x9F,0x3D,0x17,0x61,0x24,
+0x27,0xB5,0xC1,0x8B,0x7E,0xCE,0xF9,0x5B,
+0x2F,0xDD,0x63,0x9F,0xDF,0x06,0x15,0x5A,
+0x2F,0x42,0x98,0x91,0xCF,0x53,0xE3,0x89,
+0x2F,0xD4,0x58,0x8E,0x78,0x6E,0x63,0xE4,
+0x2F,0x47,0x90,0xC8,0x3B,0xA3,0x4E,0x37,
+0x27,0x48,0x29,0x50,0xA1,0x91,0xB4,0xE5,
+0x27,0x44,0x9A,0x11,0x9B,0x9F,0x21,0x18,
+0x27,0x85,0x61,0xAE,0x8F,0xC0,0x75,0xF0,
+0x27,0x73,0x5F,0xA2,0xEB,0x3B,0xC7,0x9C,
+0x2F,0xEB,0x1B,0x48,0x0E,0x0D,0xCA,0x4A,
+0x0F,0xBA,0x8A,0x86,0x32,0x11,0x92,0x67,
+0x0F,0xA2,0x1F,0x43,0xBD,0x80,0xF6,0x1E,
+0x27,0x91,0x23,0x64,0x66,0x60,0x4D,0x15,
+0x25,0x23,0x33,0x75,0x42,0x4E,0x70,0xF9,
+0x07,0x2E,0x83,0xF1,0x91,0xFB,0x35,0xEE,
+0x07,0xBA,0xCA,0xCA,0xD4,0xC5,0x7F,0x8D,
+0x27,0x0C,0xD5,0xDA,0xAE,0x0F,0xC2,0x08,
+0x2D,0xAC,0xFB,0xAA,0x7F,0x81,0x9D,0xD5,
+0x0F,0xA2,0x60,0x0D,0x5F,0xAC,0xF8,0x3E,
+0x07,0x79,0x2C,0x05,0x80,0x9B,0x69,0xCD,
+0x27,0x9D,0x33,0xC0,0x1F,0xF8,0x86,0xEC,
+0x27,0xD5,0x16,0xAE,0xB7,0x94,0xF9,0x28,
+0x26,0x8D,0x25,0x5C,0xB3,0x03,0x3F,0x46,
+0x0F,0x69,0xEF,0xDF,0x38,0xA8,0xC5,0xB7,
+0x27,0x9D,0x90,0x2D,0xB8,0xD4,0xE4,0x4C,
+0x2D,0x45,0x4F,0x16,0x0C,0xFE,0x6E,0xD6,
+0x07,0x85,0x6D,0x78,0x6F,0x30,0xD2,0xA4,
+0x2F,0xFE,0x19,0xBF,0xA1,0xED,0x38,0xD1,
+0x2F,0x2E,0x08,0x47,0x7A,0x6A,0x55,0xF4,
+0x2F,0xC8,0xC2,0xD4,0x3F,0x33,0x48,0x1A,
+0x27,0x0E,0x4A,0x7F,0x0A,0xD6,0xAC,0xA6,
+0x27,0x30,0xE7,0xF9,0x6B,0x05,0x55,0x07,
+0x27,0x06,0x5F,0xDA,0x56,0x71,0xF3,0x43,
+0x2E,0x1E,0x9B,0xF8,0x1B,0x1C,0xD2,0xB5,
+0x0F,0x48,0x1F,0x4C,0xF3,0x56,0xF5,0x8E,
+0x2F,0x0E,0x90,0x29,0xBF,0x3B,0x9F,0x47,
+0x27,0xA3,0x52,0x29,0x90,0x62,0xEB,0xA7,
+0x2F,0x4A,0x63,0xC1,0x22,0x8D,0x08,0xD3,
+0x2F,0x97,0xA0,0xB2,0x57,0xBA,0x57,0xEC,
+0x27,0x69,0x7A,0x08,0x5D,0x81,0xD0,0x18,
+0x27,0x9E,0x95,0xA4,0x5E,0x40,0x5D,0xC3,
+0x2F,0xE0,0xB1,0x4E,0x49,0xFE,0x80,0x38,
+0x2F,0xEB,0x78,0x0C,0x67,0xB1,0xD1,0x5F,
+0x2F,0xD3,0x7A,0xAA,0x3F,0x37,0xF8,0xC0,
+0x2F,0x84,0x46,0x36,0x7A,0x10,0xBF,0x47,
+0x27,0x54,0xF7,0x65,0x9F,0x51,0x31,0x3C,
+0x2F,0x1C,0x18,0x61,0xEE,0x0C,0x67,0xA1,
+0x27,0x2A,0xC2,0x99,0xE6,0xD2,0xE3,0x56,
+0x2F,0xA2,0xA0,0xDD,0xF3,0xB7,0x25,0x6F,
+0x2F,0xBC,0xCC,0xEB,0xFE,0x5B,0x29,0xAB,
+0x2F,0x87,0xA6,0xD4,0xBF,0x28,0x1D,0xC5,
+0x2F,0x78,0xE6,0xA8,0x7B,0xF4,0x62,0x40,
+0x27,0x0D,0xA5,0x75,0xD9,0xC3,0x90,0x2F,
+0x2F,0xE9,0xB9,0x66,0x31,0x6D,0xCB,0x12,
+0x27,0x0E,0xB8,0x98,0x0B,0xF3,0xEA,0x8B,
+0x27,0x2C,0x6A,0xB3,0x9C,0x9F,0x6F,0x47,
+0x2F,0x55,0x46,0xB4,0x8B,0x50,0x6F,0x05,
+0x2F,0xEF,0x7C,0xBE,0x2A,0x2A,0x6E,0xCC,
+0x2F,0x11,0x0F,0x39,0x38,0xD8,0xF4,0x1A,
+0x27,0xEF,0xC3,0xAC,0xC2,0xCD,0x47,0x78,
+0x27,0x0A,0xE3,0x19,0x42,0x07,0x33,0xCF,
+0x2F,0xA2,0x7B,0xDE,0x40,0xE7,0x3B,0xFA,
+0x2F,0x90,0x0A,0x32,0xC6,0x5B,0x8D,0x34,
+0x27,0xCB,0xC0,0x24,0x6B,0xC7,0xF7,0x56,
+0x27,0x77,0x5C,0x89,0x75,0x6F,0x47,0xF1,
+0x27,0x9E,0x69,0x59,0x06,0x4F,0x96,0x27,
+0x27,0xDD,0xDA,0xDF,0xEA,0xD2,0xEA,0x3B,
+0x0F,0x11,0x74,0xD6,0x32,0xA5,0x48,0xB8,
+0x0F,0x49,0x30,0x60,0x26,0xD6,0xB6,0xDC,
+0x07,0xC9,0xD3,0xFB,0xA2,0x1B,0x5D,0xA5,
+0x27,0x1B,0x05,0x82,0x9D,0xFE,0x33,0xEC,
+0x21,0x28,0x5A,0x50,0x61,0x4A,0x13,0x3C,
+0x0F,0x62,0x64,0x2F,0x9E,0x39,0x8B,0xF3,
+0x2F,0xA7,0x65,0xD7,0xFA,0x4C,0xE8,0x7A,
+0x25,0xA8,0x34,0x79,0xA1,0xCB,0x7C,0x61,
+0x0F,0x52,0xE0,0x2A,0x5A,0x1C,0x2C,0xBA,
+0x27,0x0A,0xB6,0xCC,0x42,0x1A,0x5A,0x34,
+0x2D,0xD2,0x46,0xFF,0x69,0x45,0x62,0xE9,
+0x07,0x5E,0x52,0x3A,0xB8,0x73,0x47,0xDF,
+0x27,0x30,0x96,0x51,0x80,0x42,0x70,0x88,
+0x27,0x4D,0x45,0x99,0x24,0x28,0xF2,0x59,
+0x2F,0xE9,0x11,0x25,0xAB,0x5E,0x6D,0x1E,
+0x27,0xC5,0x4A,0x41,0x91,0xD9,0x73,0x4C,
+0x27,0xFF,0x78,0xBC,0x80,0xD0,0x12,0xF0,
+0x27,0x14,0xA3,0x12,0x80,0x8D,0x48,0xE3,
+0x2A,0x96,0x3B,0x52,0xFB,0xEC,0x46,0x7F,
+0x07,0x1E,0xB3,0x8D,0x53,0xF8,0x5E,0xA9,
+0x2F,0x96,0xDB,0x3D,0x95,0x1B,0xB1,0x48,
+0x2F,0x23,0xE5,0xC5,0xDF,0x87,0xD0,0xDE,
+0x27,0x3E,0x44,0x17,0x89,0x5B,0x3F,0x65,
+0x2F,0x24,0xD3,0x0D,0xB3,0x41,0x1E,0x38,
+0x27,0xB4,0x3A,0xE0,0xCC,0xED,0xB2,0x2A,
+0x27,0x84,0x51,0x7F,0x6D,0x15,0xDA,0x8C,
+0x27,0x8F,0x01,0x9B,0x77,0x3A,0x9A,0xD9,
+0x27,0xA0,0x5C,0x3C,0x8C,0x80,0xBE,0x42,
+0x2F,0x35,0xF6,0xA9,0xB1,0x21,0xAE,0xD5,
+0x2F,0x8F,0x4B,0xF0,0xC2,0x3B,0x76,0x84,
+0x27,0x0A,0x19,0x11,0x23,0xAE,0x9A,0x0C,
+0x2F,0xBE,0x03,0x93,0x8E,0x4A,0x9E,0x64,
+0x27,0xCA,0x21,0x45,0xBF,0x3E,0x84,0x20,
+0x25,0x3C,0x4D,0x8D,0xE7,0x9D,0xFC,0x9E,
+0x0F,0x74,0xD2,0xFE,0x2E,0x18,0x09,0x2F,
+0x2F,0x22,0x45,0x9C,0x21,0xD1,0x93,0xB7,
+0x2F,0xEF,0x88,0x53,0x0B,0x96,0x43,0x45,
+0x2F,0x55,0x26,0x66,0x6A,0x4A,0xFB,0x4F,
+0x2F,0x5F,0x37,0x6A,0x6F,0xAE,0x54,0x80,
+0x27,0xF6,0xB3,0x87,0xC5,0xF5,0xC5,0x0A,
+0x2F,0x2F,0x80,0x7B,0x2E,0x0A,0xF7,0x09,
+0x22,0x34,0x37,0xE4,0xBD,0x4D,0x07,0xA0,
+0x07,0xDC,0x5D,0x59,0xD5,0xA8,0x59,0x63,
+0x2F,0x09,0x05,0x9A,0xCA,0x39,0x1F,0xFB,
+0x29,0x0B,0x60,0x2C,0x01,0x80,0x39,0x96,
+0x07,0x38,0xF6,0xB6,0x2A,0xD2,0xC5,0x06,
+0x24,0x28,0xD5,0x23,0x6B,0xC2,0x53,0x3B,
+0x0F,0xE0,0x21,0x17,0x0B,0x36,0x42,0x34,
+0x2F,0x90,0x67,0x29,0xD2,0xC3,0x06,0x96,
+0x29,0x75,0xCA,0x96,0x6E,0xCA,0x12,0x38,
+0x0F,0x69,0x0B,0x58,0x97,0xA0,0x24,0x51,
+0x2F,0x55,0x3A,0x88,0x15,0x20,0x13,0x0A,
+0x27,0x7B,0x52,0xD9,0x7D,0xF4,0xE7,0x31,
+0x26,0x81,0x2D,0x00,0x6F,0x0D,0x65,0xB3,
+0x0F,0x22,0x46,0x57,0xF9,0xE9,0xD5,0x85,
+0x24,0xFA,0x8C,0x5E,0xDB,0xA3,0xC2,0x52,
+0x0F,0x27,0x99,0xA4,0x9A,0x53,0xA1,0xE2,
+0x27,0xC3,0xB1,0x3C,0x26,0x67,0x17,0xCE,
+0x27,0x8E,0xEA,0xF0,0x12,0x34,0xF4,0xD1,
+0x27,0x7D,0x27,0x12,0x4C,0x25,0x4D,0x91,
+0x27,0x83,0x97,0x9A,0x27,0x29,0x20,0xCD,
+0x27,0xC9,0x33,0x26,0x63,0xD8,0x96,0xCA,
+0x27,0x87,0xCF,0xBE,0x0F,0x8A,0xC5,0x89,
+0x27,0xAD,0x6D,0x54,0x09,0x81,0xE6,0xA3,
+0x27,0x1E,0x1C,0x24,0x49,0x52,0x89,0xE2,
+0x27,0x5E,0x1C,0xD2,0xAA,0xAF,0x7A,0xA3,
+0x21,0x1A,0x81,0x00,0x5C,0xBE,0xE4,0xED,
+0x0F,0x7A,0x75,0xF3,0x9C,0xC0,0x6A,0x6E,
+0x2F,0x9D,0xF3,0x53,0xB6,0x08,0xEA,0x01,
+0x2F,0x93,0x97,0xFF,0xE6,0x10,0x37,0x37,
+0x26,0x4E,0x1D,0x1D,0x61,0xAC,0x42,0x25,
+0x0F,0x3E,0xB2,0xFA,0x4B,0xDD,0xBF,0x19,
+0x27,0x1F,0x10,0x40,0x0A,0xF1,0x43,0x1C,
+0x27,0x9F,0x0C,0x53,0xE3,0x15,0x76,0x2E,
+0x27,0x5C,0x00,0xE8,0x3E,0xD5,0x40,0xE0,
+0x27,0xBC,0x56,0x57,0xF2,0xDA,0x5B,0x19,
+0x27,0xE8,0x25,0xBC,0xCF,0x90,0x2E,0xC0,
+0x2F,0x7D,0xF3,0x13,0xD3,0x46,0xB4,0x84,
+0x2F,0x2B,0x7E,0x71,0x83,0x7A,0x37,0xE7,
+0x27,0xE6,0x49,0x6D,0x0E,0xFB,0x04,0xC7,
+0x2F,0xB5,0xBD,0xD8,0xC7,0x08,0x4F,0xA0,
+0x27,0xD3,0x54,0xF8,0x98,0x43,0x87,0xE2,
+0x2F,0xEA,0x21,0x57,0xC9,0xD0,0x3A,0xFD,
+0x27,0x67,0x8C,0x65,0xBC,0x12,0x58,0xC8,
+0x2F,0x86,0x71,0x6C,0xDD,0x62,0x23,0x9F,
+0x27,0xBC,0x46,0x6E,0x23,0xAB,0x11,0x40,
+0x27,0x5F,0x5A,0x54,0xD5,0xC2,0x14,0xAA,
+0x2F,0x35,0xCC,0x5A,0x79,0x01,0x9F,0x56,
+0x2F,0xB3,0x1B,0x3A,0x66,0x9C,0x1F,0x76,
+0x2F,0xE0,0x5C,0xF7,0x4B,0x0E,0xD6,0x49,
+0x2F,0xF5,0xAA,0xBA,0xC2,0xA2,0xDE,0x3B,
+0x27,0xAE,0x57,0x24,0x03,0x02,0x9C,0x08,
+0x2F,0x24,0x07,0xB1,0xCA,0x20,0x65,0x69,
+0x21,0xC6,0x9E,0xAC,0x7E,0x15,0x6A,0xE0,
+0x0F,0x98,0x90,0xA4,0xBF,0x38,0x07,0x83,
+0x2F,0x19,0x46,0xE5,0xD2,0x05,0x10,0x0B,
+0x2F,0xBD,0x46,0x16,0xB6,0x5D,0xB3,0x6B,
+0x2A,0x0F,0x06,0x67,0x90,0x37,0x13,0x3C,
+0x0F,0xB7,0x0D,0x80,0xC3,0xBA,0x89,0x17,
+0x2F,0x7A,0xA4,0x70,0x41,0x37,0xEB,0x6B,
+0x27,0xC2,0x8D,0xF5,0x2B,0xAE,0x36,0x8D,
+0x27,0x2F,0x71,0x29,0xA2,0x38,0x8B,0x5B,
+0x27,0xAC,0x2D,0x85,0x69,0x3D,0x0F,0x99,
+0x27,0x3E,0x38,0x34,0xEE,0x2A,0x89,0xFE,
+0x2F,0xB4,0xAF,0x91,0x86,0x91,0xA4,0x1B,
+0x2F,0xDE,0xCC,0xB2,0xB2,0x53,0x7D,0xF2,
+0x2F,0xBA,0x0D,0x3C,0x94,0xFD,0x77,0x30,
+0x24,0x96,0x8A,0x4D,0x02,0x8F,0xB1,0xED,
+0x07,0x66,0xEB,0x75,0xFA,0xEF,0x11,0x7C,
+0x27,0x84,0x27,0xC0,0xFA,0x75,0xB4,0xA0,
+0x2F,0x37,0x34,0x78,0x31,0x7A,0x70,0x39,
+0x2F,0xBC,0xCE,0xA1,0x64,0xC1,0x5B,0x99,
+0x2B,0x59,0xCF,0x3E,0x3E,0x58,0xDE,0xF7,
+0x0F,0x9B,0x72,0x31,0xB3,0xF2,0x4C,0xA4,
+0x07,0x78,0x7B,0xBD,0x23,0x61,0x7D,0xAB,
+0x07,0x9D,0x25,0xD2,0xF9,0xE4,0xE9,0xB0,
+0x07,0x80,0xC3,0xF5,0xE2,0xAD,0xD9,0x31,
+0x27,0xF4,0x91,0xDB,0x90,0xF4,0x5C,0xD4,
+0x27,0x6F,0x57,0xF0,0x9E,0x91,0x39,0xE2,
+0x2F,0x5F,0x44,0x2D,0x94,0x05,0x87,0x26,
+0x2B,0xBE,0x0A,0x50,0xB0,0x6B,0xDF,0x54,
+0x0F,0xBD,0xA3,0x00,0xEF,0x14,0x5E,0xF6,
+0x07,0x02,0xCE,0x39,0xFF,0x65,0x62,0x60,
+0x2F,0xFF,0xC7,0x35,0xA4,0x64,0x1F,0xE4,
+0x2F,0xC5,0xC9,0x12,0xFA,0x4F,0xE0,0x10,
+0x2F,0xEB,0xD9,0xAD,0xFF,0x0D,0x01,0xE5,
+0x27,0xFF,0x08,0x87,0x4C,0x92,0x87,0xB0,
+0x07,0x4C,0x8D,0x49,0x10,0x87,0x9C,0x5F,
+0x0F,0xFB,0x7B,0x92,0x3B,0x5F,0x69,0x37,
+0x24,0x8A,0xAF,0x9C,0xAB,0xC3,0xAF,0x46,
+0x07,0x3F,0x93,0xE2,0xF6,0x41,0xF5,0xFA,
+0x0F,0x84,0x09,0xCA,0x00,0x26,0xA1,0x87,
+0x0F,0x2C,0xA9,0xC5,0x72,0xB4,0xC3,0x41,
+0x07,0x96,0xE6,0xF7,0xD8,0x88,0xA2,0x39,
+0x07,0xB7,0xD5,0xAE,0x45,0x89,0x8B,0x4C,
+0x24,0x4C,0xBD,0x94,0x0A,0xE0,0xFA,0x7E,
+0x07,0x4C,0xC5,0x72,0xE3,0x33,0x36,0x8C,
+0x2F,0x43,0x71,0x63,0xBC,0x16,0xBD,0x34,
+0x21,0x1B,0xD2,0xC0,0x77,0xFF,0x7A,0x16,
+0x0F,0x10,0xEB,0xB1,0x0B,0xD9,0x87,0x66,
+0x2F,0x3D,0x60,0xE2,0xA8,0xD6,0xDE,0x0D,
+0x29,0xFD,0x78,0xC7,0xF9,0x48,0x78,0x2C,
+0x07,0xD7,0x60,0x6E,0xA3,0x0E,0x45,0xC4,
+0x27,0xE4,0x6A,0xAB,0xF2,0xDC,0xCD,0xFA,
+0x21,0xCE,0x6A,0xF7,0xE9,0xFB,0x01,0xD0,
+0x07,0xAF,0x7F,0xBD,0xB8,0x91,0x6C,0xB0,
+0x0F,0xE3,0xBD,0x7A,0x10,0xC8,0x2F,0x5F,
+0x27,0xEF,0x38,0x9B,0x99,0x5D,0x16,0x83,
+0x2D,0x3C,0xBC,0x51,0x29,0x55,0x9F,0x5D,
+0x07,0x54,0xB5,0x7A,0xA1,0xC6,0x49,0x53,
+0x27,0xF8,0x4A,0x51,0x3D,0x88,0xE8,0xB6,
+0x2F,0x64,0x9E,0x80,0x4C,0xCF,0x1E,0x07,
+0x2F,0x3E,0xD9,0x23,0x5F,0x6B,0x77,0x5C,
+0x2F,0xE4,0xEB,0x78,0xC7,0xEB,0x90,0xD6,
+0x27,0xD7,0xB1,0xED,0x76,0x67,0x92,0x23,
+0x27,0xE3,0xF4,0x43,0xA7,0xFF,0xAA,0x42,
+0x2F,0x0B,0xB3,0x8E,0xE3,0x3E,0x6C,0x89,
+0x2F,0x16,0xB1,0x71,0xF7,0xAB,0xA0,0x31,
+0x2F,0x91,0x28,0xBF,0x8D,0x11,0xA8,0x6E,
+0x21,0x54,0x7B,0x71,0x22,0xB6,0xBD,0x17,
+0x07,0x23,0xA1,0xEC,0x8D,0xA5,0x4D,0x9E,
+0x2F,0x03,0x07,0xDC,0x1F,0x2E,0xB9,0xD5,
+0x2F,0x04,0xE3,0x5F,0x5A,0xDB,0x66,0x38,
+0x2F,0x1C,0x84,0x1C,0x8A,0x78,0x3A,0xA2,
+0x27,0x52,0xFE,0x51,0x65,0xD0,0xFE,0x37,
+0x07,0xDA,0x3F,0x58,0xBD,0xA1,0x17,0xB6,
+0x2C,0x76,0x6D,0x9B,0x02,0xB7,0x04,0x79,
+0x0F,0xEA,0xC6,0x7C,0x7A,0x4D,0x56,0x25,
+0x2C,0x91,0xA1,0x7D,0x40,0xB0,0xE9,0x0C,
+0x0F,0x15,0xF9,0x7A,0xB0,0xBE,0xAE,0x05,
+0x24,0x2D,0xB0,0x4E,0x87,0x88,0x69,0xC3,
+0x0F,0x9E,0x52,0x6E,0x90,0x5A,0x26,0x87,
+0x27,0x5C,0x76,0xAC,0x61,0xEC,0xD6,0xFF,
+0x2F,0x97,0xD0,0x66,0xB2,0x91,0xD4,0x3A,
+0x27,0xE1,0xB6,0xB7,0x3B,0xC6,0xF8,0xC9,
+0x23,0xDE,0x49,0xA3,0x5E,0xA9,0x7C,0x88,
+0x0F,0x4E,0xBB,0x6B,0x80,0xD0,0x75,0xCA,
+0x27,0xA7,0xBB,0xEB,0x8F,0xED,0x26,0x78,
+0x27,0x60,0xE1,0x25,0xDE,0x21,0xFB,0x00,
+0x2F,0x95,0xA1,0xFB,0x26,0xD4,0xC7,0x98,
+0x27,0x47,0x13,0x62,0xFC,0x40,0xC8,0x71,
+0x2F,0xE9,0xE3,0xAB,0x46,0xF8,0x80,0x98,
+0x25,0xBC,0x0A,0xD8,0xD8,0x76,0xA2,0xC2,
+0x0F,0xC0,0x36,0x1B,0xBB,0x14,0xFE,0x3B,
+0x2F,0xB6,0x62,0x7A,0x63,0x5B,0xEA,0x98,
+0x29,0x90,0x5D,0x14,0x2E,0xB5,0x3E,0x33,
+0x07,0xA3,0xD5,0x0A,0x18,0x3D,0xF7,0x8F,
+0x24,0x13,0x80,0x67,0xE4,0xFC,0xAA,0x31,
+0x07,0x0F,0xCA,0x7A,0x84,0x20,0x71,0x3C,
+0x2C,0xBD,0x1B,0x0D,0xEA,0x48,0xD5,0x8E,
+0x07,0xEF,0x14,0x60,0x20,0xB8,0x03,0xC6,
+0x2F,0x6A,0xE9,0x45,0x8D,0xD0,0xE1,0x4A,
+0x27,0x86,0x5F,0xCB,0x2F,0x13,0xD0,0x4A,
+0x2E,0xA4,0x27,0xC5,0x23,0xF8,0xE5,0x9D,
+0x07,0xBE,0x54,0x34,0xC0,0x4B,0x02,0x6F,
+0x27,0x43,0xFE,0xC2,0x00,0xBE,0x61,0x5F,
+0x27,0x17,0x95,0xD5,0xF2,0x74,0xB3,0x76,
+0x27,0x82,0x37,0xB2,0x47,0xB1,0x41,0xCB,
+0x2F,0x28,0x92,0x3B,0x21,0x2A,0x07,0x7E,
+0x27,0xC4,0x89,0x6A,0x6B,0x07,0xE4,0x86,
+0x27,0xBF,0x2F,0x4C,0x6F,0xDE,0xBD,0xBA,
+0x2F,0x40,0x71,0x42,0x90,0x4C,0x3C,0x4D,
+0x2F,0xCE,0x7A,0x22,0xF6,0x4D,0xA3,0xD0,
+0x2F,0xC7,0x20,0xD5,0xA8,0xAE,0x36,0x04,
+0x2F,0x99,0x66,0x91,0x42,0xC7,0x0E,0x46,
+0x27,0x99,0xB4,0xE3,0xEA,0x09,0x1B,0xC0,
+0x2F,0xC8,0x7D,0xF6,0x66,0xFC,0x01,0x01,
+0x2F,0x1D,0xCC,0x06,0x32,0x52,0xC9,0xEC,
+0x27,0x97,0x35,0x13,0xC0,0x22,0x47,0x28,
+0x2F,0x6B,0x22,0x62,0x5F,0xF9,0xDB,0xC0,
+0x27,0x27,0xDC,0x20,0xC9,0x48,0x97,0x6C,
+0x27,0x6D,0xEA,0x0B,0xC9,0xB0,0x42,0xA1,
+0x27,0xF5,0x63,0x95,0x20,0x3C,0xAF,0x7A,
+0x2E,0x4F,0x29,0xBC,0x2A,0x25,0xBF,0xC7,
+0x0F,0xBD,0x76,0x0E,0xB6,0xC4,0x48,0xC4,
+0x07,0xAF,0x32,0x85,0xA4,0x21,0xDE,0x98,
+0x27,0x73,0xB5,0xF4,0xEE,0x64,0xE7,0xD7,
+0x2F,0x43,0x4C,0x50,0xEC,0xB3,0x44,0x2F,
+0x27,0x66,0x41,0xC7,0x0E,0x86,0x27,0x37,
+0x27,0xF0,0xC1,0x0D,0xE6,0x8D,0x6B,0xB0,
+0x27,0xF4,0x0C,0x34,0xBE,0x53,0x33,0xEF,
+0x2F,0x0D,0xB3,0xB4,0xA2,0xF7,0xBB,0x0A,
+0x27,0x82,0xE4,0x56,0x45,0x09,0x4F,0x80,
+0x27,0x6D,0xB0,0xAF,0xE3,0xEF,0xFE,0x41,
+0x27,0x43,0x42,0x4E,0x33,0x21,0xEC,0xEF,
+0x2F,0xF4,0xFC,0xEB,0xA2,0xB0,0x48,0x58,
+0x2F,0xDF,0x77,0x51,0x55,0xA2,0x5A,0x01,
+0x27,0x82,0x76,0xE9,0xA1,0xF2,0xCE,0xC7,
+0x27,0xB0,0x11,0x08,0xA3,0x9A,0x1D,0xE4,
+0x27,0x1A,0x2A,0x9A,0x0C,0x66,0xB7,0xA7,
+0x2F,0xB4,0x6F,0xEE,0x1E,0x40,0x89,0x03,
+0x2F,0x2F,0x71,0xE2,0x3F,0xC2,0x28,0x58,
+0x27,0xF8,0xD5,0xD1,0x3F,0x1C,0x72,0xE8,
+0x29,0x63,0xC8,0xC6,0x4C,0x0D,0x75,0xBD,
+0x07,0x2E,0xFF,0x7D,0xE1,0x9F,0xAC,0x7A,
+0x2F,0xE7,0x6F,0x9F,0x29,0x5D,0xC7,0x61,
+0x27,0x8A,0x3E,0xD0,0x25,0xA6,0x4D,0x9F,
+0x27,0x47,0x43,0x8C,0x47,0xD9,0xE9,0x00,
+0x27,0xB8,0x99,0x05,0x46,0xEF,0x74,0xF2,
+0x2F,0x56,0xEF,0x01,0xD3,0x6C,0x2F,0x42,
+0x29,0x88,0x10,0x35,0x8B,0x13,0x4F,0x93,
+0x0F,0xBF,0xDA,0xDD,0xA5,0x32,0x87,0x35,
+0x27,0xB6,0xE0,0x94,0xC8,0x34,0x03,0x1B,
+0x2F,0x95,0xB4,0xE0,0x1B,0xA5,0xB4,0x42,
+0x27,0x2B,0xAF,0x3B,0xB7,0x5A,0x04,0x1B,
+0x2F,0x66,0x5F,0x80,0x11,0xF8,0x30,0xAD,
+0x2F,0xCD,0x72,0x56,0xCB,0x04,0x75,0xF0,
+0x2F,0x1A,0x8A,0x82,0x45,0x55,0x76,0xD3,
+0x27,0xD4,0x9C,0xD1,0xD4,0x67,0x8B,0x53,
+0x2F,0xB4,0x27,0x78,0x31,0x76,0x47,0x76,
+0x2F,0xB5,0xA2,0x5B,0x61,0xF5,0x9F,0x5F,
+0x27,0xBF,0x86,0xB2,0x72,0xD4,0x43,0xEA,
+0x2F,0x22,0x7E,0x7D,0x11,0x74,0xB2,0x31,
+0x27,0x04,0x50,0x7D,0xA6,0xDB,0xF1,0xE2,
+0x2F,0x1C,0x8F,0x00,0xF3,0x2B,0xD6,0xEC,
+0x27,0xC4,0x51,0xEE,0x37,0x04,0xAB,0x92,
+0x2E,0x18,0xED,0xE8,0xFA,0xDB,0xBF,0x70,
+0x07,0xFE,0x6E,0xAA,0x0E,0xD0,0x54,0x86,
+0x27,0x6E,0x70,0x86,0x54,0x4A,0x9F,0xF1,
+0x27,0x8C,0x32,0xBF,0x69,0x09,0xB0,0x2B,
+0x2F,0x6B,0x0F,0x08,0x8A,0xB2,0x9C,0x32,
+0x2F,0xA1,0xC4,0xA5,0xB6,0x82,0x48,0xA8,
+0x27,0x13,0xB4,0x7D,0xB4,0xF3,0xCD,0xD5,
+0x2F,0xA8,0x12,0x2B,0xFE,0x55,0x5F,0xB4,
+0x2F,0x17,0xFE,0x36,0xB4,0x58,0x55,0x31,
+0x2F,0x7D,0x07,0x0F,0x83,0x45,0x7D,0x84,
+0x2F,0x36,0x01,0x3B,0x1A,0xA9,0x51,0xAB,
+0x27,0xE7,0x81,0xA7,0xAC,0x50,0x1E,0x53,
+0x2F,0x70,0x03,0x6F,0x40,0xD4,0x35,0x3A,
+0x2F,0x0B,0xFB,0x5A,0x62,0x01,0xF2,0x3A,
+0x2F,0x21,0x2B,0xA4,0xA9,0x59,0x6C,0xB7,
+0x2F,0xDD,0x43,0xF8,0x6B,0xBD,0xFE,0x7B,
+0x2F,0x63,0x45,0x5B,0x13,0xB6,0x54,0xC0,
+0x23,0x2E,0xBA,0xAC,0x01,0x10,0x9E,0xC1,
+0x07,0x14,0xB3,0x5A,0x43,0x24,0xC2,0x20,
+0x24,0x92,0x69,0xCF,0xC9,0x8C,0xF2,0xD3,
+0x0F,0xE7,0x73,0x9A,0x1D,0xFF,0x39,0x6A,
+0x2F,0xBC,0xF5,0xF0,0xC6,0x33,0x15,0x00,
+0x2F,0x34,0x1D,0x93,0x06,0x77,0xA8,0x0A,
+0x22,0x0A,0xC5,0x40,0xFC,0x53,0x13,0x6F,
+0x07,0x18,0xD3,0x16,0x08,0xA9,0xDB,0x90,
+0x27,0x0E,0xA1,0x6F,0x02,0xE3,0xB7,0x52,
+0x2F,0x7D,0x73,0xDF,0xDE,0xED,0x2C,0x7C,
+0x2F,0x0F,0x46,0x68,0x59,0x6C,0xDA,0xA1,
+0x2F,0x38,0x70,0x5E,0x5D,0x13,0xF8,0x39,
+0x07,0x3B,0xDE,0x59,0x8E,0xE8,0x8A,0x30,
+0x24,0xF2,0x6E,0xF3,0x70,0xB5,0xD1,0x2D,
+0x07,0x53,0xFE,0x26,0xE1,0x03,0xA8,0x0A,
+0x24,0xDD,0xA1,0xA6,0x5E,0x06,0x9C,0x8C,
+0x07,0x8A,0x07,0xB2,0x06,0x20,0xE8,0xE2,
+0x2F,0x70,0x0E,0xD2,0x8F,0x58,0x36,0xAC,
+0x29,0x8B,0xC0,0xE9,0xB8,0x39,0x5D,0x1C,
+0x0F,0x02,0x53,0xE8,0x36,0x36,0xB4,0x6F,
+0x2F,0xC4,0xE9,0x4B,0x4E,0x8B,0xAB,0x45,
+0x21,0x56,0x82,0x1D,0x97,0xF8,0x19,0x70,
+0x0F,0x48,0x02,0x4E,0x61,0x31,0x91,0x2A,
+0x07,0xCF,0xF2,0x8B,0x8D,0x62,0xC6,0x24,
+0x07,0x68,0x10,0xE8,0x8E,0x84,0xA4,0x3F,
+0x2F,0x55,0xB7,0xC5,0x34,0x58,0x68,0x45,
+0x27,0x45,0x20,0x7B,0x8E,0xF6,0x13,0x68,
+0x2F,0xB1,0x89,0x78,0x2A,0x1B,0x03,0x6D,
+0x27,0x09,0xF9,0x1C,0xF3,0x5B,0x92,0x63,
+0x27,0xDB,0x95,0x3E,0x2F,0xA3,0xC0,0x35,
+0x21,0x9E,0x95,0x8C,0xA3,0x8D,0x0D,0x82,
+0x0F,0x22,0xD4,0xD4,0xBC,0x48,0x7E,0x3E,
+0x05,0x06,0x19,0x79,0x12,0x2B,0x85,0x0B,
+0x2F,0x81,0x54,0xBC,0x28,0x81,0xE7,0x77,
+0x21,0x67,0xC1,0x1B,0xBF,0x5F,0x5C,0x93,
+0x05,0x03,0x95,0xB9,0x12,0x11,0x41,0x22
+};
+
+#define Si2168_PATCH_3_0b6_LINES (sizeof(Si2168_PATCH_3_0b6)/(8*sizeof(unsigned char)))
+
+#define Si2168_BYTES_PER_LINE 8
+
+unsigned char Si2168_L1_API_Patch(L1_Si2168_Context *api, int iNbBytes, unsigned char *pucDataBuffer)
+{
+    int i;
+	unsigned char res;
+	unsigned char rspByteBuffer[1];
+	unsigned char sndByteBuffer[20];
+	for(i=0;i<iNbBytes;i++)
+        sndByteBuffer[i]=pucDataBuffer[i];
+	WriteI2C(api->addr,iNbBytes,sndByteBuffer);
+	res = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (res != 0)
+		return 7;
+	return 0;
+}
+
+int Si2168_LoadFirmware(L1_Si2168_Context *api, unsigned char fw_table[], int nbLines)
+{
+	int return_code;
+	int line;
+	return_code = 0;
+	// for each line in fw_table
+	for (line = 0; line < nbLines; line++)
+	{
+		// send Si2168_BYTES_PER_LINE fw bytes to Si2168
+		if ((return_code = Si2168_L1_API_Patch(api, Si2168_BYTES_PER_LINE, fw_table + Si2168_BYTES_PER_LINE*line)) != 0)
+			return 8;
+	}
+	return 0;
+}
+
+unsigned char Si2168_L1_EXIT_BOOTLOADER(L1_Si2168_Context *api,unsigned char func,unsigned char ctsien)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[1];
+	api->rsp->exit_bootloader.STATUS = api->status;
+
+	cmdByteBuffer[0] = Si2168_EXIT_BOOTLOADER_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( func   & Si2168_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2168_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+										( ctsien & Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2168_StartFirmware(L1_Si2168_Context *api)
+{
+	if (Si2168_L1_EXIT_BOOTLOADER(api, Si2168_EXIT_BOOTLOADER_CMD_FUNC_NORMAL, Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != 0)
+		return 0x0a;
+	return 0;
+}
+
+int Si2168_PowerUpWithPatch(L1_Si2168_Context *api)
+{
+	int return_code;
+	int fw_loaded;
+	return_code = 0;
+	fw_loaded   = 0;
+	// Before patching, set POWER_UP values for 'RESET' and 'BOOTLOADER
+	api->cmd->power_up.reset = Si2168_POWER_UP_CMD_RESET_RESET;
+	api->cmd->power_up.func  = Si2168_POWER_UP_CMD_FUNC_BOOTLOADER;
+	return_code = Si2168_WAKEUP(api);
+	if (return_code != 0)
+		return return_code;
+	// Get the Part Info from the chip.   This command is only valid in Bootloader mode
+	if ((return_code=Si2168_L1_PART_INFO(api))!=0)
+		return return_code;
+	// Check part info values and load the proper firmware
+	printk("ChipID:%d,%d,%X,%X,%d\n",api->rsp->part_info.romid,api->rsp->part_info.part,api->rsp->part_info.pmajor,api->rsp->part_info.pminor,api->rsp->part_info.pbuild);
+	if((api->rsp->part_info.romid==Si2168_PATCH_2_0b24_ROM)
+		&((api->rsp->part_info.part==69)||(api->rsp->part_info.part==68))
+		&(api->rsp->part_info.pmajor==Si2168_PATCH_2_0b24_PMAJOR)
+		&(api->rsp->part_info.pminor==Si2168_PATCH_2_0b24_PMINOR)
+		&(api->rsp->part_info.pbuild==Si2168_PATCH_2_0b24_PBUILD))
+	{
+		if ((return_code = Si2168_LoadFirmware(api,Si2168_PATCH_2_0b24,Si2168_PATCH_2_0b24_LINES))!=0)
+			return return_code;
+		fw_loaded++;
+	}
+	if((api->rsp->part_info.romid==Si2168_PATCH_3_0b6_ROM)
+		&((api->rsp->part_info.part==69)||(api->rsp->part_info.part==68))
+		&(api->rsp->part_info.pmajor==Si2168_PATCH_3_0b6_PMAJOR)
+		&(api->rsp->part_info.pminor == Si2168_PATCH_3_0b6_PMINOR)
+		&(api->rsp->part_info.pbuild == Si2168_PATCH_3_0b6_PBUILD))
+	{
+		if ((return_code = Si2168_LoadFirmware(api,Si2168_PATCH_3_0b6,Si2168_PATCH_3_0b6_LINES))!=0)
+			return return_code;
+		fw_loaded++;
+	}
+	printk("Firmware Loaded\n");
+	if(!fw_loaded)
+		return 8;
+	//Start the Firmware
+	if ((return_code = Si2168_StartFirmware(api)) != 0)
+	{
+		// Start firmware
+		return return_code;
+	}
+	printk("Firmware Started\n");
+	return 0;
+}
+
+int Si2168_Init(L1_Si2168_Context *api)
+{
+	int return_code;
+	if ((return_code = Si2168_PowerUpWithPatch(api)) != 0)
+	{ // PowerUp into bootloader
+		return return_code;
+	}
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_MP_DEFAULTS(L1_Si2168_Context *api,unsigned char mp_a_mode,unsigned char mp_b_mode,unsigned char mp_c_mode,unsigned char mp_d_mode)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[5];
+	unsigned char rspByteBuffer[5];
+	api->rsp->dd_mp_defaults.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DD_MP_DEFAULTS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( mp_a_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( mp_b_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB);
+	cmdByteBuffer[3] = (unsigned char) ( ( mp_c_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB);
+	cmdByteBuffer[4] = (unsigned char) ( ( mp_d_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB);
+	WriteI2C(api->addr,5,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 5, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dd_mp_defaults.mp_a_mode =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK );
+	api->rsp->dd_mp_defaults.mp_b_mode =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK );
+	api->rsp->dd_mp_defaults.mp_c_mode =   (( ( (rspByteBuffer[3]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK );
+	api->rsp->dd_mp_defaults.mp_d_mode =   (( ( (rspByteBuffer[4]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK );
+	return 0;
+}
+
+unsigned char Si2168_L1_CONFIG_PINS(L1_Si2168_Context *api,unsigned char gpio0_mode,unsigned char gpio0_read,unsigned char gpio1_mode,unsigned char gpio1_read)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[3];
+	unsigned char rspByteBuffer[3];
+	api->rsp->config_pins.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_CONFIG_PINS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( gpio0_mode & Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO0_MODE_LSB|
+										 ( gpio0_read & Si2168_CONFIG_PINS_CMD_GPIO0_READ_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO0_READ_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( gpio1_mode & Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+										 ( gpio1_read & Si2168_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+	WriteI2C(api->addr,3,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->config_pins.gpio0_mode  =   (( ( (rspByteBuffer[1]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB  ) & Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK  );
+	api->rsp->config_pins.gpio0_state =   (( ( (rspByteBuffer[1]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB ) & Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK );
+	api->rsp->config_pins.gpio1_mode  =   (( ( (rspByteBuffer[2]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+	api->rsp->config_pins.gpio1_state =   (( ( (rspByteBuffer[2]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_EXT_AGC_TER(L1_Si2168_Context *api,unsigned char agc_1_mode,unsigned char agc_1_inv,unsigned char agc_2_mode,unsigned char agc_2_inv,unsigned char agc_1_kloop,unsigned char agc_2_kloop,unsigned char agc_1_min,unsigned char agc_2_min)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[6];
+	unsigned char rspByteBuffer[3];
+	api->rsp->dd_ext_agc_ter.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DD_EXT_AGC_TER_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( agc_1_mode  & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK  ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB |
+										 ( agc_1_inv   & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB  |
+										 ( agc_2_mode  & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK  ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB |
+										 ( agc_2_inv   & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB  );
+	cmdByteBuffer[2] = (unsigned char) ( ( agc_1_kloop & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB);
+	cmdByteBuffer[3] = (unsigned char) ( ( agc_2_kloop & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB);
+	cmdByteBuffer[4] = (unsigned char) ( ( agc_1_min   & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB  );
+	cmdByteBuffer[5] = (unsigned char) ( ( agc_2_min   & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB  );
+	WriteI2C(api->addr,6,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dd_ext_agc_ter.agc_1_level =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB ) & Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK );
+	api->rsp->dd_ext_agc_ter.agc_2_level =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB ) & Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK );
+	return 0;
+}
+
+unsigned char Si2168_L1_DVBT2_FEF(L1_Si2168_Context *api,unsigned char fef_tuner_flag,unsigned char fef_tuner_flag_inv)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[12];
+	api->rsp->dvbt2_fef.STATUS = api->status;
+
+	cmdByteBuffer[0] = Si2168_DVBT2_FEF_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( fef_tuner_flag     & Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK     ) << Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB    |
+										 ( fef_tuner_flag_inv & Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK ) << Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 12, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dvbt2_fef.fef_type       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB       ) & Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK       );
+	api->rsp->dvbt2_fef.fef_length     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB     ) & Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK     );
+	api->rsp->dvbt2_fef.fef_repetition =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB ) & Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK );
+	return 0;
+}
+
+unsigned char Si2168_L1_SET_PROPERTY(L1_Si2168_Context *api,unsigned char   reserved,unsigned int    prop,unsigned int    data)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[6];
+	unsigned char rspByteBuffer[4];
+	api->rsp->set_property.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_SET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2168_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2168_SET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2168_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168_SET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2168_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+	cmdByteBuffer[4] = (unsigned char) ( ( data     & Si2168_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168_SET_PROPERTY_CMD_DATA_LSB    );
+	cmdByteBuffer[5] = (unsigned char) ((( data     & Si2168_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+	WriteI2C(api->addr,6,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 4, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->set_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2168_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2168_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+	api->rsp->set_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2168_SET_PROPERTY_RESPONSE_DATA_MASK     );
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_RESTART(L1_Si2168_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[1];
+	api->rsp->dd_restart.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DD_RESTART_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_SET_REG(L1_Si2168_Context *api,unsigned char reg_code_lsb,unsigned char reg_code_mid,unsigned char reg_code_msb,unsigned long value)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[8];
+	unsigned char rspByteBuffer[1];
+	api->rsp->dd_set_reg.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DD_SET_REG_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( reg_code_lsb & Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_LSB_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( reg_code_mid & Si2168_DD_SET_REG_CMD_REG_CODE_MID_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_MID_LSB);
+	cmdByteBuffer[3] = (unsigned char) ( ( reg_code_msb & Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_MSB_LSB);
+	cmdByteBuffer[4] = (unsigned char) ( ( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       );
+	cmdByteBuffer[5] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>8);
+	cmdByteBuffer[6] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>16);
+	cmdByteBuffer[7] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>24);
+	WriteI2C(api->addr,8,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_SSI_SQI(L1_Si2168_Context *api,char tuner_rssi)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[3];
+	api->rsp->dd_ssi_sqi.STATUS = api->status;
+
+	cmdByteBuffer[0] = Si2168_DD_SSI_SQI_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( tuner_rssi & Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MASK ) << Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dd_ssi_sqi.ssi =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_SSI_SQI_RESPONSE_SSI_LSB ) & Si2168_DD_SSI_SQI_RESPONSE_SSI_MASK );
+	api->rsp->dd_ssi_sqi.sqi = (((( ( (rspByteBuffer[2]  )) >> Si2168_DD_SSI_SQI_RESPONSE_SQI_LSB ) & Si2168_DD_SSI_SQI_RESPONSE_SQI_MASK) <<Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT ) >>Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT );
+	return 0;
+}
+
+unsigned char Si2168_L1_DD_STATUS(L1_Si2168_Context *api,unsigned char   intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[8];
+	api->rsp->dd_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DD_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DD_STATUS_CMD_INTACK_MASK ) << Si2168_DD_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 8, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dd_status.pclint       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_PCLINT_LSB       ) & Si2168_DD_STATUS_RESPONSE_PCLINT_MASK       );
+	api->rsp->dd_status.dlint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_DLINT_LSB        ) & Si2168_DD_STATUS_RESPONSE_DLINT_MASK        );
+	api->rsp->dd_status.berint       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_BERINT_LSB       ) & Si2168_DD_STATUS_RESPONSE_BERINT_MASK       );
+	api->rsp->dd_status.uncorint     =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_UNCORINT_LSB     ) & Si2168_DD_STATUS_RESPONSE_UNCORINT_MASK     );
+	api->rsp->dd_status.rsqint_bit5  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK  );
+	api->rsp->dd_status.rsqint_bit6  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK  );
+	api->rsp->dd_status.rsqint_bit7  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK  );
+	api->rsp->dd_status.pcl          =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_PCL_LSB          ) & Si2168_DD_STATUS_RESPONSE_PCL_MASK          );
+	api->rsp->dd_status.dl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_DL_LSB           ) & Si2168_DD_STATUS_RESPONSE_DL_MASK           );
+	api->rsp->dd_status.ber          =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_BER_LSB          ) & Si2168_DD_STATUS_RESPONSE_BER_MASK          );
+	api->rsp->dd_status.uncor        =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_UNCOR_LSB        ) & Si2168_DD_STATUS_RESPONSE_UNCOR_MASK        );
+	api->rsp->dd_status.rsqstat_bit5 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK );
+	api->rsp->dd_status.rsqstat_bit6 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK );
+	api->rsp->dd_status.rsqstat_bit7 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK );
+	api->rsp->dd_status.modulation   =   (( ( (rspByteBuffer[3]  )) >> Si2168_DD_STATUS_RESPONSE_MODULATION_LSB   ) & Si2168_DD_STATUS_RESPONSE_MODULATION_MASK   );
+	api->rsp->dd_status.ts_bit_rate  =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB  ) & Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK  );
+	api->rsp->dd_status.ts_clk_freq  =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB  ) & Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK  );
+	return 0;
+}
+
+unsigned char Si2168_L1_DVBT2_STATUS(L1_Si2168_Context *api,unsigned char intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[14];
+	api->rsp->dvbt2_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DVBT2_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DVBT2_STATUS_CMD_INTACK_MASK ) << Si2168_DVBT2_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 14, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dvbt2_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_PCLINT_MASK        );
+	api->rsp->dvbt2_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_DLINT_LSB         ) & Si2168_DVBT2_STATUS_RESPONSE_DLINT_MASK         );
+	api->rsp->dvbt2_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BERINT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_BERINT_MASK        );
+	api->rsp->dvbt2_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_MASK      );
+	api->rsp->dvbt2_status.notdvbt2int   =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB   ) & Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK   );
+	api->rsp->dvbt2_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_PCL_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_PCL_MASK           );
+	api->rsp->dvbt2_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_DL_LSB            ) & Si2168_DVBT2_STATUS_RESPONSE_DL_MASK            );
+	api->rsp->dvbt2_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BER_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_BER_MASK           );
+	api->rsp->dvbt2_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168_DVBT2_STATUS_RESPONSE_UNCOR_MASK         );
+	api->rsp->dvbt2_status.notdvbt2      =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK      );
+	api->rsp->dvbt2_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT2_STATUS_RESPONSE_CNR_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_CNR_MASK           );
+	api->rsp->dvbt2_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	api->rsp->dvbt2_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	api->rsp->dvbt2_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK );
+	api->rsp->dvbt2_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_SP_INV_MASK        );
+	api->rsp->dvbt2_status.fef           =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_FEF_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_FEF_MASK           );
+	api->rsp->dvbt2_status.fft_mode      =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK      );
+	api->rsp->dvbt2_status.guard_int     =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK     );
+	api->rsp->dvbt2_status.bw_ext        =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        );
+	api->rsp->dvbt2_status.num_plp       =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK       );
+	api->rsp->dvbt2_status.pilot_pattern =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK );
+	api->rsp->dvbt2_status.tx_mode       =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MASK       );
+	api->rsp->dvbt2_status.rotated       =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_ROTATED_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_ROTATED_MASK       );
+	api->rsp->dvbt2_status.short_frame   =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB   ) & Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK   );
+	api->rsp->dvbt2_status.code_rate     =   (( ( (rspByteBuffer[12] )) >> Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB     ) & Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK     );
+	api->rsp->dvbt2_status.plp_id        =   (( ( (rspByteBuffer[13] )) >> Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        );
+	return 0;
+}
+
+unsigned char Si2168_L1_DVBT_STATUS               (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[13];
+	api->rsp->dvbt_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DVBT_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DVBT_STATUS_CMD_INTACK_MASK ) << Si2168_DVBT_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 13, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dvbt_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_PCLINT_MASK        );
+	api->rsp->dvbt_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_DLINT_LSB         ) & Si2168_DVBT_STATUS_RESPONSE_DLINT_MASK         );
+	api->rsp->dvbt_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_BERINT_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_BERINT_MASK        );
+	api->rsp->dvbt_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_UNCORINT_MASK      );
+	api->rsp->dvbt_status.notdvbtint    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB    ) & Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK    );
+	api->rsp->dvbt_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_PCL_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_PCL_MASK           );
+	api->rsp->dvbt_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_DL_LSB            ) & Si2168_DVBT_STATUS_RESPONSE_DL_MASK            );
+	api->rsp->dvbt_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_BER_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_BER_MASK           );
+	api->rsp->dvbt_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168_DVBT_STATUS_RESPONSE_UNCOR_MASK         );
+	api->rsp->dvbt_status.notdvbt       =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_MASK       );
+	api->rsp->dvbt_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT_STATUS_RESPONSE_CNR_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_CNR_MASK           );
+	api->rsp->dvbt_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+	api->rsp->dvbt_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+	api->rsp->dvbt_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK );
+	api->rsp->dvbt_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_SP_INV_MASK        );
+	api->rsp->dvbt_status.rate_hp       =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT_STATUS_RESPONSE_RATE_HP_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_RATE_HP_MASK       );
+	api->rsp->dvbt_status.rate_lp       =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT_STATUS_RESPONSE_RATE_LP_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_RATE_LP_MASK       );
+	api->rsp->dvbt_status.fft_mode      =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_MASK      );
+	api->rsp->dvbt_status.guard_int     =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_MASK     );
+	api->rsp->dvbt_status.hierarchy     =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_LSB     ) & Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_MASK     );
+	api->rsp->dvbt_status.tps_length    = (((( ( (rspByteBuffer[12] )) >> Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB    ) & Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK) <<Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT    );
+	return 0;
+}
+
+unsigned char Si2168_L1_DVBT_TPS_EXTRA(L1_Si2168_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[6];
+	api->rsp->dvbt_tps_extra.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DVBT_TPS_EXTRA_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 6, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dvbt_tps_extra.lptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK );
+	api->rsp->dvbt_tps_extra.hptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK );
+	api->rsp->dvbt_tps_extra.lpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK    );
+	api->rsp->dvbt_tps_extra.hpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK    );
+	api->rsp->dvbt_tps_extra.dvbhinter   =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB   ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK   );
+	api->rsp->dvbt_tps_extra.cell_id     = (((( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB     ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK) <<Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT ) >>Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT     );
+	api->rsp->dvbt_tps_extra.tps_res1    =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK    );
+	api->rsp->dvbt_tps_extra.tps_res2    =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK    );
+	api->rsp->dvbt_tps_extra.tps_res3    =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK    );
+	api->rsp->dvbt_tps_extra.tps_res4    =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK    );
+	return 0;
+}
+
+unsigned char Si2168_L1_DVBT2_PLP_SELECT(L1_Si2168_Context *api,unsigned char plp_id,unsigned char plp_id_sel_mode)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[3];
+	unsigned char rspByteBuffer[1];
+	api->rsp->dvbt2_plp_select.STATUS = api->status;
+	cmdByteBuffer[0] = Si2168_DVBT2_PLP_SELECT_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( plp_id          & Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK          ) << Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         );
+	cmdByteBuffer[2] = (unsigned char) ( ( plp_id_sel_mode & Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK ) << Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB);
+	WriteI2C(api->addr,3,cmdByteBuffer);
+	error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+	if(error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char   Si2168_L1_SendCommand2(L1_Si2168_Context *api, unsigned int cmd_code)
+{
+	switch (cmd_code)
+	{
+		#ifdef        Si2168_CONFIG_CLKIO_CMD
+		case         Si2168_CONFIG_CLKIO_CMD_CODE:
+			return Si2168_L1_CONFIG_CLKIO (api, api->cmd->config_clkio.output, api->cmd->config_clkio.pre_driver_str, api->cmd->config_clkio.driver_str );
+			break;
+		#endif /*     Si2168_CONFIG_CLKIO_CMD */
+		#ifdef        Si2168_CONFIG_PINS_CMD
+		case         Si2168_CONFIG_PINS_CMD_CODE:
+			return Si2168_L1_CONFIG_PINS (api, api->cmd->config_pins.gpio0_mode, api->cmd->config_pins.gpio0_read, api->cmd->config_pins.gpio1_mode, api->cmd->config_pins.gpio1_read );
+			break;
+		#endif /*     Si2168_CONFIG_PINS_CMD */
+		#ifdef        Si2168_DD_BER_CMD
+		case         Si2168_DD_BER_CMD_CODE:
+			return Si2168_L1_DD_BER (api, api->cmd->dd_ber.rst );
+			break;
+		#endif /*     Si2168_DD_BER_CMD */
+		#ifdef        Si2168_DD_CBER_CMD
+		case         Si2168_DD_CBER_CMD_CODE:
+			return Si2168_L1_DD_CBER (api, api->cmd->dd_cber.rst );
+			break;
+		#endif /*     Si2168_DD_CBER_CMD */
+		#ifdef        Si2168_DD_EXT_AGC_TER_CMD
+		case         Si2168_DD_EXT_AGC_TER_CMD_CODE:
+			return Si2168_L1_DD_EXT_AGC_TER (api, api->cmd->dd_ext_agc_ter.agc_1_mode, api->cmd->dd_ext_agc_ter.agc_1_inv, api->cmd->dd_ext_agc_ter.agc_2_mode, api->cmd->dd_ext_agc_ter.agc_2_inv, api->cmd->dd_ext_agc_ter.agc_1_kloop, api->cmd->dd_ext_agc_ter.agc_2_kloop, api->cmd->dd_ext_agc_ter.agc_1_min, api->cmd->dd_ext_agc_ter.agc_2_min );
+			break;
+		#endif /*     Si2168_DD_EXT_AGC_TER_CMD */
+		#ifdef        Si2168_DD_FER_CMD
+		case         Si2168_DD_FER_CMD_CODE:
+			return Si2168_L1_DD_FER (api, api->cmd->dd_fer.rst );
+			break;
+		#endif /*     Si2168_DD_FER_CMD */
+		#ifdef        Si2168_DD_GET_REG_CMD
+		case         Si2168_DD_GET_REG_CMD_CODE:
+			return Si2168_L1_DD_GET_REG (api, api->cmd->dd_get_reg.reg_code_lsb, api->cmd->dd_get_reg.reg_code_mid, api->cmd->dd_get_reg.reg_code_msb );
+			break;
+		#endif /*     Si2168_DD_GET_REG_CMD */
+		#ifdef        Si2168_DD_MP_DEFAULTS_CMD
+		case         Si2168_DD_MP_DEFAULTS_CMD_CODE:
+			return Si2168_L1_DD_MP_DEFAULTS (api, api->cmd->dd_mp_defaults.mp_a_mode, api->cmd->dd_mp_defaults.mp_b_mode, api->cmd->dd_mp_defaults.mp_c_mode, api->cmd->dd_mp_defaults.mp_d_mode );
+			break;
+		#endif /*     Si2168_DD_MP_DEFAULTS_CMD */
+		#ifdef        Si2168_DD_PER_CMD
+		case         Si2168_DD_PER_CMD_CODE:
+			return Si2168_L1_DD_PER (api, api->cmd->dd_per.rst );
+			break;
+		#endif /*     Si2168_DD_PER_CMD */
+		#ifdef        Si2168_DD_RESTART_CMD
+		case         Si2168_DD_RESTART_CMD_CODE:
+			return Si2168_L1_DD_RESTART (api );
+			break;
+		#endif /*     Si2168_DD_RESTART_CMD */
+		#ifdef        Si2168_DD_SET_REG_CMD
+		case         Si2168_DD_SET_REG_CMD_CODE:
+			return Si2168_L1_DD_SET_REG (api, api->cmd->dd_set_reg.reg_code_lsb, api->cmd->dd_set_reg.reg_code_mid, api->cmd->dd_set_reg.reg_code_msb, api->cmd->dd_set_reg.value );
+			break;
+		#endif /*     Si2168_DD_SET_REG_CMD */
+		#ifdef        Si2168_DD_SSI_SQI_CMD
+		case         Si2168_DD_SSI_SQI_CMD_CODE:
+			return Si2168_L1_DD_SSI_SQI (api, api->cmd->dd_ssi_sqi.tuner_rssi );
+			break;
+		#endif /*     Si2168_DD_SSI_SQI_CMD */
+		#ifdef        Si2168_DD_STATUS_CMD
+		case         Si2168_DD_STATUS_CMD_CODE:
+			return Si2168_L1_DD_STATUS (api, api->cmd->dd_status.intack );
+			break;
+		#endif /*     Si2168_DD_STATUS_CMD */
+		#ifdef        Si2168_DD_UNCOR_CMD
+		case         Si2168_DD_UNCOR_CMD_CODE:
+			return Si2168_L1_DD_UNCOR (api, api->cmd->dd_uncor.rst );
+			break;
+		#endif /*     Si2168_DD_UNCOR_CMD */
+		#ifdef        Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+		case         Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_CODE:
+			return Si2168_L1_DOWNLOAD_DATASET_CONTINUE (api, api->cmd->download_dataset_continue.data0, api->cmd->download_dataset_continue.data1, api->cmd->download_dataset_continue.data2, api->cmd->download_dataset_continue.data3, api->cmd->download_dataset_continue.data4, api->cmd->download_dataset_continue.data5, api->cmd->download_dataset_continue.data6 );
+			break;
+		#endif /*     Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+		#ifdef        Si2168_DOWNLOAD_DATASET_START_CMD
+		case         Si2168_DOWNLOAD_DATASET_START_CMD_CODE:
+			return Si2168_L1_DOWNLOAD_DATASET_START (api, api->cmd->download_dataset_start.dataset_id, api->cmd->download_dataset_start.dataset_checksum, api->cmd->download_dataset_start.data0, api->cmd->download_dataset_start.data1, api->cmd->download_dataset_start.data2, api->cmd->download_dataset_start.data3, api->cmd->download_dataset_start.data4 );
+			break;
+		#endif /*     Si2168_DOWNLOAD_DATASET_START_CMD */
+		#ifdef        Si2168_DVBC_STATUS_CMD
+		case         Si2168_DVBC_STATUS_CMD_CODE:
+			return Si2168_L1_DVBC_STATUS (api, api->cmd->dvbc_status.intack );
+			break;
+		#endif /*     Si2168_DVBC_STATUS_CMD */
+		#ifdef        Si2168_DVBT2_FEF_CMD
+		case         Si2168_DVBT2_FEF_CMD_CODE:
+			return Si2168_L1_DVBT2_FEF (api, api->cmd->dvbt2_fef.fef_tuner_flag, api->cmd->dvbt2_fef.fef_tuner_flag_inv );
+			break;
+		#endif /*     Si2168_DVBT2_FEF_CMD */
+		#ifdef        Si2168_DVBT2_PLP_INFO_CMD
+		case         Si2168_DVBT2_PLP_INFO_CMD_CODE:
+			return Si2168_L1_DVBT2_PLP_INFO (api, api->cmd->dvbt2_plp_info.plp_index );
+			break;
+		#endif /*     Si2168_DVBT2_PLP_INFO_CMD */
+		#ifdef        Si2168_DVBT2_PLP_SELECT_CMD
+		case         Si2168_DVBT2_PLP_SELECT_CMD_CODE:
+			return Si2168_L1_DVBT2_PLP_SELECT (api, api->cmd->dvbt2_plp_select.plp_id, api->cmd->dvbt2_plp_select.plp_id_sel_mode );
+			break;
+		#endif /*     Si2168_DVBT2_PLP_SELECT_CMD */
+		#ifdef        Si2168_DVBT2_STATUS_CMD
+		case         Si2168_DVBT2_STATUS_CMD_CODE:
+			return Si2168_L1_DVBT2_STATUS (api, api->cmd->dvbt2_status.intack );
+			break;
+		#endif /*     Si2168_DVBT2_STATUS_CMD */
+		#ifdef        Si2168_DVBT2_TX_ID_CMD
+		case         Si2168_DVBT2_TX_ID_CMD_CODE:
+			return Si2168_L1_DVBT2_TX_ID (api );
+			break;
+		#endif /*     Si2168_DVBT2_TX_ID_CMD */
+		#ifdef        Si2168_DVBT_STATUS_CMD
+		case         Si2168_DVBT_STATUS_CMD_CODE:
+			return Si2168_L1_DVBT_STATUS (api, api->cmd->dvbt_status.intack );
+			break;
+		#endif /*     Si2168_DVBT_STATUS_CMD */
+		#ifdef        Si2168_DVBT_TPS_EXTRA_CMD
+		case         Si2168_DVBT_TPS_EXTRA_CMD_CODE:
+			return Si2168_L1_DVBT_TPS_EXTRA (api );
+			break;
+		#endif /*     Si2168_DVBT_TPS_EXTRA_CMD */
+		#ifdef        Si2168_EXIT_BOOTLOADER_CMD
+		case         Si2168_EXIT_BOOTLOADER_CMD_CODE:
+			return Si2168_L1_EXIT_BOOTLOADER (api, api->cmd->exit_bootloader.func, api->cmd->exit_bootloader.ctsien );
+			break;
+		#endif /*     Si2168_EXIT_BOOTLOADER_CMD */
+		#ifdef        Si2168_GET_PROPERTY_CMD
+		case         Si2168_GET_PROPERTY_CMD_CODE:
+			return Si2168_L1_GET_PROPERTY (api, api->cmd->get_property.reserved, api->cmd->get_property.prop );
+			break;
+		#endif /*     Si2168_GET_PROPERTY_CMD */
+		#ifdef        Si2168_GET_REV_CMD
+		case         Si2168_GET_REV_CMD_CODE:
+			return Si2168_L1_GET_REV (api );
+			break;
+		#endif /*     Si2168_GET_REV_CMD */
+		#ifdef        Si2168_I2C_PASSTHROUGH_CMD
+		case         Si2168_I2C_PASSTHROUGH_CMD_CODE:
+			return Si2168_L1_I2C_PASSTHROUGH (api, api->cmd->i2c_passthrough.subcode, api->cmd->i2c_passthrough.i2c_passthru, api->cmd->i2c_passthrough.reserved );
+			break;
+		#endif /*     Si2168_I2C_PASSTHROUGH_CMD */
+		#ifdef        Si2168_PART_INFO_CMD
+		case         Si2168_PART_INFO_CMD_CODE:
+			return Si2168_L1_PART_INFO (api );
+			break;
+		#endif /*     Si2168_PART_INFO_CMD */
+		#ifdef        Si2168_POWER_DOWN_CMD
+		case         Si2168_POWER_DOWN_CMD_CODE:
+			return Si2168_L1_POWER_DOWN (api );
+			break;
+		#endif /*     Si2168_POWER_DOWN_CMD */
+		#ifdef        Si2168_POWER_UP_CMD
+		case         Si2168_POWER_UP_CMD_CODE:
+			return Si2168_L1_POWER_UP (api, api->cmd->power_up.subcode, api->cmd->power_up.reset, api->cmd->power_up.reserved2, api->cmd->power_up.reserved4, api->cmd->power_up.reserved1, api->cmd->power_up.addr_mode, api->cmd->power_up.reserved5, api->cmd->power_up.func, api->cmd->power_up.clock_freq, api->cmd->power_up.ctsien, api->cmd->power_up.wake_up );
+			break;
+		#endif /*     Si2168_POWER_UP_CMD */
+		#ifdef        Si2168_RSSI_ADC_CMD
+		case         Si2168_RSSI_ADC_CMD_CODE:
+			return Si2168_L1_RSSI_ADC (api, api->cmd->rssi_adc.on_off );
+			break;
+		#endif /*     Si2168_RSSI_ADC_CMD */
+		#ifdef        Si2168_SCAN_CTRL_CMD
+		case         Si2168_SCAN_CTRL_CMD_CODE:
+			return Si2168_L1_SCAN_CTRL (api, api->cmd->scan_ctrl.action, api->cmd->scan_ctrl.tuned_rf_freq );
+			break;
+		#endif /*     Si2168_SCAN_CTRL_CMD */
+		#ifdef        Si2168_SCAN_STATUS_CMD
+		case         Si2168_SCAN_STATUS_CMD_CODE:
+			return Si2168_L1_SCAN_STATUS (api, api->cmd->scan_status.intack );
+			break;
+		#endif /*     Si2168_SCAN_STATUS_CMD */
+		#ifdef        Si2168_SET_PROPERTY_CMD
+		case         Si2168_SET_PROPERTY_CMD_CODE:
+			return Si2168_L1_SET_PROPERTY (api, api->cmd->set_property.reserved, api->cmd->set_property.prop, api->cmd->set_property.data );
+			break;
+		#endif /*     Si2168_SET_PROPERTY_CMD */
+		#ifdef        Si2168_START_CLK_CMD
+		case         Si2168_START_CLK_CMD_CODE:
+			return Si2168_L1_START_CLK (api, api->cmd->start_clk.subcode, api->cmd->start_clk.reserved1, api->cmd->start_clk.tune_cap, api->cmd->start_clk.reserved2, api->cmd->start_clk.clk_mode, api->cmd->start_clk.reserved3, api->cmd->start_clk.reserved4, api->cmd->start_clk.start_clk );
+			break;
+		#endif /*     Si2168_START_CLK_CMD */
+		default:
+			break;
+	}
+	return 0;
+}
+
+void Si2168_setupCOMMONDefaults(L1_Si2168_Context *api)
+{
+	api->prop->master_ien.ddien                       = Si2168_MASTER_IEN_PROP_DDIEN_OFF   ; /* (default 'OFF') */
+	api->prop->master_ien.scanien                     = Si2168_MASTER_IEN_PROP_SCANIEN_OFF ; /* (default 'OFF') */
+	api->prop->master_ien.errien                      = Si2168_MASTER_IEN_PROP_ERRIEN_OFF  ; /* (default 'OFF') */
+	api->prop->master_ien.ctsien                      = Si2168_MASTER_IEN_PROP_CTSIEN_OFF  ; /* (default 'OFF') */
+
+};
+
+void Si2168_setupDDDefaults(L1_Si2168_Context *api)
+{
+	api->prop->dd_ber_resol.exp                       =     7; /* (default     7) */
+	api->prop->dd_ber_resol.mant                      =     1; /* (default     1) */
+	api->prop->dd_cber_resol.exp                      =     5; /* (default     5) */
+	api->prop->dd_cber_resol.mant                     =     1; /* (default     1) */
+	api->prop->dd_fer_resol.exp                       =     2; /* (default     3) */
+	api->prop->dd_fer_resol.mant                      =     1; /* (default     1) */
+	api->prop->dd_ien.ien_bit0                        = Si2168_DD_IEN_PROP_IEN_BIT0_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit1                        = Si2168_DD_IEN_PROP_IEN_BIT1_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit2                        = Si2168_DD_IEN_PROP_IEN_BIT2_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit3                        = Si2168_DD_IEN_PROP_IEN_BIT3_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit4                        = Si2168_DD_IEN_PROP_IEN_BIT4_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit5                        = Si2168_DD_IEN_PROP_IEN_BIT5_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit6                        = Si2168_DD_IEN_PROP_IEN_BIT6_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_ien.ien_bit7                        = Si2168_DD_IEN_PROP_IEN_BIT7_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_if_input_freq.offset                =  5000; /* (default  5000) */
+	api->prop->dd_int_sense.neg_bit0                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit1                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit2                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit3                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit4                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit5                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit6                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.neg_bit7                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit0                  = Si2168_DD_INT_SENSE_PROP_POS_BIT0_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit1                  = Si2168_DD_INT_SENSE_PROP_POS_BIT1_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit2                  = Si2168_DD_INT_SENSE_PROP_POS_BIT2_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit3                  = Si2168_DD_INT_SENSE_PROP_POS_BIT3_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit4                  = Si2168_DD_INT_SENSE_PROP_POS_BIT4_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit5                  = Si2168_DD_INT_SENSE_PROP_POS_BIT5_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit6                  = Si2168_DD_INT_SENSE_PROP_POS_BIT6_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_int_sense.pos_bit7                  = Si2168_DD_INT_SENSE_PROP_POS_BIT7_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dd_mode.bw                             = Si2168_DD_MODE_PROP_BW_BW_8MHZ              ; /* (default 'BW_8MHZ') */
+	api->prop->dd_mode.modulation                     = Si2168_DD_MODE_PROP_MODULATION_DVBT         ; /* (default 'DVBT') */
+	api->prop->dd_mode.invert_spectrum                = Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL  ; /* (default 'NORMAL') */
+	api->prop->dd_mode.auto_detect                    = Si2168_DD_MODE_PROP_AUTO_DETECT_NONE        ; /* (default 'NONE') */
+	api->prop->dd_per_resol.exp                       =     5; /* (default     5) */
+	api->prop->dd_per_resol.mant                      =     1; /* (default     1) */
+	api->prop->dd_rsq_ber_threshold.exp               =     1; /* (default     1) */
+	api->prop->dd_rsq_ber_threshold.mant              =    10; /* (default    10) */
+	api->prop->dd_ssi_sqi_param.sqi_average           =    16; /* (default     1) */
+	api->prop->dd_ts_freq.req_freq_10khz              =   720; /* (default   720) */
+	api->prop->dd_ts_mode.mode                        = Si2168_DD_TS_MODE_PROP_MODE_TRISTATE            ; /* (default 'TRISTATE') */
+	api->prop->dd_ts_mode.clock                       = Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_FIXED         ; /* (default 'AUTO_FIXED') */
+	api->prop->dd_ts_mode.clk_gapped_en               = Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED   ; /* (default 'DISABLED') */
+	api->prop->dd_ts_setup_par.ts_data_strength       =     7; /* (default     3) */
+	api->prop->dd_ts_setup_par.ts_data_shape          =     1; /* (default     1) */
+	api->prop->dd_ts_setup_par.ts_clk_strength        =     7; /* (default     3) */
+	api->prop->dd_ts_setup_par.ts_clk_shape           =     1; /* (default     1) */
+	api->prop->dd_ts_setup_par.ts_clk_invert          = Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED    ; /* (default 'INVERTED') */
+	api->prop->dd_ts_setup_par.ts_clk_shift           =     0; /* (default     0) */
+	api->prop->dd_ts_setup_ser.ts_data_strength       =    15; /* (default    15) */
+	api->prop->dd_ts_setup_ser.ts_data_shape          =     3; /* (default     3) */
+	api->prop->dd_ts_setup_ser.ts_clk_strength        =    15; /* (default    15) */
+	api->prop->dd_ts_setup_ser.ts_clk_shape           =     3; /* (default     3) */
+	api->prop->dd_ts_setup_ser.ts_clk_invert          = Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED      ; /* (default 'INVERTED') */
+	api->prop->dd_ts_setup_ser.ts_sync_duration       = Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BYTE ; /* (default 'FIRST_BYTE') */
+	api->prop->dd_ts_setup_ser.ts_byte_order          = Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST     ; /* (default 'MSB_FIRST') */
+};
+
+void Si2168_setupDVBCDefaults(L1_Si2168_Context *api)
+{
+	api->prop->dvbc_adc_crest_factor.crest_factor     =   112; /* (default   112) */
+	api->prop->dvbc_afc_range.range_khz               =   100; /* (default   100) */
+	api->prop->dvbc_constellation.constellation       = Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO ; /* (default 'AUTO') */
+	api->prop->dvbc_symbol_rate.rate                  =  6900; /* (default  6900) */
+};
+
+void Si2168_setupDVBTDefaults(L1_Si2168_Context *api)
+{
+	api->prop->dvbt_adc_crest_factor.crest_factor     =   130; /* (default   130) */
+	api->prop->dvbt_afc_range.range_khz               =   550; /* (default   550) */
+	api->prop->dvbt_hierarchy.stream                  = Si2168_DVBT_HIERARCHY_PROP_STREAM_HP ; /* (default 'HP') */
+};
+
+void Si2168_setupDVBT2Defaults(L1_Si2168_Context *api)
+{
+	api->prop->dvbt2_adc_crest_factor.crest_factor    =   130; /* (default   130) */
+	api->prop->dvbt2_afc_range.range_khz              =   550; /* (default   550) */
+	api->prop->dvbt2_fef_tuner.tuner_delay            =     0; /* (default     0) */
+	api->prop->dvbt2_fef_tuner.tuner_freeze_time      =     0; /* (default     0) */
+	api->prop->dvbt2_fef_tuner.tuner_unfreeze_time    =     0; /* (default     0) */
+};
+
+void Si2168_setupSCANDefaults(L1_Si2168_Context *api)
+{
+	api->prop->scan_fmax.scan_fmax                    =     0; /* (default     0) */
+	api->prop->scan_fmin.scan_fmin                    =     0; /* (default     0) */
+	api->prop->scan_ien.buzien                        = Si2168_SCAN_IEN_PROP_BUZIEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->scan_ien.reqien                        = Si2168_SCAN_IEN_PROP_REQIEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->scan_int_sense.buznegen                = Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE  ; /* (default 'ENABLE') */
+	api->prop->scan_int_sense.reqnegen                = Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->scan_int_sense.buzposen                = Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->scan_int_sense.reqposen                = Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE  ; /* (default 'ENABLE') */
+	api->prop->scan_symb_rate_max.scan_symb_rate_max  =     0; /* (default     0) */
+	api->prop->scan_symb_rate_min.scan_symb_rate_min  =     0; /* (default     0) */
+	api->prop->scan_ter_config.mode                   = Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN          ; /* (default 'BLIND_SCAN') */
+	api->prop->scan_ter_config.analog_bw              = Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ           ; /* (default '8MHZ') */
+	api->prop->scan_ter_config.search_analog          = Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE    ; /* (default 'DISABLE') */
+};
+
+void Si2168_setupAllDefaults(L1_Si2168_Context *api)
+{
+	Si2168_setupCOMMONDefaults    (api);
+	Si2168_setupDDDefaults        (api);
+	Si2168_setupDVBCDefaults      (api);
+	Si2168_setupDVBTDefaults      (api);
+	Si2168_setupDVBT2Defaults     (api);
+	Si2168_setupSCANDefaults      (api);
+};
+
+unsigned char Si2168_L1_SetProperty(L1_Si2168_Context *api, unsigned int prop, int  data)
+{
+	unsigned char  reserved          = 0;
+	return Si2168_L1_SET_PROPERTY (api, reserved, prop, data);
+}
+
+unsigned char Si2168_L1_SetProperty2(L1_Si2168_Context *api, unsigned int prop_code)
+{
+    int data;
+    switch (prop_code) {
+    #ifdef        Si2168_DD_BER_RESOL_PROP
+     case         Si2168_DD_BER_RESOL_PROP_CODE:
+       data = (api->prop->dd_ber_resol.exp  & Si2168_DD_BER_RESOL_PROP_EXP_MASK ) << Si2168_DD_BER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_ber_resol.mant & Si2168_DD_BER_RESOL_PROP_MANT_MASK) << Si2168_DD_BER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_BER_RESOL_PROP */
+    #ifdef        Si2168_DD_CBER_RESOL_PROP
+     case         Si2168_DD_CBER_RESOL_PROP_CODE:
+       data = (api->prop->dd_cber_resol.exp  & Si2168_DD_CBER_RESOL_PROP_EXP_MASK ) << Si2168_DD_CBER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_cber_resol.mant & Si2168_DD_CBER_RESOL_PROP_MANT_MASK) << Si2168_DD_CBER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_CBER_RESOL_PROP */
+
+    #ifdef        Si2168_DD_FER_RESOL_PROP
+     case         Si2168_DD_FER_RESOL_PROP_CODE:
+       data = (api->prop->dd_fer_resol.exp  & Si2168_DD_FER_RESOL_PROP_EXP_MASK ) << Si2168_DD_FER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_fer_resol.mant & Si2168_DD_FER_RESOL_PROP_MANT_MASK) << Si2168_DD_FER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_FER_RESOL_PROP */
+    #ifdef        Si2168_DD_IEN_PROP
+     case         Si2168_DD_IEN_PROP_CODE:
+       data = (api->prop->dd_ien.ien_bit0 & Si2168_DD_IEN_PROP_IEN_BIT0_MASK) << Si2168_DD_IEN_PROP_IEN_BIT0_LSB  |
+              (api->prop->dd_ien.ien_bit1 & Si2168_DD_IEN_PROP_IEN_BIT1_MASK) << Si2168_DD_IEN_PROP_IEN_BIT1_LSB  |
+              (api->prop->dd_ien.ien_bit2 & Si2168_DD_IEN_PROP_IEN_BIT2_MASK) << Si2168_DD_IEN_PROP_IEN_BIT2_LSB  |
+              (api->prop->dd_ien.ien_bit3 & Si2168_DD_IEN_PROP_IEN_BIT3_MASK) << Si2168_DD_IEN_PROP_IEN_BIT3_LSB  |
+              (api->prop->dd_ien.ien_bit4 & Si2168_DD_IEN_PROP_IEN_BIT4_MASK) << Si2168_DD_IEN_PROP_IEN_BIT4_LSB  |
+              (api->prop->dd_ien.ien_bit5 & Si2168_DD_IEN_PROP_IEN_BIT5_MASK) << Si2168_DD_IEN_PROP_IEN_BIT5_LSB  |
+              (api->prop->dd_ien.ien_bit6 & Si2168_DD_IEN_PROP_IEN_BIT6_MASK) << Si2168_DD_IEN_PROP_IEN_BIT6_LSB  |
+              (api->prop->dd_ien.ien_bit7 & Si2168_DD_IEN_PROP_IEN_BIT7_MASK) << Si2168_DD_IEN_PROP_IEN_BIT7_LSB ;
+     break;
+    #endif /*     Si2168_DD_IEN_PROP */
+    #ifdef        Si2168_DD_IF_INPUT_FREQ_PROP
+     case         Si2168_DD_IF_INPUT_FREQ_PROP_CODE:
+       data = (api->prop->dd_if_input_freq.offset & Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK) << Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2168_DD_IF_INPUT_FREQ_PROP */
+    #ifdef        Si2168_DD_INT_SENSE_PROP
+     case         Si2168_DD_INT_SENSE_PROP_CODE:
+       data = (api->prop->dd_int_sense.neg_bit0 & Si2168_DD_INT_SENSE_PROP_NEG_BIT0_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT0_LSB  |
+              (api->prop->dd_int_sense.neg_bit1 & Si2168_DD_INT_SENSE_PROP_NEG_BIT1_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT1_LSB  |
+              (api->prop->dd_int_sense.neg_bit2 & Si2168_DD_INT_SENSE_PROP_NEG_BIT2_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT2_LSB  |
+              (api->prop->dd_int_sense.neg_bit3 & Si2168_DD_INT_SENSE_PROP_NEG_BIT3_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT3_LSB  |
+              (api->prop->dd_int_sense.neg_bit4 & Si2168_DD_INT_SENSE_PROP_NEG_BIT4_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT4_LSB  |
+              (api->prop->dd_int_sense.neg_bit5 & Si2168_DD_INT_SENSE_PROP_NEG_BIT5_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT5_LSB  |
+              (api->prop->dd_int_sense.neg_bit6 & Si2168_DD_INT_SENSE_PROP_NEG_BIT6_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT6_LSB  |
+              (api->prop->dd_int_sense.neg_bit7 & Si2168_DD_INT_SENSE_PROP_NEG_BIT7_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT7_LSB  |
+              (api->prop->dd_int_sense.pos_bit0 & Si2168_DD_INT_SENSE_PROP_POS_BIT0_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT0_LSB  |
+              (api->prop->dd_int_sense.pos_bit1 & Si2168_DD_INT_SENSE_PROP_POS_BIT1_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT1_LSB  |
+              (api->prop->dd_int_sense.pos_bit2 & Si2168_DD_INT_SENSE_PROP_POS_BIT2_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT2_LSB  |
+              (api->prop->dd_int_sense.pos_bit3 & Si2168_DD_INT_SENSE_PROP_POS_BIT3_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT3_LSB  |
+              (api->prop->dd_int_sense.pos_bit4 & Si2168_DD_INT_SENSE_PROP_POS_BIT4_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT4_LSB  |
+              (api->prop->dd_int_sense.pos_bit5 & Si2168_DD_INT_SENSE_PROP_POS_BIT5_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT5_LSB  |
+              (api->prop->dd_int_sense.pos_bit6 & Si2168_DD_INT_SENSE_PROP_POS_BIT6_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT6_LSB  |
+              (api->prop->dd_int_sense.pos_bit7 & Si2168_DD_INT_SENSE_PROP_POS_BIT7_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT7_LSB ;
+     break;
+    #endif /*     Si2168_DD_INT_SENSE_PROP */
+    #ifdef        Si2168_DD_MODE_PROP
+     case         Si2168_DD_MODE_PROP_CODE:
+       data = (api->prop->dd_mode.bw              & Si2168_DD_MODE_PROP_BW_MASK             ) << Si2168_DD_MODE_PROP_BW_LSB  |
+              (api->prop->dd_mode.modulation      & Si2168_DD_MODE_PROP_MODULATION_MASK     ) << Si2168_DD_MODE_PROP_MODULATION_LSB  |
+              (api->prop->dd_mode.invert_spectrum & Si2168_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168_DD_MODE_PROP_INVERT_SPECTRUM_LSB  |
+              (api->prop->dd_mode.auto_detect     & Si2168_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168_DD_MODE_PROP_AUTO_DETECT_LSB ;
+     break;
+    #endif /*     Si2168_DD_MODE_PROP */
+    #ifdef        Si2168_DD_PER_RESOL_PROP
+     case         Si2168_DD_PER_RESOL_PROP_CODE:
+       data = (api->prop->dd_per_resol.exp  & Si2168_DD_PER_RESOL_PROP_EXP_MASK ) << Si2168_DD_PER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_per_resol.mant & Si2168_DD_PER_RESOL_PROP_MANT_MASK) << Si2168_DD_PER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_PER_RESOL_PROP */
+    #ifdef        Si2168_DD_RSQ_BER_THRESHOLD_PROP
+     case         Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE:
+       data = (api->prop->dd_rsq_ber_threshold.exp  & Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK ) << Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB  |
+              (api->prop->dd_rsq_ber_threshold.mant & Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK) << Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+    #ifdef        Si2168_DD_SSI_SQI_PARAM_PROP
+     case         Si2168_DD_SSI_SQI_PARAM_PROP_CODE:
+       data = (api->prop->dd_ssi_sqi_param.sqi_average & Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_MASK) << Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_LSB ;
+     break;
+    #endif /*     Si2168_DD_SSI_SQI_PARAM_PROP */
+    #ifdef        Si2168_DD_TS_FREQ_PROP
+     case         Si2168_DD_TS_FREQ_PROP_CODE:
+       data = (api->prop->dd_ts_freq.req_freq_10khz & Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK) << Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_FREQ_PROP */
+    #ifdef        Si2168_DD_TS_MODE_PROP
+     case         Si2168_DD_TS_MODE_PROP_CODE:
+       data = (api->prop->dd_ts_mode.mode          & Si2168_DD_TS_MODE_PROP_MODE_MASK         ) << Si2168_DD_TS_MODE_PROP_MODE_LSB  |
+              (api->prop->dd_ts_mode.clock         & Si2168_DD_TS_MODE_PROP_CLOCK_MASK        ) << Si2168_DD_TS_MODE_PROP_CLOCK_LSB  |
+              (api->prop->dd_ts_mode.clk_gapped_en & Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK) << Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_MODE_PROP */
+    #ifdef        Si2168_DD_TS_SETUP_PAR_PROP
+     case         Si2168_DD_TS_SETUP_PAR_PROP_CODE:
+       data = (api->prop->dd_ts_setup_par.ts_data_strength & Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK) << Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_par.ts_data_shape    & Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK   ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_strength  & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_shape     & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK    ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_invert    & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK   ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_shift     & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK    ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_SETUP_PAR_PROP */
+    #ifdef        Si2168_DD_TS_SETUP_SER_PROP
+     case         Si2168_DD_TS_SETUP_SER_PROP_CODE:
+       data = (api->prop->dd_ts_setup_ser.ts_data_strength & Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK) << Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_data_shape    & Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_strength  & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_shape     & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK    ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_invert    & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_sync_duration & Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK) << Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_byte_order    & Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_SETUP_SER_PROP */
+    #ifdef        Si2168_DVBC_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbc_adc_crest_factor.crest_factor & Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBC_AFC_RANGE_PROP
+     case         Si2168_DVBC_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbc_afc_range.range_khz & Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBC_CONSTELLATION_PROP
+     case         Si2168_DVBC_CONSTELLATION_PROP_CODE:
+       data = (api->prop->dvbc_constellation.constellation & Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_CONSTELLATION_PROP */
+    #ifdef        Si2168_DVBC_SYMBOL_RATE_PROP
+     case         Si2168_DVBC_SYMBOL_RATE_PROP_CODE:
+       data = (api->prop->dvbc_symbol_rate.rate & Si2168_DVBC_SYMBOL_RATE_PROP_RATE_MASK) << Si2168_DVBC_SYMBOL_RATE_PROP_RATE_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+    #ifdef        Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbt2_adc_crest_factor.crest_factor & Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBT2_AFC_RANGE_PROP
+     case         Si2168_DVBT2_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbt2_afc_range.range_khz & Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBT2_FEF_TUNER_PROP
+     case         Si2168_DVBT2_FEF_TUNER_PROP_CODE:
+       data = (api->prop->dvbt2_fef_tuner.tuner_delay         & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        ) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB  |
+              (api->prop->dvbt2_fef_tuner.tuner_freeze_time   & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK  ) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB  |
+              (api->prop->dvbt2_fef_tuner.tuner_unfreeze_time & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_FEF_TUNER_PROP */
+
+    #ifdef        Si2168_DVBT_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbt_adc_crest_factor.crest_factor & Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBT_AFC_RANGE_PROP
+     case         Si2168_DVBT_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbt_afc_range.range_khz & Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBT_HIERARCHY_PROP
+     case         Si2168_DVBT_HIERARCHY_PROP_CODE:
+       data = (api->prop->dvbt_hierarchy.stream & Si2168_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168_DVBT_HIERARCHY_PROP_STREAM_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_HIERARCHY_PROP */
+
+    #ifdef        Si2168_MASTER_IEN_PROP
+     case         Si2168_MASTER_IEN_PROP_CODE:
+       data = (api->prop->master_ien.ddien   & Si2168_MASTER_IEN_PROP_DDIEN_MASK  ) << Si2168_MASTER_IEN_PROP_DDIEN_LSB  |
+              (api->prop->master_ien.scanien & Si2168_MASTER_IEN_PROP_SCANIEN_MASK) << Si2168_MASTER_IEN_PROP_SCANIEN_LSB  |
+              (api->prop->master_ien.errien  & Si2168_MASTER_IEN_PROP_ERRIEN_MASK ) << Si2168_MASTER_IEN_PROP_ERRIEN_LSB  |
+              (api->prop->master_ien.ctsien  & Si2168_MASTER_IEN_PROP_CTSIEN_MASK ) << Si2168_MASTER_IEN_PROP_CTSIEN_LSB ;
+     break;
+    #endif /*     Si2168_MASTER_IEN_PROP */
+    #ifdef        Si2168_SCAN_FMAX_PROP
+     case         Si2168_SCAN_FMAX_PROP_CODE:
+       data = (api->prop->scan_fmax.scan_fmax & Si2168_SCAN_FMAX_PROP_SCAN_FMAX_MASK) << Si2168_SCAN_FMAX_PROP_SCAN_FMAX_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_FMAX_PROP */
+    #ifdef        Si2168_SCAN_FMIN_PROP
+     case         Si2168_SCAN_FMIN_PROP_CODE:
+       data = (api->prop->scan_fmin.scan_fmin & Si2168_SCAN_FMIN_PROP_SCAN_FMIN_MASK) << Si2168_SCAN_FMIN_PROP_SCAN_FMIN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_FMIN_PROP */
+    #ifdef        Si2168_SCAN_IEN_PROP
+     case         Si2168_SCAN_IEN_PROP_CODE:
+       data = (api->prop->scan_ien.buzien & Si2168_SCAN_IEN_PROP_BUZIEN_MASK) << Si2168_SCAN_IEN_PROP_BUZIEN_LSB  |
+              (api->prop->scan_ien.reqien & Si2168_SCAN_IEN_PROP_REQIEN_MASK) << Si2168_SCAN_IEN_PROP_REQIEN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_IEN_PROP */
+    #ifdef        Si2168_SCAN_INT_SENSE_PROP
+     case         Si2168_SCAN_INT_SENSE_PROP_CODE:
+       data = (api->prop->scan_int_sense.buznegen & Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB  |
+              (api->prop->scan_int_sense.reqnegen & Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_LSB  |
+              (api->prop->scan_int_sense.buzposen & Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB  |
+              (api->prop->scan_int_sense.reqposen & Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_INT_SENSE_PROP */
+
+    #ifdef        Si2168_SCAN_SYMB_RATE_MAX_PROP
+     case         Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE:
+       data = (api->prop->scan_symb_rate_max.scan_symb_rate_max & Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK) << Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_SYMB_RATE_MAX_PROP */
+    #ifdef        Si2168_SCAN_SYMB_RATE_MIN_PROP
+     case         Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE:
+       data = (api->prop->scan_symb_rate_min.scan_symb_rate_min & Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK) << Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_SYMB_RATE_MIN_PROP */
+    #ifdef        Si2168_SCAN_TER_CONFIG_PROP
+     case         Si2168_SCAN_TER_CONFIG_PROP_CODE:
+       data = (api->prop->scan_ter_config.mode          & Si2168_SCAN_TER_CONFIG_PROP_MODE_MASK         ) << Si2168_SCAN_TER_CONFIG_PROP_MODE_LSB  |
+              (api->prop->scan_ter_config.analog_bw     & Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK    ) << Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB  |
+              (api->prop->scan_ter_config.search_analog & Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK) << Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB;
+     break;
+    #endif /*     Si2168_SCAN_TER_CONFIG_PROP */
+
+   default : break;
+    }
+    return Si2168_L1_SetProperty(api, prop_code & 0xffff , data);
+}
+
+int  Si2168_downloadCOMMONProperties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_MASTER_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_MASTER_IEN_PROP_CODE            ) != 0) {return 3;}
+#endif /* Si2168_MASTER_IEN_PROP */
+return 0;
+};
+
+int  Si2168_downloadDDProperties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_DD_BER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_BER_RESOL_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2168_DD_BER_RESOL_PROP */
+#ifdef    Si2168_DD_CBER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_CBER_RESOL_PROP_CODE         ) != 0) {return 3;}
+#endif /* Si2168_DD_CBER_RESOL_PROP */
+
+#ifdef    Si2168_DD_FER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_FER_RESOL_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2168_DD_FER_RESOL_PROP */
+#ifdef    Si2168_DD_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_IEN_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2168_DD_IEN_PROP */
+#ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_IF_INPUT_FREQ_PROP_CODE      ) != 0) {return 3;}
+#endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+#ifdef    Si2168_DD_INT_SENSE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_INT_SENSE_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2168_DD_INT_SENSE_PROP */
+#ifdef    Si2168_DD_MODE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_MODE_PROP_CODE               ) != 0) {return 3;}
+#endif /* Si2168_DD_MODE_PROP */
+#ifdef    Si2168_DD_PER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_PER_RESOL_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2168_DD_PER_RESOL_PROP */
+#ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE  ) != 0) {return 3;}
+#endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+#ifdef    Si2168_DD_SSI_SQI_PARAM_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_SSI_SQI_PARAM_PROP_CODE      ) != 0) {return 3;}
+#endif /* Si2168_DD_SSI_SQI_PARAM_PROP */
+#ifdef    Si2168_DD_TS_FREQ_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_FREQ_PROP_CODE            ) != 0) {return 3;}
+#endif /* Si2168_DD_TS_FREQ_PROP */
+#ifdef    Si2168_DD_TS_MODE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_MODE_PROP_CODE            ) != 0) {return 3;}
+#endif /* Si2168_DD_TS_MODE_PROP */
+#ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_SETUP_PAR_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+#ifdef    Si2168_DD_TS_SETUP_SER_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_SETUP_SER_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2168_DD_TS_SETUP_SER_PROP */
+return 0;
+};
+
+int  Si2168_downloadDVBCProperties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE ) != 0) {return 3;}
+#endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBC_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_AFC_RANGE_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2168_DVBC_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBC_CONSTELLATION_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_CONSTELLATION_PROP_CODE    ) != 0) {return 3;}
+#endif /* Si2168_DVBC_CONSTELLATION_PROP */
+#ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_SYMBOL_RATE_PROP_CODE      ) != 0) {return 3;}
+#endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+return 0;
+};
+
+int  Si2168_downloadDVBTProperties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE ) != 0) {return 3;}
+#endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBT_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_AFC_RANGE_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2168_DVBT_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBT_HIERARCHY_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_HIERARCHY_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2168_DVBT_HIERARCHY_PROP */
+return 0;
+};
+
+int  Si2168_downloadDVBT2Properties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE) != 0) {return 3;}
+#endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_AFC_RANGE_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_FEF_TUNER_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+return 0;
+};
+
+int  Si2168_downloadSCANProperties(L1_Si2168_Context *api)
+{
+#ifdef    Si2168_SCAN_FMAX_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_FMAX_PROP_CODE             ) != 0) {return 3;}
+#endif /* Si2168_SCAN_FMAX_PROP */
+#ifdef    Si2168_SCAN_FMIN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_FMIN_PROP_CODE             ) != 0) {return 3;}
+#endif /* Si2168_SCAN_FMIN_PROP */
+#ifdef    Si2168_SCAN_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_IEN_PROP_CODE              ) != 0) {return 3;}
+#endif /* Si2168_SCAN_IEN_PROP */
+#ifdef    Si2168_SCAN_INT_SENSE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_INT_SENSE_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE    ) != 0) {return 3;}
+#endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+#ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE    ) != 0) {return 3;}
+#endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+#ifdef    Si2168_SCAN_TER_CONFIG_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_TER_CONFIG_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2168_SCAN_TER_CONFIG_PROP */
+return 0;
+};
+
+int Si2168_downloadAllProperties(L1_Si2168_Context *api)
+{
+	Si2168_downloadCOMMONProperties    (api);
+	Si2168_downloadDDProperties        (api);
+	if (api->media == Si2168_TERRESTRIAL)
+		Si2168_downloadDVBCProperties      (api);
+	if (api->media == Si2168_TERRESTRIAL)
+		Si2168_downloadDVBTProperties      (api);
+	if (api->media == Si2168_TERRESTRIAL)
+		Si2168_downloadDVBT2Properties     (api);
+	Si2168_downloadSCANProperties      (api);
+	return 0;
+};
+
+int Si2168_Configure(L1_Si2168_Context *api)
+{
+	int return_code;
+	return_code = 0;
+	// AGC settings when not used
+	api->cmd->dd_mp_defaults.mp_a_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE;
+	api->cmd->dd_mp_defaults.mp_b_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE;
+	api->cmd->dd_mp_defaults.mp_c_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE;
+	api->cmd->dd_mp_defaults.mp_d_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE;
+	Si2168_L1_SendCommand2(api, Si2168_DD_MP_DEFAULTS_CMD_CODE);
+	// LEDS MANAGEMENT
+	// set hardware lock on green LED
+	api->cmd->config_pins.gpio0_mode     = Si2168_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK;
+	api->cmd->config_pins.gpio0_read     = Si2168_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ;
+	if (api->media == Si2168_TERRESTRIAL)
+	{
+		/* Settings for TER AGC. These settings need to match the HW design for TER AGCs */
+		api->cmd->dd_ext_agc_ter.agc_1_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NOT_USED;
+		#ifdef    Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_1_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_INVERTED;
+		#else  // Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_1_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED;
+		#endif // Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_1_kloop = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN;
+		api->cmd->dd_ext_agc_ter.agc_1_min   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN;
+
+		api->cmd->dd_ext_agc_ter.agc_2_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_A;
+		#ifdef    Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_2_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_INVERTED;
+		#else  // Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_2_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED;
+		#endif // Si2168_TER_AGC_INVERTED
+		api->cmd->dd_ext_agc_ter.agc_2_kloop = 18;
+		api->cmd->dd_ext_agc_ter.agc_2_min   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN;
+		Si2168_L1_SendCommand2(api, Si2168_DD_EXT_AGC_TER_CMD_CODE);
+		// SET FEF capability ON MP_B pins and Active HIGH
+		api->cmd->dvbt2_fef.fef_tuner_flag      = Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B;
+		api->cmd->dvbt2_fef.fef_tuner_flag_inv  = Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH;
+		Si2168_L1_SendCommand2(api, Si2168_DVBT2_FEF_CMD_CODE);
+	}
+	api->cmd->config_pins.gpio1_mode     = Si2168_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR;
+	api->cmd->config_pins.gpio1_read     = Si2168_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;
+	Si2168_L1_SendCommand2(api, Si2168_CONFIG_PINS_CMD_CODE);
+	// Set All Properties startup configuration
+	Si2168_setupAllDefaults     (api);
+	// TS settings in parallel
+	//api->prop->dd_ts_mode.mode           = Si2168_DD_TS_MODE_PROP_MODE_PARALLEL;
+	// TS settings in serial
+	api->prop->dd_ts_mode.mode           = Si2168_DD_TS_MODE_PROP_MODE_SERIAL;
+	api->prop->dd_ts_mode.clock          = Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT;
+	Si2168_downloadAllProperties(api);
+	// Setting GPIF clock to not_inverted to allow TS over USB transfer
+	Si2168_L1_DD_SET_REG  (api, 0 , 35, 1, 0);
+	return return_code;
+}
+
+unsigned char Si2146_CurrentResponseStatus(L1_Si2146_Context *api, unsigned char ptDataBuffer)
+{
+	api->status->tunint = ((ptDataBuffer >> 0 ) & 0x01);
+	api->status->atvint = ((ptDataBuffer >> 1 ) & 0x01);
+	api->status->dtvint = ((ptDataBuffer >> 2 ) & 0x01);
+	api->status->err    = ((ptDataBuffer >> 6 ) & 0x01);
+	api->status->cts    = ((ptDataBuffer >> 7 ) & 0x01);
+	return (api->status->err ? 5 : 0);
+}
+
+unsigned char Si2148_CurrentResponseStatus(L1_Si2148_Context *api, unsigned char ptDataBuffer)
+{
+	api->status->tunint = ((ptDataBuffer >> 0 ) & 0x01);
+	api->status->atvint = ((ptDataBuffer >> 1 ) & 0x01);
+	api->status->dtvint = ((ptDataBuffer >> 2 ) & 0x01);
+	api->status->err    = ((ptDataBuffer >> 6 ) & 0x01);
+	api->status->cts    = ((ptDataBuffer >> 7 ) & 0x01);
+	return (api->status->err ? 5 : 0);
+}
+
+unsigned char Si2146_pollForResponse (L1_Si2146_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer)
+{
+	int i;
+	for(i=0;i<100;i++)
+	{
+		ReadI2C(api->addr,nbBytes,pByteBuffer);
+		//printk("%x,%d,%x\n",api->addr,nbBytes,pByteBuffer[0]);
+		// return response err flag if CTS set
+		if (pByteBuffer[0] & 0x80)
+			return Si2146_CurrentResponseStatus(api, pByteBuffer[0]);
+		MyDelay(10);
+	}
+	return 4;
+}
+
+unsigned char Si2148_pollForResponse (L1_Si2148_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer)
+{
+	int i;
+	for(i=0;i<100;i++)
+	{
+		ReadI2C(api->addr,nbBytes,pByteBuffer);
+		//printk("%x,%d,%x\n",api->addr,nbBytes,pByteBuffer[0]);
+		// return response err flag if CTS set
+		if (pByteBuffer[0] & 0x80)
+			return Si2148_CurrentResponseStatus(api, pByteBuffer[0]);
+		MyDelay(10);
+	}
+	return 4;
+}
+
+unsigned char Si2146_L1_SET_PROPERTY(L1_Si2146_Context *api,unsigned char   reserved,unsigned int    prop,unsigned int    data)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[6];
+	unsigned char rspByteBuffer[4];
+	api->rsp->set_property.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_SET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2146_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2146_SET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2146_SET_PROPERTY_CMD_PROP_MASK     ) << Si2146_SET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2146_SET_PROPERTY_CMD_PROP_MASK     ) << Si2146_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+	cmdByteBuffer[4] = (unsigned char) ( ( data     & Si2146_SET_PROPERTY_CMD_DATA_MASK     ) << Si2146_SET_PROPERTY_CMD_DATA_LSB    );
+	cmdByteBuffer[5] = (unsigned char) ((( data     & Si2146_SET_PROPERTY_CMD_DATA_MASK     ) << Si2146_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+	WriteI2C(api->addr,6,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 4, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->set_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2146_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2146_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+	api->rsp->set_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2146_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2146_SET_PROPERTY_RESPONSE_DATA_MASK     );
+	return 0;
+}
+
+unsigned char Si2146_L1_SetProperty(L1_Si2146_Context *api, unsigned int prop, int  data)
+{
+    unsigned char  reserved          = 0;
+    return Si2146_L1_SET_PROPERTY (api, reserved, prop, data);
+}
+
+unsigned char Si2148_L1_SET_PROPERTY    (L1_Si2148_Context *api,unsigned char   reserved,unsigned int    prop,unsigned int    data)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[6];
+	unsigned char rspByteBuffer[4];
+	api->rsp->set_property.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_SET_PROPERTY_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2148_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2148_SET_PROPERTY_CMD_RESERVED_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2148_SET_PROPERTY_CMD_PROP_MASK     ) << Si2148_SET_PROPERTY_CMD_PROP_LSB    );
+	cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2148_SET_PROPERTY_CMD_PROP_MASK     ) << Si2148_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+	cmdByteBuffer[4] = (unsigned char) ( ( data     & Si2148_SET_PROPERTY_CMD_DATA_MASK     ) << Si2148_SET_PROPERTY_CMD_DATA_LSB    );
+	cmdByteBuffer[5] = (unsigned char) ((( data     & Si2148_SET_PROPERTY_CMD_DATA_MASK     ) << Si2148_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+	WriteI2C(api->addr,6,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 4, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->set_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2148_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2148_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+	api->rsp->set_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2148_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2148_SET_PROPERTY_RESPONSE_DATA_MASK     );
+	return 0;
+}
+
+unsigned char Si2148_L1_SetProperty(L1_Si2148_Context *api, unsigned int prop, int  data)
+{
+    unsigned char  reserved          = 0;
+    return Si2148_L1_SET_PROPERTY (api, reserved, prop, data);
+}
+
+unsigned char Si2146_L1_SetProperty2(L1_Si2146_Context *api, unsigned int prop_code) {
+    int data;
+    switch (prop_code) {
+    #ifdef        Si2146_ATV_AFC_RANGE_PROP
+     case         Si2146_ATV_AFC_RANGE_PROP_CODE:
+       data = (api->prop->atv_afc_range.range_khz & Si2146_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2146_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2146_ATV_AFC_RANGE_PROP */
+    #ifdef        Si2146_ATV_AF_OUT_PROP
+     case         Si2146_ATV_AF_OUT_PROP_CODE:
+       data = (api->prop->atv_af_out.volume & Si2146_ATV_AF_OUT_PROP_VOLUME_MASK) << Si2146_ATV_AF_OUT_PROP_VOLUME_LSB ;
+     break;
+    #endif /*     Si2146_ATV_AF_OUT_PROP */
+    #ifdef        Si2146_ATV_AGC_SPEED_PROP
+     case         Si2146_ATV_AGC_SPEED_PROP_CODE:
+       data = (api->prop->atv_agc_speed.if_agc_speed & Si2146_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2146_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+     break;
+    #endif /*     Si2146_ATV_AGC_SPEED_PROP */
+    #ifdef        Si2146_ATV_AUDIO_MODE_PROP
+     case         Si2146_ATV_AUDIO_MODE_PROP_CODE:
+       data = (api->prop->atv_audio_mode.audio_sys  & Si2146_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK ) << Si2146_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB  |
+              (api->prop->atv_audio_mode.demod_mode & Si2146_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK) << Si2146_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB  |
+              (api->prop->atv_audio_mode.chan_bw    & Si2146_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << Si2146_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+     break;
+    #endif /*     Si2146_ATV_AUDIO_MODE_PROP */
+    #ifdef        Si2146_ATV_CVBS_OUT_PROP
+     case         Si2146_ATV_CVBS_OUT_PROP_CODE:
+       data = (api->prop->atv_cvbs_out.offset & Si2146_ATV_CVBS_OUT_PROP_OFFSET_MASK) << Si2146_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+              (api->prop->atv_cvbs_out.amp    & Si2146_ATV_CVBS_OUT_PROP_AMP_MASK   ) << Si2146_ATV_CVBS_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2146_ATV_CVBS_OUT_PROP */
+    #ifdef        Si2146_ATV_CVBS_OUT_FINE_PROP
+     case         Si2146_ATV_CVBS_OUT_FINE_PROP_CODE:
+       data = (api->prop->atv_cvbs_out_fine.offset & Si2146_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << Si2146_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+              (api->prop->atv_cvbs_out_fine.amp    & Si2146_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << Si2146_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2146_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef        Si2146_ATV_IEN_PROP
+     case         Si2146_ATV_IEN_PROP_CODE:
+       data = (api->prop->atv_ien.chlien  & Si2146_ATV_IEN_PROP_CHLIEN_MASK ) << Si2146_ATV_IEN_PROP_CHLIEN_LSB  |
+              (api->prop->atv_ien.pclien  & Si2146_ATV_IEN_PROP_PCLIEN_MASK ) << Si2146_ATV_IEN_PROP_PCLIEN_LSB  |
+              (api->prop->atv_ien.dlien   & Si2146_ATV_IEN_PROP_DLIEN_MASK  ) << Si2146_ATV_IEN_PROP_DLIEN_LSB  |
+              (api->prop->atv_ien.snrlien & Si2146_ATV_IEN_PROP_SNRLIEN_MASK) << Si2146_ATV_IEN_PROP_SNRLIEN_LSB  |
+              (api->prop->atv_ien.snrhien & Si2146_ATV_IEN_PROP_SNRHIEN_MASK) << Si2146_ATV_IEN_PROP_SNRHIEN_LSB ;
+     break;
+    #endif /*     Si2146_ATV_IEN_PROP */
+    #ifdef        Si2146_ATV_INT_SENSE_PROP
+     case         Si2146_ATV_INT_SENSE_PROP_CODE:
+       data = (api->prop->atv_int_sense.chlnegen  & Si2146_ATV_INT_SENSE_PROP_CHLNEGEN_MASK ) << Si2146_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+              (api->prop->atv_int_sense.pclnegen  & Si2146_ATV_INT_SENSE_PROP_PCLNEGEN_MASK ) << Si2146_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+              (api->prop->atv_int_sense.dlnegen   & Si2146_ATV_INT_SENSE_PROP_DLNEGEN_MASK  ) << Si2146_ATV_INT_SENSE_PROP_DLNEGEN_LSB  |
+              (api->prop->atv_int_sense.snrlnegen & Si2146_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK) << Si2146_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB  |
+              (api->prop->atv_int_sense.snrhnegen & Si2146_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK) << Si2146_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB  |
+              (api->prop->atv_int_sense.chlposen  & Si2146_ATV_INT_SENSE_PROP_CHLPOSEN_MASK ) << Si2146_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+              (api->prop->atv_int_sense.pclposen  & Si2146_ATV_INT_SENSE_PROP_PCLPOSEN_MASK ) << Si2146_ATV_INT_SENSE_PROP_PCLPOSEN_LSB  |
+              (api->prop->atv_int_sense.dlposen   & Si2146_ATV_INT_SENSE_PROP_DLPOSEN_MASK  ) << Si2146_ATV_INT_SENSE_PROP_DLPOSEN_LSB  |
+              (api->prop->atv_int_sense.snrlposen & Si2146_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK) << Si2146_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB  |
+              (api->prop->atv_int_sense.snrhposen & Si2146_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK) << Si2146_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB ;
+     break;
+    #endif /*     Si2146_ATV_INT_SENSE_PROP */
+    #ifdef        Si2146_ATV_RF_TOP_PROP
+     case         Si2146_ATV_RF_TOP_PROP_CODE:
+       data = (api->prop->atv_rf_top.atv_rf_top & Si2146_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << Si2146_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+     break;
+    #endif /*     Si2146_ATV_RF_TOP_PROP */
+    #ifdef        Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP
+     case         Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE:
+       data = (api->prop->atv_rsq_rssi_threshold.lo & Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->atv_rsq_rssi_threshold.hi & Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef        Si2146_ATV_RSQ_SNR_THRESHOLD_PROP
+     case         Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_CODE:
+       data = (api->prop->atv_rsq_snr_threshold.lo & Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->atv_rsq_snr_threshold.hi & Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2146_ATV_RSQ_SNR_THRESHOLD_PROP */
+    #ifdef        Si2146_ATV_SIF_OUT_PROP
+     case         Si2146_ATV_SIF_OUT_PROP_CODE:
+       data = (api->prop->atv_sif_out.offset & Si2146_ATV_SIF_OUT_PROP_OFFSET_MASK) << Si2146_ATV_SIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->atv_sif_out.amp    & Si2146_ATV_SIF_OUT_PROP_AMP_MASK   ) << Si2146_ATV_SIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2146_ATV_SIF_OUT_PROP */
+    #ifdef        Si2146_ATV_SOUND_AGC_LIMIT_PROP
+     case         Si2146_ATV_SOUND_AGC_LIMIT_PROP_CODE:
+       data = (api->prop->atv_sound_agc_limit.max_gain & Si2146_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK) << Si2146_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB  |
+              (api->prop->atv_sound_agc_limit.min_gain & Si2146_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK) << Si2146_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB ;
+     break;
+    #endif /*     Si2146_ATV_SOUND_AGC_LIMIT_PROP */
+    #ifdef        Si2146_ATV_SOUND_AGC_SPEED_PROP
+     case         Si2146_ATV_SOUND_AGC_SPEED_PROP_CODE:
+       data = (api->prop->atv_sound_agc_speed.system_l      & Si2146_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK     ) << Si2146_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB  |
+              (api->prop->atv_sound_agc_speed.other_systems & Si2146_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << Si2146_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB ;
+     break;
+    #endif /*     Si2146_ATV_SOUND_AGC_SPEED_PROP */
+    #ifdef        Si2146_ATV_VIDEO_EQUALIZER_PROP
+     case         Si2146_ATV_VIDEO_EQUALIZER_PROP_CODE:
+       data = (api->prop->atv_video_equalizer.slope & Si2146_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << Si2146_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+     break;
+    #endif /*     Si2146_ATV_VIDEO_EQUALIZER_PROP */
+    #ifdef        Si2146_ATV_VIDEO_MODE_PROP
+     case         Si2146_ATV_VIDEO_MODE_PROP_CODE:
+       data = (api->prop->atv_video_mode.video_sys       & Si2146_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << Si2146_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+              (api->prop->atv_video_mode.color           & Si2146_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << Si2146_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+              (api->prop->atv_video_mode.trans           & Si2146_ATV_VIDEO_MODE_PROP_TRANS_MASK          ) << Si2146_ATV_VIDEO_MODE_PROP_TRANS_LSB  |
+              (api->prop->atv_video_mode.invert_spectrum & Si2146_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2146_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB  |
+              (api->prop->atv_video_mode.invert_signal   & Si2146_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK  ) << Si2146_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB ;
+     break;
+    #endif /*     Si2146_ATV_VIDEO_MODE_PROP */
+    #ifdef        Si2146_ATV_VSNR_CAP_PROP
+     case         Si2146_ATV_VSNR_CAP_PROP_CODE:
+       data = (api->prop->atv_vsnr_cap.atv_vsnr_cap & Si2146_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << Si2146_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+     break;
+    #endif /*     Si2146_ATV_VSNR_CAP_PROP */
+    #ifdef        Si2146_ATV_VSYNC_TRACKING_PROP
+     case         Si2146_ATV_VSYNC_TRACKING_PROP_CODE:
+       data = (api->prop->atv_vsync_tracking.min_pulses_to_lock   & Si2146_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK  ) << Si2146_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  |
+              (api->prop->atv_vsync_tracking.min_fields_to_unlock & Si2146_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK) << Si2146_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB ;
+     break;
+    #endif /*     Si2146_ATV_VSYNC_TRACKING_PROP */
+    #ifdef        Si2146_CRYSTAL_TRIM_PROP
+     case         Si2146_CRYSTAL_TRIM_PROP_CODE:
+       data = (api->prop->crystal_trim.xo_cap & Si2146_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << Si2146_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+     break;
+    #endif /*     Si2146_CRYSTAL_TRIM_PROP */
+    #ifdef        Si2146_DTV_AGC_FREEZE_INPUT_PROP
+     case         Si2146_DTV_AGC_FREEZE_INPUT_PROP_CODE:
+       data = (api->prop->dtv_agc_freeze_input.level & Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK) << Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB  |
+              (api->prop->dtv_agc_freeze_input.pin   & Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK  ) << Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB ;
+     break;
+    #endif /*     Si2146_DTV_AGC_FREEZE_INPUT_PROP */
+    #ifdef        Si2146_DTV_AGC_SPEED_PROP
+     case         Si2146_DTV_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_agc_speed.if_agc_speed & Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_agc_speed.agc_decim    & Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2146_DTV_AGC_SPEED_PROP */
+    #ifdef        Si2146_DTV_CONFIG_IF_PORT_PROP
+     case         Si2146_DTV_CONFIG_IF_PORT_PROP_CODE:
+       data = (api->prop->dtv_config_if_port.dtv_out_type   & Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK  ) << Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB  |
+              (api->prop->dtv_config_if_port.dtv_agc_source & Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK) << Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB ;
+     break;
+    #endif /*     Si2146_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef        Si2146_DTV_EXT_AGC_PROP
+     case         Si2146_DTV_EXT_AGC_PROP_CODE:
+       data = (api->prop->dtv_ext_agc.min_10mv & Si2146_DTV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2146_DTV_EXT_AGC_PROP_MIN_10MV_LSB  |
+              (api->prop->dtv_ext_agc.max_10mv & Si2146_DTV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2146_DTV_EXT_AGC_PROP_MAX_10MV_LSB ;
+     break;
+    #endif /*     Si2146_DTV_EXT_AGC_PROP */
+    #ifdef        Si2146_DTV_IEN_PROP
+     case         Si2146_DTV_IEN_PROP_CODE:
+       data = (api->prop->dtv_ien.chlien & Si2146_DTV_IEN_PROP_CHLIEN_MASK) << Si2146_DTV_IEN_PROP_CHLIEN_LSB ;
+     break;
+    #endif /*     Si2146_DTV_IEN_PROP */
+    #ifdef        Si2146_DTV_INITIAL_AGC_SPEED_PROP
+     case         Si2146_DTV_INITIAL_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed.if_agc_speed & Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_initial_agc_speed.agc_decim    & Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2146_DTV_INITIAL_AGC_SPEED_PROP */
+    #ifdef        Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+     case         Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed_period.period & Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+     break;
+    #endif /*     Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+    #ifdef        Si2146_DTV_INT_SENSE_PROP
+     case         Si2146_DTV_INT_SENSE_PROP_CODE:
+       data = (api->prop->dtv_int_sense.chlnegen & Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+              (api->prop->dtv_int_sense.chlposen & Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_LSB ;
+     break;
+    #endif /*     Si2146_DTV_INT_SENSE_PROP */
+    #ifdef        Si2146_DTV_LIF_FREQ_PROP
+     case         Si2146_DTV_LIF_FREQ_PROP_CODE:
+       data = (api->prop->dtv_lif_freq.offset & Si2146_DTV_LIF_FREQ_PROP_OFFSET_MASK) << Si2146_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2146_DTV_LIF_FREQ_PROP */
+    #ifdef        Si2146_DTV_LIF_OUT_PROP
+     case         Si2146_DTV_LIF_OUT_PROP_CODE:
+       data = (api->prop->dtv_lif_out.offset & Si2146_DTV_LIF_OUT_PROP_OFFSET_MASK) << Si2146_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->dtv_lif_out.amp    & Si2146_DTV_LIF_OUT_PROP_AMP_MASK   ) << Si2146_DTV_LIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2146_DTV_LIF_OUT_PROP */
+    #ifdef        Si2146_DTV_MODE_PROP
+     case         Si2146_DTV_MODE_PROP_CODE:
+       data = (api->prop->dtv_mode.bw              & Si2146_DTV_MODE_PROP_BW_MASK             ) << Si2146_DTV_MODE_PROP_BW_LSB  |
+              (api->prop->dtv_mode.modulation      & Si2146_DTV_MODE_PROP_MODULATION_MASK     ) << Si2146_DTV_MODE_PROP_MODULATION_LSB  |
+              (api->prop->dtv_mode.invert_spectrum & Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+     break;
+    #endif /*     Si2146_DTV_MODE_PROP */
+    #ifdef        Si2146_DTV_RF_TOP_PROP
+     case         Si2146_DTV_RF_TOP_PROP_CODE:
+       data = (api->prop->dtv_rf_top.dtv_rf_top & Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+     break;
+    #endif /*     Si2146_DTV_RF_TOP_PROP */
+    #ifdef        Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+     case         Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE:
+       data = (api->prop->dtv_rsq_rssi_threshold.lo & Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->dtv_rsq_rssi_threshold.hi & Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef        Si2146_MASTER_IEN_PROP
+     case         Si2146_MASTER_IEN_PROP_CODE:
+       data = (api->prop->master_ien.tunien & Si2146_MASTER_IEN_PROP_TUNIEN_MASK) << Si2146_MASTER_IEN_PROP_TUNIEN_LSB  |
+              (api->prop->master_ien.atvien & Si2146_MASTER_IEN_PROP_ATVIEN_MASK) << Si2146_MASTER_IEN_PROP_ATVIEN_LSB  |
+              (api->prop->master_ien.dtvien & Si2146_MASTER_IEN_PROP_DTVIEN_MASK) << Si2146_MASTER_IEN_PROP_DTVIEN_LSB  |
+              (api->prop->master_ien.errien & Si2146_MASTER_IEN_PROP_ERRIEN_MASK) << Si2146_MASTER_IEN_PROP_ERRIEN_LSB  |
+              (api->prop->master_ien.ctsien & Si2146_MASTER_IEN_PROP_CTSIEN_MASK) << Si2146_MASTER_IEN_PROP_CTSIEN_LSB ;
+     break;
+    #endif /*     Si2146_MASTER_IEN_PROP */
+    #ifdef        Si2146_TUNER_BLOCKED_VCO_PROP
+     case         Si2146_TUNER_BLOCKED_VCO_PROP_CODE:
+       data = (api->prop->tuner_blocked_vco.vco_code & Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+     break;
+    #endif /*     Si2146_TUNER_BLOCKED_VCO_PROP */
+    #ifdef        Si2146_TUNER_IEN_PROP
+     case         Si2146_TUNER_IEN_PROP_CODE:
+       data = (api->prop->tuner_ien.tcien    & Si2146_TUNER_IEN_PROP_TCIEN_MASK   ) << Si2146_TUNER_IEN_PROP_TCIEN_LSB  |
+              (api->prop->tuner_ien.rssilien & Si2146_TUNER_IEN_PROP_RSSILIEN_MASK) << Si2146_TUNER_IEN_PROP_RSSILIEN_LSB  |
+              (api->prop->tuner_ien.rssihien & Si2146_TUNER_IEN_PROP_RSSIHIEN_MASK) << Si2146_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+     break;
+    #endif /*     Si2146_TUNER_IEN_PROP */
+    #ifdef        Si2146_TUNER_INT_SENSE_PROP
+     case         Si2146_TUNER_INT_SENSE_PROP_CODE:
+       data = (api->prop->tuner_int_sense.tcnegen    & Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssilnegen & Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssihnegen & Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+              (api->prop->tuner_int_sense.tcposen    & Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssilposen & Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssihposen & Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+     break;
+    #endif /*     Si2146_TUNER_INT_SENSE_PROP */
+    #ifdef        Si2146_TUNER_LO_INJECTION_PROP
+     case         Si2146_TUNER_LO_INJECTION_PROP_CODE:
+       data = (api->prop->tuner_lo_injection.band_1 & Si2146_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << Si2146_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+              (api->prop->tuner_lo_injection.band_2 & Si2146_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << Si2146_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+              (api->prop->tuner_lo_injection.band_3 & Si2146_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << Si2146_TUNER_LO_INJECTION_PROP_BAND_3_LSB  |
+              (api->prop->tuner_lo_injection.band_4 & Si2146_TUNER_LO_INJECTION_PROP_BAND_4_MASK) << Si2146_TUNER_LO_INJECTION_PROP_BAND_4_LSB  |
+              (api->prop->tuner_lo_injection.band_5 & Si2146_TUNER_LO_INJECTION_PROP_BAND_5_MASK) << Si2146_TUNER_LO_INJECTION_PROP_BAND_5_LSB ;
+     break;
+    #endif /*     Si2146_TUNER_LO_INJECTION_PROP */
+   default : break;
+    }
+    return Si2146_L1_SetProperty(api, prop_code & 0xffff , data);
+}
+
+unsigned char Si2148_L1_SetProperty2(L1_Si2148_Context *api, unsigned int prop_code) {
+    int data;
+    switch (prop_code) {
+    #ifdef        Si2148_ATV_ARTIFICIAL_SNOW_PROP
+     case         Si2148_ATV_ARTIFICIAL_SNOW_PROP_CODE:
+       data = (api->prop->atv_artificial_snow.gain   & Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK  ) << Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  |
+              (api->prop->atv_artificial_snow.offset & Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK) << Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2148_ATV_ARTIFICIAL_SNOW_PROP */
+    #ifdef        Si2148_ATV_EXT_AGC_PROP
+     case         Si2148_ATV_EXT_AGC_PROP_CODE:
+       data = (api->prop->atv_ext_agc.min_10mv & Si2148_ATV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2148_ATV_EXT_AGC_PROP_MIN_10MV_LSB  |
+              (api->prop->atv_ext_agc.max_10mv & Si2148_ATV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2148_ATV_EXT_AGC_PROP_MAX_10MV_LSB ;
+     break;
+    #endif /*     Si2148_ATV_EXT_AGC_PROP */
+    #ifdef        Si2148_ATV_LIF_FREQ_PROP
+     case         Si2148_ATV_LIF_FREQ_PROP_CODE:
+       data = (api->prop->atv_lif_freq.offset & Si2148_ATV_LIF_FREQ_PROP_OFFSET_MASK) << Si2148_ATV_LIF_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2148_ATV_LIF_FREQ_PROP */
+    #ifdef        Si2148_ATV_LIF_OUT_PROP
+     case         Si2148_ATV_LIF_OUT_PROP_CODE:
+       data = (api->prop->atv_lif_out.offset & Si2148_ATV_LIF_OUT_PROP_OFFSET_MASK) << Si2148_ATV_LIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->atv_lif_out.amp    & Si2148_ATV_LIF_OUT_PROP_AMP_MASK   ) << Si2148_ATV_LIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2148_ATV_LIF_OUT_PROP */
+    #ifdef        Si2148_ATV_PGA_TARGET_PROP
+     case         Si2148_ATV_PGA_TARGET_PROP_CODE:
+       data = (api->prop->atv_pga_target.pga_target      & Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+              (api->prop->atv_pga_target.override_enable & Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+     break;
+    #endif /*     Si2148_ATV_PGA_TARGET_PROP */
+    #ifdef        Si2148_CRYSTAL_TRIM_PROP
+     case         Si2148_CRYSTAL_TRIM_PROP_CODE:
+       data = (api->prop->crystal_trim.xo_cap & Si2148_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << Si2148_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+     break;
+    #endif /*     Si2148_CRYSTAL_TRIM_PROP */
+    #ifdef        Si2148_DTV_AGC_FREEZE_INPUT_PROP
+     case         Si2148_DTV_AGC_FREEZE_INPUT_PROP_CODE:
+       data = (api->prop->dtv_agc_freeze_input.level & Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK) << Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB  |
+              (api->prop->dtv_agc_freeze_input.pin   & Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK  ) << Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB ;
+     break;
+    #endif /*     Si2148_DTV_AGC_FREEZE_INPUT_PROP */
+    #ifdef        Si2148_DTV_AGC_SPEED_PROP
+     case         Si2148_DTV_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_agc_speed.if_agc_speed & Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_agc_speed.agc_decim    & Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2148_DTV_AGC_SPEED_PROP */
+    #ifdef        Si2148_DTV_CONFIG_IF_PORT_PROP
+     case         Si2148_DTV_CONFIG_IF_PORT_PROP_CODE:
+       data = (api->prop->dtv_config_if_port.dtv_out_type   & Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK  ) << Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB  |
+              (api->prop->dtv_config_if_port.dtv_agc_source & Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK) << Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB ;
+     break;
+    #endif /*     Si2148_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef        Si2148_DTV_EXT_AGC_PROP
+     case         Si2148_DTV_EXT_AGC_PROP_CODE:
+       data = (api->prop->dtv_ext_agc.min_10mv & Si2148_DTV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2148_DTV_EXT_AGC_PROP_MIN_10MV_LSB  |
+              (api->prop->dtv_ext_agc.max_10mv & Si2148_DTV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2148_DTV_EXT_AGC_PROP_MAX_10MV_LSB ;
+     break;
+    #endif /*     Si2148_DTV_EXT_AGC_PROP */
+    #ifdef        Si2148_DTV_FILTER_SELECT_PROP
+     case         Si2148_DTV_FILTER_SELECT_PROP_CODE:
+       data = (api->prop->dtv_filter_select.filter & Si2148_DTV_FILTER_SELECT_PROP_FILTER_MASK) << Si2148_DTV_FILTER_SELECT_PROP_FILTER_LSB ;
+     break;
+    #endif /*     Si2148_DTV_FILTER_SELECT_PROP */
+    #ifdef        Si2148_DTV_IEN_PROP
+     case         Si2148_DTV_IEN_PROP_CODE:
+       data = (api->prop->dtv_ien.chlien & Si2148_DTV_IEN_PROP_CHLIEN_MASK) << Si2148_DTV_IEN_PROP_CHLIEN_LSB ;
+     break;
+    #endif /*     Si2148_DTV_IEN_PROP */
+    #ifdef        Si2148_DTV_INITIAL_AGC_SPEED_PROP
+     case         Si2148_DTV_INITIAL_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed.if_agc_speed & Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_initial_agc_speed.agc_decim    & Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2148_DTV_INITIAL_AGC_SPEED_PROP */
+    #ifdef        Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+     case         Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed_period.period & Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+     break;
+    #endif /*     Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+    #ifdef        Si2148_DTV_INTERNAL_ZIF_PROP
+     case         Si2148_DTV_INTERNAL_ZIF_PROP_CODE:
+       data = (api->prop->dtv_internal_zif.atsc   & Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_MASK  ) << Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_LSB  |
+              (api->prop->dtv_internal_zif.qam_us & Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK) << Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB  |
+              (api->prop->dtv_internal_zif.dvbt   & Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_MASK  ) << Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_LSB  |
+              (api->prop->dtv_internal_zif.dvbc   & Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_MASK  ) << Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_LSB  |
+              (api->prop->dtv_internal_zif.isdbt  & Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK ) << Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB  |
+              (api->prop->dtv_internal_zif.isdbc  & Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK ) << Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB  |
+              (api->prop->dtv_internal_zif.dtmb   & Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_MASK  ) << Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_LSB ;
+     break;
+    #endif /*     Si2148_DTV_INTERNAL_ZIF_PROP */
+    #ifdef        Si2148_DTV_INT_SENSE_PROP
+     case         Si2148_DTV_INT_SENSE_PROP_CODE:
+       data = (api->prop->dtv_int_sense.chlnegen & Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+              (api->prop->dtv_int_sense.chlposen & Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_LSB ;
+     break;
+    #endif /*     Si2148_DTV_INT_SENSE_PROP */
+    #ifdef        Si2148_DTV_LIF_FREQ_PROP
+     case         Si2148_DTV_LIF_FREQ_PROP_CODE:
+       data = (api->prop->dtv_lif_freq.offset & Si2148_DTV_LIF_FREQ_PROP_OFFSET_MASK) << Si2148_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2148_DTV_LIF_FREQ_PROP */
+    #ifdef        Si2148_DTV_LIF_OUT_PROP
+     case         Si2148_DTV_LIF_OUT_PROP_CODE:
+       data = (api->prop->dtv_lif_out.offset & Si2148_DTV_LIF_OUT_PROP_OFFSET_MASK) << Si2148_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->dtv_lif_out.amp    & Si2148_DTV_LIF_OUT_PROP_AMP_MASK   ) << Si2148_DTV_LIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2148_DTV_LIF_OUT_PROP */
+    #ifdef        Si2148_DTV_MODE_PROP
+     case         Si2148_DTV_MODE_PROP_CODE:
+       data = (api->prop->dtv_mode.bw              & Si2148_DTV_MODE_PROP_BW_MASK             ) << Si2148_DTV_MODE_PROP_BW_LSB  |
+              (api->prop->dtv_mode.modulation      & Si2148_DTV_MODE_PROP_MODULATION_MASK     ) << Si2148_DTV_MODE_PROP_MODULATION_LSB  |
+              (api->prop->dtv_mode.invert_spectrum & Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+     break;
+    #endif /*     Si2148_DTV_MODE_PROP */
+    #ifdef        Si2148_DTV_PGA_LIMITS_PROP
+     case         Si2148_DTV_PGA_LIMITS_PROP_CODE:
+       data = (api->prop->dtv_pga_limits.min & Si2148_DTV_PGA_LIMITS_PROP_MIN_MASK) << Si2148_DTV_PGA_LIMITS_PROP_MIN_LSB  |
+              (api->prop->dtv_pga_limits.max & Si2148_DTV_PGA_LIMITS_PROP_MAX_MASK) << Si2148_DTV_PGA_LIMITS_PROP_MAX_LSB ;
+     break;
+    #endif /*     Si2148_DTV_PGA_LIMITS_PROP */
+    #ifdef        Si2148_DTV_PGA_TARGET_PROP
+     case         Si2148_DTV_PGA_TARGET_PROP_CODE:
+       data = (api->prop->dtv_pga_target.pga_target      & Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+              (api->prop->dtv_pga_target.override_enable & Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+     break;
+    #endif /*     Si2148_DTV_PGA_TARGET_PROP */
+    #ifdef        Si2148_DTV_RF_TOP_PROP
+     case         Si2148_DTV_RF_TOP_PROP_CODE:
+       data = (api->prop->dtv_rf_top.dtv_rf_top & Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+     break;
+    #endif /*     Si2148_DTV_RF_TOP_PROP */
+    #ifdef        Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP
+     case         Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE:
+       data = (api->prop->dtv_rsq_rssi_threshold.lo & Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->dtv_rsq_rssi_threshold.hi & Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef        Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP
+     case         Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE:
+       data = (api->prop->dtv_zif_dc_canceller_bw.bandwidth & Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK) << Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB ;
+     break;
+    #endif /*     Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP */
+    #ifdef        Si2148_MASTER_IEN_PROP
+     case         Si2148_MASTER_IEN_PROP_CODE:
+       data = (api->prop->master_ien.tunien & Si2148_MASTER_IEN_PROP_TUNIEN_MASK) << Si2148_MASTER_IEN_PROP_TUNIEN_LSB  |
+              (api->prop->master_ien.atvien & Si2148_MASTER_IEN_PROP_ATVIEN_MASK) << Si2148_MASTER_IEN_PROP_ATVIEN_LSB  |
+              (api->prop->master_ien.dtvien & Si2148_MASTER_IEN_PROP_DTVIEN_MASK) << Si2148_MASTER_IEN_PROP_DTVIEN_LSB  |
+              (api->prop->master_ien.errien & Si2148_MASTER_IEN_PROP_ERRIEN_MASK) << Si2148_MASTER_IEN_PROP_ERRIEN_LSB  |
+              (api->prop->master_ien.ctsien & Si2148_MASTER_IEN_PROP_CTSIEN_MASK) << Si2148_MASTER_IEN_PROP_CTSIEN_LSB ;
+     break;
+    #endif /*     Si2148_MASTER_IEN_PROP */
+    #ifdef        Si2148_TUNER_BLOCKED_VCO_PROP
+     case         Si2148_TUNER_BLOCKED_VCO_PROP_CODE:
+       data = (api->prop->tuner_blocked_vco.vco_code & Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+     break;
+    #endif /*     Si2148_TUNER_BLOCKED_VCO_PROP */
+    #ifdef        Si2148_TUNER_IEN_PROP
+     case         Si2148_TUNER_IEN_PROP_CODE:
+       data = (api->prop->tuner_ien.tcien    & Si2148_TUNER_IEN_PROP_TCIEN_MASK   ) << Si2148_TUNER_IEN_PROP_TCIEN_LSB  |
+              (api->prop->tuner_ien.rssilien & Si2148_TUNER_IEN_PROP_RSSILIEN_MASK) << Si2148_TUNER_IEN_PROP_RSSILIEN_LSB  |
+              (api->prop->tuner_ien.rssihien & Si2148_TUNER_IEN_PROP_RSSIHIEN_MASK) << Si2148_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+     break;
+    #endif /*     Si2148_TUNER_IEN_PROP */
+    #ifdef        Si2148_TUNER_INT_SENSE_PROP
+     case         Si2148_TUNER_INT_SENSE_PROP_CODE:
+       data = (api->prop->tuner_int_sense.tcnegen    & Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssilnegen & Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssihnegen & Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+              (api->prop->tuner_int_sense.tcposen    & Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssilposen & Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssihposen & Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+     break;
+    #endif /*     Si2148_TUNER_INT_SENSE_PROP */
+    #ifdef        Si2148_TUNER_LO_INJECTION_PROP
+     case         Si2148_TUNER_LO_INJECTION_PROP_CODE:
+       data = (api->prop->tuner_lo_injection.band_1 & Si2148_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << Si2148_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+              (api->prop->tuner_lo_injection.band_2 & Si2148_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << Si2148_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+              (api->prop->tuner_lo_injection.band_3 & Si2148_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << Si2148_TUNER_LO_INJECTION_PROP_BAND_3_LSB ;
+     break;
+    #endif /*     Si2148_TUNER_LO_INJECTION_PROP */
+    #ifdef        Si2148_TUNER_RETURN_LOSS_PROP
+     case         Si2148_TUNER_RETURN_LOSS_PROP_CODE:
+       data = (api->prop->tuner_return_loss.config & Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_MASK) << Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_LSB  |
+              (api->prop->tuner_return_loss.mode   & Si2148_TUNER_RETURN_LOSS_PROP_MODE_MASK  ) << Si2148_TUNER_RETURN_LOSS_PROP_MODE_LSB ;
+     break;
+    #endif /*     Si2148_TUNER_RETURN_LOSS_PROP */
+   default : break;
+    }
+    return Si2148_L1_SetProperty(api, prop_code & 0xffff , data);
+}
+
+int Si2168_L2_TER_FEF(Si2168_L2_Context *front_end, int fef)
+{
+	Si2168_L2_Tuner_I2C_Enable(front_end);
+	Si2168_L2_Tuner_I2C_Disable(front_end);
+	return 1;
+}
+
+unsigned char Si2146_pollForCTS (L1_Si2146_Context *api)
+{
+	unsigned char rspByteBuffer[1];
+	int i;
+	for(i=0;i<100;i++)
+	{
+		ReadI2C(api->addr,1,rspByteBuffer);
+		// return OK if CTS set
+		if (rspByteBuffer[0] & 0x80)
+			return 0;
+		MyDelay(10);
+	}
+	return 4;
+}
+
+unsigned char Si2148_pollForCTS (L1_Si2148_Context *api)
+{
+	unsigned char rspByteBuffer[1];
+	int i;
+	for(i=0;i<100;i++)
+	{
+		ReadI2C(api->addr,1,rspByteBuffer);
+		// return OK if CTS set
+		if (rspByteBuffer[0] & 0x80)
+			return 0;
+		MyDelay(10);
+	}
+	return 4;
+}
+
+unsigned char Si2146_L1_POWER_UP(L1_Si2146_Context *api,unsigned char   subcode,unsigned char   reserved1,unsigned char   reserved2,unsigned char   reserved3,unsigned char   clock_mode,unsigned char   clock_freq,unsigned char   addr_mode,unsigned char   func,unsigned char   ctsien,unsigned char   wake_up)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[9];
+	unsigned char rspByteBuffer[1];
+	api->rsp->power_up.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_POWER_UP_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2146_POWER_UP_CMD_SUBCODE_MASK    ) << Si2146_POWER_UP_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (unsigned char) ( ( reserved1  & Si2146_POWER_UP_CMD_RESERVED1_MASK  ) << Si2146_POWER_UP_CMD_RESERVED1_LSB );
+	cmdByteBuffer[3] = (unsigned char) ( ( reserved2  & Si2146_POWER_UP_CMD_RESERVED2_MASK  ) << Si2146_POWER_UP_CMD_RESERVED2_LSB );
+	cmdByteBuffer[4] = (unsigned char) ( ( reserved3  & Si2146_POWER_UP_CMD_RESERVED3_MASK  ) << Si2146_POWER_UP_CMD_RESERVED3_LSB );
+	cmdByteBuffer[5] = (unsigned char) ( ( clock_mode & Si2146_POWER_UP_CMD_CLOCK_MODE_MASK ) << Si2146_POWER_UP_CMD_CLOCK_MODE_LSB|
+										 ( clock_freq & Si2146_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2146_POWER_UP_CMD_CLOCK_FREQ_LSB);
+	cmdByteBuffer[6] = (unsigned char) ( ( addr_mode  & Si2146_POWER_UP_CMD_ADDR_MODE_MASK  ) << Si2146_POWER_UP_CMD_ADDR_MODE_LSB );
+	cmdByteBuffer[7] = (unsigned char) ( ( func       & Si2146_POWER_UP_CMD_FUNC_MASK       ) << Si2146_POWER_UP_CMD_FUNC_LSB      |
+										 ( ctsien     & Si2146_POWER_UP_CMD_CTSIEN_MASK     ) << Si2146_POWER_UP_CMD_CTSIEN_LSB    );
+	cmdByteBuffer[8] = (unsigned char) ( ( wake_up    & Si2146_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2146_POWER_UP_CMD_WAKE_UP_LSB   );
+	WriteI2C(api->addr,9,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2148_L1_POWER_UP(L1_Si2148_Context *api,unsigned char   subcode,unsigned char   clock_mode,unsigned char   en_xout,unsigned char   pd_ldo,unsigned char   reserved2,unsigned char   reserved3,unsigned char   reserved4,unsigned char   reserved5,unsigned char   reserved6,unsigned char   reserved7,unsigned char   reset,unsigned char   clock_freq,unsigned char   reserved8,unsigned char   func,unsigned char   ctsien,unsigned char   wake_up)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[15];
+	unsigned char rspByteBuffer[1];
+	api->rsp->power_up.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_POWER_UP_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2148_POWER_UP_CMD_SUBCODE_MASK    ) << Si2148_POWER_UP_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (unsigned char) ( ( clock_mode & Si2148_POWER_UP_CMD_CLOCK_MODE_MASK ) << Si2148_POWER_UP_CMD_CLOCK_MODE_LSB|
+										 ( en_xout    & Si2148_POWER_UP_CMD_EN_XOUT_MASK    ) << Si2148_POWER_UP_CMD_EN_XOUT_LSB   );
+	cmdByteBuffer[3] = (unsigned char) ( ( pd_ldo     & Si2148_POWER_UP_CMD_PD_LDO_MASK     ) << Si2148_POWER_UP_CMD_PD_LDO_LSB    );
+	cmdByteBuffer[4] = (unsigned char) ( ( reserved2  & Si2148_POWER_UP_CMD_RESERVED2_MASK  ) << Si2148_POWER_UP_CMD_RESERVED2_LSB );
+	cmdByteBuffer[5] = (unsigned char) ( ( reserved3  & Si2148_POWER_UP_CMD_RESERVED3_MASK  ) << Si2148_POWER_UP_CMD_RESERVED3_LSB );
+	cmdByteBuffer[6] = (unsigned char) ( ( reserved4  & Si2148_POWER_UP_CMD_RESERVED4_MASK  ) << Si2148_POWER_UP_CMD_RESERVED4_LSB );
+	cmdByteBuffer[7] = (unsigned char) ( ( reserved5  & Si2148_POWER_UP_CMD_RESERVED5_MASK  ) << Si2148_POWER_UP_CMD_RESERVED5_LSB );
+	cmdByteBuffer[8] = (unsigned char) ( ( reserved6  & Si2148_POWER_UP_CMD_RESERVED6_MASK  ) << Si2148_POWER_UP_CMD_RESERVED6_LSB );
+	cmdByteBuffer[9] = (unsigned char) ( ( reserved7  & Si2148_POWER_UP_CMD_RESERVED7_MASK  ) << Si2148_POWER_UP_CMD_RESERVED7_LSB );
+	cmdByteBuffer[10] = (unsigned char) ( ( reset      & Si2148_POWER_UP_CMD_RESET_MASK      ) << Si2148_POWER_UP_CMD_RESET_LSB     );
+	cmdByteBuffer[11] = (unsigned char) ( ( clock_freq & Si2148_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2148_POWER_UP_CMD_CLOCK_FREQ_LSB);
+	cmdByteBuffer[12] = (unsigned char) ( ( reserved8  & Si2148_POWER_UP_CMD_RESERVED8_MASK  ) << Si2148_POWER_UP_CMD_RESERVED8_LSB );
+	cmdByteBuffer[13] = (unsigned char) ( ( func       & Si2148_POWER_UP_CMD_FUNC_MASK       ) << Si2148_POWER_UP_CMD_FUNC_LSB      |
+										 ( ctsien     & Si2148_POWER_UP_CMD_CTSIEN_MASK     ) << Si2148_POWER_UP_CMD_CTSIEN_LSB    );
+	cmdByteBuffer[14] = (unsigned char) ( ( wake_up    & Si2148_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2148_POWER_UP_CMD_WAKE_UP_LSB   );
+	WriteI2C(api->addr,15,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2146_L1_PART_INFO                 (L1_Si2146_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[13];
+	api->rsp->part_info.STATUS = api->status;
+
+	cmdByteBuffer[0] = Si2146_PART_INFO_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 13, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->part_info.chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2146_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2146_PART_INFO_RESPONSE_CHIPREV_MASK  );
+	api->rsp->part_info.part     =   (( ( (rspByteBuffer[2]  )) >> Si2146_PART_INFO_RESPONSE_PART_LSB     ) & Si2146_PART_INFO_RESPONSE_PART_MASK     );
+	api->rsp->part_info.pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2146_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2146_PART_INFO_RESPONSE_PMAJOR_MASK   );
+	api->rsp->part_info.pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2146_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2146_PART_INFO_RESPONSE_PMINOR_MASK   );
+	api->rsp->part_info.pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2146_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2146_PART_INFO_RESPONSE_PBUILD_MASK   );
+	api->rsp->part_info.reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2146_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2146_PART_INFO_RESPONSE_RESERVED_MASK );
+	api->rsp->part_info.serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2146_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2146_PART_INFO_RESPONSE_SERIAL_MASK   );
+	api->rsp->part_info.romid    =   (( ( (rspByteBuffer[12] )) >> Si2146_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2146_PART_INFO_RESPONSE_ROMID_MASK    );
+	return 0;
+}
+
+unsigned char Si2148_L1_PART_INFO       (L1_Si2148_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[13];
+	api->rsp->part_info.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_PART_INFO_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 13, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->part_info.chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2148_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2148_PART_INFO_RESPONSE_CHIPREV_MASK  );
+	api->rsp->part_info.part     =   (( ( (rspByteBuffer[2]  )) >> Si2148_PART_INFO_RESPONSE_PART_LSB     ) & Si2148_PART_INFO_RESPONSE_PART_MASK     );
+	api->rsp->part_info.pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2148_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2148_PART_INFO_RESPONSE_PMAJOR_MASK   );
+	api->rsp->part_info.pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2148_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2148_PART_INFO_RESPONSE_PMINOR_MASK   );
+	api->rsp->part_info.pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2148_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2148_PART_INFO_RESPONSE_PBUILD_MASK   );
+	api->rsp->part_info.reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2148_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2148_PART_INFO_RESPONSE_RESERVED_MASK );
+	api->rsp->part_info.serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2148_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2148_PART_INFO_RESPONSE_SERIAL_MASK   );
+	api->rsp->part_info.romid    =   (( ( (rspByteBuffer[12] )) >> Si2148_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2148_PART_INFO_RESPONSE_ROMID_MASK    );
+	return 0;
+}
+
+unsigned char Si2146_L1_EXIT_BOOTLOADER           (L1_Si2146_Context *api,unsigned char   func,unsigned char   ctsien)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[1];
+	api->rsp->exit_bootloader.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_EXIT_BOOTLOADER_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( func   & Si2146_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2146_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+										 ( ctsien & Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2146_StartFirmware       (L1_Si2146_Context *api)
+{
+	if (Si2146_L1_EXIT_BOOTLOADER(api, Si2146_EXIT_BOOTLOADER_CMD_FUNC_TUNER, Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != 0)
+		return 0x0a;
+	return 0;
+}
+
+int Si2146_PowerUpWithPatch(L1_Si2146_Context *api)
+{
+	int return_code;
+	return_code = 0;
+	// always wait for CTS prior to POWER_UP command
+	if ((return_code = Si2146_pollForCTS  (api)) != 0)
+		return return_code;
+	if ((return_code = Si2146_L1_POWER_UP (api,Si2146_POWER_UP_CMD_SUBCODE_CODE,Si2146_POWER_UP_CMD_RESERVED1_RESERVED,Si2146_POWER_UP_CMD_RESERVED2_RESERVED,Si2146_POWER_UP_CMD_RESERVED3_RESERVED,Si2146_POWER_UP_CMD_CLOCK_MODE_XTAL,Si2146_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,Si2146_POWER_UP_CMD_ADDR_MODE_CURRENT,Si2146_POWER_UP_CMD_FUNC_BOOTLOADER,Si2146_POWER_UP_CMD_CTSIEN_DISABLE,Si2146_POWER_UP_CMD_WAKE_UP_WAKE_UP)) != 0)
+		return return_code;
+	// Get the Part Info from the chip.   This command is only valid in Bootloader mode
+	if ((return_code = Si2146_L1_PART_INFO(api)) != 0)
+		return return_code;
+	/* Load the if needed */
+#ifdef LOAD_PATCH_11b2
+	if (api->rsp->part_info.romid == 0x11)
+	{
+		// Load the Firmware
+		if ((return_code = Si2146_LoadFirmware(api, Si2146_FW_1_1b2, FIRMWARE_LINES_1_1b2)) != 0)
+			return return_code;
+	}
+#endif //LOAD_PATCH_11b2
+	/*Start the Firmware */
+	if ((return_code = Si2146_StartFirmware(api)) != 0)
+		return return_code;
+	return 0;
+}
+
+unsigned char Si2148_FW_0_Eb15[] = {
+0x04,0x01,0x80,0x00,0xCC,0x58,0x98,0xD7,
+0x05,0xD3,0x99,0xC6,0xB2,0xBD,0x68,0x8B,
+0x05,0xDF,0xB3,0x1B,0x73,0x9E,0xAA,0x51,
+0x27,0xCF,0xF6,0x6C,0xCD,0xDD,0x5E,0x64,
+0x22,0xEB,0x8D,0x75,0xC2,0x4A,0xA8,0xFB,
+0x0F,0x04,0x3A,0x48,0x7C,0xCF,0x5A,0x5A,
+0x27,0x4B,0x3E,0x35,0x0D,0xBA,0xE9,0x2A,
+0x29,0x50,0x14,0x34,0xC1,0xD7,0x08,0x8B,
+0x07,0x1F,0xA0,0x69,0xFB,0xBD,0xA5,0x46,
+0x2E,0xF3,0xF8,0xBB,0xFD,0xC9,0x64,0xCB,
+0x0F,0x7E,0x43,0xA7,0xAA,0x87,0x5E,0x3B,
+0x2F,0x41,0xAB,0xE6,0xB5,0x5D,0xF0,0x86,
+0x2B,0x16,0x7D,0x1A,0x4C,0x72,0x68,0xFB,
+0x07,0x17,0x87,0x60,0x3C,0x6D,0x0C,0x60,
+0x26,0x8C,0xCD,0xE5,0x90,0x80,0x5C,0x53,
+0x07,0x6E,0xA1,0x0F,0x6A,0xBE,0x0D,0x3B,
+0x2F,0x15,0xB8,0x23,0xED,0x6D,0x1A,0xDE,
+0x24,0x6F,0xE7,0x95,0x1E,0x6F,0x9A,0x85,
+0x0F,0xE4,0x4F,0x35,0xA8,0xE6,0x37,0xBF,
+0x22,0x76,0xD4,0x39,0x4C,0xFA,0x73,0x59,
+0x0F,0xD6,0xB4,0xF1,0x43,0x6B,0xCE,0xF1,
+0x2A,0xE2,0xF6,0xC6,0x39,0x39,0x82,0x2A,
+0x0F,0xB9,0xF6,0x5D,0xD6,0x3C,0x25,0x17,
+0x2F,0x0C,0x63,0x24,0xC6,0xF1,0xB1,0x37,
+0x2F,0xF9,0xA4,0xED,0x41,0xD0,0xCA,0xED,
+0x23,0xD4,0x9D,0x4A,0xAB,0xF1,0x81,0x3C,
+0x07,0x79,0xF8,0xA4,0xB4,0x71,0x25,0xCE,
+0x2F,0xCC,0x0A,0x0C,0x1D,0x0F,0x79,0x1F,
+0x2F,0x2A,0xB8,0x84,0xE2,0x43,0x4E,0x1B,
+0x26,0xAA,0x6B,0x06,0x2B,0xB1,0x6F,0xB2,
+0x0F,0x12,0x4F,0xCB,0x29,0x04,0xFB,0xD0,
+0x25,0x3E,0xE7,0x17,0x64,0xF1,0x47,0xC0,
+0x0F,0x8F,0x43,0x9F,0x23,0x2A,0x50,0x36,
+0x2A,0x6C,0x03,0xD7,0x29,0x87,0xA5,0x99,
+0x07,0xC3,0x49,0x0D,0x73,0x77,0x0C,0xC6,
+0x07,0x3A,0x8E,0x3D,0x75,0xB8,0x48,0x55,
+0x0F,0xAB,0x62,0x72,0x46,0x0D,0xD6,0x80,
+0x27,0x75,0x1F,0x93,0x37,0x7A,0x0D,0x41,
+0x21,0xCB,0xD3,0x31,0x0E,0x28,0x7B,0x26,
+0x0F,0xBA,0x8F,0x86,0xC0,0xE7,0xE1,0x26,
+0x22,0xCD,0xE0,0x65,0x94,0x2F,0xBC,0x19,
+0x07,0x6E,0xDA,0xCB,0x11,0xFE,0x04,0x3B,
+0x22,0xE6,0x08,0x94,0xBC,0x66,0x71,0x25,
+0x07,0x1B,0x30,0xE8,0x18,0xA4,0xAD,0x50,
+0x2D,0xA7,0x33,0x7F,0xD8,0x5B,0xC1,0xFD,
+0x0F,0x5E,0xC5,0x85,0x19,0x54,0xE3,0x7F,
+0x22,0xEA,0x90,0xBB,0xB7,0x7C,0xFB,0xFF,
+0x07,0xE4,0x01,0x5A,0x01,0x51,0x1A,0x47,
+0x27,0xEC,0x3C,0x1D,0x21,0x79,0x16,0x9A,
+0x2C,0xE6,0x0B,0x70,0xDD,0xCC,0x12,0x8A,
+0x0F,0x1D,0x5C,0x4D,0x07,0x1A,0x95,0xE2,
+0x25,0x3C,0x22,0x25,0x82,0xC4,0x59,0xB7,
+0x07,0xDE,0xB8,0xE2,0xF4,0x47,0x47,0xFF,
+0x25,0xDD,0x02,0x19,0x2A,0x45,0xD2,0x31,
+0x0F,0xE3,0xF4,0xAA,0x14,0xEB,0x9D,0xF2,
+0x2F,0x74,0xF7,0x2B,0xD1,0xB6,0x18,0xFF,
+0x2F,0xDD,0x9C,0x99,0x0A,0x21,0x99,0x8E,
+0x23,0x3C,0x04,0x20,0xAC,0x1A,0xC5,0xCD,
+0x07,0x73,0xF1,0x31,0x2C,0x44,0x58,0x74,
+0x2F,0xEC,0x1B,0xB1,0x7B,0xAD,0x76,0x32,
+0x29,0x35,0xAF,0xE2,0x21,0x09,0xB4,0x79,
+0x07,0x66,0xC5,0xA6,0x16,0xCB,0xE9,0x5C,
+0x27,0xB5,0x4F,0xE6,0xE9,0x19,0x5E,0x25,
+0x27,0x72,0x69,0x1C,0xFB,0x30,0xE6,0xB3,
+0x0F,0xFB,0xA9,0x53,0x94,0x2A,0x75,0x61,
+0x25,0x66,0x1E,0xE7,0xC9,0x9D,0x79,0xF5,
+0x0F,0x73,0x01,0x7F,0xE9,0x0C,0x7E,0xED,
+0x2A,0xDF,0x41,0x2E,0x2D,0x50,0x72,0xC3,
+0x0F,0x49,0xDE,0xAB,0xBC,0xF8,0x8D,0x55,
+0x27,0xE6,0x18,0xE6,0x07,0xF1,0x84,0xE2,
+0x29,0x7B,0xA1,0x1E,0x13,0x4E,0xE7,0x3C,
+0x07,0xA3,0x01,0xEB,0x93,0xB2,0x36,0x16,
+0x0F,0xD3,0x86,0x31,0x67,0x4A,0xB0,0x79,
+0x07,0x01,0xD4,0x98,0x17,0x16,0xF3,0xB4,
+0x25,0xFD,0x6F,0xF1,0xDA,0x9A,0xBA,0x06,
+0x07,0x8D,0xD3,0xD6,0xFC,0xD9,0xD6,0x02,
+0x2A,0xF1,0x24,0x79,0xC5,0x25,0xBD,0xE1,
+0x07,0xB5,0xA7,0x60,0xBB,0xD5,0x39,0x5A,
+0x0F,0x08,0xA1,0x96,0xCB,0x4F,0x93,0x52,
+0x0F,0x6C,0x82,0xC2,0xE0,0x02,0x04,0x70,
+0x2A,0xB5,0x75,0x46,0x6E,0xDF,0x04,0x40,
+0x0F,0xF3,0xF7,0xD4,0xFB,0x54,0x68,0x5C,
+0x27,0x97,0xCB,0x54,0x5C,0x63,0x88,0xDF,
+0x27,0xF0,0x16,0x41,0x54,0xE0,0xF6,0xFC,
+0x27,0x1B,0x1D,0x50,0xE8,0x99,0x3C,0x0E,
+0x22,0x48,0xCB,0x3F,0xC2,0x7B,0x1E,0xF7,
+0x07,0x78,0xDA,0x29,0x4D,0xB9,0xBE,0x4C,
+0x2F,0x62,0x65,0x80,0x4B,0x86,0x44,0xC4,
+0x29,0x38,0x47,0x9D,0xEF,0x1D,0xC7,0x7C,
+0x07,0xB6,0x36,0x2D,0x07,0x57,0x4F,0x32,
+0x07,0x1F,0xB4,0xC3,0x7E,0xC3,0xD3,0xB0,
+0x0F,0x8E,0x90,0x8D,0xC1,0x1E,0x05,0x05,
+0x2F,0xFC,0x8C,0x2A,0x7E,0x9B,0x7E,0x72,
+0x2C,0xAB,0xE9,0xEF,0x08,0xF6,0x5B,0x24,
+0x07,0x48,0x19,0xA9,0x76,0x95,0x8A,0x75,
+0x2A,0x1F,0x74,0x4C,0xE6,0x81,0x61,0x4B,
+0x0F,0xA5,0xFF,0x5F,0x77,0x1C,0x7A,0x05,
+0x2A,0x47,0xAF,0x53,0x84,0x9B,0xDA,0x3D,
+0x0F,0xC9,0x90,0x35,0xDE,0xE3,0xFB,0xCA,
+0x27,0x99,0x88,0x5F,0xF6,0x47,0x3F,0x26,
+0x2F,0x32,0x4B,0x93,0x94,0x9C,0x6D,0x9A,
+0x0F,0x3E,0xE0,0x43,0x9B,0x46,0x55,0x0C,
+0x2A,0x57,0xF5,0x67,0x7B,0x16,0xC7,0x91,
+0x0F,0x2D,0xA7,0x3A,0x1F,0xE5,0x9C,0x84,
+0x25,0xE9,0x7F,0xC0,0xD4,0xE6,0xAA,0xA2,
+0x07,0x51,0xC0,0x9F,0x11,0xD9,0x05,0x50,
+0x07,0x58,0xC8,0x3A,0x83,0xFB,0x65,0x7D,
+0x07,0x8B,0xB2,0xE4,0x8B,0x39,0xFB,0xA4,
+0x2D,0x4B,0x48,0xC4,0x6B,0xF6,0xAC,0x0E,
+0x0F,0x46,0x87,0x58,0x0F,0xFB,0xA1,0x3A,
+0x27,0x8D,0xFF,0x73,0xBF,0xE9,0x1D,0x16,
+0x24,0x18,0xDD,0x33,0x35,0x60,0x5E,0x94,
+0x0F,0xF9,0xC4,0x00,0x32,0xBB,0x04,0x17,
+0x27,0xB6,0x18,0x19,0x23,0xB6,0xA8,0xBB,
+0x27,0xFF,0x27,0x44,0xBC,0x42,0x1B,0x78,
+0x07,0x6B,0x39,0x5D,0x45,0xB4,0x99,0xDC,
+0x22,0x02,0xF2,0x0C,0x5B,0x86,0x2E,0x0B,
+0x0F,0x82,0xB4,0xE3,0x91,0x47,0xE0,0x47,
+0x2A,0x02,0x13,0x80,0x76,0x73,0x28,0x9F,
+0x0F,0x87,0x3E,0xC7,0x4A,0x1D,0x7F,0x21,
+0x27,0xD7,0x2F,0xA5,0x7B,0xDF,0xFD,0x46,
+0x2C,0x5C,0x60,0xE9,0x8B,0x8B,0x1E,0xF4,
+0x07,0xDB,0x26,0x02,0x2F,0x35,0x81,0x69,
+0x22,0x56,0x17,0x3C,0xCB,0x13,0xAF,0x71,
+0x0F,0x9E,0x4A,0xAB,0x85,0x80,0x02,0x3B,
+0x2A,0xFC,0xE2,0x0D,0x2F,0x81,0xC3,0xD9,
+0x07,0x2A,0x59,0xF2,0x81,0x2C,0x6B,0xED,
+0x2F,0x17,0x1F,0x1B,0xE3,0x8A,0x3A,0x8D,
+0x2C,0xE8,0x24,0x30,0x5D,0x2E,0x79,0xFE,
+0x0F,0x8C,0x0E,0xC7,0xB7,0x8D,0x24,0xC0,
+0x07,0xEB,0xB0,0x26,0xE6,0xF0,0x46,0xB5,
+0x0F,0x4F,0xD0,0xF8,0x1F,0xBD,0x70,0x55,
+0x2A,0xF3,0x7E,0xD6,0x1B,0x12,0x69,0x5D,
+0x0F,0x8F,0x1A,0x10,0x2B,0x88,0x30,0xA9,
+0x2F,0xB8,0xF3,0xA4,0x06,0x07,0x29,0xFF,
+0x2F,0x01,0x43,0xD6,0xB0,0xC4,0x3B,0xEC,
+0x0F,0x27,0x05,0x37,0x3A,0x70,0x03,0x61,
+0x22,0xF4,0xBE,0xC4,0x2C,0x24,0xEC,0xF7,
+0x0F,0xA6,0x55,0x01,0x56,0x83,0xA9,0x0C,
+0x2F,0x6D,0x58,0xF4,0xCE,0x3F,0xEE,0xEB,
+0x27,0x36,0xDB,0x2E,0xDB,0xA1,0x19,0x15,
+0x2B,0xF0,0xC1,0x61,0xEB,0x69,0x33,0xFC,
+0x0F,0xF2,0x3F,0xCF,0xE7,0xB8,0x7A,0x36,
+0x27,0x8D,0x3C,0xF0,0x2B,0x96,0x53,0x87,
+0x27,0xC4,0x34,0xD0,0x97,0xCF,0x09,0x6D,
+0x27,0x80,0x27,0xF4,0x16,0x02,0xC6,0x68,
+0x22,0x59,0x26,0x8B,0xCD,0x33,0x5B,0x33,
+0x07,0x7F,0x1A,0x77,0x2E,0xAD,0xA6,0x73,
+0x2F,0xF4,0x63,0x96,0xD2,0xC7,0x82,0x50,
+0x2F,0x2D,0xA5,0x04,0xF7,0xD3,0x95,0x52,
+0x2F,0x72,0x8D,0x25,0xCC,0xDA,0x7D,0x15,
+0x27,0xD3,0xA9,0x03,0x1A,0xAC,0xE1,0x1B,
+0x2F,0xD4,0x0B,0x66,0x6A,0xBB,0xD1,0xDB,
+0x27,0xDE,0x79,0xC3,0x56,0x99,0x90,0x74,
+0x27,0xF1,0x5E,0x6B,0xFD,0x9A,0x55,0xD0,
+0x27,0xD0,0x78,0xF9,0x49,0x29,0x87,0xCD,
+0x2F,0x02,0x98,0xC9,0x89,0x58,0x3B,0x6C,
+0x27,0xC7,0x35,0x07,0x08,0x8B,0x12,0xE4,
+0x2F,0x41,0x54,0x4A,0xBB,0x0D,0x53,0x13,
+0x2F,0x37,0xC7,0x6D,0x6C,0x0A,0xE6,0xE0,
+0x2F,0x68,0x30,0x30,0xD6,0x96,0x51,0x09,
+0x2F,0x31,0x8A,0x38,0x0D,0xA6,0xFE,0x4C,
+0x2F,0x6E,0x44,0x89,0x42,0x4C,0x2D,0x62,
+0x27,0xED,0x16,0x32,0x0F,0x43,0x91,0xF2,
+0x2F,0x06,0x9B,0xBC,0x98,0x0F,0xA4,0xFC,
+0x2F,0x81,0x46,0x60,0x37,0x7F,0xBA,0xB2,
+0x21,0x64,0x93,0x15,0xFE,0x15,0x6B,0x4D,
+0x0F,0xC8,0x53,0xAF,0x7D,0x4A,0x0F,0xAE,
+0x2F,0x03,0xFD,0x13,0x13,0xFD,0xB9,0xB5,
+0x27,0xB5,0x5C,0x7E,0x14,0xD4,0x31,0xB1,
+0x2F,0x56,0xF3,0x70,0xA0,0xE3,0x20,0xD2,
+0x2F,0xB8,0xA8,0x39,0x36,0x23,0x9F,0x8E,
+0x27,0x01,0x83,0xB8,0x38,0x6B,0x54,0x59,
+0x2F,0xFC,0x27,0xF8,0xB6,0x5C,0xF5,0x1C,
+0x2F,0x6D,0xD1,0x4D,0x3D,0x57,0x1F,0x63,
+0x27,0xBA,0xDD,0x2E,0x43,0xA6,0xB3,0x8F,
+0x2F,0x8B,0x7A,0x9E,0xF6,0xFD,0x69,0xC2,
+0x26,0x5B,0x45,0x2F,0xA2,0xDA,0x5B,0x5B,
+0x07,0xDE,0xD3,0xDA,0xCB,0x6B,0xD3,0xB3,
+0x07,0xA6,0x63,0xC2,0x67,0x78,0xAC,0xC4,
+0x2F,0xE3,0x75,0xB2,0xC9,0x88,0xB2,0x8E,
+0x27,0x3C,0x34,0x26,0xDE,0x91,0x2C,0xD5,
+0x2F,0xC0,0x91,0x75,0x7D,0xBF,0xEF,0xDF,
+0x27,0x4A,0x25,0x4B,0xB1,0x59,0x2C,0xF7,
+0x27,0xF5,0xFB,0xFD,0x95,0xAD,0x12,0xF2,
+0x27,0xA1,0x6D,0xD6,0xFD,0x80,0x91,0xF6,
+0x27,0x03,0x6F,0xE0,0x8B,0x36,0x58,0xBC,
+0x2F,0x98,0xF2,0x0B,0xE1,0xD1,0x65,0x11,
+0x2F,0x77,0xA5,0x32,0x8E,0x29,0x3D,0x76,
+0x2F,0x90,0x17,0xDA,0x3A,0x62,0xFC,0x57,
+0x27,0x80,0xD9,0x58,0x03,0xAF,0x1A,0xDE,
+0x2F,0xBC,0x01,0xD2,0x74,0xB0,0x3C,0x5A,
+0x2F,0x8A,0x13,0x1D,0x29,0x77,0xBB,0x59,
+0x2F,0x28,0xD9,0xA2,0x28,0xDA,0xBC,0x14,
+0x2F,0xFD,0x1D,0x3B,0xA1,0x58,0xF5,0xCA,
+0x2F,0xE1,0xEA,0x52,0x38,0x8F,0xF0,0x5F,
+0x2F,0xD6,0x2F,0xD2,0x0E,0xB4,0xDF,0x33,
+0x27,0xC8,0x6E,0x63,0x64,0x42,0x28,0x32,
+0x27,0x96,0x44,0xF9,0x47,0x6B,0xC7,0xC7,
+0x22,0xA4,0xF9,0x54,0x66,0x87,0x6A,0xCF,
+0x07,0x8C,0xFF,0x74,0xC5,0x29,0xFF,0xB9,
+0x0F,0x14,0x12,0xD0,0x19,0x2B,0xCF,0x6F,
+0x07,0x8D,0xA1,0x1A,0x4E,0xCC,0xF9,0x79,
+0x0F,0x69,0x19,0x4B,0x70,0x95,0xE0,0x38,
+0x07,0x70,0x85,0x50,0x32,0x42,0xA6,0x38,
+0x07,0xF4,0xE6,0xE4,0x2E,0x17,0xF0,0x51,
+0x0F,0x5B,0x0E,0xE6,0x51,0x3A,0x5E,0x8B,
+0x27,0x0A,0xC1,0x97,0x47,0x25,0x9C,0x11,
+0x27,0x43,0x28,0xCC,0xFD,0xBB,0xD2,0xD9,
+0x27,0xA9,0x84,0x32,0x5A,0x74,0xBA,0xA6,
+0x27,0x65,0x77,0xAD,0x35,0x2D,0xE4,0xCC,
+0x2D,0x1F,0x3F,0xB8,0x31,0x18,0x42,0x99,
+0x0F,0xA7,0x88,0x12,0x1E,0x68,0x48,0x70,
+0x2F,0x12,0x22,0x4F,0x63,0x39,0x19,0x25,
+0x27,0x07,0xCE,0xBF,0x8D,0x8A,0x58,0x55,
+0x27,0x93,0xCF,0x3E,0xB2,0xF1,0xC5,0x0C,
+0x26,0x62,0xD0,0x69,0x81,0x07,0xE1,0xFD,
+0x07,0x21,0x5A,0x26,0x9F,0xCA,0x93,0x31,
+0x2F,0x34,0xFB,0xEB,0xBF,0x07,0xBD,0xF3,
+0x27,0x8C,0x0D,0xE9,0xE4,0xF3,0xAD,0xBB,
+0x25,0xC7,0x5A,0xA0,0xB3,0x09,0xCC,0x9F,
+0x0F,0xDA,0xC1,0xE3,0xCD,0xED,0x60,0xC5,
+0x2E,0xF4,0xC5,0x03,0x26,0xAC,0x7E,0xE0,
+0x0F,0x50,0x8B,0x90,0xF1,0xFB,0x6E,0x58,
+0x0F,0x3C,0x53,0x76,0xFB,0xAA,0x44,0xAD,
+0x0F,0x4B,0xA4,0x5D,0x17,0xC8,0x88,0xE9,
+0x2F,0x9F,0x61,0x47,0x83,0xC9,0x5D,0x95,
+0x2F,0x18,0xA7,0x74,0x2D,0x5D,0x09,0xC4,
+0x27,0x83,0xB7,0xC1,0x23,0xE5,0x9D,0x0B,
+0x2F,0xF2,0x68,0xAF,0xA2,0x10,0xEF,0xC2,
+0x2F,0x96,0xFB,0x85,0x89,0x3D,0xAD,0x09,
+0x27,0xBA,0xF3,0x7B,0xEA,0x0E,0xB7,0xC4,
+0x27,0x36,0xBD,0xC2,0x05,0x47,0xDD,0x23,
+0x2F,0x17,0x09,0x79,0x6E,0xB0,0x69,0x58,
+0x2F,0x13,0xB1,0xFC,0x4D,0x12,0x57,0x30,
+0x2F,0xA8,0x02,0x53,0x7A,0xD8,0x05,0x60,
+0x25,0x98,0xC5,0xAD,0xAF,0x2B,0x9B,0x0E,
+0x07,0x07,0xEB,0xC9,0x7B,0x20,0x62,0xB4,
+0x27,0x68,0xB4,0x0C,0x3C,0x6C,0xB8,0xEC,
+0x0F,0xCF,0x24,0xBF,0xDA,0xC7,0xBE,0x93,
+0x27,0x8D,0xAE,0xA3,0xD0,0x58,0x99,0x3D,
+0x2F,0x50,0x54,0x87,0xFC,0xC5,0xB4,0xF8,
+0x2F,0x68,0xE4,0xD4,0xF3,0x5A,0x3C,0x93,
+0x2F,0xAA,0xE2,0xCD,0xC7,0xCB,0x5D,0xCC,
+0x2F,0x6D,0x0F,0xFA,0xA6,0x26,0xDF,0xBD,
+0x2F,0x55,0x0E,0xAC,0xDF,0x8E,0x4A,0xFF,
+0x27,0xB2,0x31,0xA5,0xEB,0x9E,0x7F,0x5C,
+0x27,0x38,0x96,0x01,0xFE,0x95,0xF2,0xBA,
+0x2D,0xC3,0x24,0xCE,0x2E,0xE6,0xB9,0x9D,
+0x07,0xDF,0xB6,0x66,0xC7,0xC7,0xF0,0xBA,
+0x2F,0x30,0x29,0x65,0xDE,0x39,0x22,0x22,
+0x27,0x6F,0xA4,0x35,0xA1,0x0C,0x80,0x5D,
+0x27,0x8F,0x21,0x3C,0xC1,0x21,0x83,0x0E,
+0x27,0xE1,0x4B,0xC3,0x70,0xA0,0x34,0x0D,
+0x27,0x62,0xF1,0x80,0x17,0x8B,0x88,0xE7,
+0x2F,0x96,0x84,0x5E,0x1A,0xFA,0x32,0x7A,
+0x2F,0xBA,0xF8,0x30,0x2E,0x28,0x29,0x93,
+0x27,0xD8,0x01,0x42,0x89,0x1E,0x59,0xC8,
+0x2F,0xC4,0x8B,0x8D,0x0C,0x2B,0x63,0x6C,
+0x27,0x9F,0xC0,0xFC,0xB3,0xB6,0x6D,0xFF,
+0x2F,0x69,0xC4,0xD7,0xA2,0xD6,0xB6,0x58,
+0x27,0x3E,0x7E,0x81,0x59,0xD9,0x39,0x03,
+0x2F,0x0D,0xFD,0x6C,0x1F,0x69,0x9A,0x4F,
+0x27,0xBB,0x4B,0xD3,0x27,0x83,0x9A,0x82,
+0x2F,0x6C,0x35,0x3E,0xAA,0x42,0xE0,0x83,
+0x27,0xD7,0xE3,0x9C,0x3A,0xBD,0x63,0x1B,
+0x27,0x5F,0x62,0xE9,0x97,0x06,0x7C,0xAF,
+0x2F,0xB1,0x6A,0xAB,0x56,0x8F,0xF5,0x37,
+0x2F,0xD8,0xC2,0x84,0x22,0x37,0xC3,0x68,
+0x2F,0xCE,0x69,0x3E,0x93,0x92,0x25,0x0A,
+0x2F,0x82,0x9B,0x04,0x16,0x62,0x38,0x0D,
+0x2F,0xA5,0x9B,0x08,0xD6,0xD5,0x1A,0xE2,
+0x27,0x58,0x2F,0x61,0xE0,0x3F,0xB3,0x5F,
+0x2F,0x44,0x1F,0x53,0x54,0xB3,0xF0,0x0B,
+0x27,0xC5,0x61,0xD4,0x10,0x23,0x8E,0x53,
+0x27,0x6D,0x70,0xB6,0x8F,0xAB,0xF7,0xF0,
+0x2F,0xF5,0x44,0x86,0x10,0x72,0xB5,0x41,
+0x27,0x86,0xE6,0x0E,0x07,0x44,0xAF,0x42,
+0x27,0x25,0x29,0x60,0x59,0x78,0x39,0xB6,
+0x27,0xC2,0xE2,0x16,0xDD,0xC5,0x4C,0x0E,
+0x27,0x5D,0x77,0x9C,0xA4,0x77,0xC6,0xD3,
+0x27,0x56,0x7A,0xB0,0x94,0x36,0x94,0x71,
+0x27,0xA1,0x00,0x37,0x28,0x8C,0x7E,0x5A,
+0x27,0xFB,0x7B,0x7A,0x2E,0x0C,0x74,0x94,
+0x27,0x98,0x96,0xC0,0x93,0x44,0xC0,0x0E,
+0x2F,0xA2,0x9E,0x73,0xDB,0x28,0x30,0x67,
+0x2B,0x54,0x99,0xA0,0x36,0xFA,0xE0,0x0E,
+0x27,0xA6,0xC7,0x09,0x05,0xF3,0xF6,0x79,
+0x2F,0xE6,0x31,0xFB,0x3B,0xFD,0xC7,0x19,
+0x2F,0x74,0x34,0x09,0x0B,0xCB,0x23,0x0D,
+0x27,0xA1,0xD1,0xE5,0x15,0x2C,0x28,0x1A,
+0x27,0xFF,0x6D,0xF4,0x8A,0xD1,0xBB,0x2F,
+0x2F,0x7C,0x9F,0x73,0x05,0x5A,0xBD,0x6F,
+0x27,0x70,0xFF,0xAA,0xA9,0x5F,0xD8,0xBF,
+0x23,0x11,0xF8,0xEC,0x09,0x7B,0xA3,0xB4,
+0x0F,0x2B,0xCC,0x07,0x26,0x3E,0xAA,0x85,
+0x0F,0x0C,0xD6,0x7F,0x56,0x59,0xA4,0x80,
+0x07,0xD3,0xDB,0x8A,0x83,0x71,0x0B,0xC6,
+0x07,0x9C,0xA8,0x42,0x7C,0x52,0xF7,0x7A,
+0x0F,0x3F,0xC6,0xF6,0x2C,0x76,0xD6,0xF7,
+0x27,0x26,0x93,0x83,0x9F,0xA8,0x19,0x9D,
+0x22,0x4A,0x2E,0x56,0x0C,0x05,0x6A,0xDD,
+0x0F,0x67,0xAC,0xCF,0x70,0x7A,0x99,0x70,
+0x27,0x6A,0x5C,0x33,0xE2,0xFF,0x69,0x1A,
+0x27,0x0A,0xC6,0xED,0x2A,0xEE,0x1E,0xA9,
+0x2F,0x3E,0x76,0xB1,0x0D,0x1F,0xC1,0x09,
+0x27,0x98,0xA7,0xC3,0xB4,0x73,0xD3,0x8C,
+0x2F,0x8D,0x61,0xA8,0xFC,0x20,0x9C,0x71,
+0x2F,0x1E,0xDA,0xC7,0xFD,0x83,0x75,0x34,
+0x27,0x17,0x6F,0x90,0x8C,0x18,0x25,0x1A,
+0x2F,0xCF,0xC6,0x8E,0x96,0xF2,0xDC,0xEA,
+0x2F,0x05,0xC9,0x10,0x99,0xD6,0x99,0x59,
+0x2F,0x1A,0x2D,0x82,0xCF,0xCA,0xE2,0x65,
+0x27,0x3B,0xC2,0x9F,0x09,0x3B,0x8F,0xF4,
+0x27,0x7B,0x26,0x24,0x46,0xDE,0x7B,0x7F,
+0x27,0x6E,0xF2,0xF8,0x68,0xFC,0x68,0xAB,
+0x27,0x1C,0x74,0xA7,0x48,0xB4,0xDE,0x59,
+0x27,0xC2,0xE7,0x18,0x14,0x33,0xAB,0x02,
+0x07,0x01,0x89,0xE7,0x85,0xAB,0xD1,0x19,
+0x2F,0x5A,0x73,0x10,0x0A,0xE1,0x9F,0xF8,
+0x2F,0x33,0x2D,0xC4,0x51,0x73,0x07,0xFC,
+0x2F,0x78,0xFA,0x10,0x5E,0xDA,0x83,0xB8,
+0x27,0x29,0x53,0xC3,0x9B,0x02,0x3B,0x07,
+0x27,0x09,0x7A,0xF4,0xB6,0xFF,0xEC,0x9F,
+0x2F,0x21,0x49,0x40,0x49,0x74,0x99,0xA9,
+0x2F,0x42,0x51,0xFC,0x11,0x11,0x58,0x17,
+0x27,0x5A,0xD1,0x69,0xE9,0xC7,0xC0,0x32,
+0x07,0x70,0x28,0x7C,0x89,0x1F,0x74,0x9E,
+0x2F,0x06,0x06,0x08,0x49,0xD7,0x13,0x4F,
+0x2F,0xD5,0x71,0x5D,0x6F,0x66,0xB4,0x70,
+0x27,0x52,0x6E,0x78,0xB6,0x0C,0x59,0xB8,
+0x2F,0x94,0x84,0x3F,0xEC,0xAE,0x59,0xEC,
+0x2F,0x00,0x66,0x02,0x64,0x73,0xD1,0x86,
+0x27,0x30,0x52,0x96,0x42,0x9E,0x9A,0xD7,
+0x2F,0xDC,0x52,0x87,0x6E,0x56,0x3D,0x9C,
+0x27,0x8F,0x4D,0x09,0xC6,0x80,0xB9,0x70,
+0x26,0x3F,0x89,0x6A,0xCA,0xCC,0x8E,0x15,
+0x0F,0xC3,0x42,0xEF,0x5D,0x46,0xBA,0xC0,
+0x2F,0xAB,0xE2,0x2C,0x22,0xE8,0xAA,0x77,
+0x2F,0x9F,0xF2,0x5A,0x22,0x7C,0x5F,0x59,
+0x2B,0xDC,0x4A,0x8B,0x8D,0x9E,0xCC,0xA5,
+0x0F,0xB6,0x22,0xC3,0xC7,0xE1,0x44,0x93,
+0x27,0x38,0xE4,0x24,0x4B,0x1C,0x32,0xB0,
+0x2F,0xCB,0x77,0xD9,0x75,0x98,0xFE,0x93,
+0x2A,0x19,0xC5,0x04,0x48,0x26,0x97,0x86,
+0x07,0x3F,0x57,0xCA,0xDE,0xB6,0xB6,0xFC,
+0x27,0x12,0x36,0x5A,0xC7,0xE2,0xA5,0x83,
+0x2F,0x3F,0x91,0x6D,0xCF,0x8E,0x8D,0x30,
+0x27,0x3B,0x20,0x62,0x2B,0x38,0xC0,0x19,
+0x27,0xBA,0x2D,0x92,0xE4,0xD7,0x21,0x54,
+0x2F,0x62,0x09,0x70,0x89,0x4A,0xEE,0x40,
+0x07,0xBE,0x30,0xF1,0x4F,0x56,0xA8,0x6E,
+0x2F,0x5D,0x82,0xC5,0x24,0x87,0xA5,0xA2,
+0x2F,0x96,0xF0,0xD2,0x74,0x43,0x26,0x34,
+0x2F,0xAA,0x22,0x1F,0x93,0x87,0x56,0x2C,
+0x07,0x1F,0xBD,0x7B,0x6C,0xE6,0x19,0x82,
+0x27,0x36,0x85,0x50,0x38,0xCC,0x2C,0x39,
+0x2F,0xE2,0xE7,0xB3,0x67,0x08,0x07,0xE2,
+0x27,0xE6,0xF0,0xED,0x6D,0x23,0x1F,0xA9,
+0x27,0x85,0xA5,0xF6,0x20,0x3B,0xC7,0x18,
+0x27,0xC6,0x1D,0xB2,0xAC,0x2C,0xB1,0x53,
+0x2B,0x06,0xB8,0x47,0xC8,0x3A,0xDA,0xFF,
+0x0F,0x5A,0x6E,0x4A,0xD9,0x87,0xA6,0xAC,
+0x27,0x44,0xF4,0x69,0xC9,0x45,0x1B,0xF3,
+0x2F,0x95,0x35,0x58,0xB8,0x21,0x34,0x8D,
+0x27,0x7A,0x8B,0xCD,0x94,0xD3,0x6B,0x0A,
+0x2F,0x47,0x55,0x74,0x10,0x7D,0x91,0xF8,
+0x2F,0xC0,0xAA,0x3A,0xD1,0x4C,0xA6,0xE2,
+0x22,0x87,0xCA,0xBF,0xE2,0xFA,0x5C,0xFF,
+0x0F,0x76,0xBA,0xAD,0x5F,0xBC,0x79,0x55,
+0x27,0xF8,0xC1,0x39,0x8E,0x04,0x66,0x48,
+0x27,0xC8,0x9D,0xC4,0x74,0xC3,0x30,0x72,
+0x2F,0x6D,0xCB,0x9A,0xBF,0x91,0x44,0x16,
+0x27,0xF3,0x10,0x5A,0xCC,0x2B,0x09,0x40,
+0x27,0x60,0xFA,0x25,0xFF,0x71,0x02,0xC9,
+0x2F,0x69,0x9D,0xA7,0x08,0xA1,0x4B,0xA0,
+0x27,0x8D,0x5C,0x1B,0x7C,0xBD,0xC7,0x2A,
+0x27,0xD9,0x2F,0x58,0xE3,0x27,0xCA,0x59,
+0x27,0x12,0x5C,0x91,0x96,0x14,0xC3,0x50,
+0x2F,0x6C,0x6F,0x83,0xA7,0x0A,0x8E,0x8E,
+0x2F,0x4E,0x37,0x7F,0xB8,0x1A,0x8E,0x83,
+0x27,0x5A,0x40,0xA0,0xFE,0xC3,0xDE,0xE9,
+0x27,0xD0,0xE5,0xA6,0xE5,0x28,0x11,0x46,
+0x27,0xE0,0x6B,0x3E,0xBC,0x5A,0x8C,0xDB,
+0x27,0xAA,0x8F,0x45,0x4E,0x7E,0xC4,0xEC,
+0x24,0x2E,0x5E,0x4B,0x44,0xB6,0x45,0x0C,
+0x07,0x78,0x54,0xB3,0x24,0xEE,0xB9,0x6A,
+0x27,0x5C,0xDF,0xEC,0x63,0x54,0x69,0x24,
+0x2F,0x89,0x9A,0x4D,0x80,0x3F,0x8F,0xB1,
+0x27,0x86,0x4C,0x02,0x07,0x7E,0x13,0x7E,
+0x2F,0x4D,0x0E,0xFA,0x6B,0xEE,0xE3,0x4E,
+0x2F,0x9A,0x51,0x1D,0x18,0x1D,0xA2,0x5B,
+0x27,0x47,0xF9,0x76,0x79,0x17,0x81,0x3F,
+0x2F,0x7E,0x24,0xD7,0xA6,0x14,0xA5,0x3B,
+0x2F,0x53,0xAA,0x09,0xF7,0x65,0xC8,0xEE,
+0x27,0x4A,0xFC,0x61,0x5F,0x7B,0xAB,0xFB,
+0x26,0x49,0xA5,0x7C,0xC8,0xAA,0x4B,0xDD,
+0x07,0x15,0x2E,0x15,0x14,0xA7,0xE7,0xC4,
+0x07,0x1C,0x68,0xD8,0x61,0x8D,0xB6,0x9B,
+0x27,0x07,0x18,0x32,0xBA,0x4E,0x93,0xD1,
+0x27,0x53,0xF0,0xD1,0x94,0xA3,0x80,0x06,
+0x22,0x95,0x51,0x30,0x4D,0x6F,0x16,0x52,
+0x07,0xDD,0xDC,0x2D,0xF5,0x6A,0x0A,0xFE,
+0x2F,0xFD,0x00,0x06,0x6E,0xC2,0x7F,0x31,
+0x2F,0x96,0x74,0xB6,0xDE,0x9C,0xD3,0xDD,
+0x2F,0x16,0x59,0xB0,0x6D,0xFC,0xA6,0x76,
+0x29,0xF4,0xDD,0x3D,0xE6,0x68,0x21,0xC4,
+0x07,0x10,0x8E,0x65,0x84,0x3F,0xC8,0x6E,
+0x2F,0xB5,0x9B,0x84,0x0B,0x86,0xD6,0x5E,
+0x2F,0x25,0x80,0xF3,0xC4,0xF5,0x21,0x66,
+0x27,0x12,0xCF,0x43,0x77,0xB8,0xED,0x45,
+0x27,0x55,0x48,0xD3,0x7D,0x1F,0x95,0x6C,
+0x2D,0x34,0xD7,0x8B,0x3F,0x10,0xA3,0x47,
+0x0F,0x96,0xD4,0x5C,0x81,0xB2,0x84,0x25,
+0x2F,0xBA,0x9B,0xB2,0x8D,0x79,0xB8,0x3E,
+0x27,0x04,0xA7,0x4C,0x7A,0x45,0x92,0x66,
+0x27,0x3F,0x7B,0x39,0xA5,0x67,0x21,0xC2,
+0x27,0xA1,0x3E,0x67,0x17,0x7B,0x0F,0x11,
+0x27,0xB1,0x55,0x7B,0x24,0x80,0x1C,0x36,
+0x2F,0xAE,0x40,0x86,0xCA,0xA8,0xA6,0x13,
+0x27,0xC7,0xE0,0x9A,0x79,0x9C,0xF2,0xC8,
+0x2F,0x96,0x66,0x20,0xCF,0x41,0x82,0x09,
+0x2F,0x3F,0xC4,0x25,0x41,0xEC,0x7B,0xEA,
+0x2F,0x3B,0xE6,0xB4,0x99,0xED,0x42,0xCF,
+0x2F,0x0A,0x9F,0x49,0x5A,0xD9,0x0A,0xC6,
+0x07,0xEF,0x47,0xE4,0x0E,0x69,0xF7,0xF6,
+0x0F,0x57,0xEE,0x7E,0xD5,0x18,0xCD,0x17,
+0x0F,0x5E,0x2E,0x58,0xF1,0x14,0x0D,0x99,
+0x0F,0x2B,0xD2,0x01,0x16,0x81,0x7E,0xFF,
+0x2F,0x42,0x0F,0xC4,0x97,0xFF,0x94,0x91,
+0x2F,0x2F,0x1E,0x65,0xD4,0xCA,0x10,0x4B,
+0x25,0x96,0x7F,0xC3,0x25,0xFD,0xE0,0x9E,
+0x0F,0x77,0x27,0xE4,0x13,0xC0,0xBB,0x3C,
+0x27,0x0E,0xBB,0x60,0xFF,0xC0,0x88,0xA4,
+0x27,0x42,0xCC,0x24,0x2A,0xCB,0xA5,0xFF,
+0x27,0x74,0xD9,0xE9,0xFD,0x6D,0x30,0xFC,
+0x27,0x3B,0x39,0xCC,0x41,0x8D,0x01,0xCA,
+0x2F,0x70,0xBD,0xF1,0x38,0xEF,0x22,0x63,
+0x24,0x5E,0x54,0xB3,0x79,0xBA,0x7B,0xBA,
+0x07,0x3A,0xC5,0xBA,0x83,0x85,0x61,0xB9,
+0x0F,0x8A,0x97,0x6A,0x93,0x08,0x72,0x4A,
+0x07,0xAF,0x46,0x26,0x27,0xBE,0x5F,0x30,
+0x0F,0x79,0x53,0xFA,0xEC,0xDD,0xF5,0xDF,
+0x2F,0xA1,0xBF,0x3B,0x6B,0xF6,0x65,0xF5,
+0x2F,0xC3,0xC3,0xC3,0x63,0xD0,0x2E,0x56,
+0x2F,0xD2,0xE0,0x1C,0xAC,0xA9,0x37,0x5F,
+0x27,0x9B,0xC5,0x5C,0x8F,0xC7,0x7A,0x3C,
+0x2B,0x9E,0x00,0x31,0x2F,0x62,0x83,0x17,
+0x0F,0x66,0x40,0x34,0xAE,0x82,0x56,0x07,
+0x27,0x09,0xA8,0x95,0x20,0x26,0x09,0xFC,
+0x2A,0x16,0xA0,0xED,0x5C,0xE6,0xB9,0x80,
+0x0F,0x5A,0x6C,0x1A,0x09,0x2F,0x35,0xCD,
+0x27,0x50,0x2E,0xBB,0x6C,0x51,0x14,0xB5,
+0x27,0x70,0x54,0x56,0x07,0x7C,0x1B,0x61,
+0x2F,0x29,0x81,0x08,0x41,0xCA,0x3D,0xCD,
+0x2F,0xC5,0x37,0x1E,0xCA,0x96,0x0A,0x82,
+0x27,0x21,0x0D,0xD8,0xD7,0x4C,0xF7,0x4B,
+0x2F,0xD3,0x35,0xF0,0x84,0xFD,0xCF,0xB4,
+0x27,0xD1,0x5C,0xD3,0x8A,0xB4,0x1E,0xD6,
+0x2F,0x04,0xFA,0x28,0x48,0x05,0xC2,0x94,
+0x2F,0xC9,0x66,0xCD,0x2D,0x77,0xBC,0x58,
+0x2F,0x63,0x20,0x0F,0x8E,0x18,0x99,0x74,
+0x27,0xF2,0x78,0x1A,0x5E,0x17,0x43,0x61,
+0x2F,0x26,0xA5,0x5B,0x14,0x9B,0x6C,0x4C,
+0x2F,0xBA,0xC4,0x03,0x3E,0xE5,0xAC,0xEC,
+0x27,0x5E,0x8D,0x0D,0xAF,0x0F,0x44,0x77,
+0x27,0x29,0x3C,0xC4,0xFC,0x64,0x6B,0x4C,
+0x2F,0x4B,0x8C,0xE0,0x06,0x31,0x93,0xCB,
+0x27,0xF4,0x4D,0x38,0x7F,0x98,0x3D,0xB4,
+0x27,0xEB,0x1A,0xB4,0x2F,0x15,0x1E,0xEA,
+0x27,0x6B,0xED,0xE0,0xA3,0x13,0x4C,0xC5,
+0x2F,0x77,0xAA,0x58,0x31,0x0C,0xAB,0xF5,
+0x23,0x05,0xA1,0x61,0x4A,0xEC,0xDB,0xE1,
+0x0F,0x67,0x02,0xC2,0xAA,0x83,0x51,0x5F,
+0x2F,0x02,0xE4,0x30,0x84,0x05,0x10,0xEB,
+0x2A,0xCF,0x84,0x1A,0xD0,0x10,0x6D,0x7B,
+0x07,0x09,0x53,0xAB,0xBE,0xC4,0x91,0x33,
+0x2F,0x7D,0xF4,0xED,0x7F,0xBC,0x84,0x7F,
+0x27,0x49,0xB2,0xCE,0xB1,0xF2,0xFD,0x27,
+0x27,0x9C,0xB5,0xB8,0x91,0xDF,0xD1,0xE7,
+0x27,0x5E,0x32,0x21,0xC4,0x4B,0x64,0x91,
+0x27,0x42,0xD5,0x8A,0x5C,0xC5,0xC7,0x42,
+0x27,0xAD,0x05,0x97,0xAF,0xDB,0x74,0x5A,
+0x27,0x8D,0xB8,0x82,0x0D,0xFD,0x57,0x82,
+0x27,0x66,0x4E,0xC5,0x0E,0x7B,0xFE,0xED,
+0x0F,0xAC,0x4C,0x29,0x56,0xCB,0x36,0xA6,
+0x0F,0xDB,0x09,0x8B,0x3D,0x71,0x85,0x45,
+0x0F,0x32,0xC5,0x4B,0x1D,0x3B,0x08,0xB7,
+0x07,0x49,0xF4,0x32,0x1C,0x0E,0x75,0xC1,
+0x27,0x5F,0x11,0xDC,0x0B,0x76,0x9D,0xB4,
+0x2E,0xB0,0x17,0xAD,0x6E,0x6A,0x89,0x9B,
+0x0F,0xAF,0x1B,0x5C,0x92,0xE3,0xCE,0x17,
+0x0F,0x85,0x55,0x70,0x25,0xE7,0xF5,0x33,
+0x25,0x42,0xF3,0x1F,0xF7,0x69,0xAF,0xEE,
+0x0F,0xD5,0x85,0xBE,0x6C,0xD9,0x60,0xBD,
+0x07,0xE4,0xA0,0x9C,0x20,0x2E,0xAD,0xE6,
+0x07,0x09,0x04,0x83,0xD1,0xF5,0xA9,0xFF,
+0x27,0x72,0x86,0xBD,0xFE,0x36,0xF6,0xC2,
+0x2F,0x99,0x79,0xD4,0x09,0xDE,0x0E,0x9E,
+0x2F,0xD0,0x57,0x2E,0x51,0x89,0x0A,0xA7,
+0x27,0x91,0x76,0x58,0x66,0xA2,0x6B,0x6F,
+0x24,0x4F,0x09,0x68,0xAA,0x8C,0xAA,0x40,
+0x07,0x70,0x93,0x6B,0x23,0x8B,0xEC,0x2A,
+0x0F,0x20,0xE4,0x4A,0xC8,0x26,0x78,0x28,
+0x2A,0x92,0x35,0x37,0xD5,0xB4,0xC1,0xE3,
+0x07,0xBC,0x34,0x5C,0xA0,0x5B,0x6F,0x52,
+0x25,0xC3,0x39,0xD8,0x7E,0x44,0xBD,0x7C,
+0x0F,0xC4,0x52,0x72,0xB9,0xC0,0x99,0xF6,
+0x27,0xEB,0xFC,0x6B,0x09,0x5F,0xE5,0x06,
+0x27,0xE0,0x05,0xA2,0x27,0x32,0x7F,0xB7,
+0x27,0xB1,0xCF,0x4D,0x11,0x0A,0xCA,0xBB,
+0x23,0x12,0xA5,0x18,0x01,0xBE,0x6C,0x8D,
+0x0F,0xF0,0x14,0xA9,0xF2,0x94,0xFD,0x5A,
+0x2F,0xD1,0x32,0x70,0xCC,0xA0,0x99,0xD6,
+0x27,0x4A,0xD8,0x57,0xD0,0x49,0x99,0x2A,
+0x2F,0x4F,0x93,0xC1,0xDB,0x54,0xEE,0x29,
+0x2F,0x4B,0x25,0x9A,0xFC,0xED,0x87,0x52,
+0x27,0x64,0x9F,0x82,0xE0,0xC3,0x8C,0x84,
+0x2F,0x90,0x91,0xAB,0x03,0x42,0x74,0x12,
+0x2F,0x60,0x53,0x89,0xF5,0xAF,0xC9,0x89,
+0x2F,0x47,0xBE,0xEF,0x42,0xE8,0xA4,0x51,
+0x27,0x39,0x05,0x38,0xE5,0x79,0x78,0xE5,
+0x27,0x5D,0x2C,0x62,0x28,0xDF,0xB4,0x5F,
+0x27,0xE2,0x9A,0x7E,0x28,0xEB,0x21,0xC3,
+0x2D,0xDB,0x43,0x0D,0x55,0x18,0x74,0x46,
+0x0F,0xCF,0x0F,0x90,0x21,0xC5,0x32,0x0C,
+0x2F,0x13,0xB4,0x48,0x3B,0x35,0xFD,0x66,
+0x2F,0x27,0x92,0x64,0xE8,0xC0,0xF1,0xB1,
+0x2F,0x38,0xCD,0xCA,0xDF,0x48,0x66,0x7D,
+0x2F,0x36,0x80,0x2F,0x2A,0xDA,0x68,0xDC,
+0x27,0xB4,0x9C,0xF3,0xAC,0xC7,0x70,0x64,
+0x2F,0x16,0x69,0xF0,0x33,0xF3,0x42,0x7A,
+0x27,0x90,0x0C,0xB5,0x6E,0xDB,0xD3,0x6B,
+0x2F,0xEE,0x4E,0xD5,0xEB,0x22,0x69,0xD2,
+0x2F,0x44,0x9F,0xF2,0x60,0xA9,0xC2,0xB6,
+0x2F,0x4D,0x44,0xB6,0x86,0x1D,0x6E,0xD1,
+0x27,0xD3,0x19,0x67,0x29,0x8C,0xC5,0x74,
+0x2F,0x7D,0x4C,0x0C,0x7F,0x3F,0x9E,0xE8,
+0x27,0x0A,0x7C,0x47,0xE0,0x58,0x46,0xF5,
+0x23,0x67,0x71,0x1B,0x71,0xF5,0x2B,0x63,
+0x07,0x9C,0x65,0x3C,0xB9,0x3F,0x9C,0x98,
+0x2F,0x22,0x40,0xAB,0x08,0xB6,0xAE,0xED,
+0x2F,0xC0,0xAE,0x06,0x5B,0x2D,0x19,0x43,
+0x27,0xD1,0xE4,0xAA,0x4C,0xAD,0xD5,0x80,
+0x27,0xE1,0x7F,0x7C,0xFC,0x8A,0xC6,0xCC,
+0x27,0x84,0x4C,0x37,0xB5,0x32,0x60,0x67,
+0x27,0xCC,0xE7,0x44,0x99,0xE0,0x25,0x92,
+0x2F,0x34,0x5E,0xBA,0x0F,0x90,0x1C,0xC0,
+0x27,0x0C,0x07,0xF8,0x47,0xA6,0xF1,0x95,
+0x2F,0x52,0xF9,0x84,0x82,0x4D,0xB4,0x6B,
+0x2F,0x91,0x3A,0xA3,0xB4,0x8E,0xD3,0x1D,
+0x2F,0x5D,0xC7,0x5B,0x3D,0x3E,0x4F,0x11,
+0x2E,0x23,0x91,0xA8,0x4D,0x31,0xDC,0x06,
+0x07,0x45,0xB3,0x91,0x45,0x24,0x65,0x0F,
+0x27,0x74,0xCF,0x30,0xAE,0x89,0xE1,0xAB,
+0x0F,0x0F,0xC2,0xB5,0xD4,0xCA,0xB4,0x98,
+0x2F,0x4A,0xB0,0x1D,0x7C,0xBF,0x1F,0x76,
+0x2F,0xB4,0x14,0xFC,0x16,0x85,0x5A,0xC5,
+0x2F,0x82,0xAA,0xE4,0xF4,0x12,0x0F,0x64,
+0x27,0x1F,0x40,0xAC,0x00,0x89,0xF4,0x9D,
+0x0F,0x00,0x73,0xF2,0xC6,0x20,0xBF,0xEF,
+0x2F,0x07,0x1A,0x8C,0x7C,0x49,0x84,0x1C,
+0x21,0x13,0x08,0x30,0x44,0xDB,0xB5,0xED,
+0x07,0x1B,0x88,0xDE,0xB1,0x8E,0xA0,0xED,
+0x2F,0x60,0x10,0x40,0x40,0xE7,0x7F,0x8B,
+0x2F,0x27,0x51,0x4F,0xC3,0x18,0xB2,0x14,
+0x2D,0x0E,0xBD,0x51,0x11,0x20,0x2D,0x20,
+0x0F,0xB6,0x74,0xB4,0xB8,0x33,0x7B,0xA1,
+0x2A,0x21,0xC7,0x3C,0x7A,0xCD,0x07,0x09,
+0x07,0xA2,0x85,0x93,0xE5,0x07,0x00,0x9A,
+0x25,0xAB,0x10,0x72,0xEE,0x95,0xD4,0xD4,
+0x0F,0xA1,0x3E,0x1E,0xF3,0x09,0x3D,0x15,
+0x2F,0x08,0xB4,0x2D,0xD6,0x95,0xD9,0x14,
+0x27,0xA2,0x3E,0xAA,0x79,0x4E,0x78,0x5F,
+0x2F,0x53,0xD2,0x3D,0xE6,0x6B,0x93,0x27,
+0x27,0x7B,0xD9,0xC1,0xE5,0x08,0x9C,0xF1,
+0x2F,0xAA,0x20,0x6B,0x6C,0xBD,0x1E,0x9D,
+0x2F,0x7B,0x3A,0x39,0x52,0x51,0x83,0xED,
+0x27,0x92,0xB7,0x38,0x75,0x0E,0xB1,0x2B,
+0x27,0x9A,0x40,0x11,0xDC,0x06,0x2B,0x1E,
+0x27,0xFE,0x34,0xBC,0x59,0x6E,0x31,0xF3,
+0x2F,0x8D,0xFC,0xB5,0x4F,0x4C,0xB5,0x52,
+0x27,0xA0,0x4A,0x70,0x02,0xFB,0xD7,0xD1,
+0x27,0xEA,0x01,0x87,0xBE,0x8D,0x29,0xC6,
+0x2F,0x39,0xC3,0x8B,0xB7,0x96,0xC2,0x56,
+0x2F,0x50,0xE6,0xF4,0x50,0x03,0xBA,0x61,
+0x27,0x02,0xCC,0x03,0xAF,0x2F,0x3F,0xAC,
+0x27,0xAB,0x69,0xD0,0xCF,0xA7,0x4B,0x76,
+0x27,0xDF,0x31,0x4B,0xDE,0x55,0x54,0x19,
+0x2F,0x98,0xCB,0x8A,0x7F,0x1F,0xE3,0x62,
+0x2F,0x45,0x33,0x58,0xAD,0x03,0x57,0x81,
+0x2F,0x6D,0xC9,0xAA,0xDF,0x20,0x6E,0xF0,
+0x27,0xBC,0x1F,0x99,0xF3,0xDC,0x86,0xB5,
+0x27,0x19,0xE3,0x17,0x86,0x74,0xB8,0xFE,
+0x2F,0xED,0xCC,0x7F,0x97,0x47,0xFA,0xBB,
+0x27,0xB5,0xD9,0xC0,0xD1,0x7B,0x5E,0x9C,
+0x27,0xDA,0x1F,0x04,0xD9,0x0B,0xE2,0xB4,
+0x27,0xFF,0x8B,0xEF,0x7E,0x3A,0x4E,0xB9,
+0x2B,0xB0,0x49,0x12,0xA0,0x7E,0x02,0x5B,
+0x07,0x7D,0xAF,0x99,0x07,0xCC,0x75,0xF7,
+0x26,0x7C,0x3B,0xDC,0xBC,0xFC,0x49,0xCA,
+0x0F,0x8A,0x20,0x87,0x5D,0x14,0xF8,0xA6,
+0x27,0xB0,0xD5,0x65,0xFA,0xD1,0x0A,0xD7,
+0x27,0x3C,0x1A,0x67,0xE4,0x22,0x02,0xC8,
+0x27,0xA9,0x1B,0x72,0x33,0x88,0xAA,0x85,
+0x27,0x0E,0xCD,0x9D,0x2B,0x7F,0x2D,0xD7,
+0x27,0x78,0xA1,0xA1,0xF3,0x7C,0x03,0x6F,
+0x2F,0x1B,0x8D,0x6C,0xD7,0xF4,0xB1,0x05,
+0x2F,0x70,0x87,0x41,0xA8,0x8C,0x10,0xA6,
+0x2C,0x35,0x20,0x16,0x97,0x0B,0x8A,0xED,
+0x0F,0x15,0x1D,0xA2,0x5E,0x45,0xD3,0xC5,
+0x27,0x2C,0x0F,0xBD,0x38,0x35,0xC6,0x5F,
+0x2F,0x57,0x2A,0x4E,0x04,0xEB,0x1D,0x7C,
+0x27,0xBE,0x8B,0x7C,0x95,0x61,0xE8,0xCB,
+0x2F,0xBC,0xD4,0xC3,0xE3,0x0D,0x7A,0x30,
+0x27,0xC4,0x21,0x3B,0x73,0x01,0x99,0xDE,
+0x25,0x34,0x18,0xBB,0x31,0xC5,0x15,0x08,
+0x0F,0x50,0x89,0x4D,0x52,0x71,0x92,0xE3,
+0x2B,0x74,0xF0,0x5D,0xE7,0x28,0x74,0x47,
+0x0F,0x9B,0x52,0x53,0x3D,0x32,0x1F,0x7E,
+0x27,0x38,0x66,0xA1,0x48,0x1E,0x0E,0xD0,
+0x2F,0x13,0xF7,0x78,0x24,0xE7,0x4C,0xB6,
+0x29,0x11,0x9F,0xBA,0xA8,0x82,0x76,0x88,
+0x0F,0xC5,0x68,0x52,0xA8,0x98,0x41,0x7B,
+0x27,0xF4,0x5D,0x97,0x5B,0x2A,0xB5,0x9E,
+0x2F,0xF4,0x8A,0xE9,0x82,0xED,0x88,0x0F,
+0x27,0xC0,0x5B,0xB8,0xF8,0x53,0xC0,0x78,
+0x22,0x96,0x2E,0x0C,0x35,0xD3,0x60,0xB6,
+0x07,0x8F,0xDD,0x53,0xEE,0x41,0x75,0xC7,
+0x23,0xFB,0xC4,0xEB,0x71,0x45,0x70,0xCA,
+0x07,0x55,0x30,0xCF,0xEB,0xD0,0x69,0x85,
+0x2F,0x19,0xB4,0xB2,0xE0,0x96,0x3D,0x7D,
+0x2F,0xD4,0xDE,0x25,0xFF,0xCD,0x9B,0xAD,
+0x29,0xD9,0x0F,0x39,0xF5,0xCF,0x6C,0xF5,
+0x07,0x16,0xAA,0x3E,0x5D,0xE8,0xDC,0xE5,
+0x0F,0xFA,0x0B,0xA3,0xA6,0xC1,0x28,0x24,
+0x07,0x4E,0x25,0xA6,0x64,0x41,0xE4,0xDD,
+0x2C,0xED,0x9B,0x2D,0x69,0x43,0x68,0x8B,
+0x0F,0x2C,0xB0,0x8D,0x2F,0x87,0x58,0x82,
+0x2F,0xCF,0xA3,0xA6,0x34,0x85,0x77,0x3F,
+0x2F,0x9F,0x74,0x2E,0x81,0x54,0x64,0x40,
+0x2A,0xA6,0xEA,0xC1,0xDE,0xF0,0x4F,0xFC,
+0x07,0x09,0x4E,0x1E,0xD1,0x2D,0x91,0x04,
+0x07,0x81,0x03,0xE9,0x60,0x92,0x34,0xC8,
+0x07,0x56,0xD8,0x69,0xCA,0xD0,0x9C,0x50,
+0x2F,0x24,0x86,0x22,0x65,0xC2,0x00,0xB6,
+0x27,0xA9,0x07,0x54,0x03,0x61,0x4D,0x31,
+0x2F,0x26,0x00,0x6F,0x75,0x5E,0x60,0x5D,
+0x27,0xB2,0xA8,0xD5,0x5A,0xEE,0xE7,0xC5,
+0x22,0x43,0x1E,0x8E,0xB1,0x9A,0x9F,0x5C,
+0x0F,0x0B,0xD5,0x21,0x6A,0x6B,0xA2,0xF7,
+0x27,0x84,0xC6,0x1F,0x77,0xCF,0x40,0xBF,
+0x2F,0x1D,0xAA,0x6E,0x17,0x04,0x91,0x12,
+0x25,0xE6,0x94,0xB8,0x4B,0x56,0xAC,0xAB,
+0x07,0x43,0x87,0xC3,0xA1,0xE1,0xF5,0x35,
+0x2F,0x82,0xEC,0x75,0xEE,0x18,0x86,0xC8,
+0x2F,0xD4,0x89,0xB1,0x05,0x1C,0x87,0x1E,
+0x2F,0xA0,0xC9,0x6D,0x82,0x88,0x91,0xBE,
+0x2F,0x11,0xB4,0x4D,0x77,0xC0,0x1B,0x51,
+0x27,0x94,0x19,0xBE,0xB9,0x4B,0xAF,0x8A,
+0x27,0x20,0x2B,0xA5,0xB0,0xCB,0x00,0x53,
+0x2F,0x3F,0x77,0xD8,0xF1,0x9F,0xE3,0x5A,
+0x27,0xF6,0x3D,0x86,0xCA,0x8C,0x1A,0xD0,
+0x2D,0xD4,0x5E,0x18,0xAE,0x72,0x4D,0x60,
+0x0F,0xC4,0x8F,0xFB,0x7B,0xBB,0xDC,0x6B,
+0x2F,0x66,0x6D,0x58,0x1B,0x72,0xD1,0x84,
+0x27,0x31,0x44,0x6C,0x2A,0x18,0xDB,0x48,
+0x24,0x52,0xE5,0x00,0x0A,0x04,0xA7,0xDD,
+0x0F,0xA9,0xCC,0x71,0x35,0x7B,0xC0,0xDB,
+0x22,0x05,0xB3,0x25,0xAE,0x4F,0x1D,0x7C,
+0x07,0x23,0x9A,0x73,0x0F,0x3A,0xE6,0x6C,
+0x07,0xA3,0x4D,0xE1,0x80,0x1F,0xBF,0xC8,
+0x07,0x40,0x8D,0x7C,0x63,0xB9,0x6A,0x67,
+0x27,0x94,0x3C,0xB2,0x77,0x08,0x74,0x7B,
+0x27,0xD0,0xB6,0x69,0x26,0xAE,0x0F,0x80,
+0x2F,0x08,0x05,0x93,0xF3,0xB5,0x72,0x58,
+0x2F,0x90,0x96,0x7B,0xFD,0x27,0x09,0x6C,
+0x2F,0xEC,0xE4,0x48,0x31,0x65,0x93,0x1B,
+0x27,0x4F,0xB0,0xA9,0xD7,0xF6,0xC0,0xB2,
+0x27,0x62,0x89,0x87,0xD8,0xFA,0x05,0x02,
+0x27,0x65,0xAE,0xDE,0xBB,0x4D,0x24,0x8D,
+0x2B,0xD7,0x1A,0xE7,0x6E,0x85,0x07,0xF1,
+0x0F,0x32,0x40,0xA9,0x86,0xB4,0x46,0x81,
+0x2F,0x6D,0x19,0x7C,0xC8,0x15,0x81,0xC2,
+0x2C,0xC6,0x93,0x32,0x55,0xA0,0x4F,0xBC,
+0x07,0x63,0x01,0x3A,0xF7,0x3B,0x3A,0x59,
+0x26,0x66,0xBC,0xDB,0xD5,0xFE,0xBE,0x4B,
+0x07,0xCF,0xC8,0x2C,0x5D,0x60,0xF5,0x97,
+0x26,0xDF,0xF9,0x7C,0x9E,0xCC,0xB1,0xAA,
+0x07,0x3D,0xAA,0x99,0x80,0x8D,0x52,0xA5,
+0x27,0x12,0x8D,0x24,0xE8,0xAB,0xC8,0xA0,
+0x22,0xD1,0x1D,0xD7,0x21,0xC5,0xAB,0x4E,
+0x0F,0x61,0x23,0x71,0xB5,0xEF,0x60,0x59,
+0x2F,0xFC,0xF7,0x8A,0xE8,0x40,0x06,0x44,
+0x27,0xC2,0x4F,0x73,0xAE,0xC4,0x91,0x8E,
+0x2F,0xD7,0xC3,0x42,0x62,0x20,0x89,0x66,
+0x27,0xAE,0xEB,0x79,0x23,0x35,0xC3,0x6B,
+0x2A,0xB0,0x72,0x3E,0x71,0xA8,0xC8,0x30,
+0x07,0x44,0x80,0xE0,0xD8,0x3D,0x79,0x93,
+0x2F,0xA1,0x23,0x1E,0xCB,0x35,0x35,0x66,
+0x2F,0xA6,0xC1,0xC4,0x31,0x10,0x17,0xAD,
+0x27,0x8A,0xC1,0x1E,0xD6,0xA2,0x9B,0x31,
+0x27,0xA8,0x78,0xC6,0x36,0xEF,0x7A,0x2A,
+0x2F,0x48,0xCF,0xBB,0x3D,0xFF,0x05,0x5F,
+0x27,0xBB,0x68,0x9A,0xB2,0xDD,0xA4,0x64,
+0x27,0x82,0x2C,0x7D,0x2F,0x8D,0x51,0xBF,
+0x2F,0xEA,0x36,0xA6,0xEE,0x18,0x66,0x2F,
+0x2F,0x44,0xBA,0xB1,0xBD,0x2A,0x2B,0x45,
+0x25,0xD8,0xCB,0x36,0x86,0xF6,0x09,0xFC,
+0x07,0x20,0xAE,0x4B,0xD2,0xB5,0x1D,0x79,
+0x27,0xE7,0x9D,0xB3,0xA1,0xB5,0x5D,0xBE,
+0x2F,0xB3,0x64,0xFC,0xC5,0x56,0xE7,0xED,
+0x2F,0x1C,0x4C,0xBA,0x51,0x70,0x0A,0xEB,
+0x2F,0x3E,0x68,0xA5,0x6E,0xF0,0x2A,0xCF,
+0x22,0xB7,0x97,0x9B,0x8C,0x1B,0x51,0x79,
+0x07,0x76,0x72,0x71,0xA3,0xA4,0xFD,0x7C,
+0x27,0x02,0xC8,0x5F,0x35,0x96,0xDF,0xAA,
+0x2F,0xF8,0x13,0x5D,0x35,0x2D,0x44,0x88,
+0x27,0x6D,0x1C,0xBE,0x74,0xC5,0x3D,0xF8,
+0x27,0x84,0xBF,0x3D,0x01,0x88,0xC4,0x6A,
+0x27,0x47,0xE1,0x6D,0x99,0x9E,0x7A,0x93,
+0x27,0x83,0xCA,0xF0,0x90,0x88,0xEC,0xEB,
+0x2F,0x22,0x89,0x70,0x18,0xF1,0x01,0x9E,
+0x27,0x8A,0x3B,0x8D,0x03,0xC0,0x4E,0x6B,
+0x27,0xF0,0x3B,0x24,0x67,0xB8,0x0A,0xCD,
+0x27,0x7D,0x85,0x3C,0x2F,0x18,0xB9,0x83,
+0x27,0xB1,0x41,0xDD,0x7D,0x11,0xD4,0x27,
+0x2F,0xE3,0xBE,0x5E,0x32,0x71,0xDB,0x59,
+0x27,0x73,0xDD,0xE1,0xB0,0x9A,0xA2,0x0A,
+0x27,0xB3,0x05,0xE9,0x25,0x74,0xB2,0x54,
+0x27,0x5B,0xAD,0xF4,0x3C,0x36,0xA4,0xF7,
+0x2F,0x5C,0xA3,0x0C,0x91,0xC6,0x8F,0x9D,
+0x27,0xB7,0x23,0x4B,0x3F,0xBC,0x54,0xD2,
+0x27,0x6D,0x77,0x19,0x5B,0x7A,0x58,0x36,
+0x2F,0x66,0x04,0xDE,0x62,0xCE,0xFB,0xFF,
+0x2F,0xA9,0xD2,0x06,0xBC,0x93,0xE9,0xA3,
+0x27,0x94,0x2A,0xA5,0xF9,0x38,0x21,0xEA,
+0x2F,0x87,0x8E,0x3E,0x7C,0x87,0x96,0xAB,
+0x27,0xAB,0x89,0x5F,0x6F,0xA7,0xB1,0x1C,
+0x2F,0x71,0xB5,0x90,0x2E,0xD6,0xA2,0xC4,
+0x2F,0x0B,0x1F,0xFC,0x60,0x4B,0x20,0xC3,
+0x2F,0x6A,0x36,0xA5,0xC4,0xE0,0x6C,0xD7,
+0x23,0x18,0xC1,0x26,0x30,0x42,0xEA,0x7C,
+0x07,0x26,0x5F,0x0B,0xA2,0xA2,0x5E,0x0F,
+0x2F,0xA4,0x1D,0x41,0x4C,0xA8,0xFF,0x60,
+0x22,0xB3,0x40,0x69,0x6B,0x2D,0x6A,0x0C,
+0x07,0x85,0x63,0xF2,0x37,0x0E,0xE1,0xAD,
+0x07,0x65,0x0F,0x17,0xAF,0x05,0x10,0xF4,
+0x2D,0x1C,0xFE,0xFE,0xCB,0x8A,0xD0,0x41,
+0x0F,0xB5,0x42,0x10,0x22,0x74,0x40,0x48,
+0x27,0x2F,0x6A,0x9F,0x55,0xBE,0x0D,0x2D,
+0x2F,0xB5,0xDE,0xD6,0x02,0x3A,0x28,0x49,
+0x2F,0xFD,0x1D,0x5D,0x69,0xB6,0xEC,0x23,
+0x2F,0xC9,0x5F,0x89,0x13,0xC3,0x14,0xDB,
+0x27,0xE2,0xC9,0x07,0x8C,0xA2,0x40,0xA7,
+0x27,0x53,0x06,0xCB,0xEB,0xCE,0x1E,0x40,
+0x2A,0xA6,0x21,0x81,0x1A,0xD4,0x7E,0x39,
+0x0F,0xCE,0x0A,0xCD,0x7F,0x2B,0x83,0x36,
+0x27,0xBE,0xB8,0x80,0x33,0x67,0x55,0x33,
+0x27,0xB6,0xC8,0x4C,0x25,0x1B,0x5F,0xCA,
+0x2F,0x65,0x1B,0x22,0xF6,0x29,0x9D,0xF1,
+0x27,0x7A,0xE7,0x46,0x25,0x2E,0xC1,0x6D,
+0x0F,0x50,0x4E,0x47,0x9F,0x3F,0x99,0xE7,
+0x07,0xDE,0xA2,0x39,0xF7,0x48,0x24,0x2B,
+0x25,0x77,0x68,0x1A,0xF6,0xF7,0x5C,0x55,
+0x0F,0x04,0xA0,0x1F,0x15,0xD8,0xDF,0x26,
+0x27,0x7B,0x6E,0xBA,0x24,0x7B,0xB9,0xE0,
+0x27,0x11,0x99,0xAD,0xF8,0xB3,0x6E,0x04,
+0x2F,0xE5,0x26,0x2B,0x70,0xE3,0xDF,0xF7,
+0x27,0xF8,0x7A,0xCB,0x99,0x91,0x4B,0x54,
+0x27,0xA9,0x68,0x25,0x0D,0xEE,0x28,0x3B,
+0x27,0xFD,0xE4,0xB8,0x1C,0x74,0x88,0x0A,
+0x2F,0x57,0x01,0xCE,0xB1,0xEE,0x36,0xCF,
+0x21,0x41,0xDA,0x5B,0x24,0x66,0x8F,0x19,
+0x0F,0x93,0xD7,0x88,0x22,0x93,0xAC,0x34,
+0x2F,0xD1,0x30,0x86,0x0F,0x5F,0xF1,0x1D,
+0x27,0x28,0x4A,0xF0,0x44,0xBE,0xC7,0xBE,
+0x26,0x98,0xC4,0x0E,0xDB,0x11,0x39,0xCA,
+0x07,0x3A,0x15,0x01,0x3E,0xA0,0x4E,0x1B,
+0x0F,0xFF,0xE0,0xC5,0xA0,0x22,0x66,0xF5,
+0x2F,0x04,0xEF,0x2B,0x6A,0xFE,0xE7,0xB8,
+0x2E,0x1D,0x61,0xEC,0xDD,0x66,0x22,0xB5,
+0x07,0x0E,0x87,0x8D,0x6B,0x70,0xBA,0x75,
+0x2F,0x55,0xDB,0x50,0xEA,0x37,0xD0,0xD2,
+0x21,0x96,0xFC,0x00,0xC2,0x5A,0x07,0xBB,
+0x07,0xC5,0x30,0xD6,0x7B,0x9F,0xC7,0x46,
+0x2E,0x5C,0x6F,0x0B,0x2C,0x9D,0x97,0x86,
+0x0F,0xC3,0xB6,0x94,0x98,0x38,0x67,0x4E,
+0x27,0xDC,0x9A,0x2B,0x74,0x50,0x37,0x8F,
+0x27,0x40,0xF8,0x7F,0x38,0xA1,0x88,0x22,
+0x21,0xEF,0x32,0x74,0x59,0xAB,0x3E,0xB7,
+0x07,0xEF,0x73,0xA1,0xE5,0x52,0x6F,0xD9,
+0x2F,0x3B,0x5C,0xA2,0xFE,0x57,0x71,0x3D,
+0x27,0x71,0xD6,0xD2,0x6F,0xA1,0x57,0xAF,
+0x29,0x80,0x58,0xA6,0xC2,0x3B,0x79,0x07,
+0x07,0x87,0x89,0xB8,0x58,0xC4,0xE1,0xEF,
+0x2F,0x42,0xC8,0x29,0x21,0x3B,0xA5,0x4D,
+0x27,0x70,0xBE,0xCB,0x27,0xFF,0xA8,0x32,
+0x27,0x15,0x20,0x00,0xBE,0x53,0x17,0x3C,
+0x24,0x74,0x9F,0xCC,0xB8,0x3C,0x0B,0xC0,
+0x07,0xC3,0x7B,0x30,0x31,0xBD,0xCC,0x71,
+0x27,0x54,0x84,0x7F,0x44,0x70,0x5C,0xDF,
+0x2E,0x3C,0x44,0x61,0x84,0x31,0x45,0x33,
+0x07,0x89,0xF4,0x7C,0xFD,0x29,0xDF,0x6B,
+0x0F,0xB7,0xC6,0x9A,0xAE,0xA0,0x7F,0xA7,
+0x07,0xB3,0x2B,0x76,0x10,0x6C,0x4D,0xB5,
+0x0F,0x4E,0x2D,0xA4,0xBD,0x9B,0x28,0x11,
+0x27,0xDC,0xE5,0xCA,0xD1,0x38,0x9C,0xED,
+0x21,0xD0,0x50,0x3E,0xD6,0xEE,0x51,0xD6,
+0x07,0xC9,0x09,0xEB,0x81,0x08,0xCD,0xD5,
+0x0F,0x3D,0x95,0xCA,0xD0,0xCB,0xB7,0x1D,
+0x24,0x85,0x36,0xFE,0x13,0xE2,0xA3,0xB0,
+0x0F,0x7A,0xEE,0xF6,0x31,0xB3,0xED,0x5A,
+0x2F,0x08,0xE6,0x8D,0x1A,0x33,0x46,0x6A,
+0x2A,0x28,0x7C,0x3A,0x09,0x17,0xB9,0xF6,
+0x0F,0xF6,0x76,0x59,0xB4,0x34,0x85,0x04,
+0x0F,0x8F,0xF4,0x4D,0x53,0xFE,0xB0,0xAC,
+0x07,0xB8,0x8B,0x7A,0xFC,0xDA,0xB9,0xB3,
+0x2F,0xCB,0x49,0x90,0x3E,0x4F,0xB7,0xC2,
+0x2F,0x96,0x4D,0x2B,0xD0,0xD5,0x0C,0xCD,
+0x24,0x6C,0x76,0xCB,0xFE,0xAA,0xE8,0x19,
+0x07,0xC5,0xFA,0x8E,0x11,0x27,0x44,0x7E,
+0x07,0x23,0x6A,0x88,0x96,0x3C,0x0E,0x99,
+0x2F,0x88,0xFE,0xD8,0xC3,0xA9,0xFE,0xBF,
+0x2F,0x1B,0xC0,0xA6,0xAC,0x46,0x26,0xA5,
+0x27,0x04,0x76,0x3B,0xAD,0x58,0x86,0x97,
+0x27,0x90,0x32,0xA1,0x0C,0x71,0x6A,0x71,
+0x2F,0x15,0xC0,0x9F,0xAC,0xF8,0x1D,0x7A,
+0x2F,0x55,0x31,0x69,0x4F,0x65,0x84,0xC2,
+0x27,0x71,0x7E,0xBF,0x94,0x3D,0xD9,0x2E,
+0x27,0x9C,0x0A,0xD7,0x84,0x50,0x49,0x47,
+0x2A,0xE6,0xB1,0xE9,0x90,0xEA,0xCF,0xE0,
+0x0F,0xDD,0x1F,0x02,0x0D,0x4D,0x52,0x96,
+0x2F,0x50,0x33,0x58,0x7F,0xAB,0x25,0xF7,
+0x2A,0xD6,0x8B,0x4B,0x18,0xEB,0xF0,0x73,
+0x07,0xC2,0x19,0x96,0x72,0x18,0x83,0xA9,
+0x27,0x34,0x62,0x63,0x13,0x17,0x0E,0xBA,
+0x2F,0x23,0x22,0x98,0xC3,0xBB,0x1D,0x7E,
+0x2F,0x55,0x82,0xC1,0x7A,0x77,0x1F,0xBB,
+0x2D,0xA2,0x0A,0xF7,0xDF,0xE6,0x39,0xEC,
+0x07,0xC2,0x9B,0xD4,0x8F,0xFF,0x76,0x3A,
+0x27,0xDF,0xDC,0xB1,0xAE,0xD2,0x9C,0x8D,
+0x2F,0x38,0x4E,0x60,0x4B,0xDC,0x4A,0x47,
+0x27,0x1C,0xDE,0x42,0x96,0x3F,0xD1,0x78,
+0x2F,0x64,0x3B,0x73,0xCC,0x59,0x5D,0xD6,
+0x2F,0xB1,0x49,0x96,0xA2,0xC8,0x07,0xE6,
+0x23,0x42,0x4A,0x75,0x20,0x70,0xBA,0x34,
+0x07,0x07,0xA9,0xF7,0x72,0xE4,0xF9,0x3B,
+0x2F,0x8A,0xB3,0x65,0xC7,0x1D,0x21,0xF2,
+0x27,0xBF,0x6B,0x3F,0x40,0x34,0x35,0x9D,
+0x27,0xAD,0x1D,0x70,0x70,0xB0,0x4B,0xBD,
+0x27,0xC8,0xED,0x1A,0x70,0xD9,0x88,0x2E,
+0x2A,0xC8,0xE2,0x87,0x53,0xD0,0xB3,0xC6,
+0x07,0x47,0x08,0xAE,0xEE,0x6D,0x5A,0x4F,
+0x2F,0x34,0x6C,0xF2,0x4E,0x54,0x08,0x05,
+0x25,0xAC,0xEB,0x95,0x91,0xF4,0x7E,0x30,
+0x0F,0x41,0xD9,0xB5,0xD3,0x6C,0xAB,0x40,
+0x2F,0x0C,0xCF,0x3F,0xD8,0x2A,0xEA,0x62,
+0x2F,0x83,0xC8,0x69,0xF8,0xF4,0x7A,0x3F,
+0x2F,0x5D,0xBA,0xF4,0x05,0xFD,0x64,0x85,
+0x22,0x7E,0x70,0x08,0xDF,0xE2,0x65,0x68,
+0x07,0x3B,0xC2,0xA4,0xDF,0x52,0xFA,0xAD,
+0x2F,0xE4,0x44,0xDD,0x33,0x8D,0x2C,0x65,
+0x27,0x9B,0x7A,0xF9,0x6C,0xBF,0x3E,0x6A,
+0x27,0xE7,0xF2,0xBD,0xC4,0xD7,0x7D,0x72,
+0x2F,0x06,0x22,0x2F,0x8C,0x99,0x74,0x76,
+0x27,0x8F,0x7E,0xFE,0x72,0x85,0xCC,0xF2,
+0x27,0xA7,0x8D,0xFD,0x42,0x8F,0x7A,0xC4,
+0x21,0x08,0x47,0x9B,0x35,0x0B,0xCB,0x6F,
+0x0F,0x79,0xC5,0xFD,0x27,0xE5,0xAE,0x6F,
+0x27,0x75,0x1E,0x56,0x9E,0xB7,0x03,0x35,
+0x2C,0x6A,0x8B,0x09,0x76,0xA5,0x32,0xF1,
+0x07,0x58,0xD3,0x55,0x9D,0x35,0x7A,0x2E,
+0x2F,0x74,0x2B,0xE0,0xFA,0x4C,0xF0,0x94,
+0x27,0xB9,0xAD,0xA5,0x57,0x6B,0x73,0x85,
+0x27,0xDF,0xE2,0x48,0x95,0x82,0x06,0x9E,
+0x21,0x09,0x8F,0x08,0x33,0xD2,0x44,0xAE,
+0x0F,0x01,0x09,0x0E,0xE8,0xCE,0x55,0xAF,
+0x2F,0x06,0xC3,0x3C,0x45,0x3D,0x6F,0x47,
+0x2B,0x78,0x42,0xB5,0xCB,0xFB,0xE9,0xB4,
+0x0F,0xDC,0x5D,0xCD,0x54,0x5E,0x2A,0x87,
+0x07,0xDD,0x50,0x14,0xC4,0x10,0x65,0xF9,
+0x0F,0xCA,0x75,0x48,0xFA,0x62,0x1B,0x5A,
+0x07,0x46,0x26,0xB8,0x91,0x94,0xC4,0x4D,
+0x07,0xDB,0xB4,0x18,0x8B,0x72,0xD9,0x29,
+0x0F,0xBC,0x66,0x4D,0x47,0xD6,0x49,0xEE,
+0x0F,0x0A,0xA3,0x8C,0x98,0xA7,0xE3,0x53,
+0x27,0xB5,0x26,0xD7,0x2E,0x6E,0xB4,0x74,
+0x22,0x3A,0x81,0xF3,0xF2,0xBF,0x01,0x7D,
+0x07,0xCB,0xF6,0x19,0xDA,0xC8,0x29,0xF0,
+0x26,0x0C,0x37,0x76,0xA6,0x20,0x6E,0x11,
+0x07,0x7E,0xE4,0x92,0x02,0x37,0x81,0xB4,
+0x27,0x02,0x82,0x4D,0xD6,0x53,0x10,0x6C,
+0x26,0xB7,0x93,0x39,0x03,0x73,0x2D,0xC9,
+0x0F,0x61,0xA8,0x64,0x31,0xFF,0xA6,0x3B,
+0x27,0xEF,0x92,0x83,0xB0,0xC9,0x91,0x8A,
+0x27,0x36,0x10,0x8C,0x0F,0x7B,0xA2,0x6F,
+0x2C,0x2B,0xBB,0xAC,0xA2,0x2F,0x41,0x7D,
+0x0F,0x96,0x06,0x2F,0x0E,0x9C,0xE5,0xC4,
+0x07,0xC7,0x0D,0xA3,0x73,0x83,0x5B,0xFE,
+0x07,0xCC,0x4A,0x0E,0x31,0x2F,0xA4,0x5E,
+0x2F,0xBC,0xAA,0x4F,0x6C,0x86,0x20,0x5C,
+0x27,0xF3,0x9B,0x22,0xFF,0x0C,0x5C,0x77,
+0x2F,0xA1,0x3E,0x50,0xB8,0x06,0xE3,0x50,
+0x2F,0x5E,0x79,0xDA,0xA3,0x7B,0xAB,0x3B,
+0x2F,0xD7,0x17,0x68,0xCD,0x39,0xF4,0x4D,
+0x2F,0x2C,0xE1,0xF9,0x0B,0x1F,0x77,0xD4,
+0x2F,0xD0,0x4C,0x8A,0x1F,0x90,0x56,0x31,
+0x2F,0x60,0x11,0xE1,0x0F,0xD5,0x91,0x8D,
+0x2F,0x78,0xCF,0xCA,0x9E,0xFF,0x68,0x5C,
+0x27,0xE5,0x03,0xC2,0x8B,0x5B,0xBE,0xC2,
+0x27,0xBC,0x12,0x48,0x79,0xDE,0x24,0x2E,
+0x27,0x6F,0x36,0xA9,0x5E,0xCC,0x2F,0xEE,
+0x2F,0x57,0x89,0xD4,0x7C,0xCB,0xC2,0xCF,
+0x27,0x1B,0xCF,0x7E,0x10,0xF0,0xDB,0x1D,
+0x27,0xC8,0x14,0x51,0x41,0x22,0xCD,0xCE,
+0x27,0x86,0x90,0xBB,0xA4,0x60,0xB5,0x38,
+0x2F,0xFC,0x26,0x6D,0x26,0x4F,0x07,0xA5,
+0x26,0x8B,0xBE,0x3A,0x86,0x4C,0x1E,0xFD,
+0x07,0xC2,0xA7,0xDE,0x06,0x63,0x17,0xCF,
+0x27,0x97,0x06,0x66,0x20,0x78,0xBE,0x49,
+0x2F,0x92,0x39,0x99,0x02,0x45,0x50,0x43,
+0x22,0x6A,0xAC,0x8E,0x09,0x48,0x5E,0xDE,
+0x0F,0x4F,0xC4,0xF8,0xAF,0x1E,0x68,0x3D,
+0x27,0x82,0x99,0x89,0x6F,0x92,0x52,0xFD,
+0x22,0xEE,0xBD,0xE7,0xBE,0x1B,0x3D,0x93,
+0x0F,0x11,0x2C,0x9F,0xC0,0x70,0x29,0xD9,
+0x0F,0xD7,0x2C,0x5C,0x0E,0x47,0xDF,0xFF,
+0x2F,0x14,0xA3,0xCA,0xE5,0x12,0xFB,0xEA,
+0x29,0x26,0x89,0x15,0xAE,0xCE,0xD0,0x68,
+0x0F,0xCF,0x38,0x06,0x11,0xD6,0x88,0x9C,
+0x2F,0x4A,0x16,0xF0,0xAB,0xF8,0x24,0x6C,
+0x27,0xD1,0xF4,0xEA,0x80,0x49,0xA5,0x2B,
+0x27,0x5F,0x4A,0x55,0xB8,0x43,0x5B,0xF5,
+0x23,0xFE,0x16,0x7A,0x7A,0x8E,0x22,0x9A,
+0x0F,0xE3,0xE5,0xA4,0xD9,0x3D,0xE5,0xF1,
+0x2F,0x02,0x3D,0xC8,0x77,0xC0,0xD9,0x36,
+0x2F,0x36,0x25,0x73,0xBF,0xA0,0x18,0x1C,
+0x2E,0x10,0x99,0x23,0x6A,0x34,0x59,0xB6,
+0x07,0x94,0x68,0xA5,0xEB,0xE8,0xFB,0x57,
+0x26,0x20,0x37,0x97,0x5B,0xF3,0xAD,0x91,
+0x07,0x34,0xD2,0x2C,0xAC,0xB4,0xF1,0x2D,
+0x2A,0xC0,0xEF,0x25,0x8C,0xF4,0xBA,0x35,
+0x0F,0x9B,0x27,0xD8,0x42,0x16,0x2F,0xB3,
+0x27,0x84,0x62,0x19,0x07,0xB8,0x4A,0xC4,
+0x27,0x2E,0x24,0x74,0x74,0x5C,0xF6,0xA2,
+0x2F,0xA8,0x2C,0x00,0x99,0xA9,0xAE,0xB8,
+0x27,0x51,0x5F,0x89,0x1F,0xC5,0xEB,0xF2,
+0x2F,0x9F,0x6E,0xFF,0x1C,0xE8,0xD5,0x12,
+0x2A,0xB5,0xCE,0x4F,0xEE,0x62,0x6B,0x01,
+0x07,0xF4,0x0E,0x27,0xD7,0xFE,0x60,0x50,
+0x27,0x6B,0x5F,0x4C,0x13,0x17,0xDB,0x4E,
+0x07,0x6B,0xA6,0xD6,0x64,0xE6,0x40,0xB4,
+0x27,0xAB,0xC3,0x98,0xB5,0x90,0x35,0xDA,
+0x27,0x1D,0xAA,0x49,0x00,0x9D,0x13,0xD4,
+0x2E,0x48,0x6E,0xFA,0x0A,0xC6,0xF3,0x49,
+0x07,0xCD,0x91,0x26,0x0E,0x77,0x69,0xEC,
+0x2F,0x31,0x38,0xCA,0x7F,0x0D,0xB3,0x60,
+0x27,0xF0,0x6E,0x1B,0xBF,0x2E,0x81,0x8C,
+0x27,0x49,0xAB,0xBB,0x8E,0x42,0x55,0x44,
+0x2F,0xB1,0x03,0x87,0x75,0xBC,0x77,0xD5,
+0x2F,0x5F,0x8F,0x62,0x5E,0xE3,0x89,0xB6,
+0x2F,0x99,0xFD,0xC3,0x01,0x2D,0xE7,0xB9,
+0x27,0x7C,0xBF,0xE9,0xBA,0x81,0x97,0xC4,
+0x2F,0x5A,0x5E,0xB2,0xBD,0x2E,0x82,0xC0,
+0x27,0xB7,0xC3,0x11,0xAA,0xFB,0x86,0xE4,
+0x2F,0x60,0x28,0x66,0xA8,0x87,0x56,0xE3,
+0x27,0xCC,0x5A,0x8F,0x5E,0xF3,0x83,0x1B,
+0x2F,0xC1,0x82,0x20,0x82,0x1D,0x4C,0x36,
+0x27,0x00,0x03,0x04,0xC5,0x86,0x5B,0x30,
+0x2F,0xFA,0xBD,0x6B,0xB8,0xAB,0xDB,0x0C,
+0x27,0x09,0x03,0xBC,0xED,0xBC,0xBD,0xF7,
+0x2F,0xE2,0xBA,0xD1,0x90,0x52,0xFB,0xD3,
+0x2F,0x5F,0x84,0x71,0x32,0x2C,0xDC,0xE4,
+0x27,0xA1,0x2A,0x6E,0xEF,0x09,0x67,0xC7,
+0x2F,0x64,0x7E,0xCC,0x3B,0xDF,0x85,0xCC,
+0x2F,0x2C,0x9C,0xC8,0xEE,0x7E,0xB9,0x16,
+0x2F,0x20,0xFF,0x70,0x65,0xC5,0x2E,0x72,
+0x2F,0x86,0x13,0x7B,0xCB,0x99,0xE2,0x21,
+0x2B,0xF8,0x5A,0x7E,0x9B,0x61,0xCF,0x56,
+0x07,0x2C,0x23,0xE2,0x86,0x26,0x20,0x6C,
+0x2F,0x5A,0x6B,0x8E,0xA6,0x99,0x79,0xAC,
+0x2F,0x6B,0x5D,0x84,0x10,0xF8,0x1A,0x10,
+0x27,0x6D,0xA8,0x8D,0x49,0x1B,0x71,0x06,
+0x27,0x2E,0x4C,0xA2,0xAC,0x10,0xD5,0x44,
+0x2F,0xF0,0xFF,0x21,0x4B,0x36,0x47,0xAE,
+0x2F,0xFF,0x33,0x5F,0x59,0xF4,0xB9,0x00,
+0x27,0x1F,0x4D,0x9B,0x07,0x13,0x85,0x73,
+0x27,0x95,0x8E,0xA3,0x6E,0x1E,0x83,0x78,
+0x27,0xB7,0xF7,0x33,0x2E,0xE0,0x0E,0x8A,
+0x27,0xB9,0xBB,0xA8,0xE3,0x9F,0xE4,0xB8,
+0x2F,0x1D,0x2A,0xFF,0x63,0x32,0x54,0xDA,
+0x2F,0x3B,0x50,0x74,0x42,0x35,0x60,0x9A,
+0x2F,0xEC,0xF8,0x4D,0xC2,0x9B,0x46,0x77,
+0x2F,0x68,0x74,0xF7,0xD6,0x10,0x92,0x27,
+0x2F,0x18,0x72,0xBF,0x52,0x4C,0x6E,0xB4,
+0x2F,0x1C,0xE9,0x82,0x82,0x56,0x48,0xAE,
+0x27,0xE2,0xC1,0xB4,0x76,0x9E,0x0F,0x16,
+0x2F,0x61,0x36,0x92,0x14,0x1E,0x8B,0x4E,
+0x2F,0xE9,0x70,0xBA,0xB2,0x9D,0x93,0x4F,
+0x29,0x5D,0xD7,0x3C,0x6C,0xF1,0xDF,0x3E,
+0x07,0xEC,0xAE,0xF0,0x46,0x07,0x9D,0xF8,
+0x27,0x84,0xE6,0x80,0x83,0xCA,0x1D,0x73,
+0x2D,0x22,0x93,0x89,0x54,0xCE,0xF0,0xC8,
+0x0F,0x46,0x7B,0x6A,0x3C,0x40,0xCE,0x1E,
+0x27,0x8C,0x25,0xE5,0x9B,0x12,0x2C,0x07,
+0x2F,0xE6,0x74,0xBE,0xD2,0x28,0xAE,0xD3,
+0x2F,0xB2,0xEB,0xDF,0xC9,0x59,0xC0,0x03,
+0x27,0x1D,0x1F,0x95,0x1F,0x5E,0xA6,0x15,
+0x2B,0x32,0x13,0xCD,0x8F,0xC8,0x77,0x61,
+0x0F,0xD6,0x5B,0x3A,0x6E,0xF3,0x60,0xDA,
+0x2F,0x0C,0x9A,0x06,0x4B,0x4B,0x1F,0x87,
+0x22,0xD1,0x0B,0x11,0x16,0x8C,0xA4,0xFD,
+0x07,0x8F,0x8A,0xFB,0x7D,0x94,0xAC,0xFE,
+0x2A,0xC1,0x1C,0x44,0xEB,0xE6,0x1F,0x60,
+0x0F,0xBB,0xB0,0xB4,0x83,0x61,0x4D,0xE6,
+0x27,0x28,0xA9,0xB8,0xF6,0xA8,0xCD,0x43,
+0x27,0x89,0xAA,0x8B,0x29,0x8A,0x7A,0x4D,
+0x2F,0xB1,0x0B,0x76,0xA1,0x33,0x87,0x99,
+0x27,0x0B,0xD9,0x56,0x14,0x2E,0x10,0xEC,
+0x27,0xED,0x2E,0x28,0xD1,0x51,0x67,0x38,
+0x27,0xEB,0xA2,0xBF,0xC8,0x6C,0x2B,0xAD,
+0x2F,0x68,0x26,0x16,0xFE,0xDD,0x74,0xFA,
+0x27,0x88,0xC5,0x35,0x9E,0x2D,0x1D,0x30,
+0x2F,0xAC,0xED,0x64,0x43,0x23,0x05,0x79,
+0x27,0x57,0x0B,0x26,0x32,0xFC,0x83,0x2D,
+0x2F,0xBC,0x7F,0x66,0x05,0xCB,0x6C,0xCC,
+0x2F,0xEC,0xDD,0x1E,0x44,0x3E,0x20,0x1E,
+0x2F,0x21,0x64,0x7D,0xEC,0xDB,0xA4,0x76,
+0x2F,0x58,0x18,0xA2,0xB6,0xA8,0x2B,0x33,
+0x24,0xB2,0x6A,0x10,0xA7,0xDD,0x6F,0xB4,
+0x07,0x0B,0x54,0xE7,0x88,0xCC,0x20,0x6B,
+0x2F,0x65,0x91,0xAD,0xD9,0xB3,0x19,0x51,
+0x29,0xE1,0x74,0x79,0xE1,0xF7,0xB2,0x98,
+0x0F,0x16,0xAD,0x9C,0xBC,0x51,0x5B,0xDE,
+0x2F,0x43,0x4C,0x92,0x39,0x2D,0x33,0x55,
+0x2B,0x7A,0x65,0xF8,0x5E,0x67,0x86,0x32,
+0x07,0x9F,0x96,0xFC,0x28,0xD1,0x20,0xA5,
+0x0F,0x7B,0xFD,0x4C,0x75,0xD8,0x69,0x9F,
+0x27,0x38,0x8A,0x4D,0xD6,0x50,0xBB,0xA5,
+0x2C,0xD6,0x5F,0x8E,0xEA,0xB3,0x67,0x68,
+0x07,0x86,0x77,0xD3,0x65,0xF9,0x3A,0xD9,
+0x27,0x00,0x0E,0x3F,0x45,0x48,0x20,0xFD,
+0x29,0x9C,0x6A,0xEC,0x96,0xAE,0x32,0x51,
+0x07,0x3B,0xF0,0x38,0xE7,0xBB,0x06,0x07,
+0x2F,0x16,0x10,0x2F,0x3F,0x5B,0xA5,0x82,
+0x2E,0x5D,0xDF,0x02,0x7C,0x30,0x5B,0xFD,
+0x0F,0x41,0x93,0xA5,0xD2,0xD8,0x32,0x28,
+0x2F,0xA0,0xBC,0x6D,0x47,0x12,0x41,0x53,
+0x0F,0x59,0x00,0xB0,0xF8,0xE0,0x59,0x2B,
+0x2F,0x95,0x18,0xBF,0xDA,0xFF,0xBF,0x26,
+0x24,0x94,0x29,0xA6,0x5C,0xA9,0x6E,0x85,
+0x0F,0xC6,0xD5,0x71,0x62,0xAE,0xF4,0xF8,
+0x07,0xF2,0x12,0x15,0xB3,0x84,0x5B,0x53,
+0x0F,0x8D,0xF3,0x42,0xE8,0xEE,0xB4,0xB1,
+0x27,0x62,0x1A,0x8C,0xF2,0xD0,0xF9,0x35,
+0x27,0xC3,0x49,0x39,0xBA,0xEF,0x7D,0xD5,
+0x2F,0x96,0x8F,0x22,0xCB,0x19,0x08,0x76,
+0x2F,0x58,0x37,0xBD,0x96,0x3A,0x0B,0xBF,
+0x2F,0xC2,0x57,0xA1,0x5E,0xB5,0x6B,0xFC,
+0x2C,0xE0,0x77,0x20,0xE6,0x93,0xDE,0x89,
+0x07,0x0E,0x3C,0xD9,0xA8,0x0C,0x0E,0xEE,
+0x27,0x1A,0xFF,0xAB,0x16,0xCE,0xE9,0x4D,
+0x0F,0x5E,0x49,0xA5,0x70,0x6B,0x74,0x98,
+0x0F,0xD8,0x35,0xB2,0x21,0xC8,0xAA,0x75,
+0x27,0xFF,0xC2,0x41,0xED,0x83,0xE3,0x63,
+0x2F,0x0C,0x8F,0x40,0x81,0x22,0x31,0x47,
+0x2F,0x00,0x41,0xEB,0x9F,0x99,0x32,0x2E,
+0x27,0xA0,0x44,0x11,0xAF,0xE0,0x03,0xAD,
+0x2F,0xE6,0x17,0x58,0x9E,0xD9,0x9B,0x6E,
+0x25,0xA0,0x8D,0xF0,0x8A,0x48,0x5B,0xBD,
+0x0F,0x83,0xA9,0xE1,0xDC,0x46,0x62,0x86,
+0x0F,0xA8,0xAB,0xF2,0x07,0xBB,0x87,0xA6,
+0x07,0x1B,0xAF,0x1E,0xCC,0xD2,0x34,0x5D,
+0x27,0x34,0xD3,0x5A,0xC7,0x6A,0x40,0x4E,
+0x27,0x65,0x3D,0xF2,0xA4,0xEA,0x4C,0xFB,
+0x07,0x18,0xAE,0xE6,0x58,0xE3,0xF9,0xD4,
+0x27,0x13,0x1B,0x85,0x8C,0xF1,0xC1,0x9C,
+0x22,0xBF,0xF7,0xB8,0x53,0xE8,0x97,0xCF,
+0x07,0x4B,0xE5,0xA0,0x84,0x67,0xA8,0xA1,
+0x2F,0x84,0xD2,0x6E,0x57,0x23,0x89,0x3E,
+0x2F,0x19,0xE5,0xB7,0xF0,0xB6,0x36,0x3C,
+0x27,0xD2,0x97,0x3F,0x47,0x74,0xF0,0x13,
+0x22,0xA8,0xEA,0x8E,0x31,0xA4,0xF4,0xA5,
+0x07,0x4D,0x6E,0x59,0x3E,0x99,0x31,0x3D,
+0x07,0x37,0x6F,0x83,0x06,0x76,0xC1,0x44,
+0x07,0x67,0x2B,0x91,0x3D,0xC7,0x1A,0xE5,
+0x27,0xBC,0xBC,0x76,0xA0,0x3D,0x6F,0x69,
+0x2F,0x41,0xBF,0xC7,0xB5,0x1E,0x13,0x0D,
+0x07,0xC8,0x82,0xA0,0xFD,0xE8,0xD1,0xF1,
+0x0F,0x8F,0x3C,0x44,0xD0,0x6B,0xD9,0xAE,
+0x2F,0xA7,0x21,0x1E,0xDE,0x3F,0x3A,0x74,
+0x27,0x79,0xBD,0x5C,0xAC,0xDC,0x44,0xDF,
+0x27,0x89,0x5A,0xC9,0x99,0xBE,0x07,0xF8,
+0x2A,0x9B,0x11,0x8D,0xCD,0x9B,0x99,0x82,
+0x07,0x5D,0xFE,0xC5,0xF0,0x36,0xB5,0x2B,
+0x2F,0x82,0x40,0xA3,0xED,0x4F,0x2E,0xA1,
+0x2F,0x83,0xDC,0xB0,0x88,0xAC,0x15,0x2C,
+0x27,0xAF,0x43,0x4A,0x42,0x9F,0x5A,0x50,
+0x2A,0xE6,0x3F,0x0E,0x35,0xA5,0xFC,0x28,
+0x0F,0xF0,0x2B,0x7A,0x3D,0x4E,0xC8,0x8A,
+0x27,0x1D,0x72,0xD7,0x9A,0x40,0x98,0xEA,
+0x27,0x3D,0x1F,0xA8,0xD6,0xC4,0x03,0x88,
+0x27,0x4F,0x48,0xE9,0x82,0x03,0x57,0x19,
+0x29,0x4E,0xC4,0xE2,0x9B,0x96,0x18,0x06,
+0x07,0x1E,0xDE,0x8C,0xD9,0xF5,0xB6,0x48,
+0x2D,0x46,0x36,0xCD,0xDB,0x96,0x2D,0x6E,
+0x07,0xB6,0xF1,0x40,0xE9,0x23,0x71,0xAE,
+0x07,0x52,0x9C,0x83,0x0E,0x8D,0x47,0x40,
+0x07,0x71,0x98,0x49,0xD6,0xF1,0x88,0x51,
+0x07,0x1F,0x22,0x63,0x56,0x41,0xCD,0x4C,
+0x2F,0xA3,0xF3,0x02,0xF0,0x87,0xF3,0x05,
+0x2F,0xFD,0x4A,0x64,0x4C,0xA5,0x55,0x19,
+0x27,0xB0,0x8B,0x10,0x5F,0x65,0x68,0xC2,
+0x27,0xB3,0x21,0x8B,0xCB,0xF4,0xE3,0x0E,
+0x27,0x47,0x75,0x5E,0xB7,0x1E,0x9F,0xF8,
+0x2E,0x01,0xC9,0x0F,0x26,0xB7,0xA6,0x9C,
+0x07,0x0B,0xAD,0x07,0xA6,0xF6,0xC3,0xAD,
+0x22,0x19,0xB7,0x88,0x85,0x95,0x44,0x10,
+0x0F,0x5C,0xFD,0xCB,0x1B,0x66,0xCD,0xA7,
+0x07,0x42,0xAD,0xC2,0xD3,0xE6,0xE0,0x9D,
+0x07,0xA0,0x9B,0x44,0x03,0x54,0xAB,0x1C,
+0x07,0x55,0x55,0x65,0x32,0x9D,0xC9,0xF4,
+0x27,0x33,0xE4,0xED,0x63,0xFF,0x61,0x6D,
+0x2A,0xB9,0x32,0x31,0x75,0x20,0xAE,0x1E,
+0x0F,0xBB,0xEF,0xCE,0xAF,0x23,0x79,0xEB,
+0x2B,0x6B,0xA3,0xF8,0xAB,0x35,0x49,0xA2,
+0x0F,0x42,0xEA,0x72,0x5B,0xC0,0x65,0xA6,
+0x25,0xDA,0x6C,0x31,0x6B,0xC2,0x60,0x92,
+0x07,0xA5,0xCE,0x5C,0xB1,0xD7,0x95,0x2E,
+0x27,0x41,0xCC,0x30,0x61,0x48,0xB0,0xBB,
+0x2F,0xD7,0x5A,0x16,0x0D,0xAD,0x83,0xD1,
+0x2F,0x53,0x85,0x0B,0x54,0x37,0xB5,0x9D,
+0x27,0x47,0xA2,0xF5,0x48,0x09,0x1F,0x4F,
+0x2F,0xA4,0xCE,0x27,0xA1,0x67,0x49,0x06,
+0x27,0x8B,0x3B,0x0D,0x36,0x51,0x5F,0xB4,
+0x27,0x71,0xE4,0xCE,0x7E,0x2D,0xAF,0x84,
+0x2D,0x17,0x74,0x8D,0x47,0x11,0x60,0x77,
+0x0F,0xAC,0xED,0x36,0x16,0x91,0x86,0x1A,
+0x27,0x2F,0x1F,0x4B,0x91,0x40,0xD0,0xA8,
+0x2F,0xD9,0x65,0x9F,0x4F,0x07,0x34,0xD8,
+0x2F,0x0B,0xDA,0x25,0x46,0xC4,0xC0,0x8D,
+0x27,0x86,0xBE,0x26,0x4F,0xD0,0xB4,0x3C,
+0x29,0x05,0xE4,0x55,0x9E,0x2F,0xEE,0x12,
+0x07,0xD1,0x35,0xBC,0x90,0x8C,0x89,0x96,
+0x0F,0x82,0xA3,0xCE,0x30,0xFE,0x3B,0x84,
+0x0F,0xC3,0x13,0x33,0xBB,0x0D,0x43,0x84,
+0x07,0xE9,0x69,0xD1,0xCA,0xF5,0x56,0xD7,
+0x0F,0x60,0x19,0xE8,0x41,0xE2,0xA3,0x70,
+0x27,0xBE,0xD8,0x29,0x29,0x9B,0x63,0x4B,
+0x2F,0xA0,0x91,0xD7,0x54,0xC8,0x4A,0xB9,
+0x07,0x4C,0x89,0x15,0x1C,0x20,0x25,0x8A,
+0x07,0xA4,0x4F,0x42,0x59,0xC1,0x58,0x6B,
+0x07,0x41,0x62,0x28,0x73,0x87,0xEF,0x5A,
+0x27,0x42,0x72,0x1C,0xE3,0xBA,0xFB,0x27,
+0x2F,0x83,0x5C,0x8D,0x3F,0x2B,0xC7,0xF2,
+0x2F,0x0C,0xBB,0x85,0x96,0x1A,0xCF,0x3B,
+0x27,0xE1,0xB8,0x39,0xFE,0x30,0xDC,0x68,
+0x27,0xBD,0x90,0x8E,0x94,0x78,0xEA,0x6C,
+0x2F,0x9A,0xFE,0x85,0x9D,0xF2,0xC6,0x2D,
+0x27,0x71,0x36,0xFF,0x15,0x75,0x4A,0x36,
+0x27,0xDC,0x70,0x3C,0xAF,0xFD,0x6E,0x54,
+0x27,0x96,0x07,0x2E,0x50,0x9E,0xE5,0xFE,
+0x2F,0xBC,0x7E,0xCB,0x7B,0xB8,0xA9,0x9A,
+0x2F,0x26,0x82,0x68,0x6A,0x82,0xF7,0xD9,
+0x27,0x02,0xD5,0x79,0x01,0xE0,0x97,0x13,
+0x27,0xC8,0xFD,0x78,0xB3,0xF2,0xF2,0xDB,
+0x2F,0x09,0x03,0x67,0x8E,0xB7,0x9F,0x15,
+0x2F,0xCD,0xD1,0xCC,0x36,0x2D,0xDD,0xB1,
+0x27,0x3E,0x42,0xC2,0xB4,0xEE,0x8B,0xEC,
+0x2F,0x08,0x87,0x07,0x03,0xC7,0xFF,0x84,
+0x27,0xBC,0x71,0x93,0xD9,0xAB,0xC6,0xE4,
+0x2F,0x84,0x15,0xA1,0xF0,0x46,0xAA,0xB1,
+0x2F,0xDD,0x3D,0xDB,0xDC,0x70,0x2E,0xDE,
+0x2F,0x28,0x3A,0x17,0x2A,0xE1,0xCB,0x60,
+0x27,0x61,0x3C,0xCF,0x2F,0x21,0xD7,0x96,
+0x2F,0xB9,0x56,0x60,0xCF,0x0B,0xF2,0xCB,
+0x07,0xD3,0xA6,0xF9,0xCC,0xDD,0xC5,0xAC,
+0x07,0xC7,0xA6,0x5F,0x5D,0x32,0xBE,0x91,
+0x27,0x55,0x54,0x1F,0x91,0x85,0x76,0xFF,
+0x27,0xB2,0x9F,0x8F,0x9D,0x71,0xBA,0x9E,
+0x27,0xAF,0x0D,0xCE,0x7C,0xA9,0x83,0xD3,
+0x27,0x1D,0x1B,0x81,0x60,0x1A,0xEE,0x9A,
+0x2F,0xF4,0x4C,0x29,0xE2,0x22,0x4A,0x6E,
+0x27,0x52,0x8C,0xFE,0xE7,0x98,0xF7,0xF6,
+0x24,0x06,0xB4,0xDA,0x51,0x87,0x8F,0x43,
+0x07,0xA6,0x4C,0xB5,0x78,0xE0,0x9D,0xB8,
+0x27,0xAC,0x24,0x74,0x88,0xF0,0x02,0x73,
+0x2F,0x51,0xD3,0x63,0x2E,0xC0,0xC8,0x8F,
+0x27,0x5E,0xB1,0x90,0xA6,0x9E,0xA1,0xD6,
+0x27,0x5F,0x8F,0xBD,0xEC,0x2F,0xDE,0x6F,
+0x27,0x40,0x46,0x2C,0xED,0x29,0xD8,0xC7,
+0x2F,0x8C,0x53,0xE4,0x5E,0xC9,0xD6,0x62,
+0x2F,0x7B,0x5A,0x08,0x67,0x80,0x4B,0x17,
+0x2F,0x31,0x21,0x06,0x58,0x3E,0xC4,0x35,
+0x2F,0x5F,0xCB,0x13,0xB6,0xBD,0x89,0xAE,
+0x23,0xAA,0x75,0xDC,0x5B,0xBA,0xC4,0x63,
+0x07,0x6C,0xE8,0x2F,0x00,0xD6,0x14,0x74,
+0x2F,0x65,0x42,0x40,0x55,0x36,0x8C,0x79,
+0x2F,0xA2,0x2F,0x2F,0xDD,0xB7,0x4C,0x91,
+0x2A,0x20,0xF1,0xE9,0xAC,0xE1,0xE5,0xA2,
+0x07,0x1D,0xBD,0x68,0x65,0xE7,0xFE,0x54,
+0x05,0xC9,0x72,0xB8,0x85,0x42,0x17,0x93,
+0x2D,0xB8,0xAD,0xAF,0x93,0x9B,0xE6,0x65,
+0x0F,0xEC,0x5A,0x0A,0x08,0x3B,0x38,0xFD,
+0x27,0x33,0x56,0xB5,0xEA,0xE5,0xC8,0x12,
+0x2F,0x42,0x93,0x5C,0xDB,0x0C,0xFC,0x87,
+0x27,0xA3,0x46,0xED,0x25,0x93,0xF3,0xA8,
+0x27,0x25,0xEB,0x58,0xD1,0x38,0xEF,0x48,
+0x2F,0x19,0xCA,0x26,0x15,0x60,0x73,0x6E,
+0x27,0x5C,0x7A,0x54,0xC3,0x92,0xD2,0x7C,
+0x27,0x6F,0x36,0xE1,0xD4,0xCB,0xF0,0xA0,
+0x27,0xE6,0x68,0xB3,0x8C,0x1F,0x09,0x7F,
+0x27,0x5B,0xAD,0x4B,0x1E,0x90,0x18,0x8F,
+0x27,0xDE,0xD8,0x4A,0x0C,0xCC,0xBF,0x78,
+0x2F,0x4A,0x8B,0xB9,0xA4,0xCD,0x5F,0xF9,
+0x2F,0x8F,0x4F,0x37,0x5E,0x02,0x50,0xFF,
+0x2F,0xF3,0xE6,0xC6,0xA9,0x6D,0xB4,0xBE,
+0x2F,0x54,0x13,0x9A,0x7E,0xB1,0xDF,0xC9,
+0x2F,0x32,0xAA,0x5A,0x88,0x86,0x1F,0x17,
+0x27,0x71,0xD5,0xB8,0x42,0xF1,0xAC,0xB0,
+0x2F,0x50,0x9B,0x8F,0x99,0xBD,0x15,0x70,
+0x2F,0xBA,0x18,0xE8,0x71,0xCA,0x51,0xA2,
+0x27,0xE2,0xF7,0xB5,0xF7,0x45,0x23,0x97,
+0x2F,0x7E,0xC7,0x5C,0x9F,0x8A,0x25,0x40,
+0x27,0x15,0xE2,0x81,0x05,0x2D,0x46,0xD6,
+0x27,0x44,0xAD,0xA0,0xDB,0x83,0x83,0x2F,
+0x27,0xD8,0x41,0x1C,0x3B,0xBE,0xF9,0x9B,
+0x27,0xB5,0x16,0xEC,0x2E,0x29,0x5E,0x08,
+0x2F,0x40,0x96,0x7A,0xD8,0x95,0xE6,0xC0,
+0x27,0x38,0xE7,0xFE,0x9C,0xC9,0x57,0x26,
+0x27,0x97,0x19,0x8B,0x8E,0x54,0x3F,0xBB,
+0x27,0x4E,0x18,0xB4,0xE0,0x60,0x11,0x9B,
+0x2F,0x67,0xF4,0xFE,0xE7,0x03,0xBD,0x19,
+0x2F,0x4D,0x78,0x06,0xBC,0xD3,0xC4,0x11,
+0x27,0x34,0xF0,0x24,0x88,0x9D,0x5A,0xCB,
+0x2F,0xEF,0xD7,0x93,0x32,0xE1,0x18,0x07,
+0x27,0x87,0xAF,0x51,0x01,0xE1,0x95,0x7C,
+0x27,0x4A,0xE1,0x39,0xDC,0xF9,0xF0,0xC8,
+0x27,0x18,0x65,0x5C,0x1A,0xA4,0x8C,0x5B,
+0x2F,0xE4,0xE2,0xD2,0xC4,0xF5,0x9E,0x58,
+0x23,0x3F,0x4E,0x68,0xD8,0x35,0xC9,0x90,
+0x27,0x3D,0x43,0x65,0xEE,0xA7,0xD2,0x8C,
+0x2F,0x1E,0x50,0x2C,0x54,0x0D,0x8A,0xEA,
+0x27,0xE5,0xE8,0xCE,0xC4,0x56,0xF3,0xF2,
+0x27,0x51,0x42,0xB0,0x9D,0x96,0xFC,0x3E,
+0x2F,0x2F,0xAA,0x4E,0xA0,0xF6,0x4B,0xD3,
+0x2F,0x7D,0xE9,0x47,0x60,0x63,0xC9,0x21,
+0x27,0x36,0x31,0xAB,0x7A,0x89,0xA4,0x51,
+0x2F,0xC9,0x16,0x05,0x9D,0x0E,0xEB,0xC7,
+0x2F,0x4C,0x14,0x23,0x1E,0x8E,0x76,0x4F,
+0x2F,0x01,0x71,0xA1,0xFE,0x88,0xCD,0x3B,
+0x27,0x2C,0x71,0xAA,0x8F,0xCA,0x71,0x20,
+0x27,0xB9,0x5E,0x57,0xED,0x5F,0xBF,0x93,
+0x2F,0x33,0xB1,0xFF,0x1C,0xDA,0x6F,0x7A,
+0x2F,0x4A,0xC1,0x9E,0x84,0x87,0xB5,0x32,
+0x2F,0x4E,0xF8,0x25,0xDF,0x69,0xCA,0xAF,
+0x27,0x05,0x75,0x0F,0xDC,0xD3,0xD7,0x18,
+0x2F,0x37,0xCA,0x47,0xD8,0x9E,0xD3,0xAD,
+0x27,0x73,0xCE,0x0C,0xEC,0xF9,0xAC,0x79,
+0x27,0x1E,0x02,0xB1,0x21,0xF3,0xC0,0xFA,
+0x2F,0xCA,0x6E,0x29,0x6D,0xD1,0xD3,0xB6,
+0x27,0x7B,0x0B,0x11,0x9E,0xED,0x8F,0x02,
+0x27,0xD5,0x29,0x1A,0xE3,0xB7,0x7C,0x47,
+0x2F,0xC7,0x5D,0x86,0x7E,0xDC,0xB4,0x09,
+0x2F,0x29,0x08,0xC0,0x57,0x17,0x2F,0x3A,
+0x2F,0x0B,0x14,0xCB,0xB5,0xF7,0xC2,0xA2,
+0x2F,0x20,0x17,0x0A,0x80,0x98,0x56,0xBB,
+0x2F,0xA6,0x1A,0x8E,0x43,0xCA,0x20,0xE7,
+0x2F,0xE5,0xCE,0xA7,0xC3,0xA6,0x74,0xFC,
+0x27,0x4B,0xF2,0x16,0x88,0xA3,0x67,0xCE,
+0x2F,0xD6,0x0C,0xC7,0x39,0x88,0x87,0xBB,
+0x27,0x57,0x64,0xCF,0xDD,0x45,0x69,0x1E,
+0x27,0xE2,0xF5,0x2F,0x79,0x58,0x4B,0x95,
+0x27,0xD9,0x6A,0x7A,0x05,0x11,0x68,0x6E,
+0x27,0xDF,0x9B,0xDF,0xD8,0x89,0xDF,0x7B,
+0x27,0x55,0x47,0xA4,0x4D,0x1C,0xBD,0xC9,
+0x27,0x43,0x0A,0x75,0xC3,0xF9,0x59,0xBD,
+0x2B,0x30,0x1A,0x70,0x07,0xD7,0x3D,0xA5,
+0x27,0x84,0xA2,0x33,0xBC,0xE1,0x70,0x75,
+0x27,0x79,0x87,0xD8,0x4F,0x3F,0xEB,0x8C,
+0x27,0x76,0xCA,0xD2,0xA2,0x3B,0x35,0xD3,
+0x27,0x2D,0x06,0x13,0x76,0x7E,0xE3,0x57,
+0x27,0x90,0x99,0xE9,0x06,0x2A,0x71,0xF6,
+0x2F,0x70,0xB5,0x04,0x80,0x4B,0x07,0xCF,
+0x22,0x77,0x70,0x3F,0x96,0x4A,0x08,0xB7,
+0x07,0x6E,0x62,0xBA,0x1E,0x92,0xA1,0xE6,
+0x2F,0x31,0xB6,0x1D,0x0F,0x07,0x49,0x1B,
+0x2A,0xBC,0x52,0x35,0xAF,0x0E,0x17,0xE7,
+0x07,0x03,0xEB,0x38,0x38,0xBB,0x5B,0x08,
+0x26,0x2C,0x1F,0xEA,0x14,0xEB,0xB0,0x07,
+0x07,0xA6,0xAA,0x2C,0x3F,0x9C,0x1A,0x5C,
+0x07,0x7D,0x4F,0xDC,0x14,0x19,0x66,0x48,
+0x27,0xA3,0x39,0x90,0xE1,0xEE,0x81,0x90,
+0x21,0x73,0x87,0x44,0x11,0x85,0x49,0x25,
+0x0F,0xBA,0xAF,0x40,0x4D,0x9E,0x10,0x0F,
+0x27,0x90,0x52,0x55,0x09,0x8E,0x4A,0x5F,
+0x21,0xAA,0x3B,0x01,0xE8,0xC6,0x5E,0xDC,
+0x0F,0xC2,0xA5,0x37,0x21,0x06,0x94,0x69,
+0x0F,0x5F,0xCD,0x94,0xDB,0xF0,0x21,0x4C,
+0x27,0x69,0x34,0x86,0x82,0x8F,0xBD,0xB1,
+0x29,0x37,0xD2,0x8E,0x66,0x28,0x38,0x1A,
+0x0F,0x77,0xE4,0x2D,0xCC,0x34,0x01,0xC8,
+0x0F,0xC0,0x3A,0x74,0x78,0xC3,0x33,0xA9,
+0x2F,0x8D,0xB3,0x1D,0x0C,0x57,0xC2,0x5D,
+0x29,0x8E,0xC2,0xB5,0x31,0x34,0x12,0xB5,
+0x07,0x38,0xD7,0xF8,0x38,0x3A,0x6E,0xF0,
+0x27,0x8D,0x74,0xA2,0x55,0x38,0x5A,0xB9,
+0x29,0x21,0x4B,0x99,0xE7,0xFF,0xE2,0xCB,
+0x0F,0xA9,0xA2,0x82,0xC3,0xF1,0x07,0x74,
+0x27,0x98,0x2A,0xD3,0xE3,0x5E,0x22,0x98,
+0x21,0x0A,0x00,0x1A,0x44,0x72,0x8B,0x05,
+0x07,0xEA,0xEE,0xFA,0x3F,0xD3,0x17,0xBA,
+0x27,0xB1,0x89,0x44,0xB3,0x5F,0x88,0x5D,
+0x29,0x03,0x37,0x09,0x99,0xEC,0x8E,0xA0,
+0x07,0x38,0xE2,0x39,0x11,0x4C,0x80,0x2E,
+0x27,0x98,0x4E,0x18,0x70,0xA0,0x6E,0x8D,
+0x2A,0x24,0x82,0x6D,0xC9,0x5A,0x67,0x4D,
+0x07,0x34,0xAA,0x51,0xB5,0x4F,0x3C,0xE4,
+0x27,0x28,0xFD,0x15,0xFC,0x45,0x8A,0x03,
+0x21,0xE7,0x0E,0xD4,0x7B,0xDE,0x72,0x94,
+0x07,0xB6,0xE8,0xBD,0x35,0x8B,0x1B,0x64,
+0x2F,0x27,0x42,0x9B,0x7B,0xFA,0x51,0x1A,
+0x2A,0x5F,0x58,0xE1,0x84,0xB9,0x69,0xC3,
+0x0F,0xE2,0x1C,0xE3,0xB5,0xFD,0xEA,0xF3,
+0x27,0x6C,0x54,0x14,0x6B,0x39,0xEA,0xDC,
+0x22,0xA5,0xB0,0xBF,0x99,0xD7,0xBA,0x84,
+0x0F,0x13,0x40,0x0F,0x79,0x46,0xAD,0x4A,
+0x27,0xFD,0xF1,0xED,0x39,0x93,0x95,0xCE,
+0x22,0xAF,0xC3,0x8F,0x60,0xD7,0xB2,0x58,
+0x07,0x86,0xE6,0x0E,0x7C,0x1F,0x0B,0x80,
+0x27,0x05,0x0B,0xBA,0xDA,0xD9,0x03,0x13,
+0x2B,0x9F,0x2D,0x9E,0xC0,0x46,0x4C,0x59,
+0x07,0x6E,0x77,0x67,0x4C,0xAA,0xDE,0xBA,
+0x2F,0x24,0x45,0x78,0x63,0x12,0x6D,0x25,
+0x07,0x61,0x67,0x20,0xCE,0xA3,0xCC,0x1E,
+0x2F,0x92,0xCE,0x1A,0x19,0x01,0x9D,0x19,
+0x23,0xDD,0xF4,0x07,0x66,0x58,0xC2,0x12,
+0x07,0x90,0x94,0x02,0x67,0xAE,0x89,0xE6,
+0x2F,0x05,0xEF,0x23,0x1E,0x45,0x73,0xD9,
+0x22,0x55,0x57,0xAD,0xA0,0xEF,0x2C,0x65,
+0x0F,0x6B,0x35,0x28,0xBA,0xD8,0xA3,0x78,
+0x27,0xAF,0x24,0x92,0x35,0x57,0xA6,0x1A,
+0x22,0x81,0xB3,0x5D,0x1F,0x8C,0x94,0x00,
+0x07,0xE0,0xFF,0x89,0x43,0xB1,0x05,0x4C,
+0x27,0x92,0x16,0xFB,0x7E,0xE0,0xC4,0x6D,
+0x29,0xA9,0x2D,0x73,0xEB,0xD7,0x2E,0xC1,
+0x07,0x4D,0x86,0x93,0xF8,0xAD,0xAC,0x8C,
+0x2F,0xE7,0x47,0xDA,0xE6,0x47,0xEA,0xC8,
+0x2A,0x4A,0x0B,0xA4,0xF8,0x15,0x9A,0x70,
+0x07,0x96,0xB7,0x90,0x05,0x25,0xFE,0xFA,
+0x27,0x7C,0xB1,0xF3,0x81,0x6D,0xCA,0x96,
+0x22,0xC2,0x5F,0x96,0x8B,0x5F,0x96,0x86,
+0x07,0x6E,0xE8,0xEE,0xE9,0xC0,0xC7,0xBB,
+0x27,0xFF,0x8C,0x64,0xDC,0x9A,0xE2,0xAF,
+0x2A,0xA2,0xBF,0xE0,0x70,0x83,0xFF,0xDD,
+0x0F,0x5A,0xC2,0x91,0x0A,0x32,0x5C,0xA9,
+0x27,0xD8,0x1F,0x43,0x7C,0x93,0x0F,0xC6,
+0x22,0x0E,0x19,0x88,0x9F,0xAE,0xB0,0x86,
+0x0F,0x40,0xB2,0x76,0x77,0x64,0xD7,0x63,
+0x2F,0x52,0x03,0xFF,0xF6,0x05,0x4A,0x65,
+0x2A,0xE0,0xC0,0xEB,0xE4,0x0F,0x4C,0xCB,
+0x0F,0x55,0xC8,0xA7,0x01,0x72,0x78,0xF8,
+0x2F,0xC5,0x2A,0xD2,0x81,0x53,0x40,0xBC,
+0x21,0x52,0x1D,0xA4,0xB7,0x6D,0xC1,0xE6,
+0x07,0xF2,0x49,0x60,0x4E,0x77,0x27,0x8C,
+0x27,0x58,0x1B,0xFF,0x51,0xEF,0xA7,0xAA,
+0x22,0x32,0x08,0xEB,0x27,0x95,0x8D,0x28,
+0x0F,0x07,0x2C,0xFA,0x76,0xCB,0xC0,0xBE,
+0x2F,0x40,0xC8,0x89,0x62,0xCD,0xC3,0x2E,
+0x2A,0x2E,0xFE,0x62,0x40,0xA0,0x91,0x79,
+0x07,0xF1,0xFF,0xEF,0x77,0xEB,0x81,0x5B,
+0x2D,0x22,0x33,0xC0,0xE8,0x86,0xCA,0xD8,
+0x0F,0x6D,0xF8,0x2E,0x72,0xBA,0x29,0x56,
+0x2F,0x6F,0x81,0x79,0x57,0x24,0x42,0xC0,
+0x2A,0xC4,0xF3,0x1E,0x5B,0x3A,0x98,0x82,
+0x0F,0x49,0x64,0xE1,0x4A,0x1E,0x6A,0x05,
+0x2F,0x27,0xED,0x72,0xFD,0x1A,0x58,0xDC,
+0x22,0x9B,0x50,0xAA,0xFD,0x4F,0xA1,0x8E,
+0x0F,0xE9,0x5C,0xA9,0xB3,0x94,0xF0,0x68,
+0x27,0x1C,0x13,0x06,0xE1,0xC1,0xC3,0x12,
+0x22,0x70,0x8F,0xDA,0xC4,0x43,0x98,0xAF,
+0x0F,0x9B,0x10,0xAC,0x80,0x56,0xD7,0xD2,
+0x25,0xB1,0x56,0x71,0xC7,0x7A,0x35,0x91,
+0x07,0x21,0xE4,0x7D,0xE0,0xBA,0x73,0x2E,
+0x27,0x73,0x75,0xFE,0x9D,0xE6,0x1F,0x6D,
+0x2A,0x7B,0x5F,0x96,0x09,0x58,0x7F,0xC2,
+0x07,0x91,0xEB,0x89,0x43,0x58,0x2C,0x7F,
+0x2F,0xDE,0x00,0x58,0xC3,0xDE,0x74,0x0C,
+0x2A,0x94,0x21,0x74,0x45,0x2C,0x8A,0xC2,
+0x0F,0x01,0x39,0xC4,0xC6,0x64,0x79,0xFC,
+0x27,0xB5,0x64,0x24,0xFD,0xA6,0xE9,0x46,
+0x0F,0xD0,0x98,0x52,0xFF,0xDE,0x21,0xDC,
+0x27,0xCC,0x40,0x70,0xBD,0x24,0xB2,0x40,
+0x2A,0xFE,0x20,0x77,0xBC,0x73,0x6E,0x36,
+0x0F,0xC8,0x03,0xF3,0x3B,0x64,0x2E,0xC9,
+0x27,0x46,0x0F,0x46,0x8E,0x57,0x83,0xC4,
+0x2A,0x24,0xCD,0xCB,0x45,0xED,0xD1,0x23,
+0x07,0x2A,0x38,0x14,0xE8,0x9D,0x13,0x49,
+0x0F,0xDD,0xEF,0x67,0x1E,0x1E,0x83,0xAF,
+0x27,0x30,0x26,0xD9,0xD8,0x18,0x5A,0xA3,
+0x2B,0x3D,0x70,0xCC,0xFB,0xE2,0xDA,0x5D,
+0x0F,0xAF,0x77,0x5A,0x46,0x32,0x3B,0x28,
+0x2F,0x67,0x02,0xFA,0x0E,0x27,0x70,0x8A,
+0x23,0x62,0x15,0xFB,0xCE,0xD0,0xC6,0x4D,
+0x0F,0xA8,0xBF,0xEB,0x17,0xD2,0x6C,0xCC,
+0x2F,0xC1,0xE0,0x39,0xFE,0x3C,0x09,0x10,
+0x2B,0xC0,0xBE,0xDF,0x7E,0x61,0x6D,0xC5,
+0x0F,0x97,0x3F,0x8F,0xEE,0x9E,0x80,0xB2,
+0x2F,0x89,0x28,0xB5,0xCE,0x93,0x65,0x13,
+0x22,0x27,0x88,0x4D,0x02,0xDE,0x04,0x7D,
+0x0F,0x1A,0xA6,0x41,0x94,0x67,0xCA,0x79,
+0x27,0xFE,0x53,0xA1,0xBC,0xB2,0xC5,0x7D,
+0x23,0x4B,0xFF,0xF3,0x88,0x21,0x27,0x58,
+0x07,0xEB,0xAB,0x49,0x69,0x85,0xE8,0x2D,
+0x2F,0x1D,0xFE,0x8C,0x1B,0x08,0x7D,0x57,
+0x23,0xDF,0xD6,0x43,0xC7,0xD2,0x2A,0x3C,
+0x0F,0x59,0x85,0xAE,0x5E,0xBE,0xF1,0xE9,
+0x2F,0x4C,0x06,0x7A,0x2F,0xFC,0x8E,0x9F,
+0x07,0x13,0x4B,0x58,0x7C,0x7C,0xC7,0x70,
+0x2F,0x11,0x2A,0xF5,0xF3,0xF6,0x77,0x9C,
+0x22,0x1C,0xC9,0x3C,0x16,0xBA,0x17,0x4C,
+0x0F,0xF4,0xD5,0x22,0x81,0xAA,0xD4,0x13,
+0x27,0xF5,0x58,0x06,0xDB,0x06,0xD6,0x90,
+0x2D,0x10,0x92,0x8F,0x6D,0xB4,0x57,0x75,
+0x0F,0x20,0x11,0x86,0xB5,0x2A,0x68,0xF2,
+0x27,0x6E,0xFA,0x08,0xD6,0xEB,0xE7,0x9D,
+0x24,0x66,0x95,0xAC,0x68,0xF3,0xE0,0x03,
+0x07,0x78,0x8D,0xD1,0xD8,0x7A,0x4D,0x72,
+0x27,0x50,0xD3,0x8D,0xB3,0x58,0x04,0x26,
+0x27,0x9E,0xEF,0x7A,0xE5,0x40,0xF1,0x43,
+0x07,0x8E,0x8D,0xED,0xEA,0xCF,0xC7,0x3B,
+0x27,0xC3,0x59,0x7B,0xAB,0x73,0xC5,0x7C,
+0x27,0xC0,0xF2,0x8F,0xF7,0x07,0xFF,0x0D,
+0x07,0xCE,0x74,0x6C,0x2C,0xDD,0x68,0x6D,
+0x2F,0x69,0x21,0x1F,0xEF,0x9A,0xEE,0xF9,
+0x2F,0xEE,0x69,0x55,0xB3,0x15,0x58,0x35,
+0x07,0xF1,0x17,0x33,0x20,0xE8,0x41,0x80,
+0x2F,0x7D,0x4E,0x68,0x4E,0xA2,0x50,0x94,
+0x2F,0x31,0xB2,0x9A,0x37,0xF3,0xBB,0x05,
+0x07,0xBC,0x11,0xB1,0x3C,0xED,0xFF,0x44,
+0x27,0x93,0x2D,0x61,0x43,0x38,0x6B,0xC2,
+0x2F,0x1F,0x3E,0xEE,0x05,0xF2,0xCA,0x91,
+0x07,0x05,0x9A,0xFF,0x85,0xD3,0x21,0x17,
+0x27,0x22,0x3C,0x60,0x1C,0xBA,0xA2,0xD6,
+0x2F,0x07,0xFF,0x12,0xEE,0x5E,0x1C,0x1C,
+0x07,0x2F,0x39,0xA3,0x8E,0xDC,0x29,0xED,
+0x0F,0x78,0x1C,0x7E,0xF3,0x9B,0x8A,0xE5,
+0x0F,0xB3,0x57,0xCA,0xA5,0xC6,0x70,0x94,
+0x07,0x3F,0x54,0x83,0xF1,0x1D,0xEB,0x1C,
+0x0F,0x71,0xCB,0xCB,0x35,0x16,0x70,0xCF,
+0x07,0x9B,0x6C,0x52,0xBE,0xDC,0xE9,0x53,
+0x07,0x1E,0xA5,0xB4,0xE5,0xDB,0x90,0xC8,
+0x07,0x09,0x8A,0xC3,0xD0,0x44,0xA3,0xC2,
+0x27,0x88,0x28,0x62,0xFD,0x5D,0x04,0x32,
+0x23,0xE6,0xBE,0xD2,0x75,0x3D,0xF2,0x31,
+0x0F,0x24,0x16,0xFE,0x9F,0x59,0x7F,0xF6,
+0x0F,0x9D,0x27,0xEF,0x9B,0x9D,0x73,0x37,
+0x05,0xDC,0x6B,0xF9,0xA2,0xC7,0xD9,0x10,
+0x27,0x78,0x0D,0x95,0x0C,0x68,0xF1,0x1E,
+0x29,0x73,0x97,0x66,0x65,0xD2,0x5F,0xE3,
+0x07,0x6E,0xF8,0x1F,0xAA,0x15,0xA1,0x2D,
+0x0F,0xB3,0x8F,0x2C,0x08,0x51,0x96,0xE3,
+0x07,0xDF,0x6E,0x4A,0x2F,0x82,0x86,0x2D,
+0x0F,0x72,0xAA,0x0B,0xF3,0x22,0xF1,0x8E,
+0x07,0x84,0x6C,0x74,0xD3,0x32,0x80,0xE5,
+0x0F,0x62,0xC0,0x47,0xD5,0xF6,0xAB,0xDE,
+0x0F,0xBF,0xC1,0x20,0x97,0x19,0xBF,0x96,
+0x07,0x56,0x96,0xC3,0x74,0x0A,0x44,0x5A,
+0x26,0x93,0x78,0x0F,0x1F,0xF3,0x8B,0xC0,
+0x07,0xCC,0x52,0x10,0x0B,0x36,0x2E,0x4A,
+0x07,0x13,0x9D,0x25,0x52,0x95,0x90,0xE0,
+0x07,0xEF,0x65,0xC1,0x0E,0x43,0x18,0x49,
+0x05,0x19,0x6E,0xD4,0x67,0xBE,0x84,0xE9,
+0x27,0x7C,0x05,0xEA,0x57,0xBA,0x1E,0xEF,
+0x29,0x5A,0x88,0x54,0x89,0x9F,0x69,0x00,
+0x0F,0xE9,0xF6,0x6F,0x62,0xA0,0xA9,0x81,
+0x07,0x59,0xE1,0x41,0xBD,0x9B,0xAB,0x04,
+0x07,0xE4,0xD1,0x8E,0x35,0x9E,0xCD,0xD0,
+0x07,0x63,0x61,0x1A,0xD5,0x0B,0xED,0x8D,
+0x05,0xFA,0x25,0x5E,0x79,0x75,0x93,0x40,
+0x2D,0x56,0x6B,0x14,0x24,0x4F,0x62,0xCA,
+0x07,0x2F,0x0D,0x7D,0xB2,0xBA,0xD6,0xCC,
+0x0F,0x25,0xBA,0xD6,0x20,0x15,0xA2,0x8C,
+0x05,0x82,0x31,0x96,0x3A,0xD0,0x48,0x95,
+0x27,0xBD,0x4A,0x80,0x4C,0xD1,0x93,0x61,
+0x27,0x8A,0xD7,0x55,0xC2,0x82,0xBF,0x82,
+0x2F,0x34,0x42,0x4C,0x4F,0xAF,0x7C,0x57,
+0x27,0xB5,0x5B,0xE6,0x5B,0xA0,0x4D,0xFE,
+0x2C,0x1F,0x8E,0x76,0xB2,0xCF,0xD5,0xED,
+0x07,0x72,0x0F,0x0E,0x29,0x1C,0xD9,0xB0,
+0x2B,0xDC,0x0B,0x98,0xFA,0x34,0xD5,0x69,
+0x07,0x5F,0x24,0xAD,0x22,0xF9,0x90,0x2D,
+0x07,0xE3,0x21,0x4B,0xDF,0x46,0x09,0x62,
+0x07,0xF1,0x8A,0x19,0x92,0xF3,0x4C,0xAF,
+0x0F,0xBB,0xFA,0x83,0x0C,0x3F,0x49,0x79,
+0x07,0x16,0xF4,0xA4,0x4D,0x82,0x5C,0xF2,
+0x24,0x4B,0xE4,0x69,0xB1,0xD2,0x0D,0xDF,
+0x0F,0x21,0x9D,0xC8,0xCF,0xE2,0xB5,0x58,
+0x0F,0x2F,0xD6,0x94,0xCD,0x52,0x1E,0x5F,
+0x0F,0xFC,0xA6,0xC8,0x3C,0x20,0xAD,0x07,
+0x07,0x6A,0x13,0x7B,0xAD,0x5C,0x57,0x42,
+0x07,0xEC,0x4E,0x2A,0x3A,0x04,0xD3,0x86,
+0x27,0x72,0x2A,0x4D,0xC0,0xDA,0x3F,0xA5,
+0x24,0x32,0x26,0x8D,0xA2,0x66,0xDB,0x69,
+0x0F,0x58,0x83,0x18,0x14,0xFB,0x88,0x0C,
+0x0F,0x8A,0xE6,0x04,0x2C,0x71,0x0C,0x54,
+0x2F,0x34,0xC3,0xD8,0x00,0x1C,0x38,0xDD,
+0x21,0x1D,0x44,0x05,0x28,0xF8,0xC5,0x85,
+0x07,0xA3,0x17,0x50,0x3A,0x03,0x6A,0xF0,
+0x07,0x40,0xA7,0xFC,0x81,0x15,0x58,0x9E,
+0x0F,0xB2,0x91,0x6B,0xB9,0x17,0xCE,0xE2,
+0x0F,0xE5,0x50,0xDD,0x47,0xE6,0xEE,0x6D,
+0x07,0x84,0x20,0xD6,0xA9,0x5A,0x8C,0x02,
+0x0F,0xEE,0xA5,0x18,0xD6,0x38,0xD5,0x46,
+0x0F,0xBE,0xB4,0x03,0xE7,0x04,0x10,0x04,
+0x05,0x53,0xF1,0x43,0xCC,0xD1,0xCA,0x3E,
+0x2E,0x87,0xD9,0xD1,0x9A,0x54,0x46,0x77,
+0x05,0xB7,0xF5,0x3D,0x7C,0xE4,0x58,0xA3,
+0x27,0xE7,0xA3,0x7B,0xB8,0x2C,0xCC,0xB3,
+0x2A,0x8D,0x21,0xD6,0xC6,0xCF,0x99,0x7A,
+0x0F,0x27,0x92,0xE1,0x4A,0x9C,0x02,0x9D,
+0x07,0x52,0x8E,0x05,0xCC,0xC9,0xC3,0xFA,
+0x22,0x05,0xC3,0x5A,0x3D,0x72,0x70,0x0D,
+0x0F,0x52,0xEE,0x30,0x16,0xC0,0x8F,0xE7,
+0x0F,0x44,0x3E,0x46,0xE7,0xF6,0xD0,0x64,
+0x07,0x06,0xDD,0xCC,0xF8,0x4E,0x23,0x82,
+0x0F,0x9F,0x05,0xC0,0xA9,0x91,0x9E,0x0B,
+0x2F,0x60,0xD8,0x39,0x2B,0x95,0x38,0x22,
+0x22,0x9C,0x32,0xAC,0x8A,0x8F,0x89,0xCF,
+0x05,0xD2,0x48,0x9C,0x7A,0x99,0x9C,0xAC,
+0x2A,0xCD,0x32,0x74,0xED,0xF8,0x63,0xBA,
+0x0F,0xB2,0xFE,0x1B,0x00,0x53,0x0F,0x3A,
+0x24,0xAB,0xA2,0xC1,0x5B,0x1D,0xAD,0x83,
+0x07,0xDB,0x87,0x28,0x0E,0x1E,0x5A,0xEC,
+0x05,0x93,0x50,0x53,0x13,0x2C,0x0C,0xAD
+};
+
+#define FIRMWARE_LINES_0_Eb15 (sizeof(Si2148_FW_0_Eb15)/(8*sizeof(unsigned char)))
+
+firmware_struct Si2148_FW_2_1b6[] = {
+{ 8 , { 0x04,0x01,0x00,0x00,0x08,0x05,0x32,0xD6 } },
+{ 8 , { 0x05,0xB6,0x4D,0xA7,0x66,0x4C,0xA7,0xD1 } },
+{ 9 , { 0x38,0x71,0xE5,0x1C,0x34,0x56,0x42,0x76,0x84 } },
+{ 8 , { 0x05,0x11,0x6F,0x2B,0x83,0x21,0x31,0x16 } },
+{ 3 , { 0x42,0x01,0x77 } },
+{ 8 , { 0x05,0x70,0x78,0x85,0x35,0x97,0xA1,0x59 } },
+{ 3 , { 0x42,0x44,0x43 } },
+{ 8 , { 0x05,0x89,0xD6,0xB7,0x39,0xD4,0x9E,0xC7 } },
+{ 3 , { 0x42,0x5E,0x98 } },
+{ 8 , { 0x05,0x88,0xC4,0x2F,0x9C,0x50,0x0D,0x60 } },
+{ 16 , { 0x37,0x4A,0xEB,0x4B,0x6D,0x19,0x16,0x2D,0xEF,0x45,0x31,0x35,0x00,0xA8,0x8D,0x62 } },
+{ 3 , { 0x4A,0x88,0xEE } },
+{ 8 , { 0x05,0xA6,0x70,0x2D,0x3A,0x92,0xB7,0x77 } },
+{ 3 , { 0x42,0x4E,0x73 } },
+{ 8 , { 0x05,0x33,0x50,0x02,0x75,0x55,0x77,0xF3 } },
+{ 3 , { 0x4A,0x5D,0xC8 } },
+{ 8 , { 0x05,0x53,0xC8,0xB4,0x86,0x2B,0xC0,0xF2 } },
+{ 12 , { 0x33,0xD6,0xE2,0x67,0x83,0x8D,0xCC,0x1A,0x11,0x19,0xC9,0x4C } },
+{ 8 , { 0x05,0x04,0xAD,0xEC,0x5E,0x50,0x41,0x04 } },
+{ 3 , { 0x4A,0x99,0xF6 } },
+{ 8 , { 0x05,0x2B,0x99,0x68,0x56,0x2D,0x4C,0x92 } },
+{ 3 , { 0x4A,0x98,0xDA } },
+{ 8 , { 0x05,0xFE,0x2B,0x2D,0x91,0x52,0x01,0x05 } },
+{ 6 , { 0x4D,0xAA,0xEF,0x8F,0xC1,0x50 } },
+{ 8 , { 0x05,0x06,0x1C,0x5A,0x2C,0x37,0x03,0xA5 } },
+{ 6 , { 0x4D,0xBE,0xE3,0xDC,0x63,0xB2 } },
+{ 8 , { 0x05,0xCC,0x23,0xD6,0x86,0xB3,0xB7,0xE6 } },
+{ 6 , { 0x4D,0x73,0x35,0x9D,0x2C,0xFA } },
+{ 8 , { 0x05,0xD2,0x46,0xC5,0x5A,0xF4,0xB2,0xDE } },
+{ 6 , { 0x45,0xDE,0x90,0xE2,0x4E,0x2B } },
+{ 8 , { 0x05,0x5C,0x86,0xF8,0xCA,0xDF,0x44,0x4B } },
+{ 3 , { 0x4A,0xEE,0xAA } },
+{ 8 , { 0x05,0x7F,0x78,0xD0,0x7C,0x40,0x59,0x6A } },
+{ 3 , { 0x4A,0x41,0x2A } },
+{ 8 , { 0x05,0xB2,0xE3,0x5C,0x90,0xD6,0xAB,0x63 } },
+{ 3 , { 0x4A,0x5E,0xB2 } },
+{ 8 , { 0x05,0xAB,0x19,0x32,0x68,0x79,0x69,0x4D } },
+{ 3 , { 0x4A,0x6A,0x8C } },
+{ 8 , { 0x05,0xA2,0x8C,0xCC,0x7D,0x08,0x9C,0x76 } },
+{ 3 , { 0x42,0x65,0x7D } },
+{ 8 , { 0x07,0x6E,0x79,0xF9,0x6B,0x55,0xD7,0x16 } },
+{ 16 , { 0x3F,0x16,0xE1,0x6F,0x2A,0xB4,0xFF,0xEC,0xF5,0xD1,0x58,0x21,0x29,0xEE,0x46,0x18 } },
+{ 16 , { 0x3F,0x7E,0x09,0x69,0x59,0x9C,0x92,0xC9,0x69,0xA9,0x82,0x32,0xC1,0xD4,0xFF,0x1F } },
+{ 16 , { 0x3F,0x32,0xDE,0xA7,0x35,0xF7,0x0F,0xBE,0x3F,0x8A,0xEA,0x17,0x25,0x6B,0x4B,0x0B } },
+{ 7 , { 0x4E,0x40,0xBC,0xE0,0xC9,0xA8,0x2C } },
+{ 8 , { 0x07,0x2D,0xB7,0xDE,0xA3,0xC4,0xA0,0x0D } },
+{ 8 , { 0x0F,0xBF,0x7E,0x2C,0x4A,0xDA,0x05,0x40 } },
+{ 8 , { 0x07,0xDD,0x73,0x54,0xBD,0x8C,0x25,0x73 } },
+{ 16 , { 0x37,0x41,0x7B,0xC9,0x5E,0x93,0x8A,0x70,0xBC,0x00,0x28,0x12,0x5E,0x9A,0x26,0xD4 } },
+{ 16 , { 0x37,0x75,0x96,0xA7,0x29,0x43,0x74,0x20,0xA9,0x03,0xA1,0x6E,0xFF,0xAC,0xD3,0x96 } },
+{ 12 , { 0x3B,0xCD,0xE0,0x1A,0xDB,0x7C,0xB4,0x41,0x4A,0x28,0xD7,0xDB } },
+{ 8 , { 0x0F,0x1A,0x3A,0x71,0x35,0x6D,0x7E,0xBE } },
+{ 16 , { 0x37,0xB5,0x8D,0x55,0x78,0xEA,0x32,0x05,0x98,0x9B,0xA0,0xA1,0x90,0xCB,0xC9,0x81 } },
+{ 16 , { 0x3F,0x67,0x0F,0x61,0xBE,0x32,0xE2,0xC6,0x84,0x65,0x31,0x45,0xBC,0x46,0x28,0x4B } },
+{ 16 , { 0x3F,0x72,0x42,0x58,0x14,0xCF,0x49,0x73,0x8A,0x05,0xBA,0xC0,0x1D,0xF6,0x94,0xC0 } },
+{ 16 , { 0x37,0x89,0x82,0xAB,0x88,0x42,0x07,0x45,0x31,0xA1,0x6D,0x14,0xE2,0x94,0x9F,0x94 } },
+{ 16 , { 0x3F,0x52,0x37,0x91,0xEE,0x41,0x44,0x5F,0x83,0x60,0xAD,0x82,0x94,0xA4,0x04,0xDF } },
+{ 16 , { 0x3F,0xC6,0x8C,0x84,0x13,0x60,0x6D,0xC8,0xED,0x13,0xBF,0x76,0x7D,0x91,0xB1,0xF8 } },
+{ 16 , { 0x37,0x79,0xE1,0xC6,0x10,0xC3,0xDB,0xB0,0xC7,0xA3,0xF1,0x14,0x44,0xF8,0x4D,0xEE } },
+{ 8 , { 0x07,0xF1,0xD5,0x54,0xBA,0x6D,0x4D,0x6F } },
+{ 12 , { 0x33,0xF8,0x95,0x4B,0xF1,0x3F,0x56,0x2C,0x50,0x97,0xFC,0xF4 } },
+{ 8 , { 0x07,0xF3,0x20,0x2A,0x3A,0x1F,0x17,0xE9 } },
+{ 10 , { 0x31,0x58,0xD9,0xEC,0x4E,0x54,0xE7,0x8D,0x12,0x74 } },
+{ 8 , { 0x0F,0x8A,0x88,0x58,0xFC,0x7A,0xFF,0x23 } },
+{ 8 , { 0x07,0x6D,0x13,0x62,0xD0,0xEE,0xAC,0x65 } },
+{ 8 , { 0x0F,0xC4,0x5C,0x09,0x4E,0x20,0xAA,0xF0 } },
+{ 15 , { 0x3E,0x06,0x46,0x89,0x4F,0xCF,0xC2,0x9A,0x17,0x76,0xA3,0x5E,0x45,0xE2,0x51 } },
+{ 8 , { 0x0F,0xCF,0x5B,0x57,0x48,0xE3,0xC5,0xBC } },
+{ 16 , { 0x3F,0x63,0xA9,0x7B,0x71,0x5D,0xC2,0xA6,0x4B,0xB6,0xC5,0x57,0x4A,0x9B,0x56,0xCC } },
+{ 16 , { 0x37,0xF6,0xEB,0x1C,0x28,0xF1,0xD8,0x11,0xF2,0x33,0xD7,0xC9,0xA2,0xC5,0x9A,0x39 } },
+{ 16 , { 0x3F,0xC4,0x05,0x61,0x9E,0x4A,0x14,0x5E,0x88,0x34,0x2C,0x13,0x0B,0xF6,0x85,0x02 } },
+{ 16 , { 0x37,0x36,0x08,0x94,0x68,0xE5,0xFC,0xC7,0x58,0x92,0x6D,0xE3,0xE4,0x66,0x09,0x4B } },
+{ 4 , { 0x43,0xB0,0xBB,0x89 } },
+{ 8 , { 0x07,0xBC,0x85,0xE2,0x55,0xCA,0x79,0x7D } },
+{ 16 , { 0x3F,0x77,0x71,0xFB,0xE9,0xB5,0xF0,0xB6,0x41,0x80,0x47,0xAD,0x91,0xE5,0x67,0xB7 } },
+{ 9 , { 0x38,0x22,0x2F,0x70,0xB1,0xE5,0xC2,0x0B,0x87 } },
+{ 8 , { 0x07,0x49,0xEE,0x5E,0x86,0xA6,0x0A,0x78 } },
+{ 16 , { 0x37,0xF6,0x09,0xBA,0xD5,0x06,0x95,0x28,0x6C,0x9C,0xD6,0x96,0x46,0x8F,0xA3,0x99 } },
+{ 16 , { 0x37,0xDB,0x64,0x7B,0x7F,0xE7,0xF0,0x98,0x81,0x57,0x8A,0x6A,0x0B,0xE8,0x45,0x83 } },
+{ 16 , { 0x3F,0x3E,0x50,0xF5,0x78,0x2A,0x69,0x51,0x0B,0x7C,0x0B,0x8D,0x59,0x37,0x3D,0x32 } },
+{ 16 , { 0x3F,0x7F,0xE5,0x86,0x04,0x26,0x9F,0x1A,0xD3,0xFF,0x6D,0xC8,0xDA,0x84,0xE2,0x7D } },
+{ 16 , { 0x37,0xDD,0xC6,0x46,0x55,0x89,0x17,0xEC,0x46,0x19,0x04,0xC7,0x40,0xFC,0xC4,0xB8 } },
+{ 16 , { 0x3F,0x2B,0xD0,0x87,0xA2,0xD0,0x4E,0x5B,0x18,0x1E,0x9E,0xA4,0xDC,0xDC,0x4B,0xDB } },
+{ 16 , { 0x3F,0xB0,0x65,0x7A,0x06,0x2B,0x06,0xA6,0xD7,0xD6,0xEF,0x85,0xF5,0x1C,0x03,0xCB } },
+{ 16 , { 0x37,0x6E,0xED,0x47,0xCA,0x1C,0xCE,0x80,0xCD,0xE1,0x65,0x72,0xFD,0x2E,0x6A,0x22 } },
+{ 16 , { 0x37,0x74,0xEC,0x40,0x60,0x21,0x07,0x3E,0x4B,0xD7,0xA4,0x8A,0x9F,0x58,0x20,0x93 } },
+{ 16 , { 0x3F,0x67,0x42,0x72,0xA2,0x44,0xAE,0x8E,0xAF,0xED,0x5D,0x12,0xC2,0xF8,0x19,0x41 } },
+{ 16 , { 0x3F,0x73,0x5D,0x4E,0x6E,0x6E,0x7C,0x85,0x53,0x3C,0x51,0xC4,0x2C,0xDF,0xC9,0x9E } },
+{ 8 , { 0x07,0xBE,0x64,0xFD,0xDE,0xC7,0x55,0x3D } },
+{ 16 , { 0x37,0x25,0x2E,0xFE,0x40,0x17,0x39,0xE9,0xCB,0xEF,0xFA,0x10,0xE4,0x8F,0x89,0x93 } },
+{ 16 , { 0x37,0xBA,0x02,0x71,0xC5,0x9F,0xD5,0x5A,0xD6,0x5D,0xD8,0x5D,0x64,0xA3,0x5B,0x13 } },
+{ 16 , { 0x37,0x9F,0x56,0x01,0x34,0x4C,0x3F,0xFF,0xA9,0x52,0x50,0xFC,0xCB,0x0E,0x8C,0x5E } },
+{ 16 , { 0x37,0x1E,0x73,0x60,0x98,0x8D,0xE6,0xF3,0x61,0x6B,0x46,0x9A,0xCC,0xBB,0x42,0xFE } },
+{ 16 , { 0x3F,0x74,0xE8,0x95,0xFC,0x41,0x83,0xF9,0x54,0xB9,0x84,0xA1,0x50,0xBD,0xAC,0x3E } },
+{ 4 , { 0x43,0x75,0x11,0x56 } },
+{ 8 , { 0x0F,0xE7,0x5E,0xF6,0x1B,0x17,0xA4,0x6D } },
+{ 8 , { 0x07,0x2D,0x4B,0x5A,0x70,0x17,0x64,0x4A } },
+{ 8 , { 0x0F,0x7B,0xD6,0x45,0x78,0x71,0x63,0x89 } },
+{ 9 , { 0x38,0x32,0x27,0x43,0xD1,0x77,0x31,0x8A,0xC3 } },
+{ 8 , { 0x0F,0x98,0x8E,0x54,0xA7,0xFE,0xCB,0x4A } },
+{ 16 , { 0x37,0x4B,0x68,0x2E,0x12,0xEA,0x97,0x16,0xAA,0x17,0x3E,0x3D,0x04,0x9D,0xC6,0xAF } },
+{ 4 , { 0x43,0xDA,0x54,0xB2 } },
+{ 8 , { 0x07,0xC9,0x33,0x9C,0x84,0x38,0x1F,0x2A } },
+{ 16 , { 0x37,0x26,0x19,0x6C,0x45,0x0A,0x57,0x66,0xFA,0xCA,0x51,0x65,0x76,0xD5,0xCF,0xAF } },
+{ 16 , { 0x37,0xE2,0x57,0x91,0x6F,0x55,0x5A,0x22,0xD0,0x34,0xE2,0x4C,0xBC,0x45,0x47,0xAE } },
+{ 16 , { 0x3F,0xDC,0x23,0x6B,0x55,0x1C,0x37,0x25,0x0B,0x9D,0x8D,0x83,0x9C,0x76,0x40,0x8B } },
+{ 16 , { 0x3F,0x1B,0x62,0x2D,0x6F,0xC1,0x38,0x9B,0x61,0xB0,0x6A,0x94,0x48,0xF5,0x4F,0xE7 } },
+{ 8 , { 0x4F,0x4C,0x0E,0xB9,0x98,0xF4,0x34,0x75 } },
+{ 8 , { 0x07,0x1F,0x11,0xE3,0x35,0x04,0x9B,0x33 } },
+{ 16 , { 0x37,0xF1,0xDA,0x5F,0x1B,0xFC,0xA8,0xC7,0x8D,0x91,0x5C,0xE0,0x94,0x57,0x5D,0xA8 } },
+{ 7 , { 0x4E,0xBE,0x37,0x43,0x51,0x0B,0xB6 } },
+{ 8 , { 0x07,0x47,0x7C,0x89,0xFA,0xD8,0x64,0x9C } },
+{ 8 , { 0x4F,0xBA,0xC7,0xA6,0xCC,0x40,0xDC,0x23 } },
+{ 8 , { 0x07,0x99,0xD5,0xA3,0x98,0xF8,0xE4,0x97 } },
+{ 11 , { 0x32,0xB1,0xF5,0xFD,0xDD,0x4A,0x3C,0x3E,0x26,0x94,0xA2 } },
+{ 8 , { 0x0F,0xAB,0x57,0xA9,0x4B,0x2E,0x3B,0x51 } },
+{ 16 , { 0x37,0xCB,0xC0,0xE3,0x76,0xB2,0xEA,0x37,0xF8,0x56,0x21,0x61,0x34,0xC2,0x5E,0xA1 } },
+{ 16 , { 0x3F,0x04,0xE3,0xE5,0x12,0x30,0xBF,0xEE,0x85,0x1E,0xC4,0xF0,0x4D,0xF8,0x47,0x04 } },
+{ 16 , { 0x37,0xDF,0x00,0x45,0x85,0x6D,0xA8,0x8B,0x1C,0x13,0x5D,0x88,0x35,0x93,0xB4,0x36 } },
+{ 4 , { 0x4B,0x43,0xBC,0xE8 } },
+{ 8 , { 0x0F,0x39,0x6F,0x1C,0x54,0x84,0x24,0xA3 } },
+{ 8 , { 0x0F,0x4F,0xB1,0x72,0x84,0xEA,0x28,0x7C } },
+{ 16 , { 0x3F,0x0D,0x77,0x41,0x34,0x17,0x07,0x6C,0x26,0x6A,0x2D,0x29,0x1C,0xB8,0x48,0xE2 } },
+{ 16 , { 0x3F,0x8E,0x17,0x2F,0x07,0x1B,0xCD,0xA0,0x2D,0x41,0x62,0xFB,0x17,0x95,0xAE,0xD5 } },
+{ 12 , { 0x3B,0x67,0x4B,0xE8,0xC4,0x51,0x43,0x67,0x78,0x76,0xA7,0x4C } },
+{ 8 , { 0x07,0x45,0xE5,0x13,0xE5,0x8E,0xE7,0xC9 } },
+{ 8 , { 0x07,0xC3,0xA0,0xFF,0xF8,0x41,0x1E,0x18 } },
+{ 12 , { 0x33,0x7B,0x9D,0x83,0x03,0xCE,0x01,0x34,0x20,0xB1,0x1A,0x52 } },
+{ 8 , { 0x07,0x99,0xEF,0x12,0x8F,0xBD,0x9D,0x07 } },
+{ 16 , { 0x3F,0xEA,0x4C,0x31,0xA4,0x63,0x03,0x56,0x8F,0x54,0x2E,0xA8,0x0C,0x4F,0xCC,0xDE } },
+{ 6 , { 0x45,0xA5,0xC1,0x78,0x84,0x57 } },
+{ 8 , { 0x0F,0xAF,0x20,0x09,0x94,0x5B,0xA5,0xA4 } },
+{ 8 , { 0x07,0x1A,0xB3,0x29,0xEC,0x22,0xDE,0x2E } },
+{ 16 , { 0x37,0x57,0xDC,0xE1,0x55,0x60,0xB3,0xA4,0xF7,0xB2,0x67,0x7D,0x68,0x68,0x36,0xD9 } },
+{ 16 , { 0x3F,0x17,0xC5,0x6E,0x1C,0x04,0x07,0x66,0xD1,0xB1,0x19,0x1D,0x86,0xEF,0x71,0x1D } },
+{ 16 , { 0x37,0x81,0x03,0x4D,0x65,0xCB,0xF9,0xA4,0xDC,0x41,0x5E,0xE4,0x6C,0x0D,0x7B,0x5C } },
+{ 9 , { 0x30,0x93,0x48,0xB3,0xF3,0x3E,0x55,0x69,0x53 } },
+{ 8 , { 0x0F,0x69,0x4F,0x5B,0xEA,0xAC,0x6E,0x3C } },
+{ 8 , { 0x07,0xD0,0xB7,0xF1,0x24,0x35,0xDD,0x67 } },
+{ 8 , { 0x07,0x18,0x2A,0xAD,0x8C,0xFA,0x03,0xDC } },
+{ 16 , { 0x3F,0x04,0x69,0xBB,0x76,0x88,0xDD,0x21,0x2C,0x44,0x10,0xF2,0x61,0x69,0x5D,0x95 } },
+{ 8 , { 0x47,0x9E,0x97,0xEF,0x5C,0x38,0x14,0x71 } },
+{ 8 , { 0x07,0x6E,0x71,0xD3,0x2E,0x9F,0x0A,0xB8 } },
+{ 7 , { 0x46,0x40,0xE2,0x1D,0xE9,0x64,0x0C } },
+{ 8 , { 0x0F,0x07,0x7D,0xB9,0x30,0x1F,0x68,0x2B } },
+{ 10 , { 0x31,0x27,0x9A,0x81,0xF9,0x9E,0x4C,0x88,0x45,0xCA } },
+{ 8 , { 0x07,0xE1,0x80,0x0C,0xFF,0xC7,0x5A,0x94 } },
+{ 8 , { 0x07,0x90,0xFF,0xAD,0xD4,0x1A,0xD4,0xC4 } },
+{ 8 , { 0x07,0x73,0x77,0x9C,0xF6,0x4D,0x0C,0x3B } },
+{ 8 , { 0x07,0x94,0x55,0x99,0xEF,0x66,0x02,0x99 } },
+{ 4 , { 0x4B,0x6E,0x94,0x4F } },
+{ 8 , { 0x07,0xDC,0xB4,0x8A,0xF8,0x70,0x36,0x9A } },
+{ 12 , { 0x3B,0x1F,0x75,0xD9,0x18,0x19,0x72,0xC0,0x14,0x35,0x0D,0x63 } },
+{ 8 , { 0x07,0x24,0x00,0x3D,0xD9,0x4D,0xB8,0xBF } },
+{ 16 , { 0x3F,0x6D,0x17,0x40,0xE0,0xF1,0x37,0x40,0xCA,0xEA,0x9F,0x99,0x7A,0x84,0xD2,0x4C } },
+{ 16 , { 0x37,0x07,0x81,0xDA,0x54,0x0D,0x48,0x5B,0x8C,0xAE,0xD9,0x09,0x61,0xD3,0xA8,0xEB } },
+{ 16 , { 0x37,0xCB,0x6A,0xBA,0x6B,0x41,0xA9,0xA6,0xB8,0x84,0x38,0xAC,0x14,0xE9,0x38,0xC3 } },
+{ 16 , { 0x37,0xC8,0x0E,0x74,0x51,0x2A,0xBE,0x15,0x23,0xAA,0x5D,0x70,0x0A,0x73,0x3F,0x45 } },
+{ 3 , { 0x42,0xA8,0x4F } },
+{ 8 , { 0x0F,0x09,0xCA,0x0A,0x2A,0xAA,0x30,0x40 } },
+{ 16 , { 0x3F,0x0F,0x28,0xDB,0x52,0x2F,0xFF,0x0D,0x85,0x47,0xC6,0x3F,0x69,0xA6,0xCE,0xB1 } },
+{ 16 , { 0x37,0x0C,0x41,0x7A,0x1F,0x30,0x94,0x0F,0xC4,0x49,0x26,0x9D,0x76,0x01,0xB7,0x6B } },
+{ 16 , { 0x3F,0x77,0xBF,0xB5,0xD9,0xA8,0x25,0xD4,0x86,0x4F,0x59,0xBF,0xFC,0x26,0xF7,0x1C } },
+{ 16 , { 0x3F,0x5F,0xA7,0x5E,0x7A,0x64,0x64,0xD0,0x91,0x25,0xA1,0x09,0x9B,0xF6,0x7A,0xE6 } },
+{ 8 , { 0x07,0x3A,0x28,0x96,0xC2,0x04,0xD1,0xF2 } },
+{ 16 , { 0x3F,0x81,0xB8,0xE3,0x61,0x93,0x6B,0xA0,0xA4,0x6B,0x67,0x16,0x9B,0x48,0x47,0x16 } },
+{ 16 , { 0x3F,0xEC,0xD7,0x33,0xD1,0xFD,0xB2,0xC8,0x02,0x99,0x9E,0x8D,0x7F,0xD5,0x80,0xED } },
+{ 16 , { 0x3F,0x20,0x2B,0xB8,0x3F,0x14,0x49,0xA8,0xD1,0x8F,0xDC,0xD2,0xE2,0xD5,0xCD,0x66 } },
+{ 16 , { 0x3F,0x55,0x34,0xAC,0x06,0x82,0x9F,0x52,0xED,0x97,0x58,0x74,0xBF,0x43,0xAA,0xC4 } },
+{ 16 , { 0x37,0x2B,0x26,0xD6,0x5A,0x9A,0x44,0x48,0x85,0xEC,0x0C,0x1C,0xE7,0xEF,0xBC,0x8B } },
+{ 16 , { 0x37,0xE7,0x11,0x25,0x61,0x23,0x4B,0x52,0xF3,0x3A,0x28,0x80,0xD8,0xE8,0xB5,0x99 } },
+{ 16 , { 0x3F,0x47,0x09,0x81,0x6B,0x03,0x2F,0x31,0xEE,0xE7,0x29,0x83,0x59,0x8E,0x8F,0xC4 } },
+{ 16 , { 0x37,0x3A,0x49,0x01,0xFC,0x82,0x70,0x23,0x85,0x54,0xB5,0xC8,0x14,0xDD,0xCB,0x9F } },
+{ 8 , { 0x07,0xAA,0x71,0x3E,0x85,0xB1,0xF2,0x70 } },
+{ 16 , { 0x37,0xE4,0xC2,0x84,0x29,0xA0,0x0E,0xBA,0xB5,0x24,0x17,0x15,0x1C,0xFC,0xE9,0xBF } },
+{ 10 , { 0x31,0xBF,0xE0,0x96,0x80,0xC4,0xD0,0xFA,0x90,0x74 } },
+{ 8 , { 0x0F,0x8D,0x77,0x6B,0xEA,0x36,0xFB,0x6B } },
+{ 9 , { 0x30,0xD6,0x65,0xA7,0xC2,0x0C,0x1D,0x70,0x1D } },
+{ 8 , { 0x07,0x51,0x56,0x88,0x09,0xF0,0xD7,0xD1 } },
+{ 16 , { 0x37,0x90,0xED,0xFE,0x41,0x40,0x46,0x09,0x58,0x1A,0xC4,0x1D,0x63,0xA4,0xA6,0x99 } },
+{ 16 , { 0x37,0x85,0x59,0x7C,0xB8,0xBF,0x73,0xED,0xC6,0x49,0xE8,0x40,0x00,0x72,0xC2,0x48 } },
+{ 6 , { 0x4D,0xD4,0x76,0xA9,0x51,0x55 } },
+{ 8 , { 0x07,0x91,0x5A,0x5E,0x63,0x8A,0xB9,0x2F } },
+{ 4 , { 0x43,0x0B,0x2B,0x01 } },
+{ 8 , { 0x0F,0xDA,0x5B,0x0B,0x61,0xE1,0x6F,0x66 } },
+{ 8 , { 0x07,0x42,0xFC,0xCC,0xE9,0x45,0x8B,0xAB } },
+{ 8 , { 0x0F,0x7D,0x06,0xC2,0x9A,0x18,0x6D,0xCB } },
+{ 11 , { 0x32,0x95,0x91,0xFB,0xB3,0x5B,0xBA,0x51,0xC0,0xFE,0xB6 } },
+{ 8 , { 0x07,0x50,0x31,0xDF,0x9D,0xBF,0xC5,0x0F } },
+{ 8 , { 0x07,0xF9,0x0E,0x39,0x59,0x2B,0x7C,0x29 } },
+{ 8 , { 0x0F,0x60,0xB0,0x7F,0x9D,0xBA,0x01,0x05 } },
+{ 8 , { 0x07,0x54,0x13,0x94,0x52,0x73,0x20,0xD6 } },
+{ 8 , { 0x0F,0x1C,0xFE,0x06,0x83,0xE3,0xDA,0x4A } },
+{ 8 , { 0x07,0x3B,0xF0,0xEA,0x73,0x3A,0x03,0xD8 } },
+{ 8 , { 0x4F,0x1B,0x5E,0x98,0xB6,0xF1,0x56,0xFD } },
+{ 8 , { 0x0F,0xB5,0x9E,0xB8,0x64,0x8D,0xF1,0xE3 } },
+{ 16 , { 0x37,0xA4,0x1B,0xC6,0x25,0x7A,0x37,0x96,0xAD,0xB9,0x86,0xF5,0xEA,0xA0,0xA5,0x75 } },
+{ 4 , { 0x4B,0xA6,0x12,0xD8 } },
+{ 8 , { 0x0F,0x90,0x17,0xE0,0xCD,0x87,0xF4,0x12 } },
+{ 8 , { 0x05,0xF0,0x52,0x90,0xC0,0x22,0x86,0x99 } },
+{ 16 , { 0x3F,0x19,0x09,0xF0,0x5F,0xD6,0x67,0x91,0xA4,0x9C,0xED,0x16,0x41,0xA8,0xA0,0x9A } },
+{ 16 , { 0x37,0xDE,0x1D,0xF8,0xE8,0x18,0x09,0xC9,0x0C,0xA0,0x9F,0x66,0xF7,0x35,0x65,0x60 } },
+{ 16 , { 0x37,0x87,0x20,0xD8,0xED,0xAD,0xD1,0xBA,0x32,0x65,0x6E,0x1D,0x36,0xE9,0x60,0x1C } },
+{ 16 , { 0x37,0xBB,0xA9,0x41,0x2C,0x40,0x45,0x2F,0xE3,0x29,0xFD,0x22,0x2B,0xD1,0xCE,0x97 } },
+{ 16 , { 0x37,0xD9,0x30,0x80,0xBA,0xFF,0x49,0xE9,0xEC,0xEC,0x50,0x21,0xEF,0xDB,0x37,0x09 } },
+{ 16 , { 0x3F,0x62,0x55,0x5A,0xAF,0xD7,0x09,0x57,0x68,0x79,0x2E,0x6E,0x07,0x83,0x5C,0x9B } },
+{ 8 , { 0x0F,0x89,0x8C,0x01,0xCC,0xE0,0x2F,0x5E } },
+{ 8 , { 0x07,0x77,0x40,0xC2,0x80,0x5E,0x21,0x97 } },
+{ 14 , { 0x3D,0x32,0x15,0x19,0x82,0x74,0x86,0x09,0x09,0x1A,0xE1,0xFA,0xF2,0xF3 } },
+{ 8 , { 0x0F,0xD8,0x6F,0x0D,0x33,0xC4,0xF5,0x71 } },
+{ 8 , { 0x07,0x4E,0xC7,0xD1,0x4D,0x13,0xFC,0xB2 } },
+{ 16 , { 0x37,0x43,0x79,0x60,0xDE,0x22,0xD8,0x7C,0x4C,0x3A,0xE1,0x75,0x87,0x1D,0xC8,0xA6 } },
+{ 8 , { 0x05,0x6A,0xBF,0x90,0x2C,0xE3,0xFC,0x67 } },
+{ 5 , { 0x44,0xA3,0x03,0x37,0x9C } },
+{ 8 , { 0x0F,0xE8,0x1A,0x1B,0xB9,0x2D,0xDC,0xC0 } },
+{ 8 , { 0x0F,0xD8,0x9A,0xE1,0xCF,0x1C,0x47,0xBB } },
+{ 8 , { 0x05,0xF4,0x1E,0x2B,0xCF,0x5B,0xFB,0x7F } },
+{ 3 , { 0x42,0x55,0xEF } },
+{ 8 , { 0x0F,0xEF,0x60,0xBA,0x44,0x3F,0x95,0x3A } },
+{ 8 , { 0x0F,0x32,0x5E,0x44,0x04,0x53,0xC8,0xEC } },
+{ 8 , { 0x0F,0xC0,0xFC,0x1E,0xDF,0x17,0x7F,0xCF } },
+{ 8 , { 0x05,0x69,0xE2,0x31,0x8D,0x94,0x8C,0x25 } },
+{ 3 , { 0x4A,0x0E,0xFC } },
+{ 8 , { 0x07,0x93,0x01,0x15,0x0E,0x0B,0x93,0xC9 } },
+{ 8 , { 0x05,0x89,0x84,0x54,0xA6,0xFC,0x4E,0x2B } },
+{ 3 , { 0x4A,0x2D,0xE0 } },
+{ 8 , { 0x05,0x22,0x35,0xA9,0x02,0x66,0x9F,0xA7 } },
+{ 3 , { 0x42,0xD8,0x7B } },
+{ 8 , { 0x05,0x83,0xA9,0x25,0xBF,0x82,0xEA,0x5C } },
+{ 4 , { 0x43,0xE2,0x5A,0x4B } },
+{ 8 , { 0x0F,0x8D,0xAB,0xFB,0x18,0xC8,0x38,0xD7 } },
+{ 8 , { 0x05,0xFB,0xB9,0xBD,0x33,0x8F,0xB4,0xE2 } }
+};
+
+#define FIRMWARE_LINES_2_1b6 (sizeof(Si2148_FW_2_1b6)/(sizeof(firmware_struct)))
+#define RAM_CRC_2_1b6 0x9652
+#define Si2148_BYTES_PER_LINE 8
+
+unsigned char Si2148_L1_API_Patch(L1_Si2148_Context *api, int iNbBytes, unsigned char *pucDataBuffer)
+{
+    int i;
+	unsigned char res;
+	unsigned char rspByteBuffer[1];
+	unsigned char sndByteBuffer[20];
+	for(i=0;i<iNbBytes;i++)
+        sndByteBuffer[i]=pucDataBuffer[i];
+	WriteI2C(api->addr,iNbBytes,sndByteBuffer);
+	res = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (res != 0)
+		return 4;
+	return 0;
+}
+
+int Si2148_LoadFirmware_16(L1_Si2148_Context *api, firmware_struct fw_table[], int nbLines)
+{
+	int return_code;
+	int line;
+	return_code = 0;
+	// for each line in fw_table
+	for (line = 0; line < nbLines; line++)
+	{
+		if (fw_table[line].firmware_len > 0)  //don't download if length is 0 , e.g. dummy firmware
+		{
+			// send firmware_len bytes (up to 16) to Si2148
+			if ((return_code = Si2148_L1_API_Patch(api, fw_table[line].firmware_len, fw_table[line].firmware_table)) != 0)
+				return 0x08;
+		}
+	}
+	return 0;
+}
+
+int Si2148_LoadFirmware(L1_Si2148_Context *api, unsigned char fw_table[], int nbLines)
+{
+	int return_code;
+	int line;
+	return_code = 0;
+	// for each line in fw_table
+	for (line = 0; line < nbLines; line++)
+	{
+		// send Si2148_BYTES_PER_LINE fw bytes to Si2148
+		if ((return_code = Si2148_L1_API_Patch(api, Si2148_BYTES_PER_LINE, fw_table + Si2148_BYTES_PER_LINE*line)) != 0)
+			return 0x08;
+	}
+	return 0;
+}
+
+unsigned char Si2148_L1_EXIT_BOOTLOADER(L1_Si2148_Context *api,unsigned char   func,unsigned char   ctsien)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[1];
+	api->rsp->exit_bootloader.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_EXIT_BOOTLOADER_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( func   & Si2148_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2148_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+										( ctsien & Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2148_StartFirmware(L1_Si2148_Context *api)
+{
+	if (Si2148_L1_EXIT_BOOTLOADER(api, Si2148_EXIT_BOOTLOADER_CMD_FUNC_TUNER, Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != 0)
+		return 0x0a;
+	return 0;
+}
+
+int Si2148_PowerUpWithPatch(L1_Si2148_Context *api)
+{
+	int return_code;
+	return_code = 0;
+	// always wait for CTS prior to POWER_UP command
+	if((return_code=Si2148_pollForCTS(api))!=0)
+		return return_code;
+	if ((return_code = Si2148_L1_POWER_UP (api,Si2148_POWER_UP_CMD_SUBCODE_CODE,Si2148_POWER_UP_CMD_CLOCK_MODE_XTAL,Si2148_POWER_UP_CMD_EN_XOUT_DIS_XOUT,Si2148_POWER_UP_CMD_PD_LDO_LDO_POWER_UP,Si2148_POWER_UP_CMD_RESERVED2_RESERVED,Si2148_POWER_UP_CMD_RESERVED3_RESERVED,Si2148_POWER_UP_CMD_RESERVED4_RESERVED,Si2148_POWER_UP_CMD_RESERVED5_RESERVED,Si2148_POWER_UP_CMD_RESERVED6_RESERVED,Si2148_POWER_UP_CMD_RESERVED7_RESERVED,Si2148_POWER_UP_CMD_RESET_RESET,Si2148_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,Si2148_POWER_UP_CMD_RESERVED8_RESERVED,Si2148_POWER_UP_CMD_FUNC_BOOTLOADER,Si2148_POWER_UP_CMD_CTSIEN_DISABLE,Si2148_POWER_UP_CMD_WAKE_UP_WAKE_UP)) != 0)
+		return return_code;
+	// Get the Part Info from the chip.   This command is only valid in Bootloader mode
+	if ((return_code = Si2148_L1_PART_INFO(api)) != 0)
+		return return_code;
+	// Load the Firmware
+	if (api->rsp->part_info.romid == 0x32)
+	{
+		// Load the Firmware
+		if ((return_code = Si2148_LoadFirmware(api, Si2148_FW_0_Eb15, FIRMWARE_LINES_0_Eb15)) != 0)
+			return return_code;
+	}
+	else if (api->rsp->part_info.romid == 0x33) // if Si2148-A20 part load firmware patch (currently a dummy patch , 20bx)
+	{
+		// This dummy patch (20bx) will skip the loadFirmware function and boot from NVM only. When a new patch is available for the Si2148-A20, include the patch file and replace the firmware array and size in the function below
+		if ((return_code = Si2148_LoadFirmware_16(api, Si2148_FW_2_1b6, FIRMWARE_LINES_2_1b6)) != 0)
+			return return_code;
+	}
+	else
+		return 0x0c;
+	//Start the Firmware
+	if ((return_code = Si2148_StartFirmware(api)) != 0)
+		return return_code;
+	return 0;
+}
+
+void Si2146_setupCOMMONDefaults(L1_Si2146_Context *api)
+{
+	api->prop->crystal_trim.xo_cap                      =     8;
+	api->prop->master_ien.tunien                        = Si2146_MASTER_IEN_PROP_TUNIEN_OFF;
+	api->prop->master_ien.atvien                        = Si2146_MASTER_IEN_PROP_ATVIEN_OFF;
+	api->prop->master_ien.dtvien                        = Si2146_MASTER_IEN_PROP_DTVIEN_OFF;
+	api->prop->master_ien.errien                        = Si2146_MASTER_IEN_PROP_ERRIEN_OFF;
+	api->prop->master_ien.ctsien                        = Si2146_MASTER_IEN_PROP_CTSIEN_OFF;
+};
+
+void Si2146_setupDTVDefaults(L1_Si2146_Context *api)
+{
+	api->prop->dtv_agc_speed.if_agc_speed               = Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+	api->prop->dtv_agc_speed.agc_decim                  = Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+	api->prop->dtv_config_if_port.dtv_out_type          = Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1;
+	api->prop->dtv_config_if_port.dtv_agc_source        =     0;
+	api->prop->dtv_ext_agc.min_10mv                     =    50;
+	api->prop->dtv_ext_agc.max_10mv                     =   200;
+	api->prop->dtv_ien.chlien                           = Si2146_DTV_IEN_PROP_CHLIEN_ENABLE;
+	api->prop->dtv_initial_agc_speed.if_agc_speed       = Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+	api->prop->dtv_initial_agc_speed.agc_decim          = Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;
+	api->prop->dtv_initial_agc_speed_period.period      =     0;
+	api->prop->dtv_int_sense.chlnegen                   = Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+	api->prop->dtv_int_sense.chlposen                   = Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+	api->prop->dtv_lif_freq.offset                      =  5000;
+	api->prop->dtv_lif_out.offset                       =   148;
+	api->prop->dtv_lif_out.amp                          =    27;
+	api->prop->dtv_mode.bw                              = Si2146_DTV_MODE_PROP_BW_BW_8MHZ;
+	api->prop->dtv_mode.modulation                      = Si2146_DTV_MODE_PROP_MODULATION_DVBT;
+	api->prop->dtv_mode.invert_spectrum                 =     0;
+	api->prop->dtv_rf_top.dtv_rf_top                    = Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO;
+	api->prop->dtv_rsq_rssi_threshold.lo                =   -80;
+	api->prop->dtv_rsq_rssi_threshold.hi                =     0;
+};
+
+void Si2146_setupTUNERDefaults(L1_Si2146_Context *api)
+{
+	api->prop->tuner_blocked_vco.vco_code               = 0x8000; /* (default 0x8000) */
+
+	api->prop->tuner_ien.tcien                          = Si2146_TUNER_IEN_PROP_TCIEN_ENABLE    ; /* (default 'DISABLE') */
+	api->prop->tuner_ien.rssilien                       = Si2146_TUNER_IEN_PROP_RSSILIEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_ien.rssihien                       = Si2146_TUNER_IEN_PROP_RSSIHIEN_DISABLE ; /* (default 'DISABLE') */
+
+	api->prop->tuner_int_sense.tcnegen                  = Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE    ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.rssilnegen               = Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.rssihnegen               = Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.tcposen                  = Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE     ; /* (default 'ENABLE') */
+	api->prop->tuner_int_sense.rssilposen               = Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE  ; /* (default 'ENABLE') */
+	api->prop->tuner_int_sense.rssihposen               = Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+	api->prop->tuner_lo_injection.band_1                = Si2146_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE ; /* (default 'HIGH_SIDE') */
+	api->prop->tuner_lo_injection.band_2                = Si2146_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+	api->prop->tuner_lo_injection.band_3                = Si2146_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+	api->prop->tuner_lo_injection.band_4                = Si2146_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+	api->prop->tuner_lo_injection.band_5                = Si2146_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+};
+
+void Si2146_setupAllDefaults(L1_Si2146_Context *api)
+{
+	Si2146_setupCOMMONDefaults    (api);
+	Si2146_setupDTVDefaults       (api);
+	Si2146_setupTUNERDefaults     (api);
+};
+
+void Si2148_setupATVDefaults        (L1_Si2148_Context *api)
+{
+	api->prop->atv_artificial_snow.gain             = Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO   ; /* (default 'AUTO') */
+	api->prop->atv_artificial_snow.offset           =     0; /* (default     0) */
+
+	api->prop->atv_ext_agc.min_10mv                 =    50; /* (default    50) */
+	api->prop->atv_ext_agc.max_10mv                 =   200; /* (default   200) */
+
+	api->prop->atv_lif_freq.offset                  =  5000; /* (default  5000) */
+
+	api->prop->atv_lif_out.offset                   =   148; /* (default   148) */
+	api->prop->atv_lif_out.amp                      =   100; /* (default   100) */
+
+	api->prop->atv_pga_target.pga_target            =     0; /* (default     0) */
+	api->prop->atv_pga_target.override_enable       = Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+
+};
+
+void Si2148_setupCOMMONDefaults     (L1_Si2148_Context *api)
+{
+	api->prop->crystal_trim.xo_cap                  = Si2148_CRYSTAL_TRIM_PROP_XO_CAP_8 ; /* (default '8') */
+
+	api->prop->master_ien.tunien                    = Si2148_MASTER_IEN_PROP_TUNIEN_OFF ; /* (default 'OFF') */
+	api->prop->master_ien.atvien                    = Si2148_MASTER_IEN_PROP_ATVIEN_OFF ; /* (default 'OFF') */
+	api->prop->master_ien.dtvien                    = Si2148_MASTER_IEN_PROP_DTVIEN_OFF ; /* (default 'OFF') */
+	api->prop->master_ien.errien                    = Si2148_MASTER_IEN_PROP_ERRIEN_OFF ; /* (default 'OFF') */
+	api->prop->master_ien.ctsien                    = Si2148_MASTER_IEN_PROP_CTSIEN_OFF ; /* (default 'OFF') */
+};
+
+void Si2148_setupDTVDefaults        (L1_Si2148_Context *api)
+{
+	api->prop->dtv_agc_freeze_input.level           = Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW  ; /* (default 'LOW') */
+	api->prop->dtv_agc_freeze_input.pin             = Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   ; /* (default 'NONE') */
+
+	api->prop->dtv_agc_speed.if_agc_speed           = Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+	api->prop->dtv_agc_speed.agc_decim              = Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+	api->prop->dtv_config_if_port.dtv_out_type      = Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1   ; /* (default 'LIF_IF1') */
+	api->prop->dtv_config_if_port.dtv_agc_source    =     0; /* (default     0) */
+
+	api->prop->dtv_ext_agc.min_10mv                 =    50; /* (default    50) */
+	api->prop->dtv_ext_agc.max_10mv                 =   200; /* (default   200) */
+
+	api->prop->dtv_filter_select.filter             = Si2148_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1 ; /* (default 'CUSTOM1') */
+
+	api->prop->dtv_ien.chlien                       = Si2148_DTV_IEN_PROP_CHLIEN_ENABLE ; /* (default 'ENABLE') */
+
+	api->prop->dtv_initial_agc_speed.if_agc_speed   = Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+	api->prop->dtv_initial_agc_speed.agc_decim      = Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+	api->prop->dtv_initial_agc_speed_period.period  =     0; /* (default     0) */
+
+	api->prop->dtv_internal_zif.atsc                = Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_LIF   ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.qam_us              = Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.dvbt                = Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_LIF   ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.dvbc                = Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_LIF   ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.isdbt               = Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.isdbc               = Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  ; /* (default 'LIF') */
+	api->prop->dtv_internal_zif.dtmb                = Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_LIF   ; /* (default 'LIF') */
+
+	api->prop->dtv_int_sense.chlnegen               = Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->dtv_int_sense.chlposen               = Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+	api->prop->dtv_lif_freq.offset                  =  5000; /* (default  5000) */
+
+	api->prop->dtv_lif_out.offset                   =   148; /* (default   148) */
+	api->prop->dtv_lif_out.amp                      =    27; /* (default    27) */
+
+	api->prop->dtv_mode.bw                          = Si2148_DTV_MODE_PROP_BW_BW_8MHZ              ; /* (default 'BW_8MHZ') */
+	api->prop->dtv_mode.modulation                  = Si2148_DTV_MODE_PROP_MODULATION_DVBT         ; /* (default 'DVBT') */
+	api->prop->dtv_mode.invert_spectrum             =     0; /* (default     0) */
+
+	api->prop->dtv_pga_limits.min                   =    -1; /* (default    -1) */
+	api->prop->dtv_pga_limits.max                   =    -1; /* (default    -1) */
+
+	api->prop->dtv_pga_target.pga_target            =     0; /* (default     0) */
+	api->prop->dtv_pga_target.override_enable       = Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+
+	api->prop->dtv_rf_top.dtv_rf_top                = Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO ; /* (default 'AUTO') */
+
+	api->prop->dtv_rsq_rssi_threshold.lo            =   -80; /* (default   -80) */
+	api->prop->dtv_rsq_rssi_threshold.hi            =     0; /* (default     0) */
+
+	api->prop->dtv_zif_dc_canceller_bw.bandwidth    = Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT ; /* (default 'DEFAULT') */
+};
+
+void Si2148_setupTUNERDefaults      (L1_Si2148_Context *api)
+{
+	api->prop->tuner_blocked_vco.vco_code           = 0x8000; /* (default 0x8000) */
+
+	api->prop->tuner_ien.tcien                      = Si2148_TUNER_IEN_PROP_TCIEN_ENABLE     ; /* (default 'ENABLE') */
+	api->prop->tuner_ien.rssilien                   = Si2148_TUNER_IEN_PROP_RSSILIEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_ien.rssihien                   = Si2148_TUNER_IEN_PROP_RSSIHIEN_DISABLE ; /* (default 'DISABLE') */
+
+	api->prop->tuner_int_sense.tcnegen              = Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE    ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.rssilnegen           = Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.rssihnegen           = Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE ; /* (default 'DISABLE') */
+	api->prop->tuner_int_sense.tcposen              = Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE     ; /* (default 'ENABLE') */
+	api->prop->tuner_int_sense.rssilposen           = Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE  ; /* (default 'ENABLE') */
+	api->prop->tuner_int_sense.rssihposen           = Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+	api->prop->tuner_lo_injection.band_1            = Si2148_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE ; /* (default 'HIGH_SIDE') */
+	api->prop->tuner_lo_injection.band_2            = Si2148_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+	api->prop->tuner_lo_injection.band_3            = Si2148_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+
+	api->prop->tuner_return_loss.config             = Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_127         ; /* (default '127') */
+	api->prop->tuner_return_loss.mode               = Si2148_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL   ; /* (default 'TERRESTRIAL') */
+};
+
+void Si2148_setupAllDefaults(L1_Si2148_Context *api)
+{
+	Si2148_setupATVDefaults       (api);
+	Si2148_setupCOMMONDefaults    (api);
+	Si2148_setupDTVDefaults       (api);
+	Si2148_setupTUNERDefaults     (api);
+};
+
+int Si2146_downloadCOMMONProperties(L1_Si2146_Context *api)
+{
+#ifdef    Si2146_CRYSTAL_TRIM_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_CRYSTAL_TRIM_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2146_CRYSTAL_TRIM_PROP */
+#ifdef    Si2146_MASTER_IEN_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_MASTER_IEN_PROP_CODE                  ) != 0) {return 3;}
+#endif /* Si2146_MASTER_IEN_PROP */
+return 0;
+};
+
+int Si2146_downloadDTVProperties(L1_Si2146_Context *api)
+{
+#ifdef    Si2146_DTV_AGC_FREEZE_INPUT_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_AGC_FREEZE_INPUT_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2146_DTV_AGC_FREEZE_INPUT_PROP */
+#ifdef    Si2146_DTV_AGC_SPEED_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_AGC_SPEED_PROP_CODE               ) != 0) {return 3;}
+#endif /* Si2146_DTV_AGC_SPEED_PROP */
+#ifdef    Si2146_DTV_CONFIG_IF_PORT_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_CONFIG_IF_PORT_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2146_DTV_CONFIG_IF_PORT_PROP */
+#ifdef    Si2146_DTV_EXT_AGC_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_EXT_AGC_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2146_DTV_EXT_AGC_PROP */
+#ifdef    Si2146_DTV_IEN_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_IEN_PROP_CODE                     ) != 0) {return 3;}
+#endif /* Si2146_DTV_IEN_PROP */
+#ifdef    Si2146_DTV_INITIAL_AGC_SPEED_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_INITIAL_AGC_SPEED_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2146_DTV_INITIAL_AGC_SPEED_PROP */
+#ifdef    Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE) != 0) {return 3;}
+#endif /* Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+#ifdef    Si2146_DTV_INT_SENSE_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_INT_SENSE_PROP_CODE               ) != 0) {return 3;}
+#endif /* Si2146_DTV_INT_SENSE_PROP */
+#ifdef    Si2146_DTV_LIF_FREQ_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_LIF_FREQ_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2146_DTV_LIF_FREQ_PROP */
+#ifdef    Si2146_DTV_LIF_OUT_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_LIF_OUT_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2146_DTV_LIF_OUT_PROP */
+#ifdef    Si2146_DTV_MODE_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_MODE_PROP_CODE                    ) != 0) {return 3;}
+#endif /* Si2146_DTV_MODE_PROP */
+#ifdef    Si2146_DTV_RF_TOP_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_RF_TOP_PROP_CODE                  ) != 0) {return 3;}
+#endif /* Si2146_DTV_RF_TOP_PROP */
+#ifdef    Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE      ) != 0) {return 3;}
+#endif /* Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP */
+return 0;
+};
+
+int Si2146_downloadTUNERProperties(L1_Si2146_Context *api)
+{
+#ifdef    Si2146_TUNER_BLOCKED_VCO_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_TUNER_BLOCKED_VCO_PROP_CODE           ) != 0) {return 3;}
+#endif /* Si2146_TUNER_BLOCKED_VCO_PROP */
+#ifdef    Si2146_TUNER_IEN_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_TUNER_IEN_PROP_CODE                   ) != 0) {return 3;}
+#endif /* Si2146_TUNER_IEN_PROP */
+#ifdef    Si2146_TUNER_INT_SENSE_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_TUNER_INT_SENSE_PROP_CODE             ) != 0) {return 3;}
+#endif /* Si2146_TUNER_INT_SENSE_PROP */
+#ifdef    Si2146_TUNER_LO_INJECTION_PROP
+  if (Si2146_L1_SetProperty2(api, Si2146_TUNER_LO_INJECTION_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2146_TUNER_LO_INJECTION_PROP */
+return 0;
+};
+
+int  Si2148_downloadATVProperties(L1_Si2148_Context *api)
+{
+#ifdef    Si2148_ATV_ARTIFICIAL_SNOW_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_ATV_ARTIFICIAL_SNOW_PROP_CODE         ) != 0) {return 3;}
+#endif /* Si2148_ATV_ARTIFICIAL_SNOW_PROP */
+#ifdef    Si2148_ATV_EXT_AGC_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_ATV_EXT_AGC_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2148_ATV_EXT_AGC_PROP */
+#ifdef    Si2148_ATV_LIF_FREQ_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_ATV_LIF_FREQ_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2148_ATV_LIF_FREQ_PROP */
+#ifdef    Si2148_ATV_LIF_OUT_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_ATV_LIF_OUT_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2148_ATV_LIF_OUT_PROP */
+#ifdef    Si2148_ATV_PGA_TARGET_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_ATV_PGA_TARGET_PROP_CODE              ) != 0) {return 3;}
+#endif /* Si2148_ATV_PGA_TARGET_PROP */
+return 0;
+};
+
+int  Si2148_downloadCOMMONProperties(L1_Si2148_Context *api)
+{
+#ifdef    Si2148_CRYSTAL_TRIM_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_CRYSTAL_TRIM_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2148_CRYSTAL_TRIM_PROP */
+#ifdef    Si2148_MASTER_IEN_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_MASTER_IEN_PROP_CODE                  ) != 0) {return 3;}
+#endif /* Si2148_MASTER_IEN_PROP */
+return 0;
+};
+
+int  Si2148_downloadDTVProperties(L1_Si2148_Context *api)
+{
+#ifdef    Si2148_DTV_AGC_FREEZE_INPUT_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_AGC_FREEZE_INPUT_PROP_CODE        ) != 0) {return 3;}
+#endif /* Si2148_DTV_AGC_FREEZE_INPUT_PROP */
+#ifdef    Si2148_DTV_AGC_SPEED_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_AGC_SPEED_PROP_CODE               ) != 0) {return 3;}
+#endif /* Si2148_DTV_AGC_SPEED_PROP */
+#ifdef    Si2148_DTV_CONFIG_IF_PORT_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_CONFIG_IF_PORT_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2148_DTV_CONFIG_IF_PORT_PROP */
+#ifdef    Si2148_DTV_EXT_AGC_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_EXT_AGC_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2148_DTV_EXT_AGC_PROP */
+#ifdef    Si2148_DTV_FILTER_SELECT_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_FILTER_SELECT_PROP_CODE           ) != 0) {return 3;}
+#endif /* Si2148_DTV_FILTER_SELECT_PROP */
+#ifdef    Si2148_DTV_IEN_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_IEN_PROP_CODE                     ) != 0) {return 3;}
+#endif /* Si2148_DTV_IEN_PROP */
+#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_INITIAL_AGC_SPEED_PROP_CODE       ) != 0) {return 3;}
+#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PROP */
+#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE) != 0) {return 3;}
+#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+#ifdef    Si2148_DTV_INTERNAL_ZIF_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_INTERNAL_ZIF_PROP_CODE            ) != 0) {return 3;}
+#endif /* Si2148_DTV_INTERNAL_ZIF_PROP */
+#ifdef    Si2148_DTV_INT_SENSE_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_INT_SENSE_PROP_CODE               ) != 0) {return 3;}
+#endif /* Si2148_DTV_INT_SENSE_PROP */
+#ifdef    Si2148_DTV_LIF_FREQ_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_LIF_FREQ_PROP_CODE                ) != 0) {return 3;}
+#endif /* Si2148_DTV_LIF_FREQ_PROP */
+#ifdef    Si2148_DTV_LIF_OUT_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_LIF_OUT_PROP_CODE                 ) != 0) {return 3;}
+#endif /* Si2148_DTV_LIF_OUT_PROP */
+#ifdef    Si2148_DTV_MODE_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_MODE_PROP_CODE                    ) != 0) {return 3;}
+#endif /* Si2148_DTV_MODE_PROP */
+#ifdef    Si2148_DTV_PGA_LIMITS_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_PGA_LIMITS_PROP_CODE              ) != 0) {return 3;}
+#endif /* Si2148_DTV_PGA_LIMITS_PROP */
+#ifdef    Si2148_DTV_PGA_TARGET_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_PGA_TARGET_PROP_CODE              ) != 0) {return 3;}
+#endif /* Si2148_DTV_PGA_TARGET_PROP */
+#ifdef    Si2148_DTV_RF_TOP_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_RF_TOP_PROP_CODE                  ) != 0) {return 3;}
+#endif /* Si2148_DTV_RF_TOP_PROP */
+#ifdef    Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE      ) != 0) {return 3;}
+#endif /* Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef    Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE     ) != 0) {return 3;}
+#endif /* Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP */
+return 0;
+};
+
+int  Si2148_downloadTUNERProperties(L1_Si2148_Context *api)
+{
+#ifdef    Si2148_TUNER_BLOCKED_VCO_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_TUNER_BLOCKED_VCO_PROP_CODE           ) != 0) {return 3;}
+#endif /* Si2148_TUNER_BLOCKED_VCO_PROP */
+#ifdef    Si2148_TUNER_IEN_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_TUNER_IEN_PROP_CODE                   ) != 0) {return 3;}
+#endif /* Si2148_TUNER_IEN_PROP */
+#ifdef    Si2148_TUNER_INT_SENSE_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_TUNER_INT_SENSE_PROP_CODE             ) != 0) {return 3;}
+#endif /* Si2148_TUNER_INT_SENSE_PROP */
+#ifdef    Si2148_TUNER_LO_INJECTION_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_TUNER_LO_INJECTION_PROP_CODE          ) != 0) {return 3;}
+#endif /* Si2148_TUNER_LO_INJECTION_PROP */
+#ifdef    Si2148_TUNER_RETURN_LOSS_PROP
+  if (Si2148_L1_SetProperty2(api, Si2148_TUNER_RETURN_LOSS_PROP_CODE           ) != 0) {return 3;}
+#endif /* Si2148_TUNER_RETURN_LOSS_PROP */
+return 0;
+};
+
+int Si2146_downloadAllProperties       (L1_Si2146_Context *api)
+{
+	Si2146_downloadCOMMONProperties    (api);
+	Si2146_downloadDTVProperties       (api);
+	Si2146_downloadTUNERProperties     (api);
+	return 0;
+};
+
+int Si2148_downloadAllProperties       (L1_Si2148_Context *api)
+{
+	Si2148_downloadATVProperties       (api);
+	Si2148_downloadCOMMONProperties    (api);
+	Si2148_downloadDTVProperties       (api);
+	Si2148_downloadTUNERProperties     (api);
+	return 0;
+};
+
+int Si2146_Configure(L1_Si2146_Context *api)
+{
+	int return_code;
+	return_code = 0;
+	/* Set All Properties startup configuration */
+	Si2146_setupAllDefaults     (api);
+	Si2146_downloadAllProperties(api);
+	return return_code;
+}
+
+int Si2148_Configure(L1_Si2148_Context *api)
+{
+	int return_code;
+	return_code = 0;
+	// Set All Properties startup configuration
+	Si2148_setupAllDefaults     (api);
+	Si2148_downloadAllProperties(api);
+	return return_code;
+}
+
+int Si2146_Init(L1_Si2146_Context *api)
+{
+	int return_code;
+	if ((return_code = Si2146_PowerUpWithPatch(api)) != 0)
+		return return_code;
+	// At this point, FW is loaded and started.
+	Si2146_Configure(api);
+	return 0;
+}
+
+int Si2148_Init(L1_Si2148_Context *api)
+{
+	int return_code;
+	if((return_code=Si2148_PowerUpWithPatch(api))!=0)
+		return return_code;
+	Si2148_Configure(api);
+	return 0;
+}
+
+unsigned char Si2146_L1_CONFIG_PINS(L1_Si2146_Context *api,unsigned char   gpio1_mode,unsigned char   gpio1_read,unsigned char   gpio2_mode,unsigned char   gpio2_read,unsigned char   gpio3_mode,unsigned char   gpio3_read,unsigned char   bclk1_mode,unsigned char   bclk1_read,unsigned char   xout_mode)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[6];
+	unsigned char rspByteBuffer[6];
+	api->rsp->config_pins.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_CONFIG_PINS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( gpio1_mode & Si2146_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+										 ( gpio1_read & Si2146_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+	cmdByteBuffer[2] = (unsigned char) ( ( gpio2_mode & Si2146_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+										 ( gpio2_read & Si2146_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+	cmdByteBuffer[3] = (unsigned char) ( ( gpio3_mode & Si2146_CONFIG_PINS_CMD_GPIO3_MODE_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO3_MODE_LSB|
+										 ( gpio3_read & Si2146_CONFIG_PINS_CMD_GPIO3_READ_MASK ) << Si2146_CONFIG_PINS_CMD_GPIO3_READ_LSB);
+	cmdByteBuffer[4] = (unsigned char) ( ( bclk1_mode & Si2146_CONFIG_PINS_CMD_BCLK1_MODE_MASK ) << Si2146_CONFIG_PINS_CMD_BCLK1_MODE_LSB|
+										 ( bclk1_read & Si2146_CONFIG_PINS_CMD_BCLK1_READ_MASK ) << Si2146_CONFIG_PINS_CMD_BCLK1_READ_LSB);
+	cmdByteBuffer[5] = (unsigned char) ( ( xout_mode  & Si2146_CONFIG_PINS_CMD_XOUT_MODE_MASK  ) << Si2146_CONFIG_PINS_CMD_XOUT_MODE_LSB );
+	WriteI2C(api->addr,6,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 6, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->config_pins.gpio1_mode  =   (( ( (rspByteBuffer[1]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+	api->rsp->config_pins.gpio1_state =   (( ( (rspByteBuffer[1]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+	api->rsp->config_pins.gpio2_mode  =   (( ( (rspByteBuffer[2]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB  ) & Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK  );
+	api->rsp->config_pins.gpio2_state =   (( ( (rspByteBuffer[2]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB ) & Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK );
+	api->rsp->config_pins.gpio3_mode  =   (( ( (rspByteBuffer[3]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB  ) & Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK  );
+	api->rsp->config_pins.gpio3_state =   (( ( (rspByteBuffer[3]  )) >> Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB ) & Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK );
+	api->rsp->config_pins.bclk1_mode  =   (( ( (rspByteBuffer[4]  )) >> Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB  ) & Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK  );
+	api->rsp->config_pins.bclk1_state =   (( ( (rspByteBuffer[4]  )) >> Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB ) & Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK );
+	api->rsp->config_pins.xout_mode   =   (( ( (rspByteBuffer[5]  )) >> Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB   ) & Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK   );
+	return 0;
+}
+
+unsigned char Si2148_L1_CONFIG_CLOCKS(L1_Si2148_Context *api,unsigned char   subcode,unsigned char   clock_mode,unsigned char   en_xout)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[3];
+	unsigned char rspByteBuffer[1];
+	api->rsp->config_clocks.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_CONFIG_CLOCKS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2148_CONFIG_CLOCKS_CMD_SUBCODE_MASK    ) << Si2148_CONFIG_CLOCKS_CMD_SUBCODE_LSB   );
+	cmdByteBuffer[2] = (unsigned char) ( ( clock_mode & Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK ) << Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB|
+										( en_xout    & Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_MASK    ) << Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_LSB   );
+	WriteI2C(api->addr,3,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2146_ClockOff(L1_Si2146_Context *Si2146)
+{
+	int return_code;
+	if ((return_code = Si2146_L1_CONFIG_PINS (Si2146,Si2146_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,Si2146_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_XOUT_MODE_DISABLE)) != 0)
+		return return_code;
+	return 0;
+}
+
+int Si2148_XoutOff(L1_Si2148_Context *api)
+{
+	int return_code;
+	if ((return_code = Si2148_L1_CONFIG_CLOCKS(api,Si2148_CONFIG_CLOCKS_CMD_SUBCODE_CODE,Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT)) != 0)
+		return return_code;
+	return 0;
+}
+
+unsigned char Si2146_L1_STANDBY(L1_Si2146_Context *api)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[1];
+	unsigned char rspByteBuffer[1];
+	api->rsp->standby.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_STANDBY_CMD;
+	WriteI2C(api->addr,1,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2148_L1_STANDBY(L1_Si2148_Context *api,unsigned char type)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[1];
+	api->rsp->standby.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_STANDBY_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( type & Si2148_STANDBY_CMD_TYPE_MASK ) << Si2148_STANDBY_CMD_TYPE_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+int Si2146_ClockOn(L1_Si2146_Context *Si2146)
+{
+	int return_code;
+	if ((return_code = Si2146_L1_CONFIG_PINS (Si2146,Si2146_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,Si2146_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_BCLK1_MODE_XOUT,Si2146_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,Si2146_CONFIG_PINS_CMD_XOUT_MODE_DISABLE)) != 0)
+		return return_code;
+	return 0;
+}
+
+int Si2148_XoutOn(L1_Si2148_Context *api)
+{
+	int return_code;
+	if ((return_code = Si2148_L1_CONFIG_CLOCKS(api,Si2148_CONFIG_CLOCKS_CMD_SUBCODE_CODE,Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT)) != 0)
+		return return_code;
+	return 0;
+}
+
+//Yann 2146/2148
+#if SiTuner==2146
+#define TER_TUNER_INIT(api)           Si2146_Init(api)
+#define TER_TUNER_CLOCK_OFF(api)      Si2146_ClockOff(api)
+#define TER_TUNER_CLOCK_ON(api)       Si2146_ClockOn(api)
+#define TER_TUNER_STANDBY(api)        Si2146_L1_STANDBY(api)
+#define TER_TUNER_WAKEUP(api)         Si2146_pollForCTS(api)
+#else
+#define TER_TUNER_INIT(api)           Si2148_Init(api)
+#define TER_TUNER_CLOCK_OFF(api)      Si2148_XoutOff(api)
+#define TER_TUNER_CLOCK_ON(api)       Si2148_XoutOn(api)
+#define TER_TUNER_STANDBY(api)        Si2148_L1_STANDBY(api,Si2148_STANDBY_CMD_TYPE_MIN)
+#define TER_TUNER_WAKEUP(api)         Si2148_pollForCTS(api)
+#endif
+unsigned char Si2168_L2_Set_Invert_Spectrum(Si2168_L2_Context *front_end)
+{
+	unsigned char inversion;
+	if (front_end->demod->media == Si2168_TERRESTRIAL)
+		inversion = Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+	return inversion;
+}
+
+int Si2168_L2_switch_to_standard(Si2168_L2_Context *front_end,int new_standard,unsigned char force_full_init)
+{
+	// previous state flags
+	int dtv_demod_already_used = 0;
+	int ter_tuner_already_used = 0;
+	int ter_clock_already_used = 0;
+	// new state flags
+	int dtv_demod_needed       = 0;
+	int ter_tuner_needed       = 0;
+	int ter_clock_needed       = 0;
+	int dtv_demod_sleep_request= 0;
+	int res;
+	// In this function is called for the first time, force a full init
+	if (front_end->first_init_done == 0)
+		force_full_init = 1;
+	/* ------------------------------------------------------------ */
+	/* Set Previous Flags                                           */
+	/* Setting flags representing the previous state                */
+	/* NB: Any value not matching a known standard will init as ATV */
+	/* Logic applied:                                               */
+	/*  dtv demod was used for TERRESTRIAL and SATELLITE reception  */
+	/*  ter tuner was used for TERRESTRIAL reception                */
+	/*   and for SATELLITE reception if it is the SAT clock source  */
+	/*  sat tuner was used for SATELLITE reception                  */
+	/*   and for TERRESTRIAL reception if it is the TER clock source*/
+	/* ------------------------------------------------------------ */
+	switch (front_end->previous_standard)
+	{
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT:
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC:
+			dtv_demod_already_used = 1;
+			ter_tuner_already_used = 1;
+			ter_clock_already_used = 1;
+			break;
+		case Si2168_DD_MODE_PROP_MODULATION_ANALOG:
+			ter_tuner_already_used = 1;
+			break;
+		default: // SLEEP
+			ter_tuner_already_used = 0;
+			break;
+	}
+	/* ------------------------------------------------------------ */
+	/* Set Needed Flags                                             */
+	/* Setting flags representing the new state                     */
+	/* Logic applied:                                               */
+	/*  dtv demod is needed for TERRESTRIAL and SATELLITE reception */
+	/*  ter tuner is needed for TERRESTRIAL reception               */
+	/*   and for SATELLITE reception if it is the SAT clock source  */
+	/*  sat tuner is needed for SATELLITE reception                 */
+	/*   and for TERRESTRIAL reception if it is the TER clock source*/
+	/* ------------------------------------------------------------ */
+	switch(new_standard)
+	{
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT:
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC:
+			dtv_demod_needed = 1;
+			ter_tuner_needed = 1;
+			ter_clock_needed = 1;
+			break;
+		case Si2168_DD_MODE_PROP_MODULATION_ANALOG:
+			ter_tuner_needed = 1;
+			break;
+		default: // SLEEP
+			ter_tuner_needed = 0;
+			break;
+	}
+	/* ------------------------------------------------------------ */
+	/* if 'force' flag is set, set flags to trigger a full init     */
+	/* This can be used to re-init the NIM after a power cycle      */
+	/*  or a HW reset                                               */
+	/* ------------------------------------------------------------ */
+	if (force_full_init)
+	{
+		// set 'init_done' flags to force full init
+		front_end->first_init_done     = 0;
+		front_end->Si2168_init_done    = 0;
+		front_end->TER_init_done       = 0;
+		front_end->TER_tuner_init_done = 0;
+		// set 'already used' flags to force full init
+		ter_tuner_already_used = 0;
+		dtv_demod_already_used = 0;
+	}
+	/* ------------------------------------------------------------ */
+	/* Request demodulator sleep if its clock will be stopped       */
+	/* ------------------------------------------------------------ */
+	if ((ter_clock_already_used == 1) & (ter_clock_needed == 0) )
+		dtv_demod_sleep_request = 1;
+	if ((ter_clock_already_used == 0) & (ter_clock_needed == 1) )
+		dtv_demod_sleep_request = 1;
+	/* ------------------------------------------------------------ */
+	/* Request demodulator sleep if transition from '1' to '0'      */
+	/* ------------------------------------------------------------ */
+	if ((dtv_demod_already_used == 1) & (dtv_demod_needed == 0) )
+		dtv_demod_sleep_request = 1;
+	/* ------------------------------------------------------------ */
+	/* Sleep dtv demodulator if requested                           */
+	/* ------------------------------------------------------------ */
+	if (dtv_demod_sleep_request == 1)
+		Si2168_STANDBY (front_end->demod);
+	/* ------------------------------------------------------------ */
+	/* Allow i2c traffic to reach the tuners                        */
+	/* ------------------------------------------------------------ */
+	Si2168_L2_Tuner_I2C_Enable(front_end);
+	/* ------------------------------------------------------------ */
+	/* Sleep Ter Tuner                                              */
+	/* Sleep terrestrial tuner  if transition from '1' to '0'       */
+	/* ------------------------------------------------------------ */
+	if ((ter_tuner_already_used == 1) & (ter_tuner_needed == 0) )
+	{
+		if ((res= TER_TUNER_CLOCK_OFF(front_end->tuner_ter)) !=0 )
+			return 0;
+		if ((res= TER_TUNER_STANDBY(front_end->tuner_ter)) !=0 )
+			return 0;
+	}
+	/* ------------------------------------------------------------ */
+	/* Wakeup Ter Tuner                                             */
+	/* Wake up terrestrial tuner if transition from '0' to '1'      */
+	/* ------------------------------------------------------------ */
+	if ((ter_tuner_already_used == 0) & (ter_tuner_needed == 1))
+	{
+		// Do a full init of the Ter Tuner only if it has not been already done
+		if (front_end->TER_tuner_init_done==0)
+		{
+			if ((res= TER_TUNER_INIT(front_end->tuner_ter)) !=0)
+				return 0;
+			front_end->TER_tuner_init_done++;
+		}
+		else
+		{
+			if ((res= TER_TUNER_WAKEUP(front_end->tuner_ter)) !=0)
+				return 0;
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* If the terrestrial tuner's clock is required, activate it    */
+	/* ------------------------------------------------------------ */
+	if (ter_clock_needed)
+	{
+		if ((res= TER_TUNER_CLOCK_ON(front_end->tuner_ter) ) !=0)
+			return 0;
+	}
+	/* ------------------------------------------------------------ */
+	/* Change Dtv Demod standard if required                        */
+	/* ------------------------------------------------------------ */
+	if ((front_end->previous_standard != new_standard) & (dtv_demod_needed == 1))
+	{
+		front_end->demod->standard = new_standard;
+		/* Set flag to trigger Si2168 init or re_init, to complete    */
+		/*  the standard change                                       */
+		dtv_demod_already_used = 0;
+	}
+	/* ------------------------------------------------------------ */
+	/* Forbid i2c traffic to reach the tuners                       */
+	/* ------------------------------------------------------------ */
+	Si2168_L2_Tuner_I2C_Disable(front_end);
+	if (front_end->Si2168_init_done)
+	{
+		if (dtv_demod_sleep_request == 1)
+		{
+			if (Si2168_WAKEUP (front_end->demod) != 0)
+				return 0;
+		}
+	}
+	/* ------------------------------------------------------------ */
+	/* Wakeup Dtv Demod                                             */
+	/* Wakeup dtv demodulator if transition from '0' to '1'         */
+	/* ------------------------------------------------------------ */
+	if ((dtv_demod_already_used == 0) & (dtv_demod_needed == 1))
+	{
+		/* Do the 'first init' only the first time, plus if requested  */
+		/* (when 'force' flag is 1, Si2168_init_done is set to '0')   */
+		front_end->demod->prop->dd_mode.modulation = (unsigned char)new_standard;
+		front_end->demod->media = Si2168_Media(front_end->demod, front_end->demod->prop->dd_mode.modulation);
+		if (!front_end->Si2168_init_done)
+		{
+			if (Si2168_Init(front_end->demod) == 0)
+				front_end->Si2168_init_done = 1;
+			else
+				return 0;
+		}
+		if (front_end->demod->media == Si2168_TERRESTRIAL)
+		{
+			if (front_end->TER_init_done == 0)
+			{
+				if (Si2168_Configure(front_end->demod) == 0)
+				{
+					/* set dd_mode.modulation again, as it is overwritten by Si2168_Configure */
+					front_end->demod->prop->dd_mode.modulation = (unsigned char)new_standard;
+					front_end->TER_init_done = 1;
+				}
+				else
+					return 0;
+			}
+			/* ------------------------------------------------------------ */
+			/* Manage FEF mode in TER tuner                                 */
+			/* ------------------------------------------------------------ */
+			if (new_standard == Si2168_DD_MODE_PROP_MODULATION_DVBT2)
+				Si2168_L2_TER_FEF (front_end, 1);
+			else
+				Si2168_L2_TER_FEF (front_end, 0);
+		}
+		front_end->demod->prop->dd_mode.invert_spectrum = Si2168_L2_Set_Invert_Spectrum(front_end);
+		if (Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE)==0)
+			Si2168_L1_DD_RESTART(front_end->demod);
+		else
+			return 0;
+	}
+	/* ------------------------------------------------------------ */
+	/* update value of previous_standard to prepare next call       */
+	/* ------------------------------------------------------------ */
+	front_end->previous_standard = new_standard;
+	front_end->demod->standard   = new_standard;
+	front_end->first_init_done = 1;
+	printk("Switch to Standard OK\n");
+	return 1;
+}
+
+int Silabs_standardCode(SILABS_FE_Context* front_end, int standard)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (standard)
+		{
+			case SILABS_DVB_T : return Si2168_DD_MODE_PROP_MODULATION_DVBT;
+			case SILABS_DVB_T2: return Si2168_DD_MODE_PROP_MODULATION_DVBT2;
+			case SILABS_DVB_C : return Si2168_DD_MODE_PROP_MODULATION_DVBC;
+			default           : return -1;
+		}
+	}
+	return -1;
+}
+
+int SiLabs_API_switch_to_standard(SILABS_FE_Context *front_end,int standard,unsigned char force_full_init)
+{
+	front_end->init_ok=0;
+	if(front_end->chip==2168)
+		front_end->init_ok=Si2168_L2_switch_to_standard(front_end->Si2168_FE,Silabs_standardCode(front_end, standard),force_full_init);
+	if(front_end->init_ok!=0)
+		front_end->standard=standard;
+	return front_end->init_ok;
+}
+
+int Silabs_constelCode(SILABS_FE_Context* front_end, CUSTOM_Constel_Enum constel)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (constel)
+		{
+			case SILABS_QAMAUTO : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO ;
+			case SILABS_QAM16   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16 ;
+			case SILABS_QAM32   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32 ;
+			case SILABS_QAM64   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64 ;
+			case SILABS_QAM128  : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128;
+			case SILABS_QAM256  : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256;
+			default             : return -1;
+		}
+	}
+	return -1;
+}
+
+int Silabs_streamCode(SILABS_FE_Context* front_end,CUSTOM_Stream_Enum stream)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (stream)
+		{
+			case SILABS_HP : return Si2168_DVBT_HIERARCHY_PROP_STREAM_HP   ;
+			case SILABS_LP : return Si2168_DVBT_HIERARCHY_PROP_STREAM_LP   ;
+			default           : return -1;
+		}
+	}
+	return -1;
+}
+
+unsigned char Si2146_L1_TUNER_TUNE_FREQ(L1_Si2146_Context *api,unsigned char   mode,unsigned long   freq)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[8];
+	unsigned char rspByteBuffer[1];
+	api->rsp->tuner_tune_freq.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_TUNER_TUNE_FREQ_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( mode & Si2146_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << Si2146_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+	cmdByteBuffer[2] = (unsigned char)0x00;
+	cmdByteBuffer[3] = (unsigned char)0x00;
+	cmdByteBuffer[4] = (unsigned char) ( ( freq & Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2146_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+	cmdByteBuffer[5] = (unsigned char) ((( freq & Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2146_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+	cmdByteBuffer[6] = (unsigned char) ((( freq & Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2146_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+	cmdByteBuffer[7] = (unsigned char) ((( freq & Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2146_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+	WriteI2C(api->addr,8,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2148_L1_TUNER_TUNE_FREQ (L1_Si2148_Context *api,unsigned char   mode,unsigned long   freq)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[8];
+	unsigned char rspByteBuffer[1];
+	api->rsp->tuner_tune_freq.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_TUNER_TUNE_FREQ_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( mode & Si2148_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << Si2148_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+	cmdByteBuffer[2] = (unsigned char)0x00;
+	cmdByteBuffer[3] = (unsigned char)0x00;
+	cmdByteBuffer[4] = (unsigned char) ( ( freq & Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2148_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+	cmdByteBuffer[5] = (unsigned char) ((( freq & Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2148_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+	cmdByteBuffer[6] = (unsigned char) ((( freq & Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2148_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+	cmdByteBuffer[7] = (unsigned char) ((( freq & Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2148_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+	WriteI2C(api->addr,8,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 1, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	return 0;
+}
+
+unsigned char Si2146_L1_CheckStatus (L1_Si2146_Context *api)
+{
+	unsigned char rspByteBuffer[1];
+	return Si2146_pollForResponse(api, 1, rspByteBuffer);
+}
+
+unsigned char Si2148_L1_CheckStatus(L1_Si2148_Context *api)
+{
+	unsigned char rspByteBuffer[1];
+	return Si2148_pollForResponse(api, 1, rspByteBuffer);
+}
+
+int  Si2146_Tune(L1_Si2146_Context *api, unsigned char mode, unsigned long freq)
+{
+	int i=0;
+	int return_code = 0;
+	if (Si2146_L1_TUNER_TUNE_FREQ (api,mode,freq) != 0)
+		return 3;
+	while(i < 20)
+	{
+		if ((return_code = Si2146_L1_CheckStatus(api)) != 0)
+			return return_code;
+		if (api->status->tunint)
+			break;
+		i++;
+		MyDelay(5);
+	}
+	if (!api->status->tunint)
+		return 0x0d;
+	i=0;
+	while(i < 2 )
+	{
+		if ((return_code = Si2146_L1_CheckStatus(api)) != 0)
+			return return_code;
+		if (api->status->dtvint)
+			break;
+		i++;
+		MyDelay(5);
+	}
+	if (api->status->dtvint)
+		return 0;
+	return 0x0e;
+}
+
+int  Si2148_Tune(L1_Si2148_Context *api, unsigned char mode, unsigned long freq)
+{
+	int i=0;
+	int return_code = 0;
+	if (Si2148_L1_TUNER_TUNE_FREQ (api,mode,freq) != 0)
+		return 3;
+	while(i < 20)
+	{
+		if ((return_code = Si2148_L1_CheckStatus(api)) != 0)
+			return return_code;
+		if (api->status->tunint)
+			break;
+		i++;
+		MyDelay(5);
+	}
+	if (!api->status->tunint)
+		return 0x0d;
+	i=0;
+	while(i<2)
+	{
+		if ((return_code = Si2148_L1_CheckStatus(api)) != 0)
+			return return_code;
+		if (api->status->dtvint)
+			break;
+		i++;
+		MyDelay(5);
+	}
+	if (api->status->dtvint)
+		return 0;
+	return 0x0e;
+}
+
+int Si2146_DTVTune(L1_Si2146_Context *Si2146, unsigned long freq, unsigned char bw, unsigned char modulation, unsigned char invert_spectrum)
+{
+	int return_code;
+	return_code = 0;
+	// update DTV_MODE_PROP property
+	Si2146->prop->dtv_mode.bw = bw;
+	Si2146->prop->dtv_mode.invert_spectrum = invert_spectrum;
+	Si2146->prop->dtv_mode.modulation = modulation;
+	if (Si2146_L1_SetProperty2(Si2146, Si2146_DTV_MODE_PROP) != 0)
+		return 3;
+	return_code = Si2146_Tune (Si2146, Si2146_TUNER_TUNE_FREQ_CMD_MODE_DTV, freq);
+	return return_code;
+}
+
+int Si2148_DTVTune(L1_Si2148_Context *api, unsigned long freq, unsigned char bw, unsigned char modulation, unsigned char invert_spectrum)
+{
+	int return_code;
+	return_code = 0;
+	// update DTV_MODE_PROP property
+	api->prop->dtv_mode.bw = bw;
+	api->prop->dtv_mode.invert_spectrum = invert_spectrum;
+	api->prop->dtv_mode.modulation = modulation;
+	if (Si2148_L1_SetProperty2(api, Si2148_DTV_MODE_PROP) != 0)
+		return 3;
+	return_code = Si2148_Tune (api, Si2148_TUNER_TUNE_FREQ_CMD_MODE_DTV, freq);
+	return return_code;
+}
+
+//Yann 2146/2148
+#if SiTuner==2146
+#define L1_RF_TER_TUNER_Tune(api,rf)  Si2146_DTVTune(api, rf, bw, modulation, Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL)
+#else
+#define L1_RF_TER_TUNER_Tune(api,rf)  Si2148_DTVTune(api, rf, bw, modulation, Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL)
+#endif
+int Si2168_L2_Tune(Si2168_L2_Context *front_end,int rf)
+{
+	char bw;
+	char modulation;
+	Si2168_L2_Tuner_I2C_Enable(front_end);
+	if (front_end->demod->media == Si2168_TERRESTRIAL)
+	{
+		if (front_end->demod->prop->dd_mode.modulation == Si2168_DD_MODE_PROP_MODULATION_DVBC )
+		{
+			modulation = L1_RF_TER_TUNER_MODULATION_DVBC;
+			bw         = 8;
+		}
+		else
+		{
+			modulation = L1_RF_TER_TUNER_MODULATION_DVBT;
+			switch (front_end->demod->prop->dd_mode.bw)
+			{
+				case Si2168_DD_MODE_PROP_BW_BW_1D7MHZ   : bw = 6; break;
+				case Si2168_DD_MODE_PROP_BW_BW_5MHZ     : bw = 6; break;
+				case Si2168_DD_MODE_PROP_BW_BW_6MHZ     : bw = 6; break;
+				case Si2168_DD_MODE_PROP_BW_BW_7MHZ     : bw = 7; break;
+				case Si2168_DD_MODE_PROP_BW_BW_8MHZ     : bw = 8; break;
+				default: bw = 8; break;
+			}
+		}
+		L1_RF_TER_TUNER_Tune(front_end->tuner_ter , rf);
+	}
+	Si2168_L2_Tuner_I2C_Disable(front_end);
+	return rf;
+}
+
+int g_nstandard=Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT;//Si2168_DD_MODE_PROP_MODULATION_DVBT;
+
+int Si2168_L2_Check_Lock(Si2168_L2_Context *front_end)
+{
+	int return_code;
+	int lock=0;
+	switch(g_nstandard)
+	{
+		default                                   :
+			return 0;
+			break;
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT  :
+		{
+			// DVB-T seek loop, using Si2168_L1_DVBT_STATUS
+			// if DL LOCKED  and NOTDVBT DVBT     : demod is locked    on  a DVB-T signal
+			// if DL NO_LOCK and NOTDVBT DVBT     : demod is searching for a DVB-T signal
+			// if DL NO_LOCK and NOTDVBT NOT_DVBT : demod says this is not a DVB-T signal
+			return_code = Si2168_L1_DVBT_STATUS(front_end->demod, Si2168_DVBT_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				goto exit_lock;
+				break;
+			}
+			if ( (front_end->demod->rsp->dvbt_status.dl  == Si2168_DVBT_STATUS_RESPONSE_DL_LOCKED   ) & ( front_end->demod->rsp->dvbt_status.notdvbt   == Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_DVBT       ) )
+			{
+				// Return 1 to signal that the Si2168 is locked on a valid DVB-T channel
+				lock = 1;
+				goto exit_lock;
+			}
+			if ( (front_end->demod->rsp->dvbt_status.dl  == Si2168_DVBT_STATUS_RESPONSE_DL_NO_LOCK  ) & ( front_end->demod->rsp->dvbt_status.notdvbt   == Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_NOT_DVBT   ) )
+			{
+				// Return 0 if firmware signals 'no DVB-T channel'
+				goto exit_lock;
+			}
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2 :
+		{
+			// DVB-T2 seek loop, using Si2168_L1_DVBT2_STATUS
+			// if DL LOCKED  and NOTDVBT2 DVBT2     : demod is locked    on  a DVB-T2 signal
+			// if DL NO_LOCK and NOTDVBT2 DVBT2     : demod is searching for a DVB-T2 signal
+			// if DL NO_LOCK and NOTDVBT2 NOT_DVBT2 : demod says this is not a DVB-T2 signal
+			return_code = Si2168_L1_DVBT2_STATUS(front_end->demod, Si2168_DVBT2_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				goto exit_lock;
+				break;
+			}
+			if ( (front_end->demod->rsp->dvbt2_status.dl == Si2168_DVBT2_STATUS_RESPONSE_DL_LOCKED  ) & ( front_end->demod->rsp->dvbt2_status.notdvbt2 == Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_DVBT2    ) )
+			{
+				// Return 1 to signal that the Si2168 is locked on a valid DVB-T2 channel
+				lock = 1;
+				goto exit_lock;
+			}
+			if ( (front_end->demod->rsp->dvbt2_status.dl == Si2168_DVBT2_STATUS_RESPONSE_DL_NO_LOCK ) & ( front_end->demod->rsp->dvbt2_status.notdvbt2 == Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_NOT_DVBT2) )
+			{
+				// Return 0 if firmware signals 'no DVB-T2 channel'
+				goto exit_lock;
+			}
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC  :
+		{
+			return_code = Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				return return_code;
+				break;
+			}
+			if ( (front_end->demod->rsp->dd_status.dl    == Si2168_DD_STATUS_RESPONSE_DL_LOCKED     ) )
+			{
+				// Return 1 to signal that the Si2168 is locked on a valid SAT channel
+				lock = 1;
+				goto exit_lock;
+			}
+			break;
+		}
+	}
+exit_lock:
+	if(lock)
+	{
+	}
+	else
+	{
+		// Call the demod global status function
+		Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_OK);
+	}
+	return lock;
+}
+
+int Si2168_Check_Lock()
+{
+	return Si2168_L2_Check_Lock(front_end->Si2168_FE);
+}
+
+int Si2168_L2_Check_CNR(Si2168_L2_Context *front_end)
+{
+	int return_code;
+	int cnr=0;
+	switch(g_nstandard)
+	{
+		default                                   :
+			break;
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT  :
+		{
+			return_code = Si2168_L1_DVBT_STATUS(front_end->demod, Si2168_DVBT_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				goto exit_cnr;
+				break;
+			}
+			cnr=front_end->demod->rsp->dvbt_status.cnr;
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2 :
+		{
+			return_code = Si2168_L1_DVBT2_STATUS(front_end->demod, Si2168_DVBT2_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				goto exit_cnr;
+				break;
+			}
+			cnr=front_end->demod->rsp->dvbt2_status.cnr;
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC  :
+			return_code = Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_CLEAR);
+			if (return_code != 0)
+			{
+				goto exit_cnr;
+				break;
+			}
+			if((front_end->demod->rsp->dd_status.dl==Si2168_DD_STATUS_RESPONSE_DL_LOCKED))
+				cnr=100;
+			else
+				cnr=0;
+			break;
+	}
+exit_cnr:
+	return cnr;
+}
+
+int Si2168_Check_CNR()
+{
+	int i=Si2168_L2_Check_CNR(front_end->Si2168_FE);
+	//printk("%d\n",i);
+	i/=4;
+	i*=2;
+	if(i>100)
+		i=0;
+	return i;
+}
+
+int Si2168_L2_lock_to_carrier(Si2168_L2_Context *front_end,int standard,int freq,int dvb_t_bandwidth_hz,int dvb_t_stream,unsigned int symbol_rate_bps,int dvb_c_constellation,int dvb_t2_plp_id)
+{
+	int return_code;
+	//int lockStartTime;
+	int lock;
+	int i=0;
+	g_nstandard=standard;
+	switch(standard)
+	{
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+		{
+			front_end->demod->prop->dd_mode.bw                = dvb_t_bandwidth_hz/1000000;
+			front_end->demod->prop->dvbt_hierarchy.stream     = (unsigned char)dvb_t_stream;
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBT_HIERARCHY_PROP_CODE);
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE);
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+		{
+			if (dvb_t_bandwidth_hz == 1700000)
+				front_end->demod->prop->dd_mode.bw              = Si2168_DD_MODE_PROP_BW_BW_1D7MHZ;
+			else
+				front_end->demod->prop->dd_mode.bw              = dvb_t_bandwidth_hz/1000000;
+			if(dvb_t2_plp_id!=-1)
+				Si2168_L1_DVBT2_PLP_SELECT(front_end->demod,(unsigned char)dvb_t2_plp_id,Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL);
+			else
+				Si2168_L1_DVBT2_PLP_SELECT(front_end->demod,0,Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO);
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE);
+			break;
+		}
+		case Si2168_DD_MODE_PROP_MODULATION_DVBC :
+		{
+			front_end->demod->prop->dd_mode.bw                       = 8;
+			front_end->demod->prop->dvbc_symbol_rate.rate            = symbol_rate_bps/1000;
+			front_end->demod->prop->dvbc_constellation.constellation = (unsigned char)dvb_c_constellation;
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE);
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBC_SYMBOL_RATE_PROP_CODE);
+			Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBC_CONSTELLATION_PROP_CODE);
+			break;
+		}
+		default : /* ATV */
+		{
+			return 0;
+			break;
+		}
+	}
+	Si2168_L2_Tune(front_end,freq);
+	Si2168_L1_DD_RESTART(front_end->demod);
+	lock = 0;
+	MyDelay(300);
+	while(1)
+	{
+		switch (standard)
+		{
+			default                                   :
+			case Si2168_DD_MODE_PROP_MODULATION_DVBT  :
+			{
+				// DVB-T seek loop, using Si2168_L1_DVBT_STATUS
+				// if DL LOCKED  and NOTDVBT DVBT     : demod is locked    on  a DVB-T signal
+				// if DL NO_LOCK and NOTDVBT DVBT     : demod is searching for a DVB-T signal
+				// if DL NO_LOCK and NOTDVBT NOT_DVBT : demod says this is not a DVB-T signal
+				return_code = Si2168_L1_DVBT_STATUS(front_end->demod, Si2168_DVBT_STATUS_CMD_INTACK_CLEAR);
+				if (return_code != 0)
+				{
+					goto exit_lock;
+					break;
+				}
+				if ( (front_end->demod->rsp->dvbt_status.dl  == Si2168_DVBT_STATUS_RESPONSE_DL_LOCKED   ) & ( front_end->demod->rsp->dvbt_status.notdvbt   == Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_DVBT       ) )
+				{
+					// Return 1 to signal that the Si2168 is locked on a valid DVB-T channel
+					lock = 1;
+					goto exit_lock;
+				}
+				if ( (front_end->demod->rsp->dvbt_status.dl  == Si2168_DVBT_STATUS_RESPONSE_DL_NO_LOCK  ) & ( front_end->demod->rsp->dvbt_status.notdvbt   == Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_NOT_DVBT   ) )
+				{
+					// Return 0 if firmware signals 'no DVB-T channel'
+					goto exit_lock;
+				}
+				break;
+			}
+			case Si2168_DD_MODE_PROP_MODULATION_DVBT2 :
+			{
+				// DVB-T2 seek loop, using Si2168_L1_DVBT2_STATUS
+				// if DL LOCKED  and NOTDVBT2 DVBT2     : demod is locked    on  a DVB-T2 signal
+				// if DL NO_LOCK and NOTDVBT2 DVBT2     : demod is searching for a DVB-T2 signal
+				// if DL NO_LOCK and NOTDVBT2 NOT_DVBT2 : demod says this is not a DVB-T2 signal
+				return_code = Si2168_L1_DVBT2_STATUS(front_end->demod, Si2168_DVBT2_STATUS_CMD_INTACK_CLEAR);
+				if (return_code != 0)
+				{
+					goto exit_lock;
+					break;
+				}
+				if ( (front_end->demod->rsp->dvbt2_status.dl == Si2168_DVBT2_STATUS_RESPONSE_DL_LOCKED  ) & ( front_end->demod->rsp->dvbt2_status.notdvbt2 == Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_DVBT2    ) )
+				{
+					// Return 1 to signal that the Si2168 is locked on a valid DVB-T2 channel
+					lock = 1;
+					Si2168_L2_Tuner_I2C_Enable(front_end);
+					Si2168_L2_TER_FEF(front_end, 1);
+					Si2168_L2_Tuner_I2C_Disable(front_end);
+					goto exit_lock;
+				}
+				if ( (front_end->demod->rsp->dvbt2_status.dl == Si2168_DVBT2_STATUS_RESPONSE_DL_NO_LOCK ) & ( front_end->demod->rsp->dvbt2_status.notdvbt2 == Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_NOT_DVBT2) )
+				{
+					// Return 0 if firmware signals 'no DVB-T2 channel'
+					goto exit_lock;
+				}
+				break;
+			}
+			case Si2168_DD_MODE_PROP_MODULATION_DVBC  :
+			{
+				return_code = Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_CLEAR);
+				if (return_code != 0)
+				{
+					return return_code;
+					break;
+				}
+				if ( (front_end->demod->rsp->dd_status.dl    == Si2168_DD_STATUS_RESPONSE_DL_LOCKED     ) )
+				{
+					// Return 1 to signal that the Si2168 is locked on a valid SAT channel
+					lock = 1;
+					goto exit_lock;
+				}
+				break;
+			}
+		}
+		// timeout management (this should never happen if timeout values are correctly set)
+		if(i>=20)
+			break;
+		i++;
+		// Check status every 20 ms
+		MyDelay(10);
+	}
+exit_lock:
+	if(lock)
+	{
+		//Si2168_L1_DD_BER(front_end->demod, Si2168_DD_BER_CMD_RST_CLEAR);
+		if(standard==2)
+			printk("Locked:DVBT\n");
+		else if(standard==3)
+			printk("Locked:DVBC\n");
+		else
+			printk("Locked:DVBT2\n");
+	}
+	else
+	{
+		// Call the demod global status function
+		Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_OK);
+		if(standard==2)
+			printk("No Locked:DVBT\n");
+		else if(standard==3)
+			printk("No Locked:DVBC\n");
+		else
+			printk("No Locked:DVBT2\n");
+	}
+	return lock;
+}
+
+int SiLabs_API_lock_to_carrier(SILABS_FE_Context *front_end, int standard, int freq, int bandwidth_Hz, int stream, int symbol_rate_bps, int constellation,int plp_id)
+{
+	int standard_code;
+	int constel_code;
+	int stream_code;
+	standard_code = Silabs_standardCode(front_end, (CUSTOM_Standard_Enum)standard);
+	constel_code  = Silabs_constelCode (front_end, (CUSTOM_Constel_Enum)constellation);
+	stream_code   = Silabs_streamCode  (front_end, (CUSTOM_Stream_Enum)stream);
+	// Use the API wrapper function to switch standard if required.
+	if (standard != front_end->standard)
+	{
+		if (SiLabs_API_switch_to_standard(front_end, standard, 0) == 0)
+			return 0;
+	}
+	if (front_end->chip == 2168)
+		return Si2168_L2_lock_to_carrier(front_end->Si2168_FE,standard_code,freq,bandwidth_Hz,stream_code,symbol_rate_bps,constel_code,plp_id);
+	return 0;
+}
+
+int Silabs_UserInput_Lock(void)
+{
+	int                  lock;
+	int                  freq;
+	int                  bandwidth_Hz;
+	int                  symbol_rate_bps;
+	CUSTOM_Constel_Enum  constellation;
+	CUSTOM_Stream_Enum   stream;
+	int                  standard;
+	standard = SILABS_DVB_T;
+	freq = 533000000;
+	bandwidth_Hz = 6000000;
+	stream = SILABS_HP;
+	if(standard==SILABS_DVB_C)
+	{
+		symbol_rate_bps=6900000;
+		constellation=SILABS_QAMAUTO;
+	}
+	if(SiLabs_API_switch_to_standard(front_end,standard,0)==0)
+		return 0;
+	last_standard        = standard;
+	last_freq            = freq;
+	last_bandwidth_Hz    = bandwidth_Hz;
+	last_stream          = stream;
+	last_symbol_rate_bps = symbol_rate_bps;
+	last_constellation   = constellation;
+	lock=SiLabs_API_lock_to_carrier(front_end,standard,freq,bandwidth_Hz,stream,symbol_rate_bps,constellation,-1);
+	return lock;
+}
+
+unsigned char Si2146_L1_TUNER_STATUS(L1_Si2146_Context *api,unsigned char intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[12];
+	api->rsp->tuner_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_TUNER_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2146_TUNER_STATUS_CMD_INTACK_MASK ) << Si2146_TUNER_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 12, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->tuner_status.tcint    =   (( ( (rspByteBuffer[1]  )) >> Si2146_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & Si2146_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+	api->rsp->tuner_status.rssilint =   (( ( (rspByteBuffer[1]  )) >> Si2146_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & Si2146_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+	api->rsp->tuner_status.rssihint =   (( ( (rspByteBuffer[1]  )) >> Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+	api->rsp->tuner_status.tc       =   (( ( (rspByteBuffer[2]  )) >> Si2146_TUNER_STATUS_RESPONSE_TC_LSB       ) & Si2146_TUNER_STATUS_RESPONSE_TC_MASK       );
+	api->rsp->tuner_status.rssil    =   (( ( (rspByteBuffer[2]  )) >> Si2146_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & Si2146_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+	api->rsp->tuner_status.rssih    =   (( ( (rspByteBuffer[2]  )) >> Si2146_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & Si2146_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+	api->rsp->tuner_status.rssi     = (((( ( (rspByteBuffer[3]  )) >> Si2146_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & Si2146_TUNER_STATUS_RESPONSE_RSSI_MASK) <<Si2146_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>Si2146_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+	api->rsp->tuner_status.freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2146_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & Si2146_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+	api->rsp->tuner_status.mode     =   (( ( (rspByteBuffer[8]  )) >> Si2146_TUNER_STATUS_RESPONSE_MODE_LSB     ) & Si2146_TUNER_STATUS_RESPONSE_MODE_MASK     );
+	api->rsp->tuner_status.vco_code = (((( ( (rspByteBuffer[10] ) | (rspByteBuffer[11] << 8 )) >> Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+	return 0;
+}
+
+unsigned char Si2146_L1_DTV_STATUS(L1_Si2146_Context *api,unsigned char   intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[4];
+	api->rsp->dtv_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2146_DTV_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2146_DTV_STATUS_CMD_INTACK_MASK ) << Si2146_DTV_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2146_pollForResponse(api, 4, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->dtv_status.chlint     =   (( ( (rspByteBuffer[1]  )) >> Si2146_DTV_STATUS_RESPONSE_CHLINT_LSB     ) & Si2146_DTV_STATUS_RESPONSE_CHLINT_MASK     );
+	api->rsp->dtv_status.chl        =   (( ( (rspByteBuffer[2]  )) >> Si2146_DTV_STATUS_RESPONSE_CHL_LSB        ) & Si2146_DTV_STATUS_RESPONSE_CHL_MASK        );
+	api->rsp->dtv_status.bw         =   (( ( (rspByteBuffer[3]  )) >> Si2146_DTV_STATUS_RESPONSE_BW_LSB         ) & Si2146_DTV_STATUS_RESPONSE_BW_MASK         );
+	api->rsp->dtv_status.modulation =   (( ( (rspByteBuffer[3]  )) >> Si2146_DTV_STATUS_RESPONSE_MODULATION_LSB ) & Si2146_DTV_STATUS_RESPONSE_MODULATION_MASK );
+	return 0;
+}
+
+unsigned char Si2148_L1_TUNER_STATUS(L1_Si2148_Context *api,unsigned char   intack)
+{
+	unsigned char error_code = 0;
+	unsigned char cmdByteBuffer[2];
+	unsigned char rspByteBuffer[12];
+	api->rsp->tuner_status.STATUS = api->status;
+	cmdByteBuffer[0] = Si2148_TUNER_STATUS_CMD;
+	cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2148_TUNER_STATUS_CMD_INTACK_MASK ) << Si2148_TUNER_STATUS_CMD_INTACK_LSB);
+	WriteI2C(api->addr,2,cmdByteBuffer);
+	error_code = Si2148_pollForResponse(api, 12, rspByteBuffer);
+	if (error_code)
+		return error_code;
+	api->rsp->tuner_status.tcint    =   (( ( (rspByteBuffer[1]  )) >> Si2148_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & Si2148_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+	api->rsp->tuner_status.rssilint =   (( ( (rspByteBuffer[1]  )) >> Si2148_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & Si2148_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+	api->rsp->tuner_status.rssihint =   (( ( (rspByteBuffer[1]  )) >> Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+	api->rsp->tuner_status.tc       =   (( ( (rspByteBuffer[2]  )) >> Si2148_TUNER_STATUS_RESPONSE_TC_LSB       ) & Si2148_TUNER_STATUS_RESPONSE_TC_MASK       );
+	api->rsp->tuner_status.rssil    =   (( ( (rspByteBuffer[2]  )) >> Si2148_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & Si2148_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+	api->rsp->tuner_status.rssih    =   (( ( (rspByteBuffer[2]  )) >> Si2148_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & Si2148_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+	api->rsp->tuner_status.rssi     = (((( ( (rspByteBuffer[3]  )) >> Si2148_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & Si2148_TUNER_STATUS_RESPONSE_RSSI_MASK) <<Si2148_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>Si2148_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+	api->rsp->tuner_status.freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2148_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & Si2148_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+	api->rsp->tuner_status.mode     =   (( ( (rspByteBuffer[8]  )) >> Si2148_TUNER_STATUS_RESPONSE_MODE_LSB     ) & Si2148_TUNER_STATUS_RESPONSE_MODE_MASK     );
+	api->rsp->tuner_status.vco_code = (((( ( (rspByteBuffer[10] ) | (rspByteBuffer[11] << 8 )) >> Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+	return 0;
+}
+
+int SiLabs_API_TER_Tuner_status(SILABS_FE_Context* front_end,CUSTOM_Status_Struct *status)
+{
+	//Yann 2146/2148
+#if SiTuner==2146
+	L1_Si2146_Context *tuner_ter;
+	if (front_end->chip ==   2168 ) { tuner_ter = front_end->Si2168_FE->tuner_ter; }
+	if (tuner_ter == NULL)
+		return 0;
+	Si2168_L2_Tuner_I2C_Enable(front_end->Si2168_FE);
+	Si2146_L1_TUNER_STATUS            (tuner_ter, Si2146_TUNER_STATUS_CMD_INTACK_OK );
+	status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+	status->tc       =  tuner_ter->rsp->tuner_status.tc;
+	status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+	status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+	status->freq     =  tuner_ter->rsp->tuner_status.freq;
+	status->mode     =  tuner_ter->rsp->tuner_status.mode;
+	status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+	Si2146_L1_DTV_STATUS            (tuner_ter, Si2146_DTV_STATUS_CMD_INTACK_OK );
+	status->chl                =  tuner_ter->rsp->dtv_status.chl;
+	status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+	status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+	//status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+	Si2168_L2_Tuner_I2C_Disable(front_end->Si2168_FE);
+	return 1;
+#else
+	L1_Si2148_Context *tuner_ter;
+	if (front_end->chip ==   2168 ) { tuner_ter = front_end->Si2168_FE->tuner_ter; }
+	if (tuner_ter == NULL)
+		return 0;
+	Si2168_L2_Tuner_I2C_Enable(front_end->Si2168_FE);
+	Si2148_L1_TUNER_STATUS(tuner_ter, Si2148_TUNER_STATUS_CMD_INTACK_OK );
+	status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+	status->tc       =  tuner_ter->rsp->tuner_status.tc;
+	status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+	status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+	status->freq     =  tuner_ter->rsp->tuner_status.freq;
+	status->mode     =  tuner_ter->rsp->tuner_status.mode;
+	status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+	//status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+	Si2168_L2_Tuner_I2C_Disable(front_end->Si2168_FE);
+	return 1;
+#endif
+}
+
+int Custom_standardCode(SILABS_FE_Context* front_end,int standard)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (standard)
+		{
+			case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+				return SILABS_DVB_T ;
+			case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+				return SILABS_DVB_T2;
+			case Si2168_DD_MODE_PROP_MODULATION_DVBC :
+				return SILABS_DVB_C ;
+			default                                  :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_streamCode (SILABS_FE_Context* front_end, int stream)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (stream)
+		{
+			case Si2168_DVBT_HIERARCHY_PROP_STREAM_HP:
+				return SILABS_HP;
+			case Si2168_DVBT_HIERARCHY_PROP_STREAM_LP:
+				return SILABS_LP;
+			default                                  :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_constelCode (SILABS_FE_Context* front_end, int constel)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (constel)
+		{
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO  :
+				return SILABS_QAMAUTO ;
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16 :
+				return SILABS_QAM16   ;
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32 :
+				return SILABS_QAM32   ;
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64 :
+				return SILABS_QAM64   ;
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128:
+				return SILABS_QAM128  ;
+			case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256:
+				return SILABS_QAM256  ;
+			default                                                 :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_fftCode(SILABS_FE_Context* front_end, int fft)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (fft)
+		{
+			case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_2K  :
+				return SILABS_FFT_MODE_2K ;
+			case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_4K  :
+				return SILABS_FFT_MODE_4K ;
+			case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_8K  :
+				return SILABS_FFT_MODE_8K ;
+			case Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_16K:
+				return SILABS_FFT_MODE_16K;
+			case Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_32K:
+				return SILABS_FFT_MODE_32K;
+			default                                       :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_giCode(SILABS_FE_Context* front_end, int gi)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (gi)
+		{
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32  :
+				return SILABS_GUARD_INTERVAL_1_32  ;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16  :
+				return SILABS_GUARD_INTERVAL_1_16  ;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8   :
+				return SILABS_GUARD_INTERVAL_1_8   ;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4   :
+				return SILABS_GUARD_INTERVAL_1_4   ;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128 :
+				return SILABS_GUARD_INTERVAL_1_128 ;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128:
+				return SILABS_GUARD_INTERVAL_19_128;
+			case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256:
+				return SILABS_GUARD_INTERVAL_19_256;
+			default                                           :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_coderateCode(SILABS_FE_Context* front_end, int coderate)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (coderate)
+		{
+			case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_1_2    :
+				return SILABS_CODERATE_1_2;
+			case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_2_3    :
+				return SILABS_CODERATE_2_3;
+			case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_3_4    :
+				return SILABS_CODERATE_3_4;
+			case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_5_6    :
+				return SILABS_CODERATE_5_6;
+			case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_7_8    :
+				return SILABS_CODERATE_7_8;
+			default                                         :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_hierarchyCode(SILABS_FE_Context* front_end, int hierarchy)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (hierarchy)
+		{
+			case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_NONE :
+				return SILABS_HIERARCHY_NONE;
+			case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1:
+				return SILABS_HIERARCHY_ALFA1;
+			case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2:
+				return SILABS_HIERARCHY_ALFA2;
+			case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4:
+				return SILABS_HIERARCHY_ALFA4;
+			default                                         :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int Custom_pilotPatternCode(SILABS_FE_Context* front_end, int pilot_pattern)
+{
+	if (front_end->chip == 2168)
+	{
+		switch (pilot_pattern)
+		{
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP1:
+				return SILABS_PILOT_PATTERN_PP1;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP2:
+				return SILABS_PILOT_PATTERN_PP2;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP3:
+				return SILABS_PILOT_PATTERN_PP3;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP4:
+				return SILABS_PILOT_PATTERN_PP4;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP5:
+				return SILABS_PILOT_PATTERN_PP5;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP6:
+				return SILABS_PILOT_PATTERN_PP6;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP7:
+				return SILABS_PILOT_PATTERN_PP7;
+			case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP8:
+				return SILABS_PILOT_PATTERN_PP8;
+			default                                            :
+				return -1;
+		}
+	}
+	return -1;
+}
+
+int SiLabs_API_Demod_status(SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status)
+{
+	// Set to 0 all info used to relock
+	status->bandwidth_Hz       = 0;
+	status->symbol_rate        = 0;
+	status->stream             = 0;
+	status->constellation      = 0;
+	//status->ber                = -1; // Set to '-1' to signal unavailability if not set later on
+	//status->per                = -1; // Set to '-1' to signal unavailability if not set later on
+	//status->fer                = -1; // Set to '-1' to signal unavailability if not set later on
+	if (front_end->chip == 2168)
+	{
+		Si2168_L1_DD_STATUS (front_end->Si2168_FE->demod, Si2168_DD_STATUS_CMD_INTACK_OK);
+		front_end->standard = Custom_standardCode(front_end, front_end->Si2168_FE->demod->rsp->dd_status.modulation);
+		switch (front_end->standard)
+		{
+			case SILABS_ANALOG:
+				status->standard     = front_end->standard;
+				return 1;
+				break;
+			case SILABS_DVB_T :
+			case SILABS_DVB_C :
+				front_end->Si2168_FE->demod->tuner_rssi = status->rssi;
+				//Si2168_L1_DD_BER    (front_end->Si2168_FE->demod, Si2168_DD_BER_CMD_RST_RUN);
+				//Si2168_L1_DD_PER    (front_end->Si2168_FE->demod, Si2168_DD_PER_CMD_RST_RUN);
+				//Si2168_L1_DD_UNCOR  (front_end->Si2168_FE->demod, Si2168_DD_UNCOR_CMD_RST_RUN);
+				status->standard           = front_end->standard;
+				// Mimick Si2167 clock_mode register values
+				status->clock_mode =  33;
+				// CHECK the exponent value to know if the BER is available or not
+				//if(front_end->Si2168_FE->demod->rsp->dd_ber.exp!=0)
+				//	status->ber = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+				// CHECK the exponent value to know if the PER is available or not
+				//if(front_end->Si2168_FE->demod->rsp->dd_fer.exp!=0)
+				//	status->per = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+				//status->uncorrs = (front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_msb<<16) + front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_lsb;
+				break;
+			case SILABS_DVB_T2:
+				//Si2168_L1_DD_BER    (front_end->Si2168_FE->demod, Si2168_DD_BER_CMD_RST_RUN);
+				//Si2168_L1_DD_FER    (front_end->Si2168_FE->demod, Si2168_DD_FER_CMD_RST_RUN);
+				//Si2168_L1_DD_PER    (front_end->Si2168_FE->demod, Si2168_DD_PER_CMD_RST_RUN);
+				//Si2168_L1_DD_UNCOR  (front_end->Si2168_FE->demod, Si2168_DD_UNCOR_CMD_RST_RUN);
+				status->standard           =  front_end->standard;
+				// Mimick Si2167 clock_mode register values
+				switch (front_end->Si2168_FE->demod->cmd->start_clk.clk_mode)
+				{
+					case Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO   :
+						status->clock_mode =  32;
+						break;
+					case Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN :
+						status->clock_mode =  34;
+						break;
+					case Si2168_START_CLK_CMD_CLK_MODE_XTAL        :
+						status->clock_mode =  33;
+						break;
+					default                                        :
+						status->clock_mode =   0;
+						break;
+				}
+				// CHECK the exponent value to know if the BER is available or not
+				//if(front_end->Si2168_FE->demod->rsp->dd_ber.exp!=0)
+				//	status->ber = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+				// CHECK the exponent value to know if the FER is available or not
+				//if(front_end->Si2168_FE->demod->rsp->dd_fer.exp!=0)
+				//	status->fer = (front_end->Si2168_FE->demod->rsp->dd_fer.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_fer.exp);
+				// CHECK the exponent value to know if the PER is available or not
+				//if(front_end->Si2168_FE->demod->rsp->dd_per.exp!=0)
+				//	status->per = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+				//status->uncorrs = (front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_msb<<16) + front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_lsb;
+				break;
+			default           :
+				return 0;
+				break;
+		}
+		// Retrieving AGC values
+		switch (front_end->standard)
+		{
+			case SILABS_DVB_T :
+			case SILABS_DVB_C :
+			case SILABS_DVB_T2:
+				front_end->Si2168_FE->demod->cmd->dd_ext_agc_ter.agc_1_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE;
+				front_end->Si2168_FE->demod->cmd->dd_ext_agc_ter.agc_2_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE;
+				Si2168_L1_SendCommand2(front_end->Si2168_FE->demod, Si2168_DD_EXT_AGC_TER_CMD_CODE);
+				status->RFagc              = 0;
+				status->IFagc              = front_end->Si2168_FE->demod->rsp->dd_ext_agc_ter.agc_2_level;
+				break;
+			default           :
+				status->RFagc              = 0;
+				status->IFagc              = 0;
+				break;
+		}
+		switch (front_end->standard)
+		{
+			case SILABS_DVB_T :
+				Si2168_L1_DVBT_STATUS    (front_end->Si2168_FE->demod, Si2168_DVBT_STATUS_CMD_INTACK_OK);
+				Si2168_L1_DVBT_TPS_EXTRA (front_end->Si2168_FE->demod);
+				Si2168_L1_DD_SSI_SQI     (front_end->Si2168_FE->demod, front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi);
+				status->demod_lock         = front_end->Si2168_FE->demod->rsp->dvbt_status.pcl;
+				status->fec_lock           = front_end->Si2168_FE->demod->rsp->dvbt_status.dl;
+				//status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt_status.cnr/4.0;
+				status->freq_offset        = front_end->Si2168_FE->demod->rsp->dvbt_status.afc_freq;
+				status->timing_offset      = front_end->Si2168_FE->demod->rsp->dvbt_status.timing_offset;
+				status->bandwidth_Hz       = front_end->Si2168_FE->demod->prop->dd_mode.bw*1000000;
+				status->stream             = Custom_streamCode   (front_end, front_end->Si2168_FE->demod->prop->dvbt_hierarchy.stream);
+				status->fft_mode           = Custom_fftCode      (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.fft_mode);
+				status->guard_interval     = Custom_giCode       (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.guard_int);
+				status->constellation      = Custom_constelCode  (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.constellation);
+				status->hierarchy          = Custom_hierarchyCode(front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.hierarchy);
+				status->code_rate_hp       = Custom_coderateCode (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.rate_hp);
+				status->code_rate_lp       = Custom_coderateCode (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.rate_lp);
+				//status->RSSI               = front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi;
+				status->SSI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.ssi;
+				status->SQI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.sqi;
+				status->symbol_rate        = 0;
+				break;
+			case SILABS_DVB_T2 :
+				Si2168_L1_DVBT2_STATUS   (front_end->Si2168_FE->demod, Si2168_DVBT2_STATUS_CMD_INTACK_OK);
+				Si2168_L1_DD_SSI_SQI     (front_end->Si2168_FE->demod, front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi);
+				status->demod_lock         = front_end->Si2168_FE->demod->rsp->dvbt2_status.pcl;
+				status->fec_lock           = front_end->Si2168_FE->demod->rsp->dvbt2_status.dl;
+				//status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt2_status.cnr/4.0;
+				status->freq_offset        = front_end->Si2168_FE->demod->rsp->dvbt2_status.afc_freq;
+				status->timing_offset      = front_end->Si2168_FE->demod->rsp->dvbt2_status.timing_offset;
+				status->bandwidth_Hz       = front_end->Si2168_FE->demod->prop->dd_mode.bw*1000000;
+				status->stream             = Custom_streamCode      (front_end, 0);
+				status->fft_mode           = Custom_fftCode         (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.fft_mode);
+				status->guard_interval     = Custom_giCode          (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.guard_int);
+				status->constellation      = Custom_constelCode     (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.constellation);
+				status->code_rate          = Custom_coderateCode    (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.code_rate);
+				status->rotated            = front_end->Si2168_FE->demod->rsp->dvbt2_status.rotated;
+				status->pilot_pattern      = Custom_pilotPatternCode(front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.pilot_pattern);
+				status->bw_ext             = front_end->Si2168_FE->demod->rsp->dvbt2_status.bw_ext;
+				status->num_plp            = front_end->Si2168_FE->demod->rsp->dvbt2_status.num_plp;
+				status->tx_mode            = front_end->Si2168_FE->demod->rsp->dvbt2_status.tx_mode;
+				status->short_frame        = front_end->Si2168_FE->demod->rsp->dvbt2_status.short_frame;
+				status->fef                = front_end->Si2168_FE->demod->rsp->dvbt2_status.fef;
+				//status->RSSI               = front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi;
+				status->SSI                = 0;
+				status->SQI                = 0;
+				status->symbol_rate        = 0;
+				break;
+			default           :
+				status->demod_lock         = 0;
+				status->fec_lock           = 0;
+				return 0;
+				break;
+		}
+	}
+	return 0;
+}
+
+int SiLabs_API_FE_status(SILABS_FE_Context* front_end,CUSTOM_Status_Struct *status)
+{
+	switch (front_end->standard)
+	{
+		case SILABS_ANALOG:
+			return 0;
+			break;
+		case SILABS_DVB_T :
+		case SILABS_DVB_T2:
+		case SILABS_DVB_C :
+			SiLabs_API_TER_Tuner_status(front_end, status);
+			break;
+		case SILABS_DVB_S :
+		case SILABS_DVB_S2:
+		case SILABS_DSS   :
+			return 0;
+			break;
+		default           :
+			return 0;
+			break;
+	}
+	SiLabs_API_Demod_status(front_end, status);
+	return 1;
+}
+
+/*void main()
+{
+	mode=USB;
+	SiLabs_API_SW_Init(&(FrontEnd_Table[0]),0xC8,0xC0);
+	SiLabs_API_HW_Connect(&(FrontEnd_Table[0]),mode);
+	front_end=&(FrontEnd_Table[0]);
+	// Setting default values for 'store' parameters
+	last_standard        = SILABS_DVB_T;
+	last_freq            = 474000000;
+	last_bandwidth_Hz    = 8000000;
+	last_stream          = SILABS_HP;
+	last_symbol_rate_bps = 6900000;
+	last_constellation   = SILABS_QAMAUTO;
+	Silabs_UserInput_Lock();
+}*/
+
+void MyDelay(int nTime)
+{
+	//LARGE_INTEGER SysTimeout;
+	//SysTimeout=RtlConvertLongToLargeInteger((-(LONG)nTime)*1000*10);
+	//KeDelayExecutionThread(KernelMode,FALSE,&SysTimeout);
+	//KeStallExecutionProcessor(nTime*1000);
+	unsigned long usec;
+	do {
+		usec = (nTime > 8000) ? 8000 : nTime;
+		msleep(usec);
+		nTime -= usec;
+		} while (nTime > 0);
+
+	return;
+}
+
+void Si2168_Initial()
+{
+	mode=USB;
+	//custom_status=&(FE_Status);
+	SiLabs_API_SW_Init(&(FrontEnd_Table[0]),0xC8,0xC0);
+	SiLabs_API_HW_Connect(&(FrontEnd_Table[0]),mode);
+	front_end=&(FrontEnd_Table[0]);
+	// Setting default values for 'store' parameters
+	last_standard        = SILABS_DVB_T;
+	last_freq            = 474000000;
+	last_bandwidth_Hz    = 8000000;
+	last_stream          = SILABS_HP;//for DVB-H only
+	last_symbol_rate_bps = 6900000;
+	last_constellation   = SILABS_QAMAUTO;
+	//SiLabs_API_FE_status(front_end,custom_status);
+}
+
+void Delay(int nTime)
+{
+	//LARGE_INTEGER SysTimeout;
+	//SysTimeout=RtlConvertLongToLargeInteger((-(LONG)nTime)*1000*10);
+	//KeDelayExecutionThread(KernelMode,FALSE,&SysTimeout);
+	//KeStallExecutionProcessor(nTime*1000);
+	unsigned long usec;
+	do {
+		usec = (nTime > 8000) ? 8000 : nTime;
+		msleep(usec);
+		nTime -= usec;
+		} while (nTime > 0);
+
+	return;
+}
+
+int Si2168_Data_Update(struct rtl2832_state* p_state,int nStandard,unsigned int nFreq,unsigned int nBandwidth,unsigned int nSymbolrate, int plp_id)
+{
+	int                  lock;
+	int                  freq;
+	int                  bandwidth_Hz;
+	int                  symbol_rate_bps;
+	CUSTOM_Constel_Enum  constellation;
+	CUSTOM_Stream_Enum   stream;
+	int                  standard;
+	//g_pContext=&context->device_control;
+	g_p_state=p_state;
+	if(nStandard==0)
+		standard = SILABS_DVB_T;
+	else if(nStandard==1)
+		standard = SILABS_DVB_T2;
+	else if(nStandard==2)
+		standard = SILABS_DVB_C;
+	else
+		return 0;
+   freq = nFreq;
+	bandwidth_Hz = nBandwidth;
+	stream = SILABS_HP;
+	if(standard==SILABS_DVB_C)
+	{
+		symbol_rate_bps=nSymbolrate;//6900000;
+		constellation=SILABS_QAMAUTO;
+	}
+	//KeWaitForSingleObject((PVOID)(&(g_pContext->EP0Event)), Executive, KernelMode, FALSE, NULL);
+	if(SiLabs_API_switch_to_standard(front_end,standard,0)==0)
+	{
+		//KeSetEvent(&(g_pContext->EP0Event), IO_NO_INCREMENT, FALSE);
+		return 0;
+	}
+	Delay(100);
+	last_standard        = standard;
+	last_freq            = freq;
+	last_bandwidth_Hz    = bandwidth_Hz;
+	last_stream          = stream;
+	last_symbol_rate_bps = symbol_rate_bps;
+	last_constellation   = constellation;
+	lock=SiLabs_API_lock_to_carrier(front_end,standard,freq,bandwidth_Hz,stream,symbol_rate_bps,constellation,plp_id);
+	/*L1_Si2168_Context *api;
+	api=front_end->Si2168_FE->demod;
+	api->prop->dd_ts_mode.mode           = Si2168_DD_TS_MODE_PROP_MODE_SERIAL;
+	api->prop->dd_ts_mode.clock          = Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT;
+	Si2168_L1_SetProperty2(api, Si2168_DD_TS_MODE_PROP_CODE);*/
+	//KeSetEvent(&(g_pContext->EP0Event), IO_NO_INCREMENT, FALSE);
+	return lock;
+}
+
+int Si2168_Check_Status()
+{
+	custom_status=&(FE_Status);
+	SiLabs_API_FE_status(front_end,custom_status);
+	return 0;
+}
diff --git a/drivers/media/usb/rtl2832u/si2168rtl.h b/drivers/media/usb/rtl2832u/si2168rtl.h
new file mode 100644
index 00000000..c3e89705
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/si2168rtl.h
@@ -0,0 +1,6166 @@
+#ifndef __Si2168RTL_H__
+#define __Si2168RTL_H__
+
+typedef enum   CUSTOM_Standard_Enum
+{
+	SILABS_ANALOG = 4,
+	SILABS_DVB_T  = 0,
+	SILABS_DVB_C  = 1,
+	SILABS_DVB_S  = 2,
+	SILABS_DVB_S2 = 3,
+	SILABS_DVB_T2 = 5,
+	SILABS_DSS    = 6
+} CUSTOM_Standard_Enum;
+
+typedef enum   CUSTOM_Constel_Enum
+{
+	SILABS_QAMAUTO = -1,
+	SILABS_QAM16   = 0,
+	SILABS_QAM32   = 1,
+	SILABS_QAM64   = 2,
+	SILABS_QAM128  = 3,
+	SILABS_QAM256  = 4,
+	SILABS_QPSK    = 5,
+	SILABS_8PSK    = 6
+} CUSTOM_Constel_Enum;
+
+typedef enum   CUSTOM_Stream_Enum
+{
+	SILABS_HP = 0,
+	SILABS_LP = 1
+} CUSTOM_Stream_Enum;
+
+typedef enum   CUSTOM_TS_Mode_Enum
+{
+	SILABS_TS_TRISTATE = 0,
+	SILABS_TS_SERIAL   = 1,
+	SILABS_TS_PARALLEL = 2,
+	SILABS_TS_GPIF     = 3
+} CUSTOM_TS_Mode_Enum;
+
+typedef enum   CUSTOM_FFT_Mode_Enum
+{
+	SILABS_FFT_MODE_2K  = 0,
+	SILABS_FFT_MODE_4K  = 1,
+	SILABS_FFT_MODE_8K  = 2,
+	SILABS_FFT_MODE_16K = 3,
+	SILABS_FFT_MODE_32K = 4
+} CUSTOM_FFT_Mode_Enum;
+
+typedef enum   CUSTOM_GI_Enum
+{
+	SILABS_GUARD_INTERVAL_1_32    = 0,
+	SILABS_GUARD_INTERVAL_1_16    = 1,
+	SILABS_GUARD_INTERVAL_1_8     = 2,
+	SILABS_GUARD_INTERVAL_1_4     = 3,
+	SILABS_GUARD_INTERVAL_1_128   = 4,
+	SILABS_GUARD_INTERVAL_19_128  = 5,
+	SILABS_GUARD_INTERVAL_19_256  = 6
+} CUSTOM_GI_Enum;
+
+typedef enum   CUSTOM_Coderate_Enum
+{
+	SILABS_CODERATE_1_2  = 0,
+	SILABS_CODERATE_2_3  = 1,
+	SILABS_CODERATE_3_4  = 2,
+	SILABS_CODERATE_4_5  = 3,
+	SILABS_CODERATE_5_6  = 4,
+	SILABS_CODERATE_7_8  = 5,
+	SILABS_CODERATE_8_9  = 6,
+	SILABS_CODERATE_9_10 = 7,
+	SILABS_CODERATE_1_3  = 8,
+	SILABS_CODERATE_1_4  = 9,
+	SILABS_CODERATE_2_5  = 10,
+	SILABS_CODERATE_3_5  = 11,
+} CUSTOM_Coderate_Enum;
+
+typedef enum   CUSTOM_Hierarchy_Enum
+{
+	SILABS_HIERARCHY_NONE  = 0,
+	SILABS_HIERARCHY_ALFA1 = 1,
+	SILABS_HIERARCHY_ALFA2 = 2,
+	SILABS_HIERARCHY_ALFA4 = 3
+} CUSTOM_Hierarchy_Enum;
+
+typedef enum   CUSTOM_Video_Sys_Enum
+{
+	SILABS_VIDEO_SYS_B  = 0,
+	SILABS_VIDEO_SYS_GH = 1,
+	SILABS_VIDEO_SYS_M  = 2,
+	SILABS_VIDEO_SYS_N  = 3,
+	SILABS_VIDEO_SYS_I  = 4,
+	SILABS_VIDEO_SYS_DK = 5,
+	SILABS_VIDEO_SYS_L  = 6,
+	SILABS_VIDEO_SYS_LP = 7
+} CUSTOM_Video_Sys_Enum;
+
+typedef enum   CUSTOM_Transmission_Mode_Enum
+{
+	SILABS_TRANSMISSION_MODE_TERRESTRIAL = 0,
+	SILABS_TRANSMISSION_MODE_CABLE       = 1
+} CUSTOM_Transmission_Mode_Enum;
+
+typedef enum   CUSTOM_Pilot_Pattern_Enum
+{
+	SILABS_PILOT_PATTERN_PP1 = 1,
+	SILABS_PILOT_PATTERN_PP2 = 2,
+	SILABS_PILOT_PATTERN_PP3 = 3,
+	SILABS_PILOT_PATTERN_PP4 = 4,
+	SILABS_PILOT_PATTERN_PP5 = 5,
+	SILABS_PILOT_PATTERN_PP6 = 6,
+	SILABS_PILOT_PATTERN_PP7 = 7,
+	SILABS_PILOT_PATTERN_PP8 = 8,
+} CUSTOM_Pilot_Pattern_Enum;
+
+typedef enum   CUSTOM_Color_Enum
+{
+	SILABS_COLOR_PAL_NTSC  = 0,
+	SILABS_COLOR_SECAM     = 1
+} CUSTOM_Color_Enum;
+
+typedef enum   CUSTOM_Audio_Sys_Enum
+{
+	SILABS_AUDIO_SYS_DEFAULT         = 0,
+	SILABS_AUDIO_SYS_MONO            = 1,
+	SILABS_AUDIO_SYS_MONO_NICAM      = 2,
+	SILABS_AUDIO_SYS_A2              = 3,
+	SILABS_AUDIO_SYS_A2_DK2          = 4,
+	SILABS_AUDIO_SYS_A2_DK3          = 5,
+	SILABS_AUDIO_SYS_BTSC            = 6,
+	SILABS_AUDIO_SYS_EIAJ            = 7,
+	SILABS_AUDIO_SYS_SCAN            = 8,
+	SILABS_AUDIO_SYS_A2_DK4          = 9,
+	SILABS_AUDIO_SYS_WIDE_SCAN       = 10,
+	SILABS_AUDIO_SYS_MONO_NICAM_6DB  = 11,
+	SILABS_AUDIO_SYS_MONO_NICAM_10DB = 12
+} CUSTOM_Audio_Sys_Enum;
+
+typedef enum CONNECTION_TYPE
+{
+	SIMU = 0,
+	USB,
+	CUSTOMER,
+	none
+} CONNECTION_TYPE;
+
+#define Si2168_TERRESTRIAL 1
+
+typedef struct L0_Context
+{
+	unsigned char   address;
+	int             indexSize;
+	CONNECTION_TYPE connectionType;
+	int             trackWrite;
+	int             trackRead;
+	int             mustReadWithoutStop;
+} L0_Context;
+
+typedef struct
+{ // Si2168_COMMON_REPLY_struct
+	unsigned char   ddint;
+	unsigned char   scanint;
+	unsigned char   err;
+	unsigned char   cts;
+} Si2168_COMMON_REPLY_struct;
+
+#define Si2168_POWER_DOWN_CMD 0x13
+
+#ifdef Si2168_POWER_DOWN_CMD
+	#define Si2168_POWER_DOWN_CMD_CODE 0x010013
+	typedef struct
+	{ // Si2168_POWER_DOWN_CMD_struct
+		unsigned char nothing;
+	} Si2168_POWER_DOWN_CMD_struct;
+	typedef struct
+	{ // Si2168_POWER_DOWN_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_POWER_DOWN_CMD_REPLY_struct;
+#endif // Si2168_POWER_DOWN_CMD
+
+#define Si2168_DD_MODE_PROP 0x100a
+
+#define Si2168_START_CLK_CMD 0xc0
+
+#ifdef Si2168_START_CLK_CMD
+	#define Si2168_START_CLK_CMD_CODE 0x0300c0
+	typedef struct
+	{ // Si2168_START_CLK_CMD_struct
+		unsigned char   subcode;
+		unsigned char   reserved1;
+		unsigned char   tune_cap;
+		unsigned char   reserved2;
+		unsigned int    clk_mode;
+		unsigned char   reserved3;
+		unsigned char   reserved4;
+		unsigned char   start_clk;
+	} Si2168_START_CLK_CMD_struct;
+	typedef struct
+	{ // Si2168_START_CLK_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_START_CLK_CMD_REPLY_struct;
+	// START_CLK command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_SUBCODE_LSB         0
+	#define  Si2168_START_CLK_CMD_SUBCODE_MASK        0xff
+	#define  Si2168_START_CLK_CMD_SUBCODE_MIN         18
+	#define  Si2168_START_CLK_CMD_SUBCODE_MAX         18
+	#define Si2168_START_CLK_CMD_SUBCODE_CODE  18
+	// START_CLK command, RESERVED1 field definition (address 2,size 8, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_RESERVED1_LSB         0
+	#define  Si2168_START_CLK_CMD_RESERVED1_MASK        0xff
+	#define  Si2168_START_CLK_CMD_RESERVED1_MIN         0
+	#define  Si2168_START_CLK_CMD_RESERVED1_MAX         0
+	#define Si2168_START_CLK_CMD_RESERVED1_RESERVED  0
+	// START_CLK command, TUNE_CAP field definition (address 3,size 4, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_TUNE_CAP_LSB         0
+	#define  Si2168_START_CLK_CMD_TUNE_CAP_MASK        0x0f
+	#define  Si2168_START_CLK_CMD_TUNE_CAP_MIN         0
+	#define  Si2168_START_CLK_CMD_TUNE_CAP_MAX         15
+	#define Si2168_START_CLK_CMD_TUNE_CAP_10P4     8
+	#define Si2168_START_CLK_CMD_TUNE_CAP_11P7     9
+	#define Si2168_START_CLK_CMD_TUNE_CAP_13P0     10
+	#define Si2168_START_CLK_CMD_TUNE_CAP_14P3     11
+	#define Si2168_START_CLK_CMD_TUNE_CAP_15P6     12
+	#define Si2168_START_CLK_CMD_TUNE_CAP_16P9     13
+	#define Si2168_START_CLK_CMD_TUNE_CAP_18P2     14
+	#define Si2168_START_CLK_CMD_TUNE_CAP_19P5     15
+	#define Si2168_START_CLK_CMD_TUNE_CAP_1P3      1
+	#define Si2168_START_CLK_CMD_TUNE_CAP_2P6      2
+	#define Si2168_START_CLK_CMD_TUNE_CAP_3P9      3
+	#define Si2168_START_CLK_CMD_TUNE_CAP_5P2      4
+	#define Si2168_START_CLK_CMD_TUNE_CAP_6P5      5
+	#define Si2168_START_CLK_CMD_TUNE_CAP_7P8      6
+	#define Si2168_START_CLK_CMD_TUNE_CAP_9P1      7
+	#define Si2168_START_CLK_CMD_TUNE_CAP_EXT_CLK  0
+	// START_CLK command, RESERVED2 field definition (address 3,size 4, lsb 4, unsigned)
+	#define  Si2168_START_CLK_CMD_RESERVED2_LSB         4
+	#define  Si2168_START_CLK_CMD_RESERVED2_MASK        0x0f
+	#define  Si2168_START_CLK_CMD_RESERVED2_MIN         0
+	#define  Si2168_START_CLK_CMD_RESERVED2_MAX         0
+	#define Si2168_START_CLK_CMD_RESERVED2_RESERVED  0
+	// START_CLK command, CLK_MODE field definition (address 4,size 12, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_CLK_MODE_LSB         0
+	#define  Si2168_START_CLK_CMD_CLK_MODE_MASK        0xfff
+	#define  Si2168_START_CLK_CMD_CLK_MODE_MIN         575
+	#define  Si2168_START_CLK_CMD_CLK_MODE_MAX         3328
+	#define Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO    3328
+	#define Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN  1536
+	#define Si2168_START_CLK_CMD_CLK_MODE_XTAL         575
+	// START_CLK command, RESERVED3 field definition (address 6,size 8, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_RESERVED3_LSB         0
+	#define  Si2168_START_CLK_CMD_RESERVED3_MASK        0xff
+	#define  Si2168_START_CLK_CMD_RESERVED3_MIN         22
+	#define  Si2168_START_CLK_CMD_RESERVED3_MAX         22
+	#define Si2168_START_CLK_CMD_RESERVED3_RESERVED  22
+	// START_CLK command, RESERVED4 field definition (address 7,size 1, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_RESERVED4_LSB         0
+	#define  Si2168_START_CLK_CMD_RESERVED4_MASK        0x01
+	#define  Si2168_START_CLK_CMD_RESERVED4_MIN         0
+	#define  Si2168_START_CLK_CMD_RESERVED4_MAX         0
+	#define Si2168_START_CLK_CMD_RESERVED4_RESERVED  0
+	// START_CLK command, START_CLK field definition (address 12,size 1, lsb 0, unsigned)
+	#define  Si2168_START_CLK_CMD_START_CLK_LSB         0
+	#define  Si2168_START_CLK_CMD_START_CLK_MASK        0x01
+	#define  Si2168_START_CLK_CMD_START_CLK_MIN         0
+	#define  Si2168_START_CLK_CMD_START_CLK_MAX         0
+	#define Si2168_START_CLK_CMD_START_CLK_START_CLK    0//Yann
+#endif // Si2168_START_CLK_CMD
+
+#define Si2168_POWER_UP_CMD 0xc0
+
+#ifdef Si2168_POWER_UP_CMD
+	#define Si2168_POWER_UP_CMD_CODE 0x0200c0
+	typedef struct
+	{ // Si2168_POWER_UP_CMD_struct
+		unsigned char   subcode;
+		unsigned char   reset;
+		unsigned char   reserved2;
+		unsigned char   reserved4;
+		unsigned char   reserved1;
+		unsigned char   addr_mode;
+		unsigned char   reserved5;
+		unsigned char   func;
+		unsigned char   clock_freq;
+		unsigned char   ctsien;
+		unsigned char   wake_up;
+	} Si2168_POWER_UP_CMD_struct;
+	typedef struct
+	{ // Si2168_POWER_UP_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_POWER_UP_CMD_REPLY_struct;
+	// POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_SUBCODE_LSB         0
+	#define  Si2168_POWER_UP_CMD_SUBCODE_MASK        0xff
+	#define  Si2168_POWER_UP_CMD_SUBCODE_MIN         6
+	#define  Si2168_POWER_UP_CMD_SUBCODE_MAX         6
+	#define Si2168_POWER_UP_CMD_SUBCODE_CODE  6
+	// POWER_UP command, RESET field definition (address 2,size 8, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_RESET_LSB         0
+	#define  Si2168_POWER_UP_CMD_RESET_MASK        0xff
+	#define  Si2168_POWER_UP_CMD_RESET_MIN         1
+	#define  Si2168_POWER_UP_CMD_RESET_MAX         8
+	#define Si2168_POWER_UP_CMD_RESET_RESET   1
+	#define Si2168_POWER_UP_CMD_RESET_RESUME  8
+	// POWER_UP command, RESERVED2 field definition (address 3,size 8, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_RESERVED2_LSB         0
+	#define  Si2168_POWER_UP_CMD_RESERVED2_MASK        0xff
+	#define  Si2168_POWER_UP_CMD_RESERVED2_MIN         15
+	#define  Si2168_POWER_UP_CMD_RESERVED2_MAX         15
+	#define Si2168_POWER_UP_CMD_RESERVED2_RESERVED  15
+	// POWER_UP command, RESERVED4 field definition (address 4,size 8, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_RESERVED4_LSB         0
+	#define  Si2168_POWER_UP_CMD_RESERVED4_MASK        0xff
+	#define  Si2168_POWER_UP_CMD_RESERVED4_MIN         0
+	#define  Si2168_POWER_UP_CMD_RESERVED4_MAX         0
+	#define Si2168_POWER_UP_CMD_RESERVED4_RESERVED  0
+	// POWER_UP command, RESERVED1 field definition (address 5,size 4, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_RESERVED1_LSB         0
+	#define  Si2168_POWER_UP_CMD_RESERVED1_MASK        0x0f
+	#define  Si2168_POWER_UP_CMD_RESERVED1_MIN         0
+	#define  Si2168_POWER_UP_CMD_RESERVED1_MAX         0
+	#define Si2168_POWER_UP_CMD_RESERVED1_RESERVED  0
+	// POWER_UP command, ADDR_MODE field definition (address 5,size 1, lsb 4, unsigned)
+	#define  Si2168_POWER_UP_CMD_ADDR_MODE_LSB         4
+	#define  Si2168_POWER_UP_CMD_ADDR_MODE_MASK        0x01
+	#define  Si2168_POWER_UP_CMD_ADDR_MODE_MIN         0
+	#define  Si2168_POWER_UP_CMD_ADDR_MODE_MAX         1
+	#define Si2168_POWER_UP_CMD_ADDR_MODE_CAPTURE  1
+	#define Si2168_POWER_UP_CMD_ADDR_MODE_CURRENT  0//Yann
+	// POWER_UP command, RESERVED5 field definition (address 5,size 1, lsb 5, unsigned)
+	#define  Si2168_POWER_UP_CMD_RESERVED5_LSB         5
+	#define  Si2168_POWER_UP_CMD_RESERVED5_MASK        0x01
+	#define  Si2168_POWER_UP_CMD_RESERVED5_MIN         1
+	#define  Si2168_POWER_UP_CMD_RESERVED5_MAX         1
+	#define Si2168_POWER_UP_CMD_RESERVED5_RESERVED     1//Yann
+	// POWER_UP command, FUNC field definition (address 6,size 4, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_FUNC_LSB         0
+	#define  Si2168_POWER_UP_CMD_FUNC_MASK        0x0f
+	#define  Si2168_POWER_UP_CMD_FUNC_MIN         0
+	#define  Si2168_POWER_UP_CMD_FUNC_MAX         1
+	#define Si2168_POWER_UP_CMD_FUNC_BOOTLOADER  0
+	#define Si2168_POWER_UP_CMD_FUNC_NORMAL      1
+	// POWER_UP command, CLOCK_FREQ field definition (address 6,size 3, lsb 4, unsigned)
+	#define  Si2168_POWER_UP_CMD_CLOCK_FREQ_LSB         4
+	#define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MASK        0x07
+	#define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+	#define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MAX         4
+	#define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ  0
+	#define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+	#define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ  3
+	// POWER_UP command, CTSIEN field definition (address 6,size 1, lsb 7, unsigned)
+	#define  Si2168_POWER_UP_CMD_CTSIEN_LSB         7
+	#define  Si2168_POWER_UP_CMD_CTSIEN_MASK        0x01
+	#define  Si2168_POWER_UP_CMD_CTSIEN_MIN         0
+	#define  Si2168_POWER_UP_CMD_CTSIEN_MAX         1
+	#define Si2168_POWER_UP_CMD_CTSIEN_DISABLE  0
+	#define Si2168_POWER_UP_CMD_CTSIEN_ENABLE   1
+	// POWER_UP command, WAKE_UP field definition (address 7,size 1, lsb 0, unsigned)
+	#define  Si2168_POWER_UP_CMD_WAKE_UP_LSB         0
+	#define  Si2168_POWER_UP_CMD_WAKE_UP_MASK        0x01
+	#define  Si2168_POWER_UP_CMD_WAKE_UP_MIN         1
+	#define  Si2168_POWER_UP_CMD_WAKE_UP_MAX         1
+	#define Si2168_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif // Si2168_POWER_UP_CMD
+
+#define Si2168_PART_INFO_CMD 0x02
+
+#ifdef Si2168_PART_INFO_CMD
+	#define Si2168_PART_INFO_CMD_CODE 0x010002
+	typedef struct
+	{ // Si2168_PART_INFO_CMD_struct
+		unsigned char nothing;
+	} Si2168_PART_INFO_CMD_struct;
+	typedef struct
+	{ // Si2168_PART_INFO_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   chiprev;
+		unsigned char   romid;
+		unsigned char   part;
+		unsigned char   pmajor;
+		unsigned char   pminor;
+		unsigned char   pbuild;
+		unsigned int    reserved;
+		unsigned long   serial;
+	} Si2168_PART_INFO_CMD_REPLY_struct;
+	// PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_CHIPREV_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+	#define Si2168_PART_INFO_RESPONSE_CHIPREV_A  1
+	#define Si2168_PART_INFO_RESPONSE_CHIPREV_B  2
+	// PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_ROMID_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_ROMID_MASK        0xff
+	// PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_PART_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_PART_MASK        0xff
+	// PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_PMAJOR_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+	// PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_PMINOR_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+	// PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_PBUILD_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+	// PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_RESERVED_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+	// PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)
+	#define  Si2168_PART_INFO_RESPONSE_SERIAL_LSB         0
+	#define  Si2168_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+#endif // Si2168_PART_INFO_CMD
+
+#define Si2168_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef Si2168_EXIT_BOOTLOADER_CMD
+	#define Si2168_EXIT_BOOTLOADER_CMD_CODE 0x010001
+	typedef struct
+	{ // Si2168_EXIT_BOOTLOADER_CMD_struct
+		unsigned char   func;
+		unsigned char   ctsien;
+	} Si2168_EXIT_BOOTLOADER_CMD_struct;
+	typedef struct
+	{ // Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct;
+	// EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned)
+	#define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+	#define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+	#define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+	#define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+	#define Si2168_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+	#define Si2168_EXIT_BOOTLOADER_CMD_FUNC_NORMAL      1
+	// EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned)
+	#define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+	#define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+	#define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+	#define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+	#define Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+	#define Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif // Si2168_EXIT_BOOTLOADER_CMD
+
+#define Si2168_DD_MP_DEFAULTS_CMD 0x88
+
+#ifdef Si2168_DD_MP_DEFAULTS_CMD
+	#define Si2168_DD_MP_DEFAULTS_CMD_CODE 0x010088
+	typedef struct
+	{ // Si2168_DD_MP_DEFAULTS_CMD_struct
+		unsigned char   mp_a_mode;
+		unsigned char   mp_b_mode;
+		unsigned char   mp_c_mode;
+		unsigned char   mp_d_mode;
+	} Si2168_DD_MP_DEFAULTS_CMD_struct;
+	typedef struct
+	{ // Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   mp_a_mode;
+		unsigned char   mp_b_mode;
+		unsigned char   mp_c_mode;
+		unsigned char   mp_d_mode;
+	} Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct;
+	// DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1,size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK        0x7f
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MIN         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MAX         3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE    1
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_0    2
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_1    3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_NO_CHANGE  0
+	// DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2,size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK        0x7f
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MIN         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MAX         3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE    1
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_0    2
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_1    3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_NO_CHANGE  0
+	// DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3,size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK        0x7f
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MIN         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MAX         3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE    1
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_0    2
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_1    3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_NO_CHANGE  0
+	// DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4,size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK        0x7f
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MIN         0
+	#define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MAX         3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE    1
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_0    2
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_1    3
+	#define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_NO_CHANGE  0
+	// DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1, size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK        0x7f
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1           3
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1_INVERTED  4
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2           5
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2_INVERTED  6
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DISABLE         0
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_0         1
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_1         2
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF             7
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF_INVERTED    8
+	// DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2, size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK        0x7f
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1           3
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1_INVERTED  4
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2           5
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2_INVERTED  6
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DISABLE         0
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_0         1
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_1         2
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF             7
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF_INVERTED    8
+	// DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3, size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK        0x7f
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1           3
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1_INVERTED  4
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2           5
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2_INVERTED  6
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DISABLE         0
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_0         1
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_1         2
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF             7
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF_INVERTED    8
+	// DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4, size 7, lsb 0, unsigned)
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB         0
+	#define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK        0x7f
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1           3
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1_INVERTED  4
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2           5
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2_INVERTED  6
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DISABLE         0
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_0         1
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_1         2
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF             7
+	#define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF_INVERTED    8
+#endif // Si2168_DD_MP_DEFAULTS_CMD
+
+#define Si2168_CONFIG_PINS_CMD 0x12
+
+#ifdef Si2168_CONFIG_PINS_CMD
+	#define Si2168_CONFIG_PINS_CMD_CODE 0x010012
+	typedef struct
+	{ // Si2168_CONFIG_PINS_CMD_struct
+		unsigned char   gpio0_mode;
+		unsigned char   gpio0_read;
+		unsigned char   gpio1_mode;
+		unsigned char   gpio1_read;
+	} Si2168_CONFIG_PINS_CMD_struct;
+	typedef struct
+	{ // Si2168_CONFIG_PINS_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   gpio0_mode;
+		unsigned char   gpio0_state;
+		unsigned char   gpio1_mode;
+		unsigned char   gpio1_state;
+	} Si2168_CONFIG_PINS_CMD_REPLY_struct;
+	// CONFIG_PINS command, GPIO0_MODE field definition (address 1,size 7, lsb 0, unsigned)
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_LSB         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MASK        0x7f
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MIN         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MAX         8
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DISABLE    1
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_0    2
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_1    3
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK    8
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_INT_FLAG   7
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_NO_CHANGE  0
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_TS_ERR     4
+	// CONFIG_PINS command, GPIO0_READ field definition (address 1,size 1, lsb 7, unsigned)
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_LSB         7
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MASK        0x01
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MIN         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MAX         1
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ  0
+	#define Si2168_CONFIG_PINS_CMD_GPIO0_READ_READ         1
+	// CONFIG_PINS command, GPIO1_MODE field definition (address 2,size 7, lsb 0, unsigned)
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MAX         8
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_HW_LOCK    8
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_INT_FLAG   7
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR     4
+	// CONFIG_PINS command, GPIO1_READ field definition (address 2,size 1, lsb 7, unsigned)
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+	#define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+	#define Si2168_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+	// CONFIG_PINS command, GPIO0_MODE field definition (address 1, size 7, lsb 0, unsigned)
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB         0
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK        0x7f
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DISABLE   1
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_0   2
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_1   3
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_HW_LOCK   8
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_INT_FLAG  7
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_TS_ERR    4
+	// CONFIG_PINS command, GPIO0_STATE field definition (address 1, size 1, lsb 7, unsigned)
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB         7
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK        0x01
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_0  0
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_1  1
+	// CONFIG_PINS command, GPIO1_MODE field definition (address 2, size 7, lsb 0, unsigned)
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE   1
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0   2
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1   3
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_HW_LOCK   8
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_INT_FLAG  7
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_TS_ERR    4
+	// CONFIG_PINS command, GPIO1_STATE field definition (address 2, size 1, lsb 7, unsigned)
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+	#define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+	#define Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+#endif // Si2168_CONFIG_PINS_CMD
+
+#define Si2168_DD_EXT_AGC_TER_CMD 0x89
+
+#ifdef Si2168_DD_EXT_AGC_TER_CMD
+	#define Si2168_DD_EXT_AGC_TER_CMD_CODE 0x010089
+	typedef struct
+	{ // Si2168_DD_EXT_AGC_TER_CMD_struct
+		unsigned char   agc_1_mode;
+		unsigned char   agc_1_inv;
+		unsigned char   agc_2_mode;
+		unsigned char   agc_2_inv;
+		unsigned char   agc_1_kloop;
+		unsigned char   agc_2_kloop;
+		unsigned char   agc_1_min;
+		unsigned char   agc_2_min;
+	} Si2168_DD_EXT_AGC_TER_CMD_struct;
+	typedef struct
+	{ // Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   agc_1_level;
+		unsigned char   agc_2_level;
+	} Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct;
+	// DD_EXT_AGC_TER command, AGC_1_MODE field definition (address 1,size 3, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK        0x07
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MAX         5
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_A       2
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_B       3
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_C       4
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_D       5
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NOT_USED   1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE  0
+	// DD_EXT_AGC_TER command, AGC_1_INV field definition (address 1,size 1, lsb 3, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB         3
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK        0x01
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MAX         1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_INVERTED      1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED  0
+	// DD_EXT_AGC_TER command, AGC_2_MODE field definition (address 1,size 3, lsb 4, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB         4
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK        0x07
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MAX         5
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_A       2
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_B       3
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_C       4
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_D       5
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NOT_USED   1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE  0
+	// DD_EXT_AGC_TER command, AGC_2_INV field definition (address 1,size 1, lsb 7, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB         7
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK        0x01
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MAX         1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_INVERTED      1
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED  0
+	// DD_EXT_AGC_TER command, AGC_1_KLOOP field definition (address 2,size 5, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK        0x1f
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN         6
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MAX         20
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MIN  6
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MAX  20
+	// DD_EXT_AGC_TER command, AGC_2_KLOOP field definition (address 3,size 5, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK        0x1f
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MIN         6
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MAX         20
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MIN  6
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MAX  20
+	// DD_EXT_AGC_TER command, AGC_1_MIN field definition (address 4,size 8, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK        0xff
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MAX         255
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MIN  0
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MAX  255
+	// DD_EXT_AGC_TER command, AGC_2_MIN field definition (address 5,size 8, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK        0xff
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN         0
+	#define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MAX         255
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MIN  0
+	#define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MAX  255
+	// DD_EXT_AGC_TER command, AGC_1_LEVEL field definition (address 1, size 8, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK        0xff
+	// DD_EXT_AGC_TER command, AGC_2_LEVEL field definition (address 2, size 8, lsb 0, unsigned)
+	#define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB         0
+	#define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK        0xff
+#endif // Si2168_DD_EXT_AGC_TER_CMD
+
+#define Si2168_DVBT2_FEF_CMD 0x51
+
+#ifdef Si2168_DVBT2_FEF_CMD
+	#define Si2168_DVBT2_FEF_CMD_CODE 0x010051
+	typedef struct
+	{ // Si2168_DVBT2_FEF_CMD_struct
+		unsigned char   fef_tuner_flag;
+		unsigned char   fef_tuner_flag_inv;
+	} Si2168_DVBT2_FEF_CMD_struct;
+	typedef struct
+	{ // Si2168_DVBT2_FEF_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   fef_type;
+		unsigned long   fef_length;
+		unsigned long   fef_repetition;
+	} Si2168_DVBT2_FEF_CMD_REPLY_struct;
+	// DVBT2_FEF command, FEF_TUNER_FLAG field definition (address 1,size 3, lsb 0, unsigned)
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB         0
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK        0x07
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MIN         0
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MAX         5
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A       2
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B       3
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C       4
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D       5
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED   1
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NO_CHANGE  0
+	// DVBT2_FEF command, FEF_TUNER_FLAG_INV field definition (address 1,size 1, lsb 3, unsigned)
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB         3
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK        0x01
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MIN         0
+	#define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MAX         1
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH  0
+	#define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_LOW   1
+	// DVBT2_FEF command, FEF_TYPE field definition (address 1, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB         0
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK        0x0f
+	// DVBT2_FEF command, FEF_LENGTH field definition (address 4, size 32, lsb 0, unsigned)
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB         0
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK        0xffffffff
+	// DVBT2_FEF command, FEF_REPETITION field definition (address 8, size 32, lsb 0, unsigned)
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB         0
+	#define  Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK        0xffffffff
+#endif // Si2168_DVBT2_FEF_CMD
+
+#define Si2168_SET_PROPERTY_CMD 0x14
+
+#ifdef Si2168_SET_PROPERTY_CMD
+	#define Si2168_SET_PROPERTY_CMD_CODE 0x010014
+	typedef struct
+	{ // Si2168_SET_PROPERTY_CMD_struct
+		unsigned char   reserved;
+		unsigned int    prop;
+		unsigned int    data;
+	} Si2168_SET_PROPERTY_CMD_struct;
+	typedef struct
+	{ // Si2168_SET_PROPERTY_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   reserved;
+		unsigned int    data;
+	} Si2168_SET_PROPERTY_CMD_REPLY_struct;
+	// SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2168_SET_PROPERTY_CMD_RESERVED_LSB         0
+	#define  Si2168_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+	#define  Si2168_SET_PROPERTY_CMD_RESERVED_MIN         0
+	#define  Si2168_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+	// SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned)
+	#define  Si2168_SET_PROPERTY_CMD_PROP_LSB         0
+	#define  Si2168_SET_PROPERTY_CMD_PROP_MASK        0xffff
+	#define  Si2168_SET_PROPERTY_CMD_PROP_MIN         0
+	#define  Si2168_SET_PROPERTY_CMD_PROP_MAX         65535
+	#define Si2168_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+	#define Si2168_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+	// SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned)
+	#define  Si2168_SET_PROPERTY_CMD_DATA_LSB         0
+	#define  Si2168_SET_PROPERTY_CMD_DATA_MASK        0xffff
+	#define  Si2168_SET_PROPERTY_CMD_DATA_MIN         0
+	#define  Si2168_SET_PROPERTY_CMD_DATA_MAX         65535
+	#define Si2168_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+	#define Si2168_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+	// SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)
+	#define  Si2168_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+	#define  Si2168_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+	#define Si2168_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+	#define Si2168_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+	// SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)
+	#define  Si2168_SET_PROPERTY_RESPONSE_DATA_LSB         0
+	#define  Si2168_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+#endif // Si2168_SET_PROPERTY_CMD
+
+#define Si2168_DD_RESTART_CMD 0x85
+
+#ifdef Si2168_DD_RESTART_CMD
+	#define Si2168_DD_RESTART_CMD_CODE 0x010085
+	typedef struct
+	{ // Si2168_DD_RESTART_CMD_struct
+		unsigned char   nothing;
+	} Si2168_DD_RESTART_CMD_struct;
+	typedef struct
+	{ // Si2168_DD_RESTART_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_DD_RESTART_CMD_REPLY_struct;
+#endif // Si2168_DD_RESTART_CMD
+
+#define Si2168_DVBT_STATUS_CMD 0xa0
+
+#ifdef Si2168_DVBT_STATUS_CMD
+	#define Si2168_DVBT_STATUS_CMD_CODE 0x0100a0
+	typedef struct
+	{ // Si2168_DVBT_STATUS_CMD_struct
+		unsigned char   intack;
+	} Si2168_DVBT_STATUS_CMD_struct;
+	typedef struct
+	{ // Si2168_DVBT_STATUS_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   pclint;
+		unsigned char   dlint;
+		unsigned char   berint;
+		unsigned char   uncorint;
+		unsigned char   notdvbtint;
+		unsigned char   fft_mode;
+		unsigned char   guard_int;
+		unsigned char   hierarchy;
+		         char   tps_length;
+		unsigned char   pcl;
+		unsigned char   dl;
+		unsigned char   ber;
+		unsigned char   uncor;
+		unsigned char   notdvbt;
+		unsigned char   cnr;
+		         int    afc_freq;
+		         int    timing_offset;
+		unsigned char   constellation;
+		unsigned char   sp_inv;
+		unsigned char   rate_hp;
+		unsigned char   rate_lp;
+	} Si2168_DVBT_STATUS_CMD_REPLY_struct;
+	// DVBT_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_CMD_INTACK_LSB         0
+	#define  Si2168_DVBT_STATUS_CMD_INTACK_MASK        0x01
+	#define  Si2168_DVBT_STATUS_CMD_INTACK_MIN         0
+	#define  Si2168_DVBT_STATUS_CMD_INTACK_MAX         1
+	#define Si2168_DVBT_STATUS_CMD_INTACK_CLEAR  1
+	#define Si2168_DVBT_STATUS_CMD_INTACK_OK     0
+	// DVBT_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_PCLINT_LSB         1
+	#define  Si2168_DVBT_STATUS_RESPONSE_PCLINT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_PCLINT_CHANGED    1
+	#define Si2168_DVBT_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+	// DVBT_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_DLINT_LSB         2
+	#define  Si2168_DVBT_STATUS_RESPONSE_DLINT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_DLINT_CHANGED    1
+	#define Si2168_DVBT_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+	// DVBT_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_BERINT_LSB         3
+	#define  Si2168_DVBT_STATUS_RESPONSE_BERINT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_BERINT_CHANGED    1
+	#define Si2168_DVBT_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+	// DVBT_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_UNCORINT_LSB         4
+	#define  Si2168_DVBT_STATUS_RESPONSE_UNCORINT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_UNCORINT_CHANGED    1
+	#define Si2168_DVBT_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+	// DVBT_STATUS command, NOTDVBTINT field definition (address 1, size 1, lsb 5, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB         5
+	#define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_CHANGED    1
+	#define Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_NO_CHANGE  0
+	// DVBT_STATUS command, FFT_MODE field definition (address 10, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+	#define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_2K  11
+	#define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_4K  12
+	#define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_8K  13
+	// DVBT_STATUS command, GUARD_INT field definition (address 10, size 3, lsb 4, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_LSB         4
+	#define  Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+	#define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_16  2
+	#define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_32  1
+	#define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_4   4
+	#define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_8   3
+	// DVBT_STATUS command, HIERARCHY field definition (address 11, size 3, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_MASK        0x07
+	#define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1  2
+	#define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2  3
+	#define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4  5
+	#define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_NONE   1
+	// DVBT_STATUS command, TPS_LENGTH field definition (address 12, size 7, lsb 0, signed)
+	#define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK        0x7f
+	#define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT       25
+	// DVBT_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_PCL_LSB         1
+	#define  Si2168_DVBT_STATUS_RESPONSE_PCL_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_PCL_LOCKED   1
+	#define Si2168_DVBT_STATUS_RESPONSE_PCL_NO_LOCK  0
+	// DVBT_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_DL_LSB         2
+	#define  Si2168_DVBT_STATUS_RESPONSE_DL_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_DL_LOCKED   1
+	#define Si2168_DVBT_STATUS_RESPONSE_DL_NO_LOCK  0
+	// DVBT_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_BER_LSB         3
+	#define  Si2168_DVBT_STATUS_RESPONSE_BER_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_BER_BER_ABOVE  1
+	#define Si2168_DVBT_STATUS_RESPONSE_BER_BER_BELOW  0
+	// DVBT_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_UNCOR_LSB         4
+	#define  Si2168_DVBT_STATUS_RESPONSE_UNCOR_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+	#define Si2168_DVBT_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+	// DVBT_STATUS command, NOTDVBT field definition (address 2, size 1, lsb 5, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_LSB         5
+	#define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_DVBT      0
+	#define Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_NOT_DVBT  1
+	// DVBT_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_CNR_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_CNR_MASK        0xff
+	// DVBT_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)
+	#define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+	#define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+	// DVBT_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)
+	#define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+	#define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+	// DVBT_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+	#define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM16  7
+	#define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM64  9
+	#define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QPSK   3
+	// DVBT_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_SP_INV_LSB         6
+	#define  Si2168_DVBT_STATUS_RESPONSE_SP_INV_MASK        0x01
+	#define Si2168_DVBT_STATUS_RESPONSE_SP_INV_INVERTED  1
+	#define Si2168_DVBT_STATUS_RESPONSE_SP_INV_NORMAL    0
+	// DVBT_STATUS command, RATE_HP field definition (address 9, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_RATE_HP_LSB         0
+	#define  Si2168_DVBT_STATUS_RESPONSE_RATE_HP_MASK        0x0f
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_1_2  1
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_2_3  2
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_3_4  3
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_5_6  5
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_7_8  7
+	// DVBT_STATUS command, RATE_LP field definition (address 9, size 4, lsb 4, unsigned)
+	#define  Si2168_DVBT_STATUS_RESPONSE_RATE_LP_LSB         4
+	#define  Si2168_DVBT_STATUS_RESPONSE_RATE_LP_MASK        0x0f
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_1_2  1
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_2_3  2
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_3_4  3
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_5_6  5
+	#define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_7_8  7
+
+#endif // Si2168_DVBT_STATUS_CMD
+
+// Si2168_DVBT2_PLP_SELECT command definition
+#define   Si2168_DVBT2_PLP_SELECT_CMD 0x52
+
+#ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+  #define Si2168_DVBT2_PLP_SELECT_CMD_CODE 0x010052
+
+    typedef struct { // Si2168_DVBT2_PLP_SELECT_CMD_struct
+     unsigned char   plp_id;
+     unsigned char   plp_id_sel_mode;
+   } Si2168_DVBT2_PLP_SELECT_CMD_struct;
+
+
+    typedef struct { // Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct;
+
+   // DVBT2_PLP_SELECT command, PLP_ID field definition (address 1,size 8, lsb 0, unsigned)
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK        0xff
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MIN         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MAX         255.0
+   // DVBT2_PLP_SELECT command, PLP_ID_SEL_MODE field definition (address 2,size 1, lsb 0, unsigned)
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK        0x01
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MIN         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MAX         1
+    #define Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO    0
+    #define Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL  1
+#endif // Si2168_DVBT2_PLP_SELECT_CMD
+
+#define Si2168_DVBT2_STATUS_CMD 0x50
+
+#ifdef Si2168_DVBT2_STATUS_CMD
+	#define Si2168_DVBT2_STATUS_CMD_CODE 0x010050
+	typedef struct
+	{ // Si2168_DVBT2_STATUS_CMD_struct
+		unsigned char   intack;
+	} Si2168_DVBT2_STATUS_CMD_struct;
+	typedef struct
+	{ // Si2168_DVBT2_STATUS_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   pclint;
+		unsigned char   dlint;
+		unsigned char   berint;
+		unsigned char   uncorint;
+		unsigned char   notdvbt2int;
+		unsigned char   num_plp;
+		unsigned char   pilot_pattern;
+		unsigned char   tx_mode;
+		unsigned char   rotated;
+		unsigned char   short_frame;
+		unsigned char   code_rate;
+		unsigned char   plp_id;
+		unsigned char   pcl;
+		unsigned char   dl;
+		unsigned char   ber;
+		unsigned char   uncor;
+		unsigned char   notdvbt2;
+		unsigned char   cnr;
+		         int    afc_freq;
+		         int    timing_offset;
+		unsigned char   constellation;
+		unsigned char   sp_inv;
+		unsigned char   fef;
+		unsigned char   fft_mode;
+		unsigned char   guard_int;
+		unsigned char   bw_ext;
+	} Si2168_DVBT2_STATUS_CMD_REPLY_struct;
+	// DVBT2_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_CMD_INTACK_LSB         0
+	#define  Si2168_DVBT2_STATUS_CMD_INTACK_MASK        0x01
+	#define  Si2168_DVBT2_STATUS_CMD_INTACK_MIN         0
+	#define  Si2168_DVBT2_STATUS_CMD_INTACK_MAX         1
+	#define Si2168_DVBT2_STATUS_CMD_INTACK_CLEAR  1
+	#define Si2168_DVBT2_STATUS_CMD_INTACK_OK     0
+	// DVBT2_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PCLINT_LSB         1
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PCLINT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_PCLINT_CHANGED    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+	// DVBT2_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_DLINT_LSB         2
+	#define  Si2168_DVBT2_STATUS_RESPONSE_DLINT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_DLINT_CHANGED    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+	// DVBT2_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BERINT_LSB         3
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BERINT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_BERINT_CHANGED    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+	// DVBT2_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_LSB         4
+	#define  Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_CHANGED    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+	// DVBT2_STATUS command, NOTDVBT2INT field definition (address 1, size 1, lsb 5, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB         5
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_CHANGED    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_NO_CHANGE  0
+	// DVBT2_STATUS command, NUM_PLP field definition (address 10, size 8, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK        0xff
+	// DVBT2_STATUS command, PILOT_PATTERN field definition (address 11, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK        0x0f
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP1  0
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP2  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP3  2
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP4  3
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP5  4
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP6  5
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP7  6
+	#define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP8  7
+	// DVBT2_STATUS command, TX_MODE field definition (address 11, size 1, lsb 4, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_LSB         4
+	#define  Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MISO  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_SISO  0
+	// DVBT2_STATUS command, ROTATED field definition (address 11, size 1, lsb 5, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_ROTATED_LSB         5
+	#define  Si2168_DVBT2_STATUS_RESPONSE_ROTATED_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_ROTATED_NORMAL   0
+	#define Si2168_DVBT2_STATUS_RESPONSE_ROTATED_ROTATED  1
+	// DVBT2_STATUS command, SHORT_FRAME field definition (address 11, size 1, lsb 6, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB         6
+	#define  Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_16K_LDPC  0
+	#define Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_64K_LDPC  1
+	// DVBT2_STATUS command, CODE_RATE field definition (address 12, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK        0x0f
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_1_2  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_2_3  2
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_3_4  3
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_3_5  13
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_4_5  4
+	#define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_5_6  5
+	// DVBT2_STATUS command, PLP_ID field definition (address 13, size 8, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        0xff
+	// DVBT2_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PCL_LSB         1
+	#define  Si2168_DVBT2_STATUS_RESPONSE_PCL_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_PCL_LOCKED   1
+	#define Si2168_DVBT2_STATUS_RESPONSE_PCL_NO_LOCK  0
+	// DVBT2_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_DL_LSB         2
+	#define  Si2168_DVBT2_STATUS_RESPONSE_DL_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_DL_LOCKED   1
+	#define Si2168_DVBT2_STATUS_RESPONSE_DL_NO_LOCK  0
+	// DVBT2_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BER_LSB         3
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BER_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_BER_BER_ABOVE  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_BER_BER_BELOW  0
+	// DVBT2_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_UNCOR_LSB         4
+	#define  Si2168_DVBT2_STATUS_RESPONSE_UNCOR_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+	#define Si2168_DVBT2_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+	// DVBT2_STATUS command, NOTDVBT2 field definition (address 2, size 1, lsb 5, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB         5
+	#define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_DVBT2      0
+	#define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_NOT_DVBT2  1
+	// DVBT2_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CNR_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CNR_MASK        0xff
+	// DVBT2_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+	#define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+	// DVBT2_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+	#define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+	// DVBT2_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM128  10
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM16   7
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM32   8
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+	#define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QPSK    3
+	// DVBT2_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_SP_INV_LSB         6
+	#define  Si2168_DVBT2_STATUS_RESPONSE_SP_INV_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_SP_INV_INVERTED  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_SP_INV_NORMAL    0
+	// DVBT2_STATUS command, FEF field definition (address 8, size 1, lsb 7, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_FEF_LSB         7
+	#define  Si2168_DVBT2_STATUS_RESPONSE_FEF_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_FEF_FEF     1
+	#define Si2168_DVBT2_STATUS_RESPONSE_FEF_NO_FEF  0
+	// DVBT2_STATUS command, FFT_MODE field definition (address 9, size 4, lsb 0, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB         0
+	#define  Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_16K  14
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_1K   10
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_2K   11
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_32K  15
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_4K   12
+	#define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_8K   13
+	// DVBT2_STATUS command, GUARD_INT field definition (address 9, size 3, lsb 4, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB         4
+	#define  Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128  6
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256  7
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128   5
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16    2
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32    1
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4     4
+	#define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8     3
+	// DVBT2_STATUS command, BW_EXT field definition (address 9, size 1, lsb 7, unsigned)
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_LSB         7
+	#define  Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        0x01
+	#define Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_EXTENDED  1
+	#define Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_NORMAL    0
+#endif // Si2168_DVBT2_STATUS_CMD
+
+/* Si2168_DD_SET_REG command definition */
+#define   Si2168_DD_SET_REG_CMD 0x8e
+
+#ifdef    Si2168_DD_SET_REG_CMD
+  #define Si2168_DD_SET_REG_CMD_CODE 0x01008e
+
+    typedef struct { /* Si2168_DD_SET_REG_CMD_struct */
+     unsigned char   reg_code_lsb;
+     unsigned char   reg_code_mid;
+     unsigned char   reg_code_msb;
+     unsigned long   value;
+   } Si2168_DD_SET_REG_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_SET_REG_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DD_SET_REG_CMD_REPLY_struct;
+
+   /* DD_SET_REG command, REG_CODE_LSB field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MAX  255
+   /* DD_SET_REG command, REG_CODE_MID field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MAX  255
+   /* DD_SET_REG command, REG_CODE_MSB field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MAX  255
+   /* DD_SET_REG command, VALUE field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_VALUE_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MASK        0xffffffff
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MAX         4294967295
+    #define Si2168_DD_SET_REG_CMD_VALUE_VALUE_MIN  0
+    #define Si2168_DD_SET_REG_CMD_VALUE_VALUE_MAX  4294967295
+#endif /* Si2168_DD_SET_REG_CMD */
+
+/* Si2168_DD_SSI_SQI command definition */
+#define   Si2168_DD_SSI_SQI_CMD 0x8b
+
+// Si2168_DD_SSI_SQI command definition
+#define   Si2168_DD_SSI_SQI_CMD 0x8b
+
+#ifdef Si2168_DD_SSI_SQI_CMD
+	#define Si2168_DD_SSI_SQI_CMD_CODE 0x01008b
+	typedef struct
+	{ // Si2168_DD_SSI_SQI_CMD_struct
+		char   tuner_rssi;
+	} Si2168_DD_SSI_SQI_CMD_struct;
+	typedef struct
+	{ // Si2168_DD_SSI_SQI_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char ssi;
+		char   sqi;
+	} Si2168_DD_SSI_SQI_CMD_REPLY_struct;
+	// DD_SSI_SQI command, TUNER_RSSI field definition (address 1,size 8, lsb 0, unsigned signed)
+	#define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_LSB         0
+	#define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MASK        0xff
+	#define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_SHIFT       24
+	#define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MIN         -128.0
+	#define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MAX         127.0
+	// DD_SSI_SQI command, SSI field definition (address 1, size 8, lsb 0, signed)
+	#define  Si2168_DD_SSI_SQI_RESPONSE_SSI_LSB         0
+	#define  Si2168_DD_SSI_SQI_RESPONSE_SSI_MASK        0xff
+	#define Si2168_DD_SSI_SQI_RESPONSE_SSI_SSI_MIN  0
+	#define Si2168_DD_SSI_SQI_RESPONSE_SSI_SSI_MAX  100
+	// DD_SSI_SQI command, SQI field definition (address 2, size 8, lsb 0, signed)
+	#define  Si2168_DD_SSI_SQI_RESPONSE_SQI_LSB         0
+	#define  Si2168_DD_SSI_SQI_RESPONSE_SQI_MASK        0xff
+	#define  Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT       24
+	#define Si2168_DD_SSI_SQI_RESPONSE_SQI_SQI_MIN  -1
+	#define Si2168_DD_SSI_SQI_RESPONSE_SQI_SQI_MAX  100
+
+#endif // Si2168_DD_SSI_SQI_CMD
+
+#define Si2168_DD_STATUS_CMD 0x87
+
+#ifdef Si2168_DD_STATUS_CMD
+	#define Si2168_DD_STATUS_CMD_CODE 0x010087
+	typedef struct
+	{ // Si2168_DD_STATUS_CMD_struct
+		unsigned char   intack;
+	} Si2168_DD_STATUS_CMD_struct;
+	typedef struct
+	{ // Si2168_DD_STATUS_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+		unsigned char   pclint;
+		unsigned char   dlint;
+		unsigned char   berint;
+		unsigned char   uncorint;
+		unsigned char   rsqint_bit5;
+		unsigned char   rsqint_bit6;
+		unsigned char   rsqint_bit7;
+		unsigned char   pcl;
+		unsigned char   dl;
+		unsigned char   ber;
+		unsigned char   uncor;
+		unsigned char   rsqstat_bit5;
+		unsigned char   rsqstat_bit6;
+		unsigned char   rsqstat_bit7;
+		unsigned char   modulation;
+		unsigned int    ts_bit_rate;
+		unsigned int    ts_clk_freq;
+	} Si2168_DD_STATUS_CMD_REPLY_struct;
+	// DD_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned)
+	#define  Si2168_DD_STATUS_CMD_INTACK_LSB         0
+	#define  Si2168_DD_STATUS_CMD_INTACK_MASK        0x01
+	#define  Si2168_DD_STATUS_CMD_INTACK_MIN         0
+	#define  Si2168_DD_STATUS_CMD_INTACK_MAX         1
+	#define Si2168_DD_STATUS_CMD_INTACK_CLEAR  1
+	#define Si2168_DD_STATUS_CMD_INTACK_OK     0
+	// DD_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_PCLINT_LSB         1
+	#define  Si2168_DD_STATUS_RESPONSE_PCLINT_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_PCLINT_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+	// DD_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_DLINT_LSB         2
+	#define  Si2168_DD_STATUS_RESPONSE_DLINT_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_DLINT_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+	// DD_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_BERINT_LSB         3
+	#define  Si2168_DD_STATUS_RESPONSE_BERINT_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_BERINT_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+	// DD_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_UNCORINT_LSB         4
+	#define  Si2168_DD_STATUS_RESPONSE_UNCORINT_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_UNCORINT_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+	// DD_STATUS command, RSQINT_BIT5 field definition (address 1, size 1, lsb 5, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB         5
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_NO_CHANGE  0
+	// DD_STATUS command, RSQINT_BIT6 field definition (address 1, size 1, lsb 6, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB         6
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_NO_CHANGE  0
+	// DD_STATUS command, RSQINT_BIT7 field definition (address 1, size 1, lsb 7, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB         7
+	#define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_CHANGED    1
+	#define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_NO_CHANGE  0
+	// DD_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_PCL_LSB         1
+	#define  Si2168_DD_STATUS_RESPONSE_PCL_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_PCL_LOCKED   1
+	#define Si2168_DD_STATUS_RESPONSE_PCL_NO_LOCK  0
+	// DD_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_DL_LSB         2
+	#define  Si2168_DD_STATUS_RESPONSE_DL_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_DL_LOCKED   1
+	#define Si2168_DD_STATUS_RESPONSE_DL_NO_LOCK  0
+	// DD_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_BER_LSB         3
+	#define  Si2168_DD_STATUS_RESPONSE_BER_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_BER_BER_ABOVE  1
+	#define Si2168_DD_STATUS_RESPONSE_BER_BER_BELOW  0
+	// DD_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_UNCOR_LSB         4
+	#define  Si2168_DD_STATUS_RESPONSE_UNCOR_MASK        0x01
+	#define Si2168_DD_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+	#define Si2168_DD_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+	// DD_STATUS command, RSQSTAT_BIT5 field definition (address 2, size 1, lsb 5, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB         5
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK        0x01
+	// DD_STATUS command, RSQSTAT_BIT6 field definition (address 2, size 1, lsb 6, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB         6
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK        0x01
+	// DD_STATUS command, RSQSTAT_BIT7 field definition (address 2, size 1, lsb 7, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB         7
+	#define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK        0x01
+	// DD_STATUS command, MODULATION field definition (address 3, size 4, lsb 0, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_MODULATION_LSB         0
+	#define  Si2168_DD_STATUS_RESPONSE_MODULATION_MASK        0x0f
+	#define Si2168_DD_STATUS_RESPONSE_MODULATION_DSS     10
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBC    3
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBS    8
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBS2   9
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBT    2
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBT2   7
+	// DD_STATUS command, TS_BIT_RATE field definition (address 4, size 16, lsb 0, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB         0
+	#define  Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK        0xffff
+	// DD_STATUS command, TS_CLK_FREQ field definition (address 6, size 16, lsb 0, unsigned)
+	#define  Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB         0
+	#define  Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK        0xffff
+#endif // Si2168_DD_STATUS_CMD
+
+/* Si2168_DVBT_TPS_EXTRA command definition */
+#define   Si2168_DVBT_TPS_EXTRA_CMD 0xa1
+
+#ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+  #define Si2168_DVBT_TPS_EXTRA_CMD_CODE 0x0100a1
+
+    typedef struct { /* Si2168_DVBT_TPS_EXTRA_CMD_struct */
+         unsigned char   nothing;   } Si2168_DVBT_TPS_EXTRA_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   lptimeslice;
+      unsigned char   hptimeslice;
+      unsigned char   lpmpefec;
+      unsigned char   hpmpefec;
+      unsigned char   dvbhinter;
+               int    cell_id;
+      unsigned char   tps_res1;
+      unsigned char   tps_res2;
+      unsigned char   tps_res3;
+      unsigned char   tps_res4;
+   }  Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct;
+
+   /* DVBT_TPS_EXTRA command, LPTIMESLICE field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_ON   1
+   /* DVBT_TPS_EXTRA command, HPTIMESLICE field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB         1
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_ON   1
+   /* DVBT_TPS_EXTRA command, LPMPEFEC field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB         2
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_ON   1
+   /* DVBT_TPS_EXTRA command, HPMPEFEC field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB         3
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_ON   1
+   /* DVBT_TPS_EXTRA command, DVBHINTER field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_IN_DEPTH  1
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_NATIVE    0
+   /* DVBT_TPS_EXTRA command, CELL_ID field definition (address 2, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK        0xffff
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT       16
+   /* DVBT_TPS_EXTRA command, TPS_RES1 field definition (address 4, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES2 field definition (address 4, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES3 field definition (address 5, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES4 field definition (address 5, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK        0x0f
+
+#endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+#define Si2168_I2C_PASSTHROUGH_CMD 0xc0
+
+#ifdef Si2168_I2C_PASSTHROUGH_CMD
+	#define Si2168_I2C_PASSTHROUGH_CMD_CODE 0x0100c0
+	typedef struct
+	{ // Si2168_I2C_PASSTHROUGH_CMD_struct
+		unsigned char   subcode;
+		unsigned char   i2c_passthru;
+		unsigned char   reserved;
+	} Si2168_I2C_PASSTHROUGH_CMD_struct;
+	typedef struct
+	{ // Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct
+		Si2168_COMMON_REPLY_struct * STATUS;
+	} Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct;
+	// I2C_PASSTHROUGH command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_LSB         0
+	#define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MASK        0xff
+	#define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MIN         13
+	#define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MAX         13
+	#define Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE  13
+	// I2C_PASSTHROUGH command, I2C_PASSTHRU field definition (address 2,size 1, lsb 0, unsigned)
+	#define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB         0
+	#define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK        0x01
+	#define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MIN         0
+	#define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MAX         1
+	#define Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE  1
+	#define Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN   0
+	// I2C_PASSTHROUGH command, RESERVED field definition (address 2,size 7, lsb 1, unsigned)
+	#define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_LSB         1
+	#define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MASK        0x7f
+	#define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MIN         0
+	#define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MAX         0
+	#define Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED  0
+#endif // Si2168_I2C_PASSTHROUGH_CMD
+
+typedef struct
+{ // Si2168_CmdObj struct
+	#ifdef    Si2168_CONFIG_CLKIO_CMD
+			  Si2168_CONFIG_CLKIO_CMD_struct               config_clkio;
+	#endif /* Si2168_CONFIG_CLKIO_CMD */
+	#ifdef    Si2168_CONFIG_PINS_CMD
+			  Si2168_CONFIG_PINS_CMD_struct                config_pins;
+	#endif /* Si2168_CONFIG_PINS_CMD */
+	#ifdef    Si2168_DD_BER_CMD
+			  Si2168_DD_BER_CMD_struct                     dd_ber;
+	#endif /* Si2168_DD_BER_CMD */
+	#ifdef    Si2168_DD_CBER_CMD
+			  Si2168_DD_CBER_CMD_struct                    dd_cber;
+	#endif /* Si2168_DD_CBER_CMD */
+
+	#ifdef    Si2168_DD_EXT_AGC_TER_CMD
+			  Si2168_DD_EXT_AGC_TER_CMD_struct             dd_ext_agc_ter;
+	#endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+	#ifdef    Si2168_DD_FER_CMD
+			  Si2168_DD_FER_CMD_struct                     dd_fer;
+	#endif /* Si2168_DD_FER_CMD */
+	#ifdef    Si2168_DD_GET_REG_CMD
+			  Si2168_DD_GET_REG_CMD_struct                 dd_get_reg;
+	#endif /* Si2168_DD_GET_REG_CMD */
+	#ifdef    Si2168_DD_MP_DEFAULTS_CMD
+			  Si2168_DD_MP_DEFAULTS_CMD_struct             dd_mp_defaults;
+	#endif /* Si2168_DD_MP_DEFAULTS_CMD */
+	#ifdef    Si2168_DD_PER_CMD
+			  Si2168_DD_PER_CMD_struct                     dd_per;
+	#endif /* Si2168_DD_PER_CMD */
+	#ifdef    Si2168_DD_RESTART_CMD
+			  Si2168_DD_RESTART_CMD_struct                 dd_restart;
+	#endif /* Si2168_DD_RESTART_CMD */
+	#ifdef    Si2168_DD_SET_REG_CMD
+			  Si2168_DD_SET_REG_CMD_struct                 dd_set_reg;
+	#endif /* Si2168_DD_SET_REG_CMD */
+	#ifdef    Si2168_DD_SSI_SQI_CMD
+			  Si2168_DD_SSI_SQI_CMD_struct                 dd_ssi_sqi;
+	#endif /* Si2168_DD_SSI_SQI_CMD */
+	#ifdef    Si2168_DD_STATUS_CMD
+			  Si2168_DD_STATUS_CMD_struct                  dd_status;
+	#endif /* Si2168_DD_STATUS_CMD */
+	#ifdef    Si2168_DD_UNCOR_CMD
+			  Si2168_DD_UNCOR_CMD_struct                   dd_uncor;
+	#endif /* Si2168_DD_UNCOR_CMD */
+	#ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+			  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_struct  download_dataset_continue;
+	#endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+	#ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+			  Si2168_DOWNLOAD_DATASET_START_CMD_struct     download_dataset_start;
+	#endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+	#ifdef    Si2168_DVBC_STATUS_CMD
+			  Si2168_DVBC_STATUS_CMD_struct                dvbc_status;
+	#endif /* Si2168_DVBC_STATUS_CMD */
+
+	#ifdef    Si2168_DVBT2_FEF_CMD
+			  Si2168_DVBT2_FEF_CMD_struct                  dvbt2_fef;
+	#endif /* Si2168_DVBT2_FEF_CMD */
+	#ifdef    Si2168_DVBT2_PLP_INFO_CMD
+			  Si2168_DVBT2_PLP_INFO_CMD_struct             dvbt2_plp_info;
+	#endif /* Si2168_DVBT2_PLP_INFO_CMD */
+	#ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+			  Si2168_DVBT2_PLP_SELECT_CMD_struct           dvbt2_plp_select;
+	#endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+	#ifdef    Si2168_DVBT2_STATUS_CMD
+			  Si2168_DVBT2_STATUS_CMD_struct               dvbt2_status;
+	#endif /* Si2168_DVBT2_STATUS_CMD */
+	#ifdef    Si2168_DVBT2_TX_ID_CMD
+			  Si2168_DVBT2_TX_ID_CMD_struct                dvbt2_tx_id;
+	#endif /* Si2168_DVBT2_TX_ID_CMD */
+
+	#ifdef    Si2168_DVBT_STATUS_CMD
+			  Si2168_DVBT_STATUS_CMD_struct                dvbt_status;
+	#endif /* Si2168_DVBT_STATUS_CMD */
+	#ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+			  Si2168_DVBT_TPS_EXTRA_CMD_struct             dvbt_tps_extra;
+	#endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+	#ifdef    Si2168_EXIT_BOOTLOADER_CMD
+			  Si2168_EXIT_BOOTLOADER_CMD_struct            exit_bootloader;
+	#endif /* Si2168_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2168_GET_PROPERTY_CMD
+			  Si2168_GET_PROPERTY_CMD_struct               get_property;
+	#endif /* Si2168_GET_PROPERTY_CMD */
+	#ifdef    Si2168_GET_REV_CMD
+			  Si2168_GET_REV_CMD_struct                    get_rev;
+	#endif /* Si2168_GET_REV_CMD */
+	#ifdef    Si2168_I2C_PASSTHROUGH_CMD
+			  Si2168_I2C_PASSTHROUGH_CMD_struct            i2c_passthrough;
+	#endif /* Si2168_I2C_PASSTHROUGH_CMD */
+	#ifdef    Si2168_PART_INFO_CMD
+			  Si2168_PART_INFO_CMD_struct                  part_info;
+	#endif /* Si2168_PART_INFO_CMD */
+	#ifdef    Si2168_POWER_DOWN_CMD
+			  Si2168_POWER_DOWN_CMD_struct                 power_down;
+	#endif /* Si2168_POWER_DOWN_CMD */
+	#ifdef    Si2168_POWER_UP_CMD
+			  Si2168_POWER_UP_CMD_struct                   power_up;
+	#endif /* Si2168_POWER_UP_CMD */
+	#ifdef    Si2168_RSSI_ADC_CMD
+			  Si2168_RSSI_ADC_CMD_struct                   rssi_adc;
+	#endif /* Si2168_RSSI_ADC_CMD */
+	#ifdef    Si2168_SCAN_CTRL_CMD
+			  Si2168_SCAN_CTRL_CMD_struct                  scan_ctrl;
+	#endif /* Si2168_SCAN_CTRL_CMD */
+	#ifdef    Si2168_SCAN_STATUS_CMD
+			  Si2168_SCAN_STATUS_CMD_struct                scan_status;
+	#endif /* Si2168_SCAN_STATUS_CMD */
+	#ifdef    Si2168_SET_PROPERTY_CMD
+			  Si2168_SET_PROPERTY_CMD_struct               set_property;
+	#endif /* Si2168_SET_PROPERTY_CMD */
+	#ifdef    Si2168_START_CLK_CMD
+			  Si2168_START_CLK_CMD_struct                  start_clk;
+	#endif /* Si2168_START_CLK_CMD */
+} Si2168_CmdObj;
+
+typedef struct
+{ // Si2168_CmdReplyObj struct
+	#ifdef    Si2168_CONFIG_CLKIO_CMD
+			  Si2168_CONFIG_CLKIO_CMD_REPLY_struct               config_clkio;
+	#endif /* Si2168_CONFIG_CLKIO_CMD */
+	#ifdef    Si2168_CONFIG_PINS_CMD
+			  Si2168_CONFIG_PINS_CMD_REPLY_struct                config_pins;
+	#endif /* Si2168_CONFIG_PINS_CMD */
+	#ifdef    Si2168_DD_BER_CMD
+			  Si2168_DD_BER_CMD_REPLY_struct                     dd_ber;
+	#endif /* Si2168_DD_BER_CMD */
+	#ifdef    Si2168_DD_CBER_CMD
+			  Si2168_DD_CBER_CMD_REPLY_struct                    dd_cber;
+	#endif /* Si2168_DD_CBER_CMD */
+
+	#ifdef    Si2168_DD_EXT_AGC_TER_CMD
+			  Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct             dd_ext_agc_ter;
+	#endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+	#ifdef    Si2168_DD_FER_CMD
+			  Si2168_DD_FER_CMD_REPLY_struct                     dd_fer;
+	#endif /* Si2168_DD_FER_CMD */
+	#ifdef    Si2168_DD_GET_REG_CMD
+			  Si2168_DD_GET_REG_CMD_REPLY_struct                 dd_get_reg;
+	#endif /* Si2168_DD_GET_REG_CMD */
+	#ifdef    Si2168_DD_MP_DEFAULTS_CMD
+			  Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct             dd_mp_defaults;
+	#endif /* Si2168_DD_MP_DEFAULTS_CMD */
+	#ifdef    Si2168_DD_PER_CMD
+			  Si2168_DD_PER_CMD_REPLY_struct                     dd_per;
+	#endif /* Si2168_DD_PER_CMD */
+	#ifdef    Si2168_DD_RESTART_CMD
+			  Si2168_DD_RESTART_CMD_REPLY_struct                 dd_restart;
+	#endif /* Si2168_DD_RESTART_CMD */
+	#ifdef    Si2168_DD_SET_REG_CMD
+			  Si2168_DD_SET_REG_CMD_REPLY_struct                 dd_set_reg;
+	#endif /* Si2168_DD_SET_REG_CMD */
+	#ifdef    Si2168_DD_SSI_SQI_CMD
+			  Si2168_DD_SSI_SQI_CMD_REPLY_struct                 dd_ssi_sqi;
+	#endif /* Si2168_DD_SSI_SQI_CMD */
+	#ifdef    Si2168_DD_STATUS_CMD
+			  Si2168_DD_STATUS_CMD_REPLY_struct                  dd_status;
+	#endif /* Si2168_DD_STATUS_CMD */
+	#ifdef    Si2168_DD_UNCOR_CMD
+			  Si2168_DD_UNCOR_CMD_REPLY_struct                   dd_uncor;
+	#endif /* Si2168_DD_UNCOR_CMD */
+	#ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+			  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct  download_dataset_continue;
+	#endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+	#ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+			  Si2168_DOWNLOAD_DATASET_START_CMD_REPLY_struct     download_dataset_start;
+	#endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+	#ifdef    Si2168_DVBC_STATUS_CMD
+			  Si2168_DVBC_STATUS_CMD_REPLY_struct                dvbc_status;
+	#endif /* Si2168_DVBC_STATUS_CMD */
+
+	#ifdef    Si2168_DVBT2_FEF_CMD
+			  Si2168_DVBT2_FEF_CMD_REPLY_struct                  dvbt2_fef;
+	#endif /* Si2168_DVBT2_FEF_CMD */
+	#ifdef    Si2168_DVBT2_PLP_INFO_CMD
+			  Si2168_DVBT2_PLP_INFO_CMD_REPLY_struct             dvbt2_plp_info;
+	#endif /* Si2168_DVBT2_PLP_INFO_CMD */
+	#ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+			  Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct           dvbt2_plp_select;
+	#endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+	#ifdef    Si2168_DVBT2_STATUS_CMD
+			  Si2168_DVBT2_STATUS_CMD_REPLY_struct               dvbt2_status;
+	#endif /* Si2168_DVBT2_STATUS_CMD */
+	#ifdef    Si2168_DVBT2_TX_ID_CMD
+			  Si2168_DVBT2_TX_ID_CMD_REPLY_struct                dvbt2_tx_id;
+	#endif /* Si2168_DVBT2_TX_ID_CMD */
+
+	#ifdef    Si2168_DVBT_STATUS_CMD
+			  Si2168_DVBT_STATUS_CMD_REPLY_struct                dvbt_status;
+	#endif /* Si2168_DVBT_STATUS_CMD */
+	#ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+			  Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct             dvbt_tps_extra;
+	#endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+	#ifdef    Si2168_EXIT_BOOTLOADER_CMD
+			  Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct            exit_bootloader;
+	#endif /* Si2168_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2168_GET_PROPERTY_CMD
+			  Si2168_GET_PROPERTY_CMD_REPLY_struct               get_property;
+	#endif /* Si2168_GET_PROPERTY_CMD */
+	#ifdef    Si2168_GET_REV_CMD
+			  Si2168_GET_REV_CMD_REPLY_struct                    get_rev;
+	#endif /* Si2168_GET_REV_CMD */
+	#ifdef    Si2168_I2C_PASSTHROUGH_CMD
+			  Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct            i2c_passthrough;
+	#endif /* Si2168_I2C_PASSTHROUGH_CMD */
+	#ifdef    Si2168_PART_INFO_CMD
+			  Si2168_PART_INFO_CMD_REPLY_struct                  part_info;
+	#endif /* Si2168_PART_INFO_CMD */
+	#ifdef    Si2168_POWER_DOWN_CMD
+			  Si2168_POWER_DOWN_CMD_REPLY_struct                 power_down;
+	#endif /* Si2168_POWER_DOWN_CMD */
+	#ifdef    Si2168_POWER_UP_CMD
+			  Si2168_POWER_UP_CMD_REPLY_struct                   power_up;
+	#endif /* Si2168_POWER_UP_CMD */
+	#ifdef    Si2168_RSSI_ADC_CMD
+			  Si2168_RSSI_ADC_CMD_REPLY_struct                   rssi_adc;
+	#endif /* Si2168_RSSI_ADC_CMD */
+	#ifdef    Si2168_SCAN_CTRL_CMD
+			  Si2168_SCAN_CTRL_CMD_REPLY_struct                  scan_ctrl;
+	#endif /* Si2168_SCAN_CTRL_CMD */
+	#ifdef    Si2168_SCAN_STATUS_CMD
+			  Si2168_SCAN_STATUS_CMD_REPLY_struct                scan_status;
+	#endif /* Si2168_SCAN_STATUS_CMD */
+	#ifdef    Si2168_SET_PROPERTY_CMD
+			  Si2168_SET_PROPERTY_CMD_REPLY_struct               set_property;
+	#endif /* Si2168_SET_PROPERTY_CMD */
+	#ifdef    Si2168_START_CLK_CMD
+			  Si2168_START_CLK_CMD_REPLY_struct                  start_clk;
+	#endif /* Si2168_START_CLK_CMD */
+} Si2168_CmdReplyObj;
+
+#define   Si2168_DD_BER_RESOL_PROP 0x1003
+
+#ifdef Si2168_DD_BER_RESOL_PROP
+	#define Si2168_DD_BER_RESOL_PROP_CODE 0x001003
+	typedef struct
+	{ // Si2168_DD_BER_RESOL_PROP_struct
+		unsigned char   exp;
+		unsigned char   mant;
+	} Si2168_DD_BER_RESOL_PROP_struct;
+	/* DD_BER_RESOL property, EXP field definition (NO TITLE)*/
+	#define  Si2168_DD_BER_RESOL_PROP_EXP_LSB         0
+	#define  Si2168_DD_BER_RESOL_PROP_EXP_MASK        0x0f
+	#define  Si2168_DD_BER_RESOL_PROP_EXP_DEFAULT    7
+	#define Si2168_DD_BER_RESOL_PROP_EXP_EXPLO_MIN  1
+	#define Si2168_DD_BER_RESOL_PROP_EXP_EXPLO_MAX  8
+	/* DD_BER_RESOL property, MANT field definition (NO TITLE)*/
+	#define  Si2168_DD_BER_RESOL_PROP_MANT_LSB         4
+	#define  Si2168_DD_BER_RESOL_PROP_MANT_MASK        0x0f
+	#define  Si2168_DD_BER_RESOL_PROP_MANT_DEFAULT    1
+	#define Si2168_DD_BER_RESOL_PROP_MANT_MANTLO_MIN  1
+	#define Si2168_DD_BER_RESOL_PROP_MANT_MANTLO_MAX  9
+#endif // Si2168_DD_BER_RESOL_PROP
+
+#define Si2168_DD_CBER_RESOL_PROP 0x1002
+
+#ifdef Si2168_DD_CBER_RESOL_PROP
+	#define Si2168_DD_CBER_RESOL_PROP_CODE 0x001002
+	typedef struct
+	{ // Si2168_DD_CBER_RESOL_PROP_struct
+		unsigned char   exp;
+		unsigned char   mant;
+	} Si2168_DD_CBER_RESOL_PROP_struct;
+	/* DD_CBER_RESOL property, EXP field definition (NO TITLE)*/
+	#define  Si2168_DD_CBER_RESOL_PROP_EXP_LSB         0
+	#define  Si2168_DD_CBER_RESOL_PROP_EXP_MASK        0x0f
+	#define  Si2168_DD_CBER_RESOL_PROP_EXP_DEFAULT    5
+	#define Si2168_DD_CBER_RESOL_PROP_EXP_EXPLO_MIN  1
+	#define Si2168_DD_CBER_RESOL_PROP_EXP_EXPLO_MAX  8
+	/* DD_CBER_RESOL property, MANT field definition (NO TITLE)*/
+	#define  Si2168_DD_CBER_RESOL_PROP_MANT_LSB         4
+	#define  Si2168_DD_CBER_RESOL_PROP_MANT_MASK        0x0f
+	#define  Si2168_DD_CBER_RESOL_PROP_MANT_DEFAULT    1
+	#define Si2168_DD_CBER_RESOL_PROP_MANT_MANTLO_MIN  1
+	#define Si2168_DD_CBER_RESOL_PROP_MANT_MANTLO_MAX  9
+#endif // Si2168_DD_CBER_RESOL_PROP
+
+/* Si2168 DD_FER_RESOL property definition */
+#define Si2168_DD_FER_RESOL_PROP 0x100c
+
+#ifdef Si2168_DD_FER_RESOL_PROP
+	#define Si2168_DD_FER_RESOL_PROP_CODE 0x00100c
+
+
+    typedef struct { /* Si2168_DD_FER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_FER_RESOL_PROP_struct;
+
+   /* DD_FER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_DEFAULT    3
+    #define Si2168_DD_FER_RESOL_PROP_EXP_EXP_MIN  1
+    #define Si2168_DD_FER_RESOL_PROP_EXP_EXP_MAX  4
+
+   /* DD_FER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_FER_RESOL_PROP_MANT_MANT_MIN  1
+    #define Si2168_DD_FER_RESOL_PROP_MANT_MANT_MAX  9
+
+#endif /* Si2168_DD_FER_RESOL_PROP */
+
+/* Si2168 DD_IEN property definition */
+#define   Si2168_DD_IEN_PROP 0x1006
+
+#ifdef    Si2168_DD_IEN_PROP
+  #define Si2168_DD_IEN_PROP_CODE 0x001006
+
+
+    typedef struct { /* Si2168_DD_IEN_PROP_struct */
+      unsigned char   ien_bit0;
+      unsigned char   ien_bit1;
+      unsigned char   ien_bit2;
+      unsigned char   ien_bit3;
+      unsigned char   ien_bit4;
+      unsigned char   ien_bit5;
+      unsigned char   ien_bit6;
+      unsigned char   ien_bit7;
+   } Si2168_DD_IEN_PROP_struct;
+
+   /* DD_IEN property, IEN_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_LSB         0
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT0_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT0_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_LSB         1
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT1_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT1_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_LSB         2
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT2_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT2_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_LSB         3
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT3_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT3_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_LSB         4
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT4_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT4_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_LSB         5
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT5_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT5_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_LSB         6
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT6_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT6_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_LSB         7
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT7_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT7_ENABLE   1
+
+#endif /* Si2168_DD_IEN_PROP */
+
+/* Si2168 DD_IF_INPUT_FREQ property definition */
+#define   Si2168_DD_IF_INPUT_FREQ_PROP 0x100b
+
+#ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+  #define Si2168_DD_IF_INPUT_FREQ_PROP_CODE 0x00100b
+
+
+    typedef struct { /* Si2168_DD_IF_INPUT_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2168_DD_IF_INPUT_FREQ_PROP_struct;
+
+   /* DD_IF_INPUT_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MAX  36000
+
+#endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+
+/* Si2168 DD_INT_SENSE property definition */
+#define   Si2168_DD_INT_SENSE_PROP 0x1007
+
+#ifdef    Si2168_DD_INT_SENSE_PROP
+  #define Si2168_DD_INT_SENSE_PROP_CODE 0x001007
+
+
+    typedef struct { /* Si2168_DD_INT_SENSE_PROP_struct */
+      unsigned char   neg_bit0;
+      unsigned char   neg_bit1;
+      unsigned char   neg_bit2;
+      unsigned char   neg_bit3;
+      unsigned char   neg_bit4;
+      unsigned char   neg_bit5;
+      unsigned char   neg_bit6;
+      unsigned char   neg_bit7;
+      unsigned char   pos_bit0;
+      unsigned char   pos_bit1;
+      unsigned char   pos_bit2;
+      unsigned char   pos_bit3;
+      unsigned char   pos_bit4;
+      unsigned char   pos_bit5;
+      unsigned char   pos_bit6;
+      unsigned char   pos_bit7;
+   } Si2168_DD_INT_SENSE_PROP_struct;
+
+   /* DD_INT_SENSE property, NEG_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_LSB         0
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT0_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_LSB         1
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT1_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_LSB         2
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT2_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_LSB         3
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT3_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_LSB         4
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT4_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_LSB         5
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT5_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_LSB         6
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT6_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_LSB         7
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT7_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_LSB         8
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT0_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT0_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_LSB         9
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT1_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT1_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_LSB         10
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT2_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT2_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_LSB         11
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT3_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT3_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_LSB         12
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT4_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT4_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_LSB         13
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT5_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT5_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_LSB         14
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT6_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT6_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_LSB         15
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT7_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT7_ENABLE   1
+
+#endif /* Si2168_DD_INT_SENSE_PROP */
+
+/* Si2168 DD_MODE property definition */
+#define   Si2168_DD_MODE_PROP 0x100a
+
+#ifdef    Si2168_DD_MODE_PROP
+  #define Si2168_DD_MODE_PROP_CODE 0x00100a
+
+
+    typedef struct { /* Si2168_DD_MODE_PROP_struct */
+      unsigned char   auto_detect;
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+   } Si2168_DD_MODE_PROP_struct;
+
+   /* DD_MODE property, AUTO_DETECT field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_LSB         9
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_MASK        0x07
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_DEFAULT    0
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_NONE               0
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2      1
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2      2
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2_DSS  3
+
+   /* DD_MODE property, BW field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_BW_LSB         0
+   #define  Si2168_DD_MODE_PROP_BW_MASK        0x0f
+   #define  Si2168_DD_MODE_PROP_BW_DEFAULT    8
+    #define Si2168_DD_MODE_PROP_BW_BW_5MHZ    5
+    #define Si2168_DD_MODE_PROP_BW_BW_6MHZ    6
+    #define Si2168_DD_MODE_PROP_BW_BW_7MHZ    7
+    #define Si2168_DD_MODE_PROP_BW_BW_8MHZ    8
+    #define Si2168_DD_MODE_PROP_BW_BW_1D7MHZ  2
+
+   /* DD_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_LSB         8
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+    #define Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2168_DD_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* DD_MODE property, MODULATION field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_MODULATION_LSB          4
+   #define  Si2168_DD_MODE_PROP_MODULATION_MASK         0x0f
+   #define  Si2168_DD_MODE_PROP_MODULATION_DEFAULT      2
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBT         2
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBC         3
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBT2        7
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBS         8
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBS2        9
+    #define Si2168_DD_MODE_PROP_MODULATION_DSS          10
+    #define Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT  15
+    #define Si2168_DD_MODE_PROP_MODULATION_ANALOG     100
+
+#endif /* Si2168_DD_MODE_PROP */
+
+/* Si2168 DD_PER_RESOL property definition */
+#define   Si2168_DD_PER_RESOL_PROP 0x1004
+
+#ifdef    Si2168_DD_PER_RESOL_PROP
+  #define Si2168_DD_PER_RESOL_PROP_CODE 0x001004
+
+
+    typedef struct { /* Si2168_DD_PER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_PER_RESOL_PROP_struct;
+
+   /* DD_PER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_DEFAULT    5
+    #define Si2168_DD_PER_RESOL_PROP_EXP_EXPLO_MIN  1
+    #define Si2168_DD_PER_RESOL_PROP_EXP_EXPLO_MAX  9
+
+   /* DD_PER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_PER_RESOL_PROP_MANT_MANTLO_MIN  1
+    #define Si2168_DD_PER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168_DD_PER_RESOL_PROP */
+
+/* Si2168 DD_RSQ_BER_THRESHOLD property definition */
+#define   Si2168_DD_RSQ_BER_THRESHOLD_PROP 0x1005
+
+#ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+  #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE 0x001005
+
+
+    typedef struct { /* Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct;
+
+   /* DD_RSQ_BER_THRESHOLD property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB         0
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_DEFAULT    1
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MIN  1
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MAX  8
+
+   /* DD_RSQ_BER_THRESHOLD property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB         4
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_DEFAULT    10
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MIN  0
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+
+/* Si2168 DD_SSI_SQI_PARAM property definition */
+#define   Si2168_DD_SSI_SQI_PARAM_PROP 0x100f
+
+#ifdef    Si2168_DD_SSI_SQI_PARAM_PROP
+  #define Si2168_DD_SSI_SQI_PARAM_PROP_CODE 0x00100f
+
+
+    typedef struct { /* Si2168_DD_SSI_SQI_PARAM_PROP_struct */
+      unsigned char   sqi_average;
+   } Si2168_DD_SSI_SQI_PARAM_PROP_struct;
+
+   /* DD_SSI_SQI_PARAM property, SQI_AVERAGE field definition (NO TITLE)*/
+   #define  Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_LSB         0
+   #define  Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_MASK        0x1f
+   #define  Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_DEFAULT    1
+    #define Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_SQI_AVERAGE_MIN  1
+    #define Si2168_DD_SSI_SQI_PARAM_PROP_SQI_AVERAGE_SQI_AVERAGE_MAX  30
+
+#endif /* Si2168_DD_SSI_SQI_PARAM_PROP */
+
+/* Si2168 DD_TS_FREQ property definition */
+#define   Si2168_DD_TS_FREQ_PROP 0x100d
+
+#ifdef    Si2168_DD_TS_FREQ_PROP
+  #define Si2168_DD_TS_FREQ_PROP_CODE 0x00100d
+
+
+    typedef struct { /* Si2168_DD_TS_FREQ_PROP_struct */
+      unsigned int    req_freq_10khz;
+   } Si2168_DD_TS_FREQ_PROP_struct;
+
+   /* DD_TS_FREQ property, REQ_FREQ_10KHZ field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB         0
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK        0x3fff
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_DEFAULT    720
+    #define Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MIN  0
+    #define Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MAX  14550
+
+#endif /* Si2168_DD_TS_FREQ_PROP */
+
+/* Si2168 DD_TS_MODE property definition */
+#define   Si2168_DD_TS_MODE_PROP 0x1001
+
+#ifdef    Si2168_DD_TS_MODE_PROP
+  #define Si2168_DD_TS_MODE_PROP_CODE 0x001001
+
+
+    typedef struct { /* Si2168_DD_TS_MODE_PROP_struct */
+      unsigned char   clk_gapped_en;
+      unsigned char   clock;
+      unsigned char   mode;
+   } Si2168_DD_TS_MODE_PROP_struct;
+
+   /* DD_TS_MODE property, CLK_GAPPED_EN field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB         6
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK        0x01
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED  0
+    #define Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_ENABLED   1
+
+   /* DD_TS_MODE property, CLOCK field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_LSB         4
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_MASK        0x03
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_FIXED  0
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT  1
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_MANUAL      2
+
+   /* DD_TS_MODE property, MODE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_MODE_LSB         0
+   #define  Si2168_DD_TS_MODE_PROP_MODE_MASK        0x0f
+   #define  Si2168_DD_TS_MODE_PROP_MODE_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_MODE_TRISTATE  0
+    #define Si2168_DD_TS_MODE_PROP_MODE_OFF       1
+    #define Si2168_DD_TS_MODE_PROP_MODE_SERIAL    3
+    #define Si2168_DD_TS_MODE_PROP_MODE_PARALLEL  6
+    #define Si2168_DD_TS_MODE_PROP_MODE_GPIF      7
+
+#endif /* Si2168_DD_TS_MODE_PROP */
+
+/* Si2168 DD_TS_SETUP_PAR property definition */
+#define   Si2168_DD_TS_SETUP_PAR_PROP 0x1009
+
+#ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+  #define Si2168_DD_TS_SETUP_PAR_PROP_CODE 0x001009
+
+
+    typedef struct { /* Si2168_DD_TS_SETUP_PAR_PROP_struct */
+      unsigned char   ts_clk_invert;
+      unsigned char   ts_clk_shape;
+      unsigned char   ts_clk_shift;
+      unsigned char   ts_clk_strength;
+      unsigned char   ts_data_shape;
+      unsigned char   ts_data_strength;
+   } Si2168_DD_TS_SETUP_PAR_PROP_struct;
+
+   /* DD_TS_SETUP_PAR property, TS_CLK_INVERT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB         12
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_DEFAULT    1
+    #define Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+    #define Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED      1
+
+   /* DD_TS_SETUP_PAR property, TS_CLK_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB         10
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_DEFAULT    1
+   /* DD_TS_SETUP_PAR property, TS_CLK_SHIFT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB         13
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK        0x07
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_DEFAULT    0
+   /* DD_TS_SETUP_PAR property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB         6
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_DEFAULT    3
+   /* DD_TS_SETUP_PAR property, TS_DATA_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB         4
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_DEFAULT    1
+   /* DD_TS_SETUP_PAR property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB         0
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_DEFAULT    3
+#endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+
+/* Si2168 DD_TS_SETUP_SER property definition */
+#define   Si2168_DD_TS_SETUP_SER_PROP 0x1008
+
+#ifdef    Si2168_DD_TS_SETUP_SER_PROP
+  #define Si2168_DD_TS_SETUP_SER_PROP_CODE 0x001008
+
+
+    typedef struct { /* Si2168_DD_TS_SETUP_SER_PROP_struct */
+      unsigned char   ts_byte_order;
+      unsigned char   ts_clk_invert;
+      unsigned char   ts_clk_shape;
+      unsigned char   ts_clk_strength;
+      unsigned char   ts_data_shape;
+      unsigned char   ts_data_strength;
+      unsigned char   ts_sync_duration;
+   } Si2168_DD_TS_SETUP_SER_PROP_struct;
+
+   /* DD_TS_SETUP_SER property, TS_BYTE_ORDER field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB         14
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_DEFAULT    0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB_FIRST  1
+
+   /* DD_TS_SETUP_SER property, TS_CLK_INVERT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB         12
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_DEFAULT    1
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED      1
+
+   /* DD_TS_SETUP_SER property, TS_CLK_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB         10
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_DEFAULT    3
+   /* DD_TS_SETUP_SER property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB         6
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_DEFAULT    15
+   /* DD_TS_SETUP_SER property, TS_DATA_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB         4
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_DEFAULT    3
+   /* DD_TS_SETUP_SER property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB         0
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_DEFAULT    15
+   /* DD_TS_SETUP_SER property, TS_SYNC_DURATION field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB         13
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_DEFAULT    0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BYTE  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BIT   1
+
+#endif /* Si2168_DD_TS_SETUP_SER_PROP */
+
+/* Si2168 DVBC_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBC_ADC_CREST_FACTOR_PROP 0x1104
+
+#ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE 0x001104
+
+
+    typedef struct { /* Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBC_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    112
+#endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBC_AFC_RANGE property definition */
+#define   Si2168_DVBC_AFC_RANGE_PROP 0x1103
+
+#ifdef    Si2168_DVBC_AFC_RANGE_PROP
+  #define Si2168_DVBC_AFC_RANGE_PROP_CODE 0x001103
+
+
+    typedef struct { /* Si2168_DVBC_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBC_AFC_RANGE_PROP_struct;
+
+   /* DVBC_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    100
+#endif /* Si2168_DVBC_AFC_RANGE_PROP */
+
+/* Si2168 DVBC_CONSTELLATION property definition */
+#define   Si2168_DVBC_CONSTELLATION_PROP 0x1101
+
+#ifdef    Si2168_DVBC_CONSTELLATION_PROP
+  #define Si2168_DVBC_CONSTELLATION_PROP_CODE 0x001101
+
+
+    typedef struct { /* Si2168_DVBC_CONSTELLATION_PROP_struct */
+      unsigned char   constellation;
+   } Si2168_DVBC_CONSTELLATION_PROP_struct;
+
+   /* DVBC_CONSTELLATION property, CONSTELLATION field definition (NO TITLE)*/
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB         0
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK        0x3f
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_DEFAULT    0
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO    0
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16   7
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32   8
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64   9
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128  10
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256  11
+
+#endif /* Si2168_DVBC_CONSTELLATION_PROP */
+
+/* Si2168 DVBC_SYMBOL_RATE property definition */
+#define   Si2168_DVBC_SYMBOL_RATE_PROP 0x1102
+
+#ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+  #define Si2168_DVBC_SYMBOL_RATE_PROP_CODE 0x001102
+
+
+    typedef struct { /* Si2168_DVBC_SYMBOL_RATE_PROP_struct */
+      unsigned int    rate;
+   } Si2168_DVBC_SYMBOL_RATE_PROP_struct;
+
+   /* DVBC_SYMBOL_RATE property, RATE field definition (NO TITLE)*/
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_LSB         0
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_MASK        0xffff
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_DEFAULT    6800
+#endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+
+/* Si2168 DVBT2_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBT2_ADC_CREST_FACTOR_PROP 0x1303
+
+#ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE 0x001303
+
+
+    typedef struct { /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBT2_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBT2_AFC_RANGE property definition */
+#define   Si2168_DVBT2_AFC_RANGE_PROP 0x1301
+
+#ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+  #define Si2168_DVBT2_AFC_RANGE_PROP_CODE 0x001301
+
+
+    typedef struct { /* Si2168_DVBT2_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBT2_AFC_RANGE_PROP_struct;
+
+   /* DVBT2_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+
+/* Si2168 DVBT2_FEF_TUNER property definition */
+#define   Si2168_DVBT2_FEF_TUNER_PROP 0x1302
+
+#ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+  #define Si2168_DVBT2_FEF_TUNER_PROP_CODE 0x001302
+
+
+    typedef struct { /* Si2168_DVBT2_FEF_TUNER_PROP_struct */
+      unsigned char   tuner_delay;
+      unsigned char   tuner_freeze_time;
+      unsigned char   tuner_unfreeze_time;
+   } Si2168_DVBT2_FEF_TUNER_PROP_struct;
+
+   /* DVBT2_FEF_TUNER property, TUNER_DELAY field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB         0
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        0xff
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_DEFAULT    0
+   /* DVBT2_FEF_TUNER property, TUNER_FREEZE_TIME field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB         8
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK        0x0f
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_DEFAULT    0
+   /* DVBT2_FEF_TUNER property, TUNER_UNFREEZE_TIME field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB         12
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK        0x0f
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_DEFAULT    0
+#endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+
+
+/* Si2168 DVBT_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBT_ADC_CREST_FACTOR_PROP 0x1203
+
+#ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE 0x001203
+
+
+    typedef struct { /* Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBT_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBT_AFC_RANGE property definition */
+#define   Si2168_DVBT_AFC_RANGE_PROP 0x1202
+
+#ifdef    Si2168_DVBT_AFC_RANGE_PROP
+  #define Si2168_DVBT_AFC_RANGE_PROP_CODE 0x001202
+
+
+    typedef struct { /* Si2168_DVBT_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBT_AFC_RANGE_PROP_struct;
+
+   /* DVBT_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168_DVBT_AFC_RANGE_PROP */
+
+/* Si2168 DVBT_HIERARCHY property definition */
+#define   Si2168_DVBT_HIERARCHY_PROP 0x1201
+
+#ifdef    Si2168_DVBT_HIERARCHY_PROP
+  #define Si2168_DVBT_HIERARCHY_PROP_CODE 0x001201
+
+
+    typedef struct { /* Si2168_DVBT_HIERARCHY_PROP_struct */
+      unsigned char   stream;
+   } Si2168_DVBT_HIERARCHY_PROP_struct;
+
+   /* DVBT_HIERARCHY property, STREAM field definition (NO TITLE)*/
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_LSB         0
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_MASK        0x01
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_DEFAULT    0
+    #define Si2168_DVBT_HIERARCHY_PROP_STREAM_HP  0
+    #define Si2168_DVBT_HIERARCHY_PROP_STREAM_LP  1
+
+#endif /* Si2168_DVBT_HIERARCHY_PROP */
+
+
+/* Si2168 MASTER_IEN property definition */
+#define   Si2168_MASTER_IEN_PROP 0x0401
+
+#ifdef    Si2168_MASTER_IEN_PROP
+  #define Si2168_MASTER_IEN_PROP_CODE 0x000401
+
+
+    typedef struct { /* Si2168_MASTER_IEN_PROP_struct */
+      unsigned char   ctsien;
+      unsigned char   ddien;
+      unsigned char   errien;
+      unsigned char   scanien;
+   } Si2168_MASTER_IEN_PROP_struct;
+
+   /* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_LSB         7
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_CTSIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_CTSIEN_ON   1
+
+   /* MASTER_IEN property, DDIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_LSB         0
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_DDIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_DDIEN_ON   1
+
+   /* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_LSB         6
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_ERRIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_ERRIEN_ON   1
+
+   /* MASTER_IEN property, SCANIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_LSB         1
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_SCANIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_SCANIEN_ON   1
+
+#endif /* Si2168_MASTER_IEN_PROP */
+
+/* Si2168 SCAN_FMAX property definition */
+#define   Si2168_SCAN_FMAX_PROP 0x0304
+
+#ifdef    Si2168_SCAN_FMAX_PROP
+  #define Si2168_SCAN_FMAX_PROP_CODE 0x000304
+
+
+    typedef struct { /* Si2168_SCAN_FMAX_PROP_struct */
+      unsigned int    scan_fmax;
+   } Si2168_SCAN_FMAX_PROP_struct;
+
+   /* SCAN_FMAX property, SCAN_FMAX field definition (NO TITLE)*/
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_LSB         0
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_MASK        0xffff
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_DEFAULT    0
+#endif /* Si2168_SCAN_FMAX_PROP */
+
+/* Si2168 SCAN_FMIN property definition */
+#define   Si2168_SCAN_FMIN_PROP 0x0303
+
+#ifdef    Si2168_SCAN_FMIN_PROP
+  #define Si2168_SCAN_FMIN_PROP_CODE 0x000303
+
+
+    typedef struct { /* Si2168_SCAN_FMIN_PROP_struct */
+      unsigned int    scan_fmin;
+   } Si2168_SCAN_FMIN_PROP_struct;
+
+   /* SCAN_FMIN property, SCAN_FMIN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_LSB         0
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_MASK        0xffff
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_DEFAULT    0
+#endif /* Si2168_SCAN_FMIN_PROP */
+
+/* Si2168 SCAN_IEN property definition */
+#define   Si2168_SCAN_IEN_PROP 0x0308
+
+#ifdef    Si2168_SCAN_IEN_PROP
+  #define Si2168_SCAN_IEN_PROP_CODE 0x000308
+
+
+    typedef struct { /* Si2168_SCAN_IEN_PROP_struct */
+      unsigned char   buzien;
+      unsigned char   reqien;
+   } Si2168_SCAN_IEN_PROP_struct;
+
+   /* SCAN_IEN property, BUZIEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_LSB         0
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_MASK        0x01
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_DEFAULT    0
+    #define Si2168_SCAN_IEN_PROP_BUZIEN_DISABLE  0
+    #define Si2168_SCAN_IEN_PROP_BUZIEN_ENABLE   1
+
+   /* SCAN_IEN property, REQIEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_LSB         1
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_MASK        0x01
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_DEFAULT    0
+    #define Si2168_SCAN_IEN_PROP_REQIEN_DISABLE  0
+    #define Si2168_SCAN_IEN_PROP_REQIEN_ENABLE   1
+
+#endif /* Si2168_SCAN_IEN_PROP */
+
+/* Si2168 SCAN_INT_SENSE property definition */
+#define   Si2168_SCAN_INT_SENSE_PROP 0x0307
+
+#ifdef    Si2168_SCAN_INT_SENSE_PROP
+  #define Si2168_SCAN_INT_SENSE_PROP_CODE 0x000307
+
+
+    typedef struct { /* Si2168_SCAN_INT_SENSE_PROP_struct */
+      unsigned char   buznegen;
+      unsigned char   buzposen;
+      unsigned char   reqnegen;
+      unsigned char   reqposen;
+   } Si2168_SCAN_INT_SENSE_PROP_struct;
+
+   /* SCAN_INT_SENSE property, BUZNEGEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB         0
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_DEFAULT    1
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, BUZPOSEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB         8
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DEFAULT    0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, REQNEGEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_LSB         1
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DEFAULT    0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, REQPOSEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_LSB         9
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_DEFAULT    1
+    #define Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE   1
+
+#endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+
+/* Si2168 SCAN_SYMB_RATE_MAX property definition */
+#define   Si2168_SCAN_SYMB_RATE_MAX_PROP 0x0306
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+  #define Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE 0x000306
+
+
+    typedef struct { /* Si2168_SCAN_SYMB_RATE_MAX_PROP_struct */
+      unsigned int    scan_symb_rate_max;
+   } Si2168_SCAN_SYMB_RATE_MAX_PROP_struct;
+
+   /* SCAN_SYMB_RATE_MAX property, SCAN_SYMB_RATE_MAX field definition (NO TITLE)*/
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB         0
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK        0xffff
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_DEFAULT    0
+#endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+
+/* Si2168 SCAN_SYMB_RATE_MIN property definition */
+#define   Si2168_SCAN_SYMB_RATE_MIN_PROP 0x0305
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+  #define Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE 0x000305
+
+
+    typedef struct { /* Si2168_SCAN_SYMB_RATE_MIN_PROP_struct */
+      unsigned int    scan_symb_rate_min;
+   } Si2168_SCAN_SYMB_RATE_MIN_PROP_struct;
+
+   /* SCAN_SYMB_RATE_MIN property, SCAN_SYMB_RATE_MIN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB         0
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK        0xffff
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_DEFAULT    0
+#endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+
+/* Si2168 SCAN_TER_CONFIG property definition */
+#define   Si2168_SCAN_TER_CONFIG_PROP 0x0301
+
+#ifdef    Si2168_SCAN_TER_CONFIG_PROP
+  #define Si2168_SCAN_TER_CONFIG_PROP_CODE 0x000301
+
+
+    typedef struct { /* Si2168_SCAN_TER_CONFIG_PROP_struct */
+      unsigned char   analog_bw;
+      unsigned char   mode;
+      unsigned char   search_analog;
+   } Si2168_SCAN_TER_CONFIG_PROP_struct;
+
+   /* SCAN_TER_CONFIG property, ANALOG_BW field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB         2
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK        0x03
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_DEFAULT    3
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_6MHZ  1
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_7MHZ  2
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ  3
+
+   /* SCAN_TER_CONFIG property, MODE field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_LSB         0
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_MASK        0x03
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_DEFAULT    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_MAPPING_SCAN  1
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_LOCK    2
+
+   /* SCAN_TER_CONFIG property, SEARCH_ANALOG field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB         4
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK        0x01
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DEFAULT    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE  0
+    #define Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_ENABLE   1
+
+#endif /* Si2168_SCAN_TER_CONFIG_PROP */
+
+typedef struct
+{
+	#ifdef    Si2168_DD_BER_RESOL_PROP
+			  Si2168_DD_BER_RESOL_PROP_struct            dd_ber_resol;
+	#endif /* Si2168_DD_BER_RESOL_PROP */
+	#ifdef    Si2168_DD_CBER_RESOL_PROP
+			  Si2168_DD_CBER_RESOL_PROP_struct           dd_cber_resol;
+	#endif /* Si2168_DD_CBER_RESOL_PROP */
+
+	#ifdef    Si2168_DD_FER_RESOL_PROP
+			  Si2168_DD_FER_RESOL_PROP_struct            dd_fer_resol;
+	#endif /* Si2168_DD_FER_RESOL_PROP */
+	#ifdef    Si2168_DD_IEN_PROP
+			  Si2168_DD_IEN_PROP_struct                  dd_ien;
+	#endif /* Si2168_DD_IEN_PROP */
+	#ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+			  Si2168_DD_IF_INPUT_FREQ_PROP_struct        dd_if_input_freq;
+	#endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+	#ifdef    Si2168_DD_INT_SENSE_PROP
+			  Si2168_DD_INT_SENSE_PROP_struct            dd_int_sense;
+	#endif /* Si2168_DD_INT_SENSE_PROP */
+	#ifdef    Si2168_DD_MODE_PROP
+			  Si2168_DD_MODE_PROP_struct                 dd_mode;
+	#endif /* Si2168_DD_MODE_PROP */
+	#ifdef    Si2168_DD_PER_RESOL_PROP
+			  Si2168_DD_PER_RESOL_PROP_struct            dd_per_resol;
+	#endif /* Si2168_DD_PER_RESOL_PROP */
+	#ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+			  Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct    dd_rsq_ber_threshold;
+	#endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+	#ifdef    Si2168_DD_SSI_SQI_PARAM_PROP
+			  Si2168_DD_SSI_SQI_PARAM_PROP_struct        dd_ssi_sqi_param;
+	#endif /* Si2168_DD_SSI_SQI_PARAM_PROP */
+	#ifdef    Si2168_DD_TS_FREQ_PROP
+			  Si2168_DD_TS_FREQ_PROP_struct              dd_ts_freq;
+	#endif /* Si2168_DD_TS_FREQ_PROP */
+	#ifdef    Si2168_DD_TS_MODE_PROP
+			  Si2168_DD_TS_MODE_PROP_struct              dd_ts_mode;
+	#endif /* Si2168_DD_TS_MODE_PROP */
+	#ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+			  Si2168_DD_TS_SETUP_PAR_PROP_struct         dd_ts_setup_par;
+	#endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+	#ifdef    Si2168_DD_TS_SETUP_SER_PROP
+			  Si2168_DD_TS_SETUP_SER_PROP_struct         dd_ts_setup_ser;
+	#endif /* Si2168_DD_TS_SETUP_SER_PROP */
+	#ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+			  Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct   dvbc_adc_crest_factor;
+	#endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+	#ifdef    Si2168_DVBC_AFC_RANGE_PROP
+			  Si2168_DVBC_AFC_RANGE_PROP_struct          dvbc_afc_range;
+	#endif /* Si2168_DVBC_AFC_RANGE_PROP */
+	#ifdef    Si2168_DVBC_CONSTELLATION_PROP
+			  Si2168_DVBC_CONSTELLATION_PROP_struct      dvbc_constellation;
+	#endif /* Si2168_DVBC_CONSTELLATION_PROP */
+	#ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+			  Si2168_DVBC_SYMBOL_RATE_PROP_struct        dvbc_symbol_rate;
+	#endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+	#ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+			  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct  dvbt2_adc_crest_factor;
+	#endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+	#ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+			  Si2168_DVBT2_AFC_RANGE_PROP_struct         dvbt2_afc_range;
+	#endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+	#ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+			  Si2168_DVBT2_FEF_TUNER_PROP_struct         dvbt2_fef_tuner;
+	#endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+
+	#ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+			  Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct   dvbt_adc_crest_factor;
+	#endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+	#ifdef    Si2168_DVBT_AFC_RANGE_PROP
+			  Si2168_DVBT_AFC_RANGE_PROP_struct          dvbt_afc_range;
+	#endif /* Si2168_DVBT_AFC_RANGE_PROP */
+	#ifdef    Si2168_DVBT_HIERARCHY_PROP
+			  Si2168_DVBT_HIERARCHY_PROP_struct          dvbt_hierarchy;
+	#endif /* Si2168_DVBT_HIERARCHY_PROP */
+
+	#ifdef    Si2168_MASTER_IEN_PROP
+			  Si2168_MASTER_IEN_PROP_struct              master_ien;
+	#endif /* Si2168_MASTER_IEN_PROP */
+	#ifdef    Si2168_SCAN_FMAX_PROP
+			  Si2168_SCAN_FMAX_PROP_struct               scan_fmax;
+	#endif /* Si2168_SCAN_FMAX_PROP */
+	#ifdef    Si2168_SCAN_FMIN_PROP
+			  Si2168_SCAN_FMIN_PROP_struct               scan_fmin;
+	#endif /* Si2168_SCAN_FMIN_PROP */
+	#ifdef    Si2168_SCAN_IEN_PROP
+			  Si2168_SCAN_IEN_PROP_struct                scan_ien;
+	#endif /* Si2168_SCAN_IEN_PROP */
+	#ifdef    Si2168_SCAN_INT_SENSE_PROP
+			  Si2168_SCAN_INT_SENSE_PROP_struct          scan_int_sense;
+	#endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+	#ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+			  Si2168_SCAN_SYMB_RATE_MAX_PROP_struct      scan_symb_rate_max;
+	#endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+	#ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+			  Si2168_SCAN_SYMB_RATE_MIN_PROP_struct      scan_symb_rate_min;
+	#endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+	#ifdef    Si2168_SCAN_TER_CONFIG_PROP
+			  Si2168_SCAN_TER_CONFIG_PROP_struct         scan_ter_config;
+	#endif /* Si2168_SCAN_TER_CONFIG_PROP */
+} Si2168_PropObj;
+
+typedef struct L1_Si2168_Context
+{
+	L0_Context                 *i2c;
+	L0_Context                  i2cObj;
+	Si2168_CmdObj              *cmd;
+	Si2168_CmdObj               cmdObj;
+	Si2168_CmdReplyObj         *rsp;
+	Si2168_CmdReplyObj          rspObj;
+	Si2168_PropObj             *prop;
+	Si2168_PropObj              propObj;
+	Si2168_COMMON_REPLY_struct *status;
+	Si2168_COMMON_REPLY_struct  statusObj;
+	int                         standard;
+	int                         media;
+	unsigned int  tuner_rssi;
+	unsigned char addr;
+} L1_Si2168_Context;
+
+typedef struct
+{ // Si2146_COMMON_REPLY_struct
+	unsigned char   tunint;
+	unsigned char   atvint;
+	unsigned char   dtvint;
+	unsigned char   err;
+	unsigned char   cts;
+} Si2146_COMMON_REPLY_struct;
+
+typedef struct
+{ // Si2148_COMMON_REPLY_struct
+	unsigned char   tunint;
+	unsigned char   atvint;
+	unsigned char   dtvint;
+	unsigned char   err;
+	unsigned char   cts;
+} Si2148_COMMON_REPLY_struct;
+
+#define   Si2146_SET_PROPERTY_CMD 0x14
+
+#ifdef Si2146_SET_PROPERTY_CMD
+	#define Si2146_SET_PROPERTY_CMD_CODE 0x010014
+    typedef struct
+	{ // Si2146_SET_PROPERTY_CMD_struct
+		unsigned char   reserved;
+		unsigned int    prop;
+		unsigned int    data;
+	} Si2146_SET_PROPERTY_CMD_struct;
+	typedef struct
+	{ // Si2146_SET_PROPERTY_CMD_REPLY_struct
+		Si2146_COMMON_REPLY_struct * STATUS;
+		unsigned char   reserved;
+		unsigned int    data;
+	} Si2146_SET_PROPERTY_CMD_REPLY_struct;
+	// SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2146_SET_PROPERTY_CMD_RESERVED_LSB         0
+	#define  Si2146_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+	#define  Si2146_SET_PROPERTY_CMD_RESERVED_MIN         0
+	#define  Si2146_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+	// SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned)
+	#define  Si2146_SET_PROPERTY_CMD_PROP_LSB         0
+	#define  Si2146_SET_PROPERTY_CMD_PROP_MASK        0xffff
+	#define  Si2146_SET_PROPERTY_CMD_PROP_MIN         0
+	#define  Si2146_SET_PROPERTY_CMD_PROP_MAX         65535
+	#define Si2146_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+	#define Si2146_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+	// SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned)
+	#define  Si2146_SET_PROPERTY_CMD_DATA_LSB         0
+	#define  Si2146_SET_PROPERTY_CMD_DATA_MASK        0xffff
+	#define  Si2146_SET_PROPERTY_CMD_DATA_MIN         0
+	#define  Si2146_SET_PROPERTY_CMD_DATA_MAX         65535
+	#define Si2146_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+	#define Si2146_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+	// SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)
+	#define  Si2146_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+	#define  Si2146_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+	#define Si2146_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+	#define Si2146_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+	// SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)
+	#define  Si2146_SET_PROPERTY_RESPONSE_DATA_LSB         0
+	#define  Si2146_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+#endif // Si2146_SET_PROPERTY_CMD
+
+// Si2146_TUNER_STATUS command definition
+#define   Si2146_TUNER_STATUS_CMD 0x42
+
+#ifdef    Si2146_TUNER_STATUS_CMD
+  #define Si2146_TUNER_STATUS_CMD_CODE 0x010042
+
+    typedef struct { /* Si2146_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2146_TUNER_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2146_TUNER_STATUS_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+      unsigned char   tcint;
+      unsigned char   rssilint;
+      unsigned char   rssihint;
+               int    vco_code;
+      unsigned char   tc;
+      unsigned char   rssil;
+      unsigned char   rssih;
+               char   rssi;
+      unsigned long   freq;
+      unsigned char   mode;
+   }  Si2146_TUNER_STATUS_CMD_REPLY_struct;
+
+   /* TUNER_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2146_TUNER_STATUS_CMD_INTACK_LSB         0
+   #define  Si2146_TUNER_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2146_TUNER_STATUS_CMD_INTACK_MIN         0
+   #define  Si2146_TUNER_STATUS_CMD_INTACK_MAX         1
+    #define Si2146_TUNER_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2146_TUNER_STATUS_CMD_INTACK_OK     0
+   /* TUNER_STATUS command, TCINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_TCINT_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_TCINT_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_TCINT_CHANGED    1
+    #define Si2146_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSILINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSILINT_LSB         1
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSILINT_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED    1
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSIHINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_LSB         2
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED    1
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+   /* TUNER_STATUS command, VCO_CODE field definition (address 10, size 16, lsb 0, signed)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_MASK        0xffff
+   #define  Si2146_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT       16
+   /* TUNER_STATUS command, TC field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_TC_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_TC_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_TC_BUSY  0
+    #define Si2146_TUNER_STATUS_RESPONSE_TC_DONE  1
+   /* TUNER_STATUS command, RSSIL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIL_LSB         1
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIL_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIL_LOW  1
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIL_OK   0
+   /* TUNER_STATUS command, RSSIH field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIH_LSB         2
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSIH_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIH_HIGH  1
+    #define Si2146_TUNER_STATUS_RESPONSE_RSSIH_OK    0
+   /* TUNER_STATUS command, RSSI field definition (address 3, size 8, lsb 0, signed)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSI_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSI_MASK        0xff
+   #define  Si2146_TUNER_STATUS_RESPONSE_RSSI_SHIFT       24
+   /* TUNER_STATUS command, FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_FREQ_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_FREQ_MASK        0xffffffff
+   /* TUNER_STATUS command, MODE field definition (address 8, size 1, lsb 0, unsigned)*/
+   #define  Si2146_TUNER_STATUS_RESPONSE_MODE_LSB         0
+   #define  Si2146_TUNER_STATUS_RESPONSE_MODE_MASK        0x01
+    #define Si2146_TUNER_STATUS_RESPONSE_MODE_ATV  1
+    #define Si2146_TUNER_STATUS_RESPONSE_MODE_DTV  0
+
+#endif /* Si2146_TUNER_STATUS_CMD */
+
+#define   Si2146_TUNER_TUNE_FREQ_CMD 0x41
+
+#ifdef    Si2146_TUNER_TUNE_FREQ_CMD
+  #define Si2146_TUNER_TUNE_FREQ_CMD_CODE 0x010041
+
+    typedef struct { /* Si2146_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+   } Si2146_TUNER_TUNE_FREQ_CMD_struct;
+
+
+    typedef struct { /* Si2146_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+   }  Si2146_TUNER_TUNE_FREQ_CMD_REPLY_struct;
+
+   /* TUNER_TUNE_FREQ command, MODE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_MODE_LSB         0
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_MODE_MASK        0x01
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_MODE_MIN         0
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_MODE_MAX         1
+    #define Si2146_TUNER_TUNE_FREQ_CMD_MODE_ATV  1
+    #define Si2146_TUNER_TUNE_FREQ_CMD_MODE_DTV  0
+   /* TUNER_TUNE_FREQ command, FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_FREQ_LSB         0
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MASK        0xffffffff
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MIN         40000000
+   #define  Si2146_TUNER_TUNE_FREQ_CMD_FREQ_MAX         1002000000
+    #define Si2146_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN  40000000
+    #define Si2146_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX  1002000000
+#endif /* Si2146_TUNER_TUNE_FREQ_CMD */
+
+#define   Si2146_POWER_UP_CMD 0xc0
+
+#ifdef    Si2146_POWER_UP_CMD
+  #define Si2146_POWER_UP_CMD_CODE 0x0100c0
+
+    typedef struct { /* Si2146_POWER_UP_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   reserved1;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+     unsigned char   clock_mode;
+     unsigned char   clock_freq;
+     unsigned char   addr_mode;
+     unsigned char   func;
+     unsigned char   ctsien;
+     unsigned char   wake_up;
+   } Si2146_POWER_UP_CMD_struct;
+
+
+    typedef struct { /* Si2146_POWER_UP_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+   }  Si2146_POWER_UP_CMD_REPLY_struct;
+
+   /* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_SUBCODE_LSB         0
+   #define  Si2146_POWER_UP_CMD_SUBCODE_MASK        0xff
+   #define  Si2146_POWER_UP_CMD_SUBCODE_MIN         5
+   #define  Si2146_POWER_UP_CMD_SUBCODE_MAX         5
+    #define Si2146_POWER_UP_CMD_SUBCODE_CODE  5
+   /* POWER_UP command, RESERVED1 field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_RESERVED1_LSB         0
+   #define  Si2146_POWER_UP_CMD_RESERVED1_MASK        0xff
+   #define  Si2146_POWER_UP_CMD_RESERVED1_MIN         1
+   #define  Si2146_POWER_UP_CMD_RESERVED1_MAX         1
+    #define Si2146_POWER_UP_CMD_RESERVED1_RESERVED  1
+   /* POWER_UP command, RESERVED2 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_RESERVED2_LSB         0
+   #define  Si2146_POWER_UP_CMD_RESERVED2_MASK        0xff
+   #define  Si2146_POWER_UP_CMD_RESERVED2_MIN         0
+   #define  Si2146_POWER_UP_CMD_RESERVED2_MAX         0
+    #define Si2146_POWER_UP_CMD_RESERVED2_RESERVED  0
+   /* POWER_UP command, RESERVED3 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_RESERVED3_LSB         0
+   #define  Si2146_POWER_UP_CMD_RESERVED3_MASK        0xff
+   #define  Si2146_POWER_UP_CMD_RESERVED3_MIN         0
+   #define  Si2146_POWER_UP_CMD_RESERVED3_MAX         0
+    #define Si2146_POWER_UP_CMD_RESERVED3_RESERVED  0
+   /* POWER_UP command, CLOCK_MODE field definition (address 5,size 2, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_CLOCK_MODE_LSB         0
+   #define  Si2146_POWER_UP_CMD_CLOCK_MODE_MASK        0x03
+   #define  Si2146_POWER_UP_CMD_CLOCK_MODE_MIN         1
+   #define  Si2146_POWER_UP_CMD_CLOCK_MODE_MAX         3
+    #define Si2146_POWER_UP_CMD_CLOCK_MODE_EXTCLK  1
+    #define Si2146_POWER_UP_CMD_CLOCK_MODE_XTAL    3
+   /* POWER_UP command, CLOCK_FREQ field definition (address 5,size 2, lsb 2, unsigned) */
+   #define  Si2146_POWER_UP_CMD_CLOCK_FREQ_LSB         2
+   #define  Si2146_POWER_UP_CMD_CLOCK_FREQ_MASK        0x03
+   #define  Si2146_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+   #define  Si2146_POWER_UP_CMD_CLOCK_FREQ_MAX         2
+    #define Si2146_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+   /* POWER_UP command, ADDR_MODE field definition (address 6,size 1, lsb 4, unsigned) */
+   #define  Si2146_POWER_UP_CMD_ADDR_MODE_LSB         4
+   #define  Si2146_POWER_UP_CMD_ADDR_MODE_MASK        0x01
+   #define  Si2146_POWER_UP_CMD_ADDR_MODE_MIN         0
+   #define  Si2146_POWER_UP_CMD_ADDR_MODE_MAX         1
+    #define Si2146_POWER_UP_CMD_ADDR_MODE_CAPTURE  1
+    #define Si2146_POWER_UP_CMD_ADDR_MODE_CURRENT  0
+   /* POWER_UP command, FUNC field definition (address 7,size 4, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_FUNC_LSB         0
+   #define  Si2146_POWER_UP_CMD_FUNC_MASK        0x0f
+   #define  Si2146_POWER_UP_CMD_FUNC_MIN         0
+   #define  Si2146_POWER_UP_CMD_FUNC_MAX         1
+    #define Si2146_POWER_UP_CMD_FUNC_BOOTLOADER  0
+    #define Si2146_POWER_UP_CMD_FUNC_NORMAL      1
+   /* POWER_UP command, CTSIEN field definition (address 7,size 1, lsb 7, unsigned) */
+   #define  Si2146_POWER_UP_CMD_CTSIEN_LSB         7
+   #define  Si2146_POWER_UP_CMD_CTSIEN_MASK        0x01
+   #define  Si2146_POWER_UP_CMD_CTSIEN_MIN         0
+   #define  Si2146_POWER_UP_CMD_CTSIEN_MAX         1
+    #define Si2146_POWER_UP_CMD_CTSIEN_DISABLE  0
+    #define Si2146_POWER_UP_CMD_CTSIEN_ENABLE   1
+   /* POWER_UP command, WAKE_UP field definition (address 8,size 1, lsb 0, unsigned) */
+   #define  Si2146_POWER_UP_CMD_WAKE_UP_LSB         0
+   #define  Si2146_POWER_UP_CMD_WAKE_UP_MASK        0x01
+   #define  Si2146_POWER_UP_CMD_WAKE_UP_MIN         1
+   #define  Si2146_POWER_UP_CMD_WAKE_UP_MAX         1
+    #define Si2146_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif /* Si2146_POWER_UP_CMD */
+
+#define   Si2146_PART_INFO_CMD 0x02
+
+#ifdef    Si2146_PART_INFO_CMD
+  #define Si2146_PART_INFO_CMD_CODE 0x010002
+
+    typedef struct { /* Si2146_PART_INFO_CMD_struct */
+         unsigned char   nothing;   } Si2146_PART_INFO_CMD_struct;
+
+
+    typedef struct { /* Si2146_PART_INFO_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+   }  Si2146_PART_INFO_CMD_REPLY_struct;
+
+   /* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_CHIPREV_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+    #define Si2146_PART_INFO_RESPONSE_CHIPREV_A  1
+    #define Si2146_PART_INFO_RESPONSE_CHIPREV_B  2
+   /* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_ROMID_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_ROMID_MASK        0xff
+   /* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_PART_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_PART_MASK        0xff
+   /* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_PMAJOR_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+   /* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_PMINOR_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+   /* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_PBUILD_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+   /* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_RESERVED_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+   /* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+   #define  Si2146_PART_INFO_RESPONSE_SERIAL_LSB         0
+   #define  Si2146_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+
+#endif /* Si2146_PART_INFO_CMD */
+
+/* Si2146_DTV_STATUS command definition */
+#define   Si2146_DTV_STATUS_CMD 0x62
+
+#ifdef    Si2146_DTV_STATUS_CMD
+	#define Si2146_DTV_STATUS_CMD_CODE 0x010062
+
+	typedef struct { /* Si2146_DTV_STATUS_CMD_struct */
+	 unsigned char   intack;
+	} Si2146_DTV_STATUS_CMD_struct;
+
+	typedef struct { /* Si2146_DTV_STATUS_CMD_REPLY_struct */
+	   Si2146_COMMON_REPLY_struct * STATUS;
+	  unsigned char   chlint;
+	  unsigned char   chl;
+	  unsigned char   bw;
+	  unsigned char   modulation;
+	}  Si2146_DTV_STATUS_CMD_REPLY_struct;
+
+	/* DTV_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+	#define  Si2146_DTV_STATUS_CMD_INTACK_LSB         0
+	#define  Si2146_DTV_STATUS_CMD_INTACK_MASK        0x01
+	#define  Si2146_DTV_STATUS_CMD_INTACK_MIN         0
+	#define  Si2146_DTV_STATUS_CMD_INTACK_MAX         1
+	#define Si2146_DTV_STATUS_CMD_INTACK_CLEAR  1
+	#define Si2146_DTV_STATUS_CMD_INTACK_OK     0
+	/* DTV_STATUS command, CHLINT field definition (address 1, size 1, lsb 0, unsigned)*/
+	#define  Si2146_DTV_STATUS_RESPONSE_CHLINT_LSB         0
+	#define  Si2146_DTV_STATUS_RESPONSE_CHLINT_MASK        0x01
+	#define Si2146_DTV_STATUS_RESPONSE_CHLINT_CHANGED    1
+	#define Si2146_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE  0
+	/* DTV_STATUS command, CHL field definition (address 2, size 1, lsb 0, unsigned)*/
+	#define  Si2146_DTV_STATUS_RESPONSE_CHL_LSB         0
+	#define  Si2146_DTV_STATUS_RESPONSE_CHL_MASK        0x01
+	#define Si2146_DTV_STATUS_RESPONSE_CHL_CHANNEL     1
+	#define Si2146_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL  0
+	/* DTV_STATUS command, BW field definition (address 3, size 4, lsb 0, unsigned)*/
+	#define  Si2146_DTV_STATUS_RESPONSE_BW_LSB         0
+	#define  Si2146_DTV_STATUS_RESPONSE_BW_MASK        0x0f
+	#define Si2146_DTV_STATUS_RESPONSE_BW_BW_6MHZ  6
+	#define Si2146_DTV_STATUS_RESPONSE_BW_BW_7MHZ  7
+	#define Si2146_DTV_STATUS_RESPONSE_BW_BW_8MHZ  8
+	/* DTV_STATUS command, MODULATION field definition (address 3, size 4, lsb 4, unsigned)*/
+	#define  Si2146_DTV_STATUS_RESPONSE_MODULATION_LSB         4
+	#define  Si2146_DTV_STATUS_RESPONSE_MODULATION_MASK        0x0f
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_ATSC    0
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_DTMB    6
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_DVBC    3
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_DVBT    2
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_ISDBC   5
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_ISDBT   4
+	#define Si2146_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+#endif /* Si2146_DTV_STATUS_CMD */
+
+#define   Si2146_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef    Si2146_EXIT_BOOTLOADER_CMD
+  #define Si2146_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+    typedef struct { /* Si2146_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+   } Si2146_EXIT_BOOTLOADER_CMD_struct;
+
+
+    typedef struct { /* Si2146_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+   }  Si2146_EXIT_BOOTLOADER_CMD_REPLY_struct;
+
+   /* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+   #define  Si2146_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+   #define  Si2146_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+   #define  Si2146_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+   #define  Si2146_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+    #define Si2146_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+    #define Si2146_EXIT_BOOTLOADER_CMD_FUNC_TUNER       1
+   /* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+   #define  Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+   #define  Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+   #define  Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+    #define Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+    #define Si2146_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif /* Si2146_EXIT_BOOTLOADER_CMD */
+
+#define   Si2146_CONFIG_PINS_CMD 0x12
+
+#ifdef    Si2146_CONFIG_PINS_CMD
+  #define Si2146_CONFIG_PINS_CMD_CODE 0x010012
+
+    typedef struct { /* Si2146_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+     unsigned char   gpio2_mode;
+     unsigned char   gpio2_read;
+     unsigned char   gpio3_mode;
+     unsigned char   gpio3_read;
+     unsigned char   bclk1_mode;
+     unsigned char   bclk1_read;
+     unsigned char   xout_mode;
+   } Si2146_CONFIG_PINS_CMD_struct;
+
+
+    typedef struct { /* Si2146_CONFIG_PINS_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+      unsigned char   gpio2_mode;
+      unsigned char   gpio2_state;
+      unsigned char   gpio3_mode;
+      unsigned char   gpio3_state;
+      unsigned char   bclk1_mode;
+      unsigned char   bclk1_state;
+      unsigned char   xout_mode;
+   }  Si2146_CONFIG_PINS_CMD_REPLY_struct;
+
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_MODE_MAX         3
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO1_READ field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+    #define Si2146_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_MODE_MASK        0x7f
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_MODE_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_MODE_MAX         3
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0    2
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1    3
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO2_READ field definition (address 2,size 1, lsb 7, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_READ_LSB         7
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_READ_MASK        0x01
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_READ_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO2_READ_MAX         1
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ  0
+    #define Si2146_CONFIG_PINS_CMD_GPIO2_READ_READ         1
+   /* CONFIG_PINS command, GPIO3_MODE field definition (address 3,size 7, lsb 0, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_MODE_MASK        0x7f
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_MODE_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_MODE_MAX         3
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_0    2
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_1    3
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO3_READ field definition (address 3,size 1, lsb 7, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_READ_LSB         7
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_READ_MASK        0x01
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_READ_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_GPIO3_READ_MAX         1
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ  0
+    #define Si2146_CONFIG_PINS_CMD_GPIO3_READ_READ         1
+   /* CONFIG_PINS command, BCLK1_MODE field definition (address 4,size 7, lsb 0, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_MODE_MASK        0x7f
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_MODE_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_MODE_MAX         11
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_MODE_NO_CHANGE  0
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_MODE_XOUT       10
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_MODE_XOUT_HIGH  11
+   /* CONFIG_PINS command, BCLK1_READ field definition (address 4,size 1, lsb 7, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_READ_LSB         7
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_READ_MASK        0x01
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_READ_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_BCLK1_READ_MAX         1
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ  0
+    #define Si2146_CONFIG_PINS_CMD_BCLK1_READ_READ         1
+   /* CONFIG_PINS command, XOUT_MODE field definition (address 5,size 7, lsb 0, unsigned) */
+   #define  Si2146_CONFIG_PINS_CMD_XOUT_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_CMD_XOUT_MODE_MASK        0x7f
+   #define  Si2146_CONFIG_PINS_CMD_XOUT_MODE_MIN         0
+   #define  Si2146_CONFIG_PINS_CMD_XOUT_MODE_MAX         10
+    #define Si2146_CONFIG_PINS_CMD_XOUT_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_CMD_XOUT_MODE_NO_CHANGE  0
+    #define Si2146_CONFIG_PINS_CMD_XOUT_MODE_XOUT       10
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE  1
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0  2
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO1_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK        0x7f
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE  1
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0  2
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO2_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB         7
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK        0x01
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0  0
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1  1
+   /* CONFIG_PINS command, GPIO3_MODE field definition (address 3, size 7, lsb 0, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK        0x7f
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_DISABLE  1
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_0  2
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO3_STATE field definition (address 3, size 1, lsb 7, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB         7
+   #define  Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK        0x01
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_0  0
+    #define Si2146_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_1  1
+   /* CONFIG_PINS command, BCLK1_MODE field definition (address 4, size 7, lsb 0, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK        0x7f
+    #define Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_DISABLE    1
+    #define Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT       10
+    #define Si2146_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT_HIGH  11
+   /* CONFIG_PINS command, BCLK1_STATE field definition (address 4, size 1, lsb 7, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB         7
+   #define  Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK        0x01
+    #define Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_0  0
+    #define Si2146_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_1  1
+   /* CONFIG_PINS command, XOUT_MODE field definition (address 5, size 7, lsb 0, unsigned)*/
+   #define  Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB         0
+   #define  Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK        0x7f
+    #define Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_DISABLE  1
+    #define Si2146_CONFIG_PINS_RESPONSE_XOUT_MODE_XOUT     10
+
+#endif /* Si2146_CONFIG_PINS_CMD */
+
+#define   Si2146_STANDBY_CMD 0x16
+
+#ifdef    Si2146_STANDBY_CMD
+  #define Si2146_STANDBY_CMD_CODE 0x010016
+
+    typedef struct { /* Si2146_STANDBY_CMD_struct */
+         unsigned char   nothing;   } Si2146_STANDBY_CMD_struct;
+
+
+    typedef struct { /* Si2146_STANDBY_CMD_REPLY_struct */
+       Si2146_COMMON_REPLY_struct * STATUS;
+   }  Si2146_STANDBY_CMD_REPLY_struct;
+
+#endif /* Si2146_STANDBY_CMD */
+
+typedef struct
+{ // Si2146_CmdObj struct
+	#ifdef    Si2146_AGC_OVERRIDE_CMD
+			  Si2146_AGC_OVERRIDE_CMD_struct               agc_override;
+	#endif /* Si2146_AGC_OVERRIDE_CMD */
+	#ifdef    Si2146_ATV_RESTART_CMD
+			  Si2146_ATV_RESTART_CMD_struct      atv_restart;
+	#endif /* Si2146_ATV_RESTART_CMD */
+	#ifdef    Si2146_ATV_STATUS_CMD
+			  Si2146_ATV_STATUS_CMD_struct       atv_status;
+	#endif /* Si2146_ATV_STATUS_CMD */
+	#ifdef    Si2146_CONFIG_PINS_CMD
+			  Si2146_CONFIG_PINS_CMD_struct                config_pins;
+	#endif /* Si2146_CONFIG_PINS_CMD */
+	#ifdef    Si2146_DTV_RESTART_CMD
+			  Si2146_DTV_RESTART_CMD_struct                dtv_restart;
+	#endif /* Si2146_DTV_RESTART_CMD */
+	#ifdef    Si2146_DTV_STATUS_CMD
+			  Si2146_DTV_STATUS_CMD_struct                 dtv_status;
+	#endif /* Si2146_DTV_STATUS_CMD */
+	#ifdef    Si2146_EXIT_BOOTLOADER_CMD
+			  Si2146_EXIT_BOOTLOADER_CMD_struct            exit_bootloader;
+	#endif /* Si2146_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2146_FINE_TUNE_CMD
+			  Si2146_FINE_TUNE_CMD_struct                  fine_tune;
+	#endif /* Si2146_FINE_TUNE_CMD */
+	#ifdef    Si2146_GET_PROPERTY_CMD
+			  Si2146_GET_PROPERTY_CMD_struct               get_property;
+	#endif /* Si2146_GET_PROPERTY_CMD */
+	#ifdef    Si2146_GET_REV_CMD
+			  Si2146_GET_REV_CMD_struct                    get_rev;
+	#endif /* Si2146_GET_REV_CMD */
+	#ifdef    Si2146_PART_INFO_CMD
+			  Si2146_PART_INFO_CMD_struct                  part_info;
+	#endif /* Si2146_PART_INFO_CMD */
+	#ifdef    Si2146_POWER_DOWN_CMD
+			  Si2146_POWER_DOWN_CMD_struct                 power_down;
+	#endif /* Si2146_POWER_DOWN_CMD */
+	#ifdef    Si2146_POWER_UP_CMD
+			  Si2146_POWER_UP_CMD_struct                   power_up;
+	#endif /* Si2146_POWER_UP_CMD */
+	#ifdef    Si2146_SET_PROPERTY_CMD
+			  Si2146_SET_PROPERTY_CMD_struct               set_property;
+	#endif /* Si2146_SET_PROPERTY_CMD */
+	#ifdef    Si2146_STANDBY_CMD
+			  Si2146_STANDBY_CMD_struct                    standby;
+	#endif /* Si2146_STANDBY_CMD */
+	#ifdef    Si2146_TUNER_STATUS_CMD
+			  Si2146_TUNER_STATUS_CMD_struct               tuner_status;
+	#endif /* Si2146_TUNER_STATUS_CMD */
+	#ifdef    Si2146_TUNER_TUNE_FREQ_CMD
+			  Si2146_TUNER_TUNE_FREQ_CMD_struct            tuner_tune_freq;
+	#endif /* Si2146_TUNER_TUNE_FREQ_CMD */
+} Si2146_CmdObj;
+
+// Si2148_CONFIG_CLOCKS command definition
+#define   Si2148_CONFIG_CLOCKS_CMD 0xc0
+
+#ifdef    Si2148_CONFIG_CLOCKS_CMD
+	#define Si2148_CONFIG_CLOCKS_CMD_CODE 0x0100c0
+	typedef struct
+	{ // Si2148_CONFIG_CLOCKS_CMD_struct
+		unsigned char   subcode;
+		unsigned char   clock_mode;
+		unsigned char   en_xout;
+	} Si2148_CONFIG_CLOCKS_CMD_struct;
+	typedef struct
+	{ // Si2148_CONFIG_CLOCKS_CMD_REPLY_struct
+		Si2148_COMMON_REPLY_struct * STATUS;
+	}  Si2148_CONFIG_CLOCKS_CMD_REPLY_struct;
+	// CONFIG_CLOCKS command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned)
+	#define  Si2148_CONFIG_CLOCKS_CMD_SUBCODE_LSB         0
+	#define  Si2148_CONFIG_CLOCKS_CMD_SUBCODE_MASK        0xff
+	#define  Si2148_CONFIG_CLOCKS_CMD_SUBCODE_MIN         0
+	#define  Si2148_CONFIG_CLOCKS_CMD_SUBCODE_MAX         0
+	#define Si2148_CONFIG_CLOCKS_CMD_SUBCODE_CODE  0
+	// CONFIG_CLOCKS command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned)
+	#define  Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB         0
+	#define  Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK        0x03
+	#define  Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_MIN         0
+	#define  Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX         2
+	#define Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_EXTCLK  2
+	#define Si2148_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL    0
+	// CONFIG_CLOCKS command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned)
+	#define  Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_LSB         2
+	#define  Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_MASK        0x07
+	#define  Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_MIN         0
+	#define  Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_MAX         3
+	#define Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT  0
+	#define Si2148_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT   3
+#endif // Si2148_CONFIG_CLOCKS_CMD
+
+// Si2148_STANDBY command definition
+#define   Si2148_STANDBY_CMD 0x16
+
+#ifdef    Si2148_STANDBY_CMD
+	#define Si2148_STANDBY_CMD_CODE 0x010016
+	typedef struct
+	{ // Si2148_STANDBY_CMD_struct
+		unsigned char   type;
+	} Si2148_STANDBY_CMD_struct;
+	typedef struct
+	{ // Si2148_STANDBY_CMD_REPLY_struct
+		Si2148_COMMON_REPLY_struct * STATUS;
+	} Si2148_STANDBY_CMD_REPLY_struct;
+	// STANDBY command, TYPE field definition (address 1,size 1, lsb 0, unsigned)
+	#define  Si2148_STANDBY_CMD_TYPE_LSB         0
+	#define  Si2148_STANDBY_CMD_TYPE_MASK        0x01
+	#define  Si2148_STANDBY_CMD_TYPE_MIN         0
+	#define  Si2148_STANDBY_CMD_TYPE_MAX         1
+	#define Si2148_STANDBY_CMD_TYPE_LNA_OFF  1
+	#define Si2148_STANDBY_CMD_TYPE_LNA_ON   0
+#endif // Si2148_STANDBY_CMD
+
+// Si2148_POWER_UP command definition
+#define   Si2148_POWER_UP_CMD 0xc0
+#ifdef    Si2148_POWER_UP_CMD
+	#define Si2148_POWER_UP_CMD_CODE 0x0300c0
+	typedef struct { /* Si2148_POWER_UP_CMD_struct */
+	 unsigned char   subcode;
+	 unsigned char   clock_mode;
+	 unsigned char   en_xout;
+	 unsigned char   pd_ldo;
+	 unsigned char   reserved2;
+	 unsigned char   reserved3;
+	 unsigned char   reserved4;
+	 unsigned char   reserved5;
+	 unsigned char   reserved6;
+	 unsigned char   reserved7;
+	 unsigned char   reset;
+	 unsigned char   clock_freq;
+	 unsigned char   reserved8;
+	 unsigned char   func;
+	 unsigned char   ctsien;
+	 unsigned char   wake_up;
+	} Si2148_POWER_UP_CMD_struct;
+	typedef struct { /* Si2148_POWER_UP_CMD_REPLY_struct */
+	   Si2148_COMMON_REPLY_struct * STATUS;
+	}  Si2148_POWER_UP_CMD_REPLY_struct;
+
+	/* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_SUBCODE_LSB         0
+	#define  Si2148_POWER_UP_CMD_SUBCODE_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_SUBCODE_MIN         0
+	#define  Si2148_POWER_UP_CMD_SUBCODE_MAX         0
+	#define Si2148_POWER_UP_CMD_SUBCODE_CODE  0
+	/* POWER_UP command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_CLOCK_MODE_LSB         0
+	#define  Si2148_POWER_UP_CMD_CLOCK_MODE_MASK        0x03
+	#define  Si2148_POWER_UP_CMD_CLOCK_MODE_MIN         0
+	#define  Si2148_POWER_UP_CMD_CLOCK_MODE_MAX         2
+	#define Si2148_POWER_UP_CMD_CLOCK_MODE_EXTCLK  2
+	#define Si2148_POWER_UP_CMD_CLOCK_MODE_XTAL    0
+	/* POWER_UP command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+	#define  Si2148_POWER_UP_CMD_EN_XOUT_LSB         2
+	#define  Si2148_POWER_UP_CMD_EN_XOUT_MASK        0x07
+	#define  Si2148_POWER_UP_CMD_EN_XOUT_MIN         0
+	#define  Si2148_POWER_UP_CMD_EN_XOUT_MAX         3
+	#define Si2148_POWER_UP_CMD_EN_XOUT_DIS_XOUT  0
+	#define Si2148_POWER_UP_CMD_EN_XOUT_EN_XOUT   3
+	/* POWER_UP command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_PD_LDO_LSB         0
+	#define  Si2148_POWER_UP_CMD_PD_LDO_MASK        0x01
+	#define  Si2148_POWER_UP_CMD_PD_LDO_MIN         0
+	#define  Si2148_POWER_UP_CMD_PD_LDO_MAX         1
+	#define Si2148_POWER_UP_CMD_PD_LDO_LDO_POWER_DOWN  1
+	#define Si2148_POWER_UP_CMD_PD_LDO_LDO_POWER_UP    0
+	/* POWER_UP command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED2_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED2_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED2_MIN         0
+	#define  Si2148_POWER_UP_CMD_RESERVED2_MAX         0
+	#define Si2148_POWER_UP_CMD_RESERVED2_RESERVED  0
+	/* POWER_UP command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED3_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED3_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED3_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESERVED3_MAX         1
+	#define Si2148_POWER_UP_CMD_RESERVED3_RESERVED  1
+	/* POWER_UP command, RESERVED4 field definition (address 6,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED4_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED4_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED4_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESERVED4_MAX         1
+	#define Si2148_POWER_UP_CMD_RESERVED4_RESERVED  1
+	/* POWER_UP command, RESERVED5 field definition (address 7,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED5_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED5_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED5_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESERVED5_MAX         1
+	#define Si2148_POWER_UP_CMD_RESERVED5_RESERVED  1
+	/* POWER_UP command, RESERVED6 field definition (address 8,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED6_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED6_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED6_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESERVED6_MAX         1
+	#define Si2148_POWER_UP_CMD_RESERVED6_RESERVED  1
+	/* POWER_UP command, RESERVED7 field definition (address 9,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED7_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED7_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED7_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESERVED7_MAX         1
+	#define Si2148_POWER_UP_CMD_RESERVED7_RESERVED  1
+	/* POWER_UP command, RESET field definition (address 10,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESET_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESET_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESET_MIN         1
+	#define  Si2148_POWER_UP_CMD_RESET_MAX         1
+	#define Si2148_POWER_UP_CMD_RESET_RESET  1
+	/* POWER_UP command, CLOCK_FREQ field definition (address 11,size 2, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_CLOCK_FREQ_LSB         0
+	#define  Si2148_POWER_UP_CMD_CLOCK_FREQ_MASK        0x03
+	#define  Si2148_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+	#define  Si2148_POWER_UP_CMD_CLOCK_FREQ_MAX         3
+	#define Si2148_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+	/* POWER_UP command, RESERVED8 field definition (address 12,size 8, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_RESERVED8_LSB         0
+	#define  Si2148_POWER_UP_CMD_RESERVED8_MASK        0xff
+	#define  Si2148_POWER_UP_CMD_RESERVED8_MIN         0
+	#define  Si2148_POWER_UP_CMD_RESERVED8_MAX         0
+	#define Si2148_POWER_UP_CMD_RESERVED8_RESERVED  0
+	/* POWER_UP command, FUNC field definition (address 13,size 4, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_FUNC_LSB         0
+	#define  Si2148_POWER_UP_CMD_FUNC_MASK        0x0f
+	#define  Si2148_POWER_UP_CMD_FUNC_MIN         0
+	#define  Si2148_POWER_UP_CMD_FUNC_MAX         1
+	#define Si2148_POWER_UP_CMD_FUNC_BOOTLOADER  0
+	#define Si2148_POWER_UP_CMD_FUNC_NORMAL      1
+	/* POWER_UP command, CTSIEN field definition (address 13,size 1, lsb 7, unsigned) */
+	#define  Si2148_POWER_UP_CMD_CTSIEN_LSB         7
+	#define  Si2148_POWER_UP_CMD_CTSIEN_MASK        0x01
+	#define  Si2148_POWER_UP_CMD_CTSIEN_MIN         0
+	#define  Si2148_POWER_UP_CMD_CTSIEN_MAX         1
+	#define Si2148_POWER_UP_CMD_CTSIEN_DISABLE  0
+	#define Si2148_POWER_UP_CMD_CTSIEN_ENABLE   1
+	/* POWER_UP command, WAKE_UP field definition (address 14,size 1, lsb 0, unsigned) */
+	#define  Si2148_POWER_UP_CMD_WAKE_UP_LSB         0
+	#define  Si2148_POWER_UP_CMD_WAKE_UP_MASK        0x01
+	#define  Si2148_POWER_UP_CMD_WAKE_UP_MIN         1
+	#define  Si2148_POWER_UP_CMD_WAKE_UP_MAX         1
+	#define Si2148_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif /* Si2148_POWER_UP_CMD */
+
+/* Si2148_PART_INFO command definition */
+#define   Si2148_PART_INFO_CMD 0x02
+
+#ifdef    Si2148_PART_INFO_CMD
+	#define Si2148_PART_INFO_CMD_CODE 0x010002
+
+	typedef struct { /* Si2148_PART_INFO_CMD_struct */
+		 unsigned char   nothing;   } Si2148_PART_INFO_CMD_struct;
+
+	typedef struct { /* Si2148_PART_INFO_CMD_REPLY_struct */
+	   Si2148_COMMON_REPLY_struct * STATUS;
+	  unsigned char   chiprev;
+	  unsigned char   romid;
+	  unsigned char   part;
+	  unsigned char   pmajor;
+	  unsigned char   pminor;
+	  unsigned char   pbuild;
+	  unsigned int    reserved;
+	  unsigned long   serial;
+	}  Si2148_PART_INFO_CMD_REPLY_struct;
+
+	/* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_CHIPREV_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+	#define Si2148_PART_INFO_RESPONSE_CHIPREV_A  1
+	#define Si2148_PART_INFO_RESPONSE_CHIPREV_B  2
+	/* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_ROMID_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_ROMID_MASK        0xff
+	/* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_PART_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_PART_MASK        0xff
+	/* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_PMAJOR_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+	/* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_PMINOR_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+	/* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_PBUILD_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+	/* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_RESERVED_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+	/* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+	#define  Si2148_PART_INFO_RESPONSE_SERIAL_LSB         0
+	#define  Si2148_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+#endif /* Si2148_PART_INFO_CMD */
+
+/* Si2148_EXIT_BOOTLOADER command definition */
+#define   Si2148_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef    Si2148_EXIT_BOOTLOADER_CMD
+  #define Si2148_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+    typedef struct { /* Si2148_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+   } Si2148_EXIT_BOOTLOADER_CMD_struct;
+
+
+    typedef struct { /* Si2148_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       Si2148_COMMON_REPLY_struct * STATUS;
+   }  Si2148_EXIT_BOOTLOADER_CMD_REPLY_struct;
+
+   /* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+   #define  Si2148_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+   #define  Si2148_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+   #define  Si2148_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+   #define  Si2148_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+    #define Si2148_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+    #define Si2148_EXIT_BOOTLOADER_CMD_FUNC_TUNER       1
+   /* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+   #define  Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+   #define  Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+   #define  Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+    #define Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+    #define Si2148_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif /* Si2148_EXIT_BOOTLOADER_CMD */
+/* Si2148_SET_PROPERTY command definition */
+#define   Si2148_SET_PROPERTY_CMD 0x14
+
+#ifdef    Si2148_SET_PROPERTY_CMD
+  #define Si2148_SET_PROPERTY_CMD_CODE 0x010014
+
+    typedef struct { /* Si2148_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int    prop;
+     unsigned int    data;
+   } Si2148_SET_PROPERTY_CMD_struct;
+
+
+    typedef struct { /* Si2148_SET_PROPERTY_CMD_REPLY_struct */
+       Si2148_COMMON_REPLY_struct * STATUS;
+      unsigned char   reserved;
+      unsigned int    data;
+   }  Si2148_SET_PROPERTY_CMD_REPLY_struct;
+
+   /* SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2148_SET_PROPERTY_CMD_RESERVED_LSB         0
+   #define  Si2148_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+   #define  Si2148_SET_PROPERTY_CMD_RESERVED_MIN         0
+   #define  Si2148_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+   /* SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+   #define  Si2148_SET_PROPERTY_CMD_PROP_LSB         0
+   #define  Si2148_SET_PROPERTY_CMD_PROP_MASK        0xffff
+   #define  Si2148_SET_PROPERTY_CMD_PROP_MIN         0
+   #define  Si2148_SET_PROPERTY_CMD_PROP_MAX         65535
+    #define Si2148_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+    #define Si2148_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+   /* SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned) */
+   #define  Si2148_SET_PROPERTY_CMD_DATA_LSB         0
+   #define  Si2148_SET_PROPERTY_CMD_DATA_MASK        0xffff
+   #define  Si2148_SET_PROPERTY_CMD_DATA_MIN         0
+   #define  Si2148_SET_PROPERTY_CMD_DATA_MAX         65535
+    #define Si2148_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+    #define Si2148_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+   /* SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2148_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+   #define  Si2148_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+    #define Si2148_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+    #define Si2148_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+   /* SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2148_SET_PROPERTY_RESPONSE_DATA_LSB         0
+   #define  Si2148_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2148_SET_PROPERTY_CMD */
+
+/* Si2148_TUNER_TUNE_FREQ command definition */
+#define   Si2148_TUNER_TUNE_FREQ_CMD 0x41
+
+#ifdef    Si2148_TUNER_TUNE_FREQ_CMD
+  #define Si2148_TUNER_TUNE_FREQ_CMD_CODE 0x010041
+
+    typedef struct { /* Si2148_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+   } Si2148_TUNER_TUNE_FREQ_CMD_struct;
+
+
+    typedef struct { /* Si2148_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       Si2148_COMMON_REPLY_struct * STATUS;
+   }  Si2148_TUNER_TUNE_FREQ_CMD_REPLY_struct;
+
+   /* TUNER_TUNE_FREQ command, MODE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_MODE_LSB         0
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_MODE_MASK        0x01
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_MODE_MIN         0
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_MODE_MAX         1
+    #define Si2148_TUNER_TUNE_FREQ_CMD_MODE_ATV  1
+    #define Si2148_TUNER_TUNE_FREQ_CMD_MODE_DTV  0
+   /* TUNER_TUNE_FREQ command, FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_FREQ_LSB         0
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MASK        0xffffffff
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MIN         40000000
+   #define  Si2148_TUNER_TUNE_FREQ_CMD_FREQ_MAX         1002000000
+    #define Si2148_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN  40000000
+    #define Si2148_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX  1002000000
+#endif /* Si2148_TUNER_TUNE_FREQ_CMD */
+
+/* Si2148_TUNER_STATUS command definition */
+#define   Si2148_TUNER_STATUS_CMD 0x42
+
+#ifdef    Si2148_TUNER_STATUS_CMD
+  #define Si2148_TUNER_STATUS_CMD_CODE 0x010042
+
+    typedef struct { /* Si2148_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2148_TUNER_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2148_TUNER_STATUS_CMD_REPLY_struct */
+       Si2148_COMMON_REPLY_struct * STATUS;
+      unsigned char   tcint;
+      unsigned char   rssilint;
+      unsigned char   rssihint;
+               int    vco_code;
+      unsigned char   tc;
+      unsigned char   rssil;
+      unsigned char   rssih;
+               char   rssi;
+      unsigned long   freq;
+      unsigned char   mode;
+   }  Si2148_TUNER_STATUS_CMD_REPLY_struct;
+
+   /* TUNER_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2148_TUNER_STATUS_CMD_INTACK_LSB         0
+   #define  Si2148_TUNER_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2148_TUNER_STATUS_CMD_INTACK_MIN         0
+   #define  Si2148_TUNER_STATUS_CMD_INTACK_MAX         1
+    #define Si2148_TUNER_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2148_TUNER_STATUS_CMD_INTACK_OK     0
+   /* TUNER_STATUS command, TCINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_TCINT_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_TCINT_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_TCINT_CHANGED    1
+    #define Si2148_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSILINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSILINT_LSB         1
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSILINT_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED    1
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSIHINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_LSB         2
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED    1
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+   /* TUNER_STATUS command, VCO_CODE field definition (address 10, size 16, lsb 0, signed)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_MASK        0xffff
+   #define  Si2148_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT       16
+   /* TUNER_STATUS command, TC field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_TC_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_TC_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_TC_BUSY  0
+    #define Si2148_TUNER_STATUS_RESPONSE_TC_DONE  1
+   /* TUNER_STATUS command, RSSIL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIL_LSB         1
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIL_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIL_LOW  1
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIL_OK   0
+   /* TUNER_STATUS command, RSSIH field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIH_LSB         2
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSIH_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIH_HIGH  1
+    #define Si2148_TUNER_STATUS_RESPONSE_RSSIH_OK    0
+   /* TUNER_STATUS command, RSSI field definition (address 3, size 8, lsb 0, signed)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSI_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSI_MASK        0xff
+   #define  Si2148_TUNER_STATUS_RESPONSE_RSSI_SHIFT       24
+   /* TUNER_STATUS command, FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_FREQ_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_FREQ_MASK        0xffffffff
+   /* TUNER_STATUS command, MODE field definition (address 8, size 1, lsb 0, unsigned)*/
+   #define  Si2148_TUNER_STATUS_RESPONSE_MODE_LSB         0
+   #define  Si2148_TUNER_STATUS_RESPONSE_MODE_MASK        0x01
+    #define Si2148_TUNER_STATUS_RESPONSE_MODE_ATV  1
+    #define Si2148_TUNER_STATUS_RESPONSE_MODE_DTV  0
+
+#endif /* Si2148_TUNER_STATUS_CMD */
+
+typedef struct { /* Si2148_CmdObj struct */
+	#ifdef    Si2148_AGC_OVERRIDE_CMD
+			  Si2148_AGC_OVERRIDE_CMD_struct     agc_override;
+	#endif /* Si2148_AGC_OVERRIDE_CMD */
+	#ifdef    Si2148_ATV_CW_TEST_CMD
+			  Si2148_ATV_CW_TEST_CMD_struct      atv_cw_test;
+	#endif /* Si2148_ATV_CW_TEST_CMD */
+	#ifdef    Si2148_CONFIG_CLOCKS_CMD
+			  Si2148_CONFIG_CLOCKS_CMD_struct    config_clocks;
+	#endif /* Si2148_CONFIG_CLOCKS_CMD */
+	#ifdef    Si2148_CONFIG_PINS_CMD
+			  Si2148_CONFIG_PINS_CMD_struct      config_pins;
+	#endif /* Si2148_CONFIG_PINS_CMD */
+	#ifdef    Si2148_DTV_RESTART_CMD
+			  Si2148_DTV_RESTART_CMD_struct      dtv_restart;
+	#endif /* Si2148_DTV_RESTART_CMD */
+	#ifdef    Si2148_DTV_STATUS_CMD
+			  Si2148_DTV_STATUS_CMD_struct       dtv_status;
+	#endif /* Si2148_DTV_STATUS_CMD */
+	#ifdef    Si2148_EXIT_BOOTLOADER_CMD
+			  Si2148_EXIT_BOOTLOADER_CMD_struct  exit_bootloader;
+	#endif /* Si2148_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2148_FINE_TUNE_CMD
+			  Si2148_FINE_TUNE_CMD_struct        fine_tune;
+	#endif /* Si2148_FINE_TUNE_CMD */
+	#ifdef    Si2148_GET_PROPERTY_CMD
+			  Si2148_GET_PROPERTY_CMD_struct     get_property;
+	#endif /* Si2148_GET_PROPERTY_CMD */
+	#ifdef    Si2148_GET_REV_CMD
+			  Si2148_GET_REV_CMD_struct          get_rev;
+	#endif /* Si2148_GET_REV_CMD */
+	#ifdef    Si2148_PART_INFO_CMD
+			  Si2148_PART_INFO_CMD_struct        part_info;
+	#endif /* Si2148_PART_INFO_CMD */
+	#ifdef    Si2148_POWER_DOWN_CMD
+			  Si2148_POWER_DOWN_CMD_struct       power_down;
+	#endif /* Si2148_POWER_DOWN_CMD */
+	#ifdef    Si2148_POWER_DOWN_HW_CMD
+			  Si2148_POWER_DOWN_HW_CMD_struct    power_down_hw;
+	#endif /* Si2148_POWER_DOWN_HW_CMD */
+	#ifdef    Si2148_POWER_UP_CMD
+			  Si2148_POWER_UP_CMD_struct         power_up;
+	#endif /* Si2148_POWER_UP_CMD */
+	#ifdef    Si2148_RAM_CRC_CMD
+			  Si2148_RAM_CRC_CMD_struct          ram_crc;
+	#endif /* Si2148_RAM_CRC_CMD */
+	#ifdef    Si2148_SET_PROPERTY_CMD
+			  Si2148_SET_PROPERTY_CMD_struct     set_property;
+	#endif /* Si2148_SET_PROPERTY_CMD */
+	#ifdef    Si2148_STANDBY_CMD
+			  Si2148_STANDBY_CMD_struct          standby;
+	#endif /* Si2148_STANDBY_CMD */
+	#ifdef    Si2148_TUNER_STATUS_CMD
+			  Si2148_TUNER_STATUS_CMD_struct     tuner_status;
+	#endif /* Si2148_TUNER_STATUS_CMD */
+	#ifdef    Si2148_TUNER_TUNE_FREQ_CMD
+			  Si2148_TUNER_TUNE_FREQ_CMD_struct  tuner_tune_freq;
+	#endif /* Si2148_TUNER_TUNE_FREQ_CMD */
+} Si2148_CmdObj;
+
+typedef struct
+{ // Si2146_CmdReplyObj struct
+	#ifdef    Si2146_AGC_OVERRIDE_CMD
+			  Si2146_AGC_OVERRIDE_CMD_REPLY_struct               agc_override;
+	#endif /* Si2146_AGC_OVERRIDE_CMD */
+	#ifdef    Si2146_ATV_RESTART_CMD
+			  Si2146_ATV_RESTART_CMD_REPLY_struct      atv_restart;
+	#endif /* Si2146_ATV_RESTART_CMD */
+	#ifdef    Si2146_ATV_STATUS_CMD
+			  Si2146_ATV_STATUS_CMD_REPLY_struct       atv_status;
+	#endif /* Si2146_ATV_STATUS_CMD */
+	#ifdef    Si2146_CONFIG_PINS_CMD
+			  Si2146_CONFIG_PINS_CMD_REPLY_struct                config_pins;
+	#endif /* Si2146_CONFIG_PINS_CMD */
+	#ifdef    Si2146_DTV_RESTART_CMD
+			  Si2146_DTV_RESTART_CMD_REPLY_struct                dtv_restart;
+	#endif /* Si2146_DTV_RESTART_CMD */
+	#ifdef    Si2146_DTV_STATUS_CMD
+			  Si2146_DTV_STATUS_CMD_REPLY_struct                 dtv_status;
+	#endif /* Si2146_DTV_STATUS_CMD */
+	#ifdef    Si2146_EXIT_BOOTLOADER_CMD
+			  Si2146_EXIT_BOOTLOADER_CMD_REPLY_struct            exit_bootloader;
+	#endif /* Si2146_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2146_FINE_TUNE_CMD
+			  Si2146_FINE_TUNE_CMD_REPLY_struct                  fine_tune;
+	#endif /* Si2146_FINE_TUNE_CMD */
+	#ifdef    Si2146_GET_PROPERTY_CMD
+			  Si2146_GET_PROPERTY_CMD_REPLY_struct               get_property;
+	#endif /* Si2146_GET_PROPERTY_CMD */
+	#ifdef    Si2146_GET_REV_CMD
+			  Si2146_GET_REV_CMD_REPLY_struct                    get_rev;
+	#endif /* Si2146_GET_REV_CMD */
+	#ifdef    Si2146_PART_INFO_CMD
+			  Si2146_PART_INFO_CMD_REPLY_struct                  part_info;
+	#endif /* Si2146_PART_INFO_CMD */
+	#ifdef    Si2146_POWER_DOWN_CMD
+			  Si2146_POWER_DOWN_CMD_REPLY_struct                 power_down;
+	#endif /* Si2146_POWER_DOWN_CMD */
+	#ifdef    Si2146_POWER_UP_CMD
+			  Si2146_POWER_UP_CMD_REPLY_struct                   power_up;
+	#endif /* Si2146_POWER_UP_CMD */
+	#ifdef    Si2146_SET_PROPERTY_CMD
+			  Si2146_SET_PROPERTY_CMD_REPLY_struct               set_property;
+	#endif /* Si2146_SET_PROPERTY_CMD */
+	#ifdef    Si2146_STANDBY_CMD
+			  Si2146_STANDBY_CMD_REPLY_struct                    standby;
+	#endif /* Si2146_STANDBY_CMD */
+	#ifdef    Si2146_TUNER_STATUS_CMD
+			  Si2146_TUNER_STATUS_CMD_REPLY_struct               tuner_status;
+	#endif /* Si2146_TUNER_STATUS_CMD */
+	#ifdef    Si2146_TUNER_TUNE_FREQ_CMD
+			  Si2146_TUNER_TUNE_FREQ_CMD_REPLY_struct            tuner_tune_freq;
+	#endif /* Si2146_TUNER_TUNE_FREQ_CMD */
+} Si2146_CmdReplyObj;
+
+typedef struct
+{ // Si2148_CmdReplyObj struct
+	#ifdef    Si2148_AGC_OVERRIDE_CMD
+			  Si2148_AGC_OVERRIDE_CMD_REPLY_struct     agc_override;
+	#endif /* Si2148_AGC_OVERRIDE_CMD */
+	#ifdef    Si2148_ATV_CW_TEST_CMD
+			  Si2148_ATV_CW_TEST_CMD_REPLY_struct      atv_cw_test;
+	#endif /* Si2148_ATV_CW_TEST_CMD */
+	#ifdef    Si2148_CONFIG_CLOCKS_CMD
+			  Si2148_CONFIG_CLOCKS_CMD_REPLY_struct    config_clocks;
+	#endif /* Si2148_CONFIG_CLOCKS_CMD */
+	#ifdef    Si2148_CONFIG_PINS_CMD
+			  Si2148_CONFIG_PINS_CMD_REPLY_struct      config_pins;
+	#endif /* Si2148_CONFIG_PINS_CMD */
+	#ifdef    Si2148_DTV_RESTART_CMD
+			  Si2148_DTV_RESTART_CMD_REPLY_struct      dtv_restart;
+	#endif /* Si2148_DTV_RESTART_CMD */
+	#ifdef    Si2148_DTV_STATUS_CMD
+			  Si2148_DTV_STATUS_CMD_REPLY_struct       dtv_status;
+	#endif /* Si2148_DTV_STATUS_CMD */
+	#ifdef    Si2148_EXIT_BOOTLOADER_CMD
+			  Si2148_EXIT_BOOTLOADER_CMD_REPLY_struct  exit_bootloader;
+	#endif /* Si2148_EXIT_BOOTLOADER_CMD */
+	#ifdef    Si2148_FINE_TUNE_CMD
+			  Si2148_FINE_TUNE_CMD_REPLY_struct        fine_tune;
+	#endif /* Si2148_FINE_TUNE_CMD */
+	#ifdef    Si2148_GET_PROPERTY_CMD
+			  Si2148_GET_PROPERTY_CMD_REPLY_struct     get_property;
+	#endif /* Si2148_GET_PROPERTY_CMD */
+	#ifdef    Si2148_GET_REV_CMD
+			  Si2148_GET_REV_CMD_REPLY_struct          get_rev;
+	#endif /* Si2148_GET_REV_CMD */
+	#ifdef    Si2148_PART_INFO_CMD
+			  Si2148_PART_INFO_CMD_REPLY_struct        part_info;
+	#endif /* Si2148_PART_INFO_CMD */
+	#ifdef    Si2148_POWER_DOWN_CMD
+			  Si2148_POWER_DOWN_CMD_REPLY_struct       power_down;
+	#endif /* Si2148_POWER_DOWN_CMD */
+	#ifdef    Si2148_POWER_DOWN_HW_CMD
+			  Si2148_POWER_DOWN_HW_CMD_REPLY_struct    power_down_hw;
+	#endif /* Si2148_POWER_DOWN_HW_CMD */
+	#ifdef    Si2148_POWER_UP_CMD
+			  Si2148_POWER_UP_CMD_REPLY_struct         power_up;
+	#endif /* Si2148_POWER_UP_CMD */
+	#ifdef    Si2148_RAM_CRC_CMD
+			  Si2148_RAM_CRC_CMD_REPLY_struct          ram_crc;
+	#endif /* Si2148_RAM_CRC_CMD */
+	#ifdef    Si2148_SET_PROPERTY_CMD
+			  Si2148_SET_PROPERTY_CMD_REPLY_struct     set_property;
+	#endif /* Si2148_SET_PROPERTY_CMD */
+	#ifdef    Si2148_STANDBY_CMD
+			  Si2148_STANDBY_CMD_REPLY_struct          standby;
+	#endif /* Si2148_STANDBY_CMD */
+	#ifdef    Si2148_TUNER_STATUS_CMD
+			  Si2148_TUNER_STATUS_CMD_REPLY_struct     tuner_status;
+	#endif /* Si2148_TUNER_STATUS_CMD */
+	#ifdef    Si2148_TUNER_TUNE_FREQ_CMD
+			  Si2148_TUNER_TUNE_FREQ_CMD_REPLY_struct  tuner_tune_freq;
+	#endif /* Si2148_TUNER_TUNE_FREQ_CMD */
+} Si2148_CmdReplyObj;
+
+#define   Si2146_DTV_AGC_FREEZE_INPUT_PROP 0x0711
+#ifdef    Si2146_DTV_AGC_FREEZE_INPUT_PROP
+  #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_CODE 0x000711
+
+
+    typedef struct { /* Si2146_DTV_AGC_FREEZE_INPUT_PROP_struct */
+      unsigned char   level;
+      unsigned char   pin;
+   } Si2146_DTV_AGC_FREEZE_INPUT_PROP_struct;
+
+   /* DTV_AGC_FREEZE_INPUT property, LEVEL field definition (NO TITLE)*/
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB         0
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK        0x01
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_DEFAULT    0
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW   0
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH  1
+
+   /* DTV_AGC_FREEZE_INPUT property, PIN field definition (NO TITLE)*/
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB         1
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK        0x03
+   #define  Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_DEFAULT    0
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   0
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1  1
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO2  2
+    #define Si2146_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO3  3
+
+#endif /* Si2146_DTV_AGC_FREEZE_INPUT_PROP */
+
+#define   Si2146_DTV_MODE_PROP 0x0703
+
+#ifdef    Si2146_DTV_MODE_PROP
+  #define Si2146_DTV_MODE_PROP_CODE 0x000703
+
+
+    typedef struct { /* Si2146_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+   } Si2146_DTV_MODE_PROP_struct;
+
+   /* DTV_MODE property, BW field definition (NO TITLE)*/
+   #define  Si2146_DTV_MODE_PROP_BW_LSB         0
+   #define  Si2146_DTV_MODE_PROP_BW_MASK        0x0f
+   #define  Si2146_DTV_MODE_PROP_BW_DEFAULT    8
+    #define Si2146_DTV_MODE_PROP_BW_BW_6MHZ  6
+    #define Si2146_DTV_MODE_PROP_BW_BW_7MHZ  7
+    #define Si2146_DTV_MODE_PROP_BW_BW_8MHZ  8
+
+   /* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_LSB         8
+   #define  Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+    #define Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2146_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+   #define  Si2146_DTV_MODE_PROP_MODULATION_LSB         4
+   #define  Si2146_DTV_MODE_PROP_MODULATION_MASK        0x0f
+   #define  Si2146_DTV_MODE_PROP_MODULATION_DEFAULT    2
+    #define Si2146_DTV_MODE_PROP_MODULATION_ATSC    0
+    #define Si2146_DTV_MODE_PROP_MODULATION_QAM_US  1
+    #define Si2146_DTV_MODE_PROP_MODULATION_DVBT    2
+    #define Si2146_DTV_MODE_PROP_MODULATION_DVBC    3
+    #define Si2146_DTV_MODE_PROP_MODULATION_ISDBT   4
+    #define Si2146_DTV_MODE_PROP_MODULATION_ISDBC   5
+    #define Si2146_DTV_MODE_PROP_MODULATION_DTMB    6
+
+#endif /* Si2146_DTV_MODE_PROP */
+
+#define   Si2146_CRYSTAL_TRIM_PROP 0x0402
+
+#ifdef    Si2146_CRYSTAL_TRIM_PROP
+  #define Si2146_CRYSTAL_TRIM_PROP_CODE 0x000402
+
+
+    typedef struct { /* Si2146_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+   } Si2146_CRYSTAL_TRIM_PROP_struct;
+
+   /* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+   #define  Si2146_CRYSTAL_TRIM_PROP_XO_CAP_LSB         0
+   #define  Si2146_CRYSTAL_TRIM_PROP_XO_CAP_MASK        0x0f
+   #define  Si2146_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT    8
+    #define Si2146_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MIN  0
+    #define Si2146_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MAX  15
+
+#endif /* Si2146_CRYSTAL_TRIM_PROP */
+
+#define   Si2146_MASTER_IEN_PROP 0x0401
+
+#ifdef    Si2146_MASTER_IEN_PROP
+  #define Si2146_MASTER_IEN_PROP_CODE 0x000401
+
+
+    typedef struct { /* Si2146_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   tunien;
+   } Si2146_MASTER_IEN_PROP_struct;
+
+   /* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+   #define  Si2146_MASTER_IEN_PROP_ATVIEN_LSB         1
+   #define  Si2146_MASTER_IEN_PROP_ATVIEN_MASK        0x01
+   #define  Si2146_MASTER_IEN_PROP_ATVIEN_DEFAULT    0
+    #define Si2146_MASTER_IEN_PROP_ATVIEN_OFF  0
+    #define Si2146_MASTER_IEN_PROP_ATVIEN_ON   1
+
+   /* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+   #define  Si2146_MASTER_IEN_PROP_CTSIEN_LSB         7
+   #define  Si2146_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+   #define  Si2146_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+    #define Si2146_MASTER_IEN_PROP_CTSIEN_OFF  0
+    #define Si2146_MASTER_IEN_PROP_CTSIEN_ON   1
+
+   /* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+   #define  Si2146_MASTER_IEN_PROP_DTVIEN_LSB         2
+   #define  Si2146_MASTER_IEN_PROP_DTVIEN_MASK        0x01
+   #define  Si2146_MASTER_IEN_PROP_DTVIEN_DEFAULT    0
+    #define Si2146_MASTER_IEN_PROP_DTVIEN_OFF  0
+    #define Si2146_MASTER_IEN_PROP_DTVIEN_ON   1
+
+   /* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+   #define  Si2146_MASTER_IEN_PROP_ERRIEN_LSB         6
+   #define  Si2146_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+   #define  Si2146_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+    #define Si2146_MASTER_IEN_PROP_ERRIEN_OFF  0
+    #define Si2146_MASTER_IEN_PROP_ERRIEN_ON   1
+
+   /* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+   #define  Si2146_MASTER_IEN_PROP_TUNIEN_LSB         0
+   #define  Si2146_MASTER_IEN_PROP_TUNIEN_MASK        0x01
+   #define  Si2146_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+    #define Si2146_MASTER_IEN_PROP_TUNIEN_OFF  0
+    #define Si2146_MASTER_IEN_PROP_TUNIEN_ON   1
+
+#endif // Si2146_MASTER_IEN_PROP
+
+#define Si2146_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef Si2146_DTV_AGC_SPEED_PROP
+	#define Si2146_DTV_AGC_SPEED_PROP_CODE 0x000708
+	typedef struct
+	{ // Si2146_DTV_AGC_SPEED_PROP_struct
+		unsigned char   agc_decim;
+		unsigned char   if_agc_speed;
+	} Si2146_DTV_AGC_SPEED_PROP_struct;
+	// DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)
+	#define  Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+	#define  Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+	#define  Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+	#define Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+	#define Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_2    1
+	#define Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_4    2
+	#define Si2146_DTV_AGC_SPEED_PROP_AGC_DECIM_8    3
+	// DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)
+	#define  Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+	#define  Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+	#define  Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+	#define Si2146_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+#endif // Si2146_DTV_AGC_SPEED_PROP
+
+#define Si2146_DTV_CONFIG_IF_PORT_PROP 0x0702
+
+#ifdef Si2146_DTV_CONFIG_IF_PORT_PROP
+	#define Si2146_DTV_CONFIG_IF_PORT_PROP_CODE 0x000702
+	typedef struct
+	{ // Si2146_DTV_CONFIG_IF_PORT_PROP_struct
+		unsigned char   dtv_agc_source;
+		unsigned char   dtv_out_type;
+	} Si2146_DTV_CONFIG_IF_PORT_PROP_struct;
+	// DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB         8
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK        0x07
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT    0
+	#define Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL       0
+	#define Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DLIF_AGC_3DB   1
+	// DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB         0
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK        0x0f
+	#define  Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT    0
+	#define Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1      0
+	#define Si2146_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A  4
+#endif // Si2146_DTV_CONFIG_IF_PORT_PROP
+
+#define Si2146_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef Si2146_DTV_EXT_AGC_PROP
+	#define Si2146_DTV_EXT_AGC_PROP_CODE 0x000705
+	typedef struct
+	{ // Si2146_DTV_EXT_AGC_PROP_struct
+		unsigned char   max_10mv;
+		unsigned char   min_10mv;
+	} Si2146_DTV_EXT_AGC_PROP_struct;
+	// DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)
+	#define  Si2146_DTV_EXT_AGC_PROP_MAX_10MV_LSB         8
+	#define  Si2146_DTV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+	#define  Si2146_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+	#define Si2146_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+	#define Si2146_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  215
+	// DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)
+	#define  Si2146_DTV_EXT_AGC_PROP_MIN_10MV_LSB         0
+	#define  Si2146_DTV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+	#define  Si2146_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+	#define Si2146_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+	#define Si2146_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  215
+#endif // Si2146_DTV_EXT_AGC_PROP
+
+#define Si2146_DTV_IEN_PROP 0x0701
+
+#ifdef Si2146_DTV_IEN_PROP
+	#define Si2146_DTV_IEN_PROP_CODE 0x000701
+	typedef struct
+	{ // Si2146_DTV_IEN_PROP_struct
+		unsigned char   chlien;
+	} Si2146_DTV_IEN_PROP_struct;
+	// DTV_IEN property, CHLIEN field definition (NO TITLE)
+	#define  Si2146_DTV_IEN_PROP_CHLIEN_LSB         0
+	#define  Si2146_DTV_IEN_PROP_CHLIEN_MASK        0x01
+	#define  Si2146_DTV_IEN_PROP_CHLIEN_DEFAULT    0
+	#define Si2146_DTV_IEN_PROP_CHLIEN_DISABLE  0
+	#define Si2146_DTV_IEN_PROP_CHLIEN_ENABLE   1
+#endif // Si2146_DTV_IEN_PROP
+
+#define Si2146_DTV_INITIAL_AGC_SPEED_PROP 0x070d
+
+#ifdef Si2146_DTV_INITIAL_AGC_SPEED_PROP
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_CODE 0x00070d
+	typedef struct
+	{ // Si2146_DTV_INITIAL_AGC_SPEED_PROP_struct
+		unsigned char   agc_decim;
+		unsigned char   if_agc_speed;
+	} Si2146_DTV_INITIAL_AGC_SPEED_PROP_struct;
+	// DTV_INITIAL_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_2    1
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_4    2
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_8    3
+	// DTV_INITIAL_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+#endif // Si2146_DTV_INITIAL_AGC_SPEED_PROP
+
+#define Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP 0x070e
+
+#ifdef Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE 0x00070e
+	typedef struct
+	{ // Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct
+		unsigned int    period;
+	} Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct;
+	// DTV_INITIAL_AGC_SPEED_PERIOD property, PERIOD field definition (NO TITLE)
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB         0
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK        0xffff
+	#define  Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_DEFAULT    0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MIN  0
+	#define Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MAX  65535
+#endif // Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+
+#define Si2146_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef Si2146_DTV_INT_SENSE_PROP
+	#define Si2146_DTV_INT_SENSE_PROP_CODE 0x00070a
+	typedef struct
+	{ // Si2146_DTV_INT_SENSE_PROP_struct
+		unsigned char   chlnegen;
+		unsigned char   chlposen;
+	} Si2146_DTV_INT_SENSE_PROP_struct;
+	// DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+	#define Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+	#define Si2146_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+	// DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+	#define  Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+	#define Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+	#define Si2146_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+#endif // Si2146_DTV_INT_SENSE_PROP
+
+#define Si2146_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef Si2146_DTV_LIF_FREQ_PROP
+	#define Si2146_DTV_LIF_FREQ_PROP_CODE 0x000706
+	typedef struct
+	{ // Si2146_DTV_LIF_FREQ_PROP_struct
+		unsigned int    offset;
+	} Si2146_DTV_LIF_FREQ_PROP_struct;
+	// DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)
+	#define  Si2146_DTV_LIF_FREQ_PROP_OFFSET_LSB         0
+	#define  Si2146_DTV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+	#define  Si2146_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+	#define Si2146_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+	#define Si2146_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+#endif // Si2146_DTV_LIF_FREQ_PROP
+
+#define Si2146_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef Si2146_DTV_LIF_OUT_PROP
+	#define Si2146_DTV_LIF_OUT_PROP_CODE 0x000707
+	typedef struct
+	{ // Si2146_DTV_LIF_OUT_PROP_struct
+		unsigned char   amp;
+		unsigned char   offset;
+	} Si2146_DTV_LIF_OUT_PROP_struct;
+	// DTV_LIF_OUT property, AMP field definition (NO TITLE)
+	#define  Si2146_DTV_LIF_OUT_PROP_AMP_LSB         8
+	#define  Si2146_DTV_LIF_OUT_PROP_AMP_MASK        0xff
+	#define  Si2146_DTV_LIF_OUT_PROP_AMP_DEFAULT    27
+	#define Si2146_DTV_LIF_OUT_PROP_AMP_AMP_MIN  0
+	#define Si2146_DTV_LIF_OUT_PROP_AMP_AMP_MAX  255
+	// DTV_LIF_OUT property, OFFSET field definition (NO TITLE)
+	#define  Si2146_DTV_LIF_OUT_PROP_OFFSET_LSB         0
+	#define  Si2146_DTV_LIF_OUT_PROP_OFFSET_MASK        0xff
+	#define  Si2146_DTV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+	#define Si2146_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+	#define Si2146_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+#endif // Si2146_DTV_LIF_OUT_PROP
+
+#define Si2146_DTV_RF_TOP_PROP 0x0709
+
+#ifdef    Si2146_DTV_RF_TOP_PROP
+	#define Si2146_DTV_RF_TOP_PROP_CODE 0x000709
+	typedef struct
+	{ // Si2146_DTV_RF_TOP_PROP_struct
+		unsigned char   dtv_rf_top;
+	} Si2146_DTV_RF_TOP_PROP_struct;
+	// DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)
+	#define  Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB         0
+	#define  Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK        0xff
+	#define  Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT    0
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO   0
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB    6
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB   7
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB   8
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB   10
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB   11
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB   12
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB   13
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB   14
+	#define Si2146_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB   15
+#endif // Si2146_DTV_RF_TOP_PROP
+
+#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+	#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000704
+	typedef struct
+	{ // Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_struct
+		char   hi;
+		char   lo;
+	} Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_struct;
+	// DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+	#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+	#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+	// DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+	#define  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -80
+	#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+	#define Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+#endif // Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+
+#define Si2146_TUNER_BLOCKED_VCO_PROP 0x0504
+
+#ifdef Si2146_TUNER_BLOCKED_VCO_PROP
+	#define Si2146_TUNER_BLOCKED_VCO_PROP_CODE 0x000504
+	typedef struct
+	{ // Si2146_TUNER_BLOCKED_VCO_PROP_struct
+		int    vco_code;
+	} Si2146_TUNER_BLOCKED_VCO_PROP_struct;
+	// TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)
+	#define  Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB         0
+	#define  Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK        0xffff
+	#define  Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+	#define Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MIN  -32768
+	#define Si2146_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MAX  32767
+#endif // Si2146_TUNER_BLOCKED_VCO_PROP
+
+#define Si2146_TUNER_IEN_PROP 0x0501
+
+#ifdef Si2146_TUNER_IEN_PROP
+	#define Si2146_TUNER_IEN_PROP_CODE 0x000501
+	typedef struct
+	{ // Si2146_TUNER_IEN_PROP_struct
+		unsigned char   rssihien;
+		unsigned char   rssilien;
+		unsigned char   tcien;
+	} Si2146_TUNER_IEN_PROP_struct;
+	// TUNER_IEN property, RSSIHIEN field definition (NO TITLE)
+	#define  Si2146_TUNER_IEN_PROP_RSSIHIEN_LSB         2
+	#define  Si2146_TUNER_IEN_PROP_RSSIHIEN_MASK        0x01
+	#define  Si2146_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+	#define Si2146_TUNER_IEN_PROP_RSSIHIEN_DISABLE  0
+	#define Si2146_TUNER_IEN_PROP_RSSIHIEN_ENABLE   1
+	// TUNER_IEN property, RSSILIEN field definition (NO TITLE)
+	#define  Si2146_TUNER_IEN_PROP_RSSILIEN_LSB         1
+	#define  Si2146_TUNER_IEN_PROP_RSSILIEN_MASK        0x01
+	#define  Si2146_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+	#define Si2146_TUNER_IEN_PROP_RSSILIEN_DISABLE  0
+	#define Si2146_TUNER_IEN_PROP_RSSILIEN_ENABLE   1
+	// TUNER_IEN property, TCIEN field definition (NO TITLE)
+	#define  Si2146_TUNER_IEN_PROP_TCIEN_LSB         0
+	#define  Si2146_TUNER_IEN_PROP_TCIEN_MASK        0x01
+	#define  Si2146_TUNER_IEN_PROP_TCIEN_DEFAULT    0
+	#define Si2146_TUNER_IEN_PROP_TCIEN_DISABLE  0
+	#define Si2146_TUNER_IEN_PROP_TCIEN_ENABLE   1
+#endif // Si2146_TUNER_IEN_PROP
+
+#define Si2146_TUNER_INT_SENSE_PROP 0x0505
+
+#ifdef Si2146_TUNER_INT_SENSE_PROP
+	#define Si2146_TUNER_INT_SENSE_PROP_CODE 0x000505
+	typedef struct
+	{ // Si2146_TUNER_INT_SENSE_PROP_struct
+		unsigned char   rssihnegen;
+		unsigned char   rssihposen;
+		unsigned char   rssilnegen;
+		unsigned char   rssilposen;
+		unsigned char   tcnegen;
+		unsigned char   tcposen;
+	} Si2146_TUNER_INT_SENSE_PROP_struct;
+	// TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB         2
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE   1
+	// TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB         10
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE   1
+	// TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB         1
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE   1
+	// TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB         9
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE   1
+	// TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_LSB         0
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT    0
+	#define Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE   1
+	// TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_LSB         8
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_MASK        0x01
+	#define  Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT    1
+	#define Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE  0
+	#define Si2146_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE   1
+#endif // Si2146_TUNER_INT_SENSE_PROP
+
+#define Si2146_TUNER_LO_INJECTION_PROP 0x0506
+
+#ifdef Si2146_TUNER_LO_INJECTION_PROP
+	#define Si2146_TUNER_LO_INJECTION_PROP_CODE 0x000506
+	typedef struct
+	{ // Si2146_TUNER_LO_INJECTION_PROP_struct
+		unsigned char   band_1;
+		unsigned char   band_2;
+		unsigned char   band_3;
+		unsigned char   band_4;
+		unsigned char   band_5;
+	} Si2146_TUNER_LO_INJECTION_PROP_struct;
+	// TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_1_LSB         0
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_1_MASK        0x01
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+	// TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_2_LSB         1
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_2_MASK        0x01
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+	// TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_3_LSB         2
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_3_MASK        0x01
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+	// TUNER_LO_INJECTION property, BAND_4 field definition (NO TITLE)
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_4_LSB         3
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_4_MASK        0x01
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_4_DEFAULT    0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE   0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_4_HIGH_SIDE  1
+	// TUNER_LO_INJECTION property, BAND_5 field definition (NO TITLE)
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_5_LSB         4
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_5_MASK        0x01
+	#define  Si2146_TUNER_LO_INJECTION_PROP_BAND_5_DEFAULT    0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE   0
+	#define Si2146_TUNER_LO_INJECTION_PROP_BAND_5_HIGH_SIDE  1
+#endif // Si2146_TUNER_LO_INJECTION_PROP
+
+typedef struct
+{
+	#ifdef    Si2146_ATV_AFC_RANGE_PROP
+			  Si2146_ATV_AFC_RANGE_PROP_struct                 atv_afc_range;
+	#endif // Si2146_ATV_AFC_RANGE_PROP
+	#ifdef    Si2146_ATV_AF_OUT_PROP
+			  Si2146_ATV_AF_OUT_PROP_struct                    atv_af_out;
+	#endif // Si2146_ATV_AF_OUT_PROP
+	#ifdef    Si2146_ATV_AGC_SPEED_PROP
+			  Si2146_ATV_AGC_SPEED_PROP_struct                 atv_agc_speed;
+	#endif // Si2146_ATV_AGC_SPEED_PROP
+	#ifdef    Si2146_ATV_AUDIO_MODE_PROP
+			  Si2146_ATV_AUDIO_MODE_PROP_struct                atv_audio_mode;
+	#endif // Si2146_ATV_AUDIO_MODE_PROP
+	#ifdef    Si2146_ATV_CVBS_OUT_PROP
+			  Si2146_ATV_CVBS_OUT_PROP_struct                  atv_cvbs_out;
+	#endif // Si2146_ATV_CVBS_OUT_PROP
+	#ifdef    Si2146_ATV_CVBS_OUT_FINE_PROP
+			  Si2146_ATV_CVBS_OUT_FINE_PROP_struct             atv_cvbs_out_fine;
+	#endif // Si2146_ATV_CVBS_OUT_FINE_PROP
+	#ifdef    Si2146_ATV_IEN_PROP
+			  Si2146_ATV_IEN_PROP_struct                       atv_ien;
+	#endif // Si2146_ATV_IEN_PROP
+	#ifdef    Si2146_ATV_INT_SENSE_PROP
+			  Si2146_ATV_INT_SENSE_PROP_struct                 atv_int_sense;
+	#endif // Si2146_ATV_INT_SENSE_PROP
+	#ifdef    Si2146_ATV_RF_TOP_PROP
+			  Si2146_ATV_RF_TOP_PROP_struct                    atv_rf_top;
+	#endif // Si2146_ATV_RF_TOP_PROP
+	#ifdef    Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP
+			  Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP_struct        atv_rsq_rssi_threshold;
+	#endif // Si2146_ATV_RSQ_RSSI_THRESHOLD_PROP
+	#ifdef    Si2146_ATV_RSQ_SNR_THRESHOLD_PROP
+			  Si2146_ATV_RSQ_SNR_THRESHOLD_PROP_struct         atv_rsq_snr_threshold;
+	#endif // Si2146_ATV_RSQ_SNR_THRESHOLD_PROP
+	#ifdef    Si2146_ATV_SIF_OUT_PROP
+			  Si2146_ATV_SIF_OUT_PROP_struct                   atv_sif_out;
+	#endif // Si2146_ATV_SIF_OUT_PROP
+	#ifdef    Si2146_ATV_SOUND_AGC_LIMIT_PROP
+			  Si2146_ATV_SOUND_AGC_LIMIT_PROP_struct           atv_sound_agc_limit;
+	#endif // Si2146_ATV_SOUND_AGC_LIMIT_PROP
+	#ifdef    Si2146_ATV_SOUND_AGC_SPEED_PROP
+			  Si2146_ATV_SOUND_AGC_SPEED_PROP_struct           atv_sound_agc_speed;
+	#endif // Si2146_ATV_SOUND_AGC_SPEED_PROP
+	#ifdef    Si2146_ATV_VIDEO_EQUALIZER_PROP
+			  Si2146_ATV_VIDEO_EQUALIZER_PROP_struct           atv_video_equalizer;
+	#endif // Si2146_ATV_VIDEO_EQUALIZER_PROP
+	#ifdef    Si2146_ATV_VIDEO_MODE_PROP
+			  Si2146_ATV_VIDEO_MODE_PROP_struct                atv_video_mode;
+	#endif // Si2146_ATV_VIDEO_MODE_PROP
+	#ifdef    Si2146_ATV_VSNR_CAP_PROP
+			  Si2146_ATV_VSNR_CAP_PROP_struct                  atv_vsnr_cap;
+	#endif // Si2146_ATV_VSNR_CAP_PROP
+	#ifdef    Si2146_ATV_VSYNC_TRACKING_PROP
+			  Si2146_ATV_VSYNC_TRACKING_PROP_struct            atv_vsync_tracking;
+	#endif // Si2146_ATV_VSYNC_TRACKING_PROP
+	#ifdef    Si2146_CRYSTAL_TRIM_PROP
+			  Si2146_CRYSTAL_TRIM_PROP_struct            crystal_trim;
+	#endif // Si2146_CRYSTAL_TRIM_PROP
+	#ifdef    Si2146_DTV_AGC_FREEZE_INPUT_PROP
+			  Si2146_DTV_AGC_FREEZE_INPUT_PROP_struct          dtv_agc_freeze_input;
+	#endif // Si2146_DTV_AGC_FREEZE_INPUT_PROP
+	#ifdef    Si2146_DTV_AGC_SPEED_PROP
+			  Si2146_DTV_AGC_SPEED_PROP_struct           dtv_agc_speed;
+	#endif // Si2146_DTV_AGC_SPEED_PROP
+	#ifdef    Si2146_DTV_CONFIG_IF_PORT_PROP
+			  Si2146_DTV_CONFIG_IF_PORT_PROP_struct      dtv_config_if_port;
+	#endif // Si2146_DTV_CONFIG_IF_PORT_PROP
+	#ifdef    Si2146_DTV_EXT_AGC_PROP
+			  Si2146_DTV_EXT_AGC_PROP_struct             dtv_ext_agc;
+	#endif // Si2146_DTV_EXT_AGC_PROP
+	#ifdef    Si2146_DTV_IEN_PROP
+			  Si2146_DTV_IEN_PROP_struct                 dtv_ien;
+	#endif // Si2146_DTV_IEN_PROP
+	#ifdef    Si2146_DTV_INITIAL_AGC_SPEED_PROP
+			  Si2146_DTV_INITIAL_AGC_SPEED_PROP_struct         dtv_initial_agc_speed;
+	#endif // Si2146_DTV_INITIAL_AGC_SPEED_PROP
+	#ifdef    Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+			  Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct  dtv_initial_agc_speed_period;
+	#endif // Si2146_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+	#ifdef    Si2146_DTV_INT_SENSE_PROP
+			  Si2146_DTV_INT_SENSE_PROP_struct           dtv_int_sense;
+	#endif // Si2146_DTV_INT_SENSE_PROP
+	#ifdef    Si2146_DTV_LIF_FREQ_PROP
+			  Si2146_DTV_LIF_FREQ_PROP_struct            dtv_lif_freq;
+	#endif // Si2146_DTV_LIF_FREQ_PROP
+	#ifdef    Si2146_DTV_LIF_OUT_PROP
+			  Si2146_DTV_LIF_OUT_PROP_struct             dtv_lif_out;
+	#endif // Si2146_DTV_LIF_OUT_PROP
+	#ifdef    Si2146_DTV_MODE_PROP
+			  Si2146_DTV_MODE_PROP_struct                dtv_mode;
+	#endif // Si2146_DTV_MODE_PROP
+	#ifdef    Si2146_DTV_RF_TOP_PROP
+			  Si2146_DTV_RF_TOP_PROP_struct              dtv_rf_top;
+	#endif // Si2146_DTV_RF_TOP_PROP
+	#ifdef    Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+			  Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP_struct  dtv_rsq_rssi_threshold;
+	#endif // Si2146_DTV_RSQ_RSSI_THRESHOLD_PROP
+	#ifdef    Si2146_MASTER_IEN_PROP
+			  Si2146_MASTER_IEN_PROP_struct              master_ien;
+	#endif // Si2146_MASTER_IEN_PROP
+	#ifdef    Si2146_TUNER_BLOCKED_VCO_PROP
+			  Si2146_TUNER_BLOCKED_VCO_PROP_struct       tuner_blocked_vco;
+	#endif // Si2146_TUNER_BLOCKED_VCO_PROP
+	#ifdef    Si2146_TUNER_IEN_PROP
+			  Si2146_TUNER_IEN_PROP_struct               tuner_ien;
+	#endif // Si2146_TUNER_IEN_PROP
+	#ifdef    Si2146_TUNER_INT_SENSE_PROP
+			  Si2146_TUNER_INT_SENSE_PROP_struct         tuner_int_sense;
+	#endif // Si2146_TUNER_INT_SENSE_PROP
+	#ifdef    Si2146_TUNER_LO_INJECTION_PROP
+			  Si2146_TUNER_LO_INJECTION_PROP_struct      tuner_lo_injection;
+	#endif // Si2146_TUNER_LO_INJECTION_PROP
+} Si2146_PropObj;
+
+/* Si2148 ATV_ARTIFICIAL_SNOW property definition */
+#define   Si2148_ATV_ARTIFICIAL_SNOW_PROP 0x0624
+
+#ifdef    Si2148_ATV_ARTIFICIAL_SNOW_PROP
+  #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_CODE 0x000624
+
+
+    typedef struct { /* Si2148_ATV_ARTIFICIAL_SNOW_PROP_struct */
+      unsigned char   gain;
+               char   offset;
+   } Si2148_ATV_ARTIFICIAL_SNOW_PROP_struct;
+
+   /* ATV_ARTIFICIAL_SNOW property, GAIN field definition (NO TITLE)*/
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB         0
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK        0xff
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_DEFAULT    0
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO  0
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_0DB   1
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_6DB   2
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_12DB  3
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_18DB  4
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_24DB  5
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_30DB  6
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_36DB  7
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_42DB  8
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_GAIN_OFF   9
+
+   /* ATV_ARTIFICIAL_SNOW property, OFFSET field definition (NO TITLE)*/
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB         8
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK        0xff
+   #define  Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_DEFAULT    0
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MIN  -128
+    #define Si2148_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MAX  127
+
+#endif /* Si2148_ATV_ARTIFICIAL_SNOW_PROP */
+
+/* Si2148 ATV_EXT_AGC property definition */
+#define   Si2148_ATV_EXT_AGC_PROP 0x0607
+
+#ifdef    Si2148_ATV_EXT_AGC_PROP
+  #define Si2148_ATV_EXT_AGC_PROP_CODE 0x000607
+
+
+    typedef struct { /* Si2148_ATV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+   } Si2148_ATV_EXT_AGC_PROP_struct;
+
+   /* ATV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+   #define  Si2148_ATV_EXT_AGC_PROP_MAX_10MV_LSB         8
+   #define  Si2148_ATV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+   #define  Si2148_ATV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+    #define Si2148_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+    #define Si2148_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+   /* ATV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+   #define  Si2148_ATV_EXT_AGC_PROP_MIN_10MV_LSB         0
+   #define  Si2148_ATV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+   #define  Si2148_ATV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+    #define Si2148_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+    #define Si2148_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+#endif /* Si2148_ATV_EXT_AGC_PROP */
+
+/* Si2148 ATV_LIF_FREQ property definition */
+#define   Si2148_ATV_LIF_FREQ_PROP 0x060c
+
+#ifdef    Si2148_ATV_LIF_FREQ_PROP
+  #define Si2148_ATV_LIF_FREQ_PROP_CODE 0x00060c
+
+
+    typedef struct { /* Si2148_ATV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2148_ATV_LIF_FREQ_PROP_struct;
+
+   /* ATV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2148_ATV_LIF_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2148_ATV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2148_ATV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2148_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2148_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+#endif /* Si2148_ATV_LIF_FREQ_PROP */
+
+/* Si2148 ATV_LIF_OUT property definition */
+#define   Si2148_ATV_LIF_OUT_PROP 0x060d
+
+#ifdef    Si2148_ATV_LIF_OUT_PROP
+  #define Si2148_ATV_LIF_OUT_PROP_CODE 0x00060d
+
+
+    typedef struct { /* Si2148_ATV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+   } Si2148_ATV_LIF_OUT_PROP_struct;
+
+   /* ATV_LIF_OUT property, AMP field definition (NO TITLE)*/
+   #define  Si2148_ATV_LIF_OUT_PROP_AMP_LSB         8
+   #define  Si2148_ATV_LIF_OUT_PROP_AMP_MASK        0xff
+   #define  Si2148_ATV_LIF_OUT_PROP_AMP_DEFAULT    100
+    #define Si2148_ATV_LIF_OUT_PROP_AMP_AMP_MIN  0
+    #define Si2148_ATV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+   /* ATV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+   #define  Si2148_ATV_LIF_OUT_PROP_OFFSET_LSB         0
+   #define  Si2148_ATV_LIF_OUT_PROP_OFFSET_MASK        0xff
+   #define  Si2148_ATV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+    #define Si2148_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2148_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* Si2148_ATV_LIF_OUT_PROP */
+
+/* Si2148 ATV_PGA_TARGET property definition */
+#define   Si2148_ATV_PGA_TARGET_PROP 0x0617
+
+#ifdef    Si2148_ATV_PGA_TARGET_PROP
+  #define Si2148_ATV_PGA_TARGET_PROP_CODE 0x000617
+
+
+    typedef struct { /* Si2148_ATV_PGA_TARGET_PROP_struct */
+      unsigned char   override_enable;
+               char   pga_target;
+   } Si2148_ATV_PGA_TARGET_PROP_struct;
+
+   /* ATV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+   #define  Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+   #define  Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+   #define  Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+    #define Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+    #define Si2148_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+   /* ATV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+   #define  Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+   #define  Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+   #define  Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+    #define Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+    #define Si2148_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+#endif /* Si2148_ATV_PGA_TARGET_PROP */
+
+/* Si2148 CRYSTAL_TRIM property definition */
+#define   Si2148_CRYSTAL_TRIM_PROP 0x0402
+
+#ifdef    Si2148_CRYSTAL_TRIM_PROP
+  #define Si2148_CRYSTAL_TRIM_PROP_CODE 0x000402
+
+
+    typedef struct { /* Si2148_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+   } Si2148_CRYSTAL_TRIM_PROP_struct;
+
+   /* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+   #define  Si2148_CRYSTAL_TRIM_PROP_XO_CAP_LSB         0
+   #define  Si2148_CRYSTAL_TRIM_PROP_XO_CAP_MASK        0x0f
+   #define  Si2148_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT    8
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_0   0
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_2   2
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_4   4
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_6   6
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_8   8
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_10  10
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_12  12
+    #define Si2148_CRYSTAL_TRIM_PROP_XO_CAP_14  14
+
+#endif /* Si2148_CRYSTAL_TRIM_PROP */
+
+/* Si2148 DTV_AGC_FREEZE_INPUT property definition */
+#define   Si2148_DTV_AGC_FREEZE_INPUT_PROP 0x0711
+
+#ifdef    Si2148_DTV_AGC_FREEZE_INPUT_PROP
+  #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_CODE 0x000711
+
+
+    typedef struct { /* Si2148_DTV_AGC_FREEZE_INPUT_PROP_struct */
+      unsigned char   level;
+      unsigned char   pin;
+   } Si2148_DTV_AGC_FREEZE_INPUT_PROP_struct;
+
+   /* DTV_AGC_FREEZE_INPUT property, LEVEL field definition (NO TITLE)*/
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB         0
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK        0x01
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_DEFAULT    0
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW   0
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH  1
+
+   /* DTV_AGC_FREEZE_INPUT property, PIN field definition (NO TITLE)*/
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB         1
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK        0x07
+   #define  Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_DEFAULT    0
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE      0
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1     1
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO2     2
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_RESERVED  3
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC1      4
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC2      5
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1A     6
+    #define Si2148_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1B     7
+
+#endif /* Si2148_DTV_AGC_FREEZE_INPUT_PROP */
+
+/* Si2148 DTV_AGC_SPEED property definition */
+#define   Si2148_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef    Si2148_DTV_AGC_SPEED_PROP
+  #define Si2148_DTV_AGC_SPEED_PROP_CODE 0x000708
+
+
+    typedef struct { /* Si2148_DTV_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+   } Si2148_DTV_AGC_SPEED_PROP_struct;
+
+   /* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+   #define  Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+   #define  Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+   #define  Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+    #define Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+    #define Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_2    1
+    #define Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_4    2
+    #define Si2148_DTV_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+   /* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+    #define Si2148_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+#endif /* Si2148_DTV_AGC_SPEED_PROP */
+
+/* Si2148 DTV_CONFIG_IF_PORT property definition */
+#define   Si2148_DTV_CONFIG_IF_PORT_PROP 0x0702
+
+#ifdef    Si2148_DTV_CONFIG_IF_PORT_PROP
+  #define Si2148_DTV_CONFIG_IF_PORT_PROP_CODE 0x000702
+
+
+    typedef struct { /* Si2148_DTV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   dtv_agc_source;
+      unsigned char   dtv_out_type;
+   } Si2148_DTV_CONFIG_IF_PORT_PROP_struct;
+
+   /* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB         8
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK        0x07
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT    0
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL   0
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC1_3DB   1
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC2_3DB   2
+
+   /* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB         0
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK        0x0f
+   #define  Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT    0
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1      0
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2      1
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A  4
+    #define Si2148_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A  5
+
+#endif /* Si2148_DTV_CONFIG_IF_PORT_PROP */
+
+/* Si2148 DTV_EXT_AGC property definition */
+#define   Si2148_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef    Si2148_DTV_EXT_AGC_PROP
+  #define Si2148_DTV_EXT_AGC_PROP_CODE 0x000705
+
+
+    typedef struct { /* Si2148_DTV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+   } Si2148_DTV_EXT_AGC_PROP_struct;
+
+   /* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+   #define  Si2148_DTV_EXT_AGC_PROP_MAX_10MV_LSB         8
+   #define  Si2148_DTV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+   #define  Si2148_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+    #define Si2148_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+    #define Si2148_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+   /* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+   #define  Si2148_DTV_EXT_AGC_PROP_MIN_10MV_LSB         0
+   #define  Si2148_DTV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+   #define  Si2148_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+    #define Si2148_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+    #define Si2148_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+#endif /* Si2148_DTV_EXT_AGC_PROP */
+
+/* Si2148 DTV_FILTER_SELECT property definition */
+#define   Si2148_DTV_FILTER_SELECT_PROP 0x070c
+
+#ifdef    Si2148_DTV_FILTER_SELECT_PROP
+  #define Si2148_DTV_FILTER_SELECT_PROP_CODE 0x00070c
+
+
+    typedef struct { /* Si2148_DTV_FILTER_SELECT_PROP_struct */
+      unsigned char   filter;
+   } Si2148_DTV_FILTER_SELECT_PROP_struct;
+
+   /* DTV_FILTER_SELECT property, FILTER field definition (NO TITLE)*/
+   #define  Si2148_DTV_FILTER_SELECT_PROP_FILTER_LSB         0
+   #define  Si2148_DTV_FILTER_SELECT_PROP_FILTER_MASK        0x03
+   #define  Si2148_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT    1
+    #define Si2148_DTV_FILTER_SELECT_PROP_FILTER_LEGACY   0
+    #define Si2148_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1  1
+    #define Si2148_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM2  2
+
+#endif /* Si2148_DTV_FILTER_SELECT_PROP */
+
+/* Si2148 DTV_IEN property definition */
+#define   Si2148_DTV_IEN_PROP 0x0701
+
+#ifdef    Si2148_DTV_IEN_PROP
+  #define Si2148_DTV_IEN_PROP_CODE 0x000701
+
+
+    typedef struct { /* Si2148_DTV_IEN_PROP_struct */
+      unsigned char   chlien;
+   } Si2148_DTV_IEN_PROP_struct;
+
+   /* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+   #define  Si2148_DTV_IEN_PROP_CHLIEN_LSB         0
+   #define  Si2148_DTV_IEN_PROP_CHLIEN_MASK        0x01
+   #define  Si2148_DTV_IEN_PROP_CHLIEN_DEFAULT    1
+    #define Si2148_DTV_IEN_PROP_CHLIEN_DISABLE  0
+    #define Si2148_DTV_IEN_PROP_CHLIEN_ENABLE   1
+
+#endif /* Si2148_DTV_IEN_PROP */
+
+/* Si2148 DTV_INITIAL_AGC_SPEED property definition */
+#define   Si2148_DTV_INITIAL_AGC_SPEED_PROP 0x070d
+
+#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PROP
+  #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_CODE 0x00070d
+
+
+    typedef struct { /* Si2148_DTV_INITIAL_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+   } Si2148_DTV_INITIAL_AGC_SPEED_PROP_struct;
+
+   /* DTV_INITIAL_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_2    1
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_4    2
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+   /* DTV_INITIAL_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PROP */
+
+/* Si2148 DTV_INITIAL_AGC_SPEED_PERIOD property definition */
+#define   Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP 0x070e
+
+#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  #define Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE 0x00070e
+
+
+    typedef struct { /* Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct */
+      unsigned int    period;
+   } Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct;
+
+   /* DTV_INITIAL_AGC_SPEED_PERIOD property, PERIOD field definition (NO TITLE)*/
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB         0
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK        0xffff
+   #define  Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_DEFAULT    0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MIN  0
+    #define Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MAX  65535
+
+#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+
+/* Si2148 DTV_INTERNAL_ZIF property definition */
+#define   Si2148_DTV_INTERNAL_ZIF_PROP 0x0710
+
+#ifdef    Si2148_DTV_INTERNAL_ZIF_PROP
+  #define Si2148_DTV_INTERNAL_ZIF_PROP_CODE 0x000710
+
+
+    typedef struct { /* Si2148_DTV_INTERNAL_ZIF_PROP_struct */
+      unsigned char   atsc;
+      unsigned char   dtmb;
+      unsigned char   dvbc;
+      unsigned char   dvbt;
+      unsigned char   isdbc;
+      unsigned char   isdbt;
+      unsigned char   qam_us;
+   } Si2148_DTV_INTERNAL_ZIF_PROP_struct;
+
+   /* DTV_INTERNAL_ZIF property, ATSC field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_LSB         0
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ATSC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DTMB field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_LSB         6
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DTMB_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DVBC field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_LSB         3
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DVBC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DVBT field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_LSB         2
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_DVBT_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, ISDBC field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB         5
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ISDBC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, ISDBT field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB         4
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_ISDBT_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, QAM_US field definition (NO TITLE)*/
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB         1
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK        0x01
+   #define  Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_DEFAULT    0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF  0
+    #define Si2148_DTV_INTERNAL_ZIF_PROP_QAM_US_ZIF  1
+
+#endif /* Si2148_DTV_INTERNAL_ZIF_PROP */
+
+/* Si2148 DTV_INT_SENSE property definition */
+#define   Si2148_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef    Si2148_DTV_INT_SENSE_PROP
+  #define Si2148_DTV_INT_SENSE_PROP_CODE 0x00070a
+
+
+    typedef struct { /* Si2148_DTV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+   } Si2148_DTV_INT_SENSE_PROP_struct;
+
+   /* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+    #define Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+    #define Si2148_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+
+   /* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+   #define  Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+    #define Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+    #define Si2148_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+
+#endif /* Si2148_DTV_INT_SENSE_PROP */
+
+/* Si2148 DTV_LIF_FREQ property definition */
+#define   Si2148_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef    Si2148_DTV_LIF_FREQ_PROP
+  #define Si2148_DTV_LIF_FREQ_PROP_CODE 0x000706
+
+
+    typedef struct { /* Si2148_DTV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2148_DTV_LIF_FREQ_PROP_struct;
+
+   /* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2148_DTV_LIF_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2148_DTV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2148_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2148_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2148_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+#endif /* Si2148_DTV_LIF_FREQ_PROP */
+
+/* Si2148 DTV_LIF_OUT property definition */
+#define   Si2148_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef    Si2148_DTV_LIF_OUT_PROP
+  #define Si2148_DTV_LIF_OUT_PROP_CODE 0x000707
+
+
+    typedef struct { /* Si2148_DTV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+   } Si2148_DTV_LIF_OUT_PROP_struct;
+
+   /* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+   #define  Si2148_DTV_LIF_OUT_PROP_AMP_LSB         8
+   #define  Si2148_DTV_LIF_OUT_PROP_AMP_MASK        0xff
+   #define  Si2148_DTV_LIF_OUT_PROP_AMP_DEFAULT    27
+    #define Si2148_DTV_LIF_OUT_PROP_AMP_AMP_MIN  0
+    #define Si2148_DTV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+   /* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+   #define  Si2148_DTV_LIF_OUT_PROP_OFFSET_LSB         0
+   #define  Si2148_DTV_LIF_OUT_PROP_OFFSET_MASK        0xff
+   #define  Si2148_DTV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+    #define Si2148_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2148_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* Si2148_DTV_LIF_OUT_PROP */
+
+/* Si2148 DTV_MODE property definition */
+#define   Si2148_DTV_MODE_PROP 0x0703
+
+#ifdef    Si2148_DTV_MODE_PROP
+  #define Si2148_DTV_MODE_PROP_CODE 0x000703
+
+
+    typedef struct { /* Si2148_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+   } Si2148_DTV_MODE_PROP_struct;
+
+   /* DTV_MODE property, BW field definition (NO TITLE)*/
+   #define  Si2148_DTV_MODE_PROP_BW_LSB         0
+   #define  Si2148_DTV_MODE_PROP_BW_MASK        0x0f
+   #define  Si2148_DTV_MODE_PROP_BW_DEFAULT    8
+    #define Si2148_DTV_MODE_PROP_BW_BW_6MHZ  6
+    #define Si2148_DTV_MODE_PROP_BW_BW_7MHZ  7
+    #define Si2148_DTV_MODE_PROP_BW_BW_8MHZ  8
+
+   /* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_LSB         8
+   #define  Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+    #define Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2148_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+   #define  Si2148_DTV_MODE_PROP_MODULATION_LSB         4
+   #define  Si2148_DTV_MODE_PROP_MODULATION_MASK        0x0f
+   #define  Si2148_DTV_MODE_PROP_MODULATION_DEFAULT    2
+    #define Si2148_DTV_MODE_PROP_MODULATION_ATSC    0
+    #define Si2148_DTV_MODE_PROP_MODULATION_QAM_US  1
+    #define Si2148_DTV_MODE_PROP_MODULATION_DVBT    2
+    #define Si2148_DTV_MODE_PROP_MODULATION_DVBC    3
+    #define Si2148_DTV_MODE_PROP_MODULATION_ISDBT   4
+    #define Si2148_DTV_MODE_PROP_MODULATION_ISDBC   5
+    #define Si2148_DTV_MODE_PROP_MODULATION_DTMB    6
+
+#endif /* Si2148_DTV_MODE_PROP */
+
+/* Si2148 DTV_PGA_LIMITS property definition */
+#define   Si2148_DTV_PGA_LIMITS_PROP 0x0713
+
+#ifdef    Si2148_DTV_PGA_LIMITS_PROP
+  #define Si2148_DTV_PGA_LIMITS_PROP_CODE 0x000713
+
+
+    typedef struct { /* Si2148_DTV_PGA_LIMITS_PROP_struct */
+               char   max;
+               char   min;
+   } Si2148_DTV_PGA_LIMITS_PROP_struct;
+
+   /* DTV_PGA_LIMITS property, MAX field definition (NO TITLE)*/
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MAX_LSB         8
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MAX_MASK        0xff
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MAX_DEFAULT    -1
+    #define Si2148_DTV_PGA_LIMITS_PROP_MAX_MAX_MIN  -1
+    #define Si2148_DTV_PGA_LIMITS_PROP_MAX_MAX_MAX  56
+
+   /* DTV_PGA_LIMITS property, MIN field definition (NO TITLE)*/
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MIN_LSB         0
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MIN_MASK        0xff
+   #define  Si2148_DTV_PGA_LIMITS_PROP_MIN_DEFAULT    -1
+    #define Si2148_DTV_PGA_LIMITS_PROP_MIN_MIN_MIN  -1
+    #define Si2148_DTV_PGA_LIMITS_PROP_MIN_MIN_MAX  56
+
+#endif /* Si2148_DTV_PGA_LIMITS_PROP */
+
+/* Si2148 DTV_PGA_TARGET property definition */
+#define   Si2148_DTV_PGA_TARGET_PROP 0x070f
+
+#ifdef    Si2148_DTV_PGA_TARGET_PROP
+  #define Si2148_DTV_PGA_TARGET_PROP_CODE 0x00070f
+
+
+    typedef struct { /* Si2148_DTV_PGA_TARGET_PROP_struct */
+      unsigned char   override_enable;
+               char   pga_target;
+   } Si2148_DTV_PGA_TARGET_PROP_struct;
+
+   /* DTV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+   #define  Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+   #define  Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+   #define  Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+    #define Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+    #define Si2148_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+   /* DTV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+   #define  Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+   #define  Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+   #define  Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+    #define Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+    #define Si2148_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+#endif /* Si2148_DTV_PGA_TARGET_PROP */
+
+/* Si2148 DTV_RF_TOP property definition */
+#define   Si2148_DTV_RF_TOP_PROP 0x0709
+
+#ifdef    Si2148_DTV_RF_TOP_PROP
+  #define Si2148_DTV_RF_TOP_PROP_CODE 0x000709
+
+
+    typedef struct { /* Si2148_DTV_RF_TOP_PROP_struct */
+      unsigned char   dtv_rf_top;
+   } Si2148_DTV_RF_TOP_PROP_struct;
+
+   /* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+   #define  Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB         0
+   #define  Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK        0xff
+   #define  Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT    0
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO     0
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P6DB     9
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P5P5DB   10
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P5DB     11
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P4P5DB   12
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P4DB     13
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P3P5DB   14
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P3DB     15
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P2P5DB   16
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P2DB     17
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P1P5DB   18
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P1DB     19
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_P0P5DB   20
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB      21
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M0P5DB   22
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB     23
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M1P5DB   24
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB     25
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M2P5DB   26
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M3DB     27
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M3P5DB   28
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB     29
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M4P5DB   30
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB     31
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M5P5DB   32
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB     33
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M6P5DB   34
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB     35
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M7P5DB   36
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB     37
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M8P5DB   38
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB     39
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M9P5DB   40
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M10DB    41
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M10P5DB  42
+    #define Si2148_DTV_RF_TOP_PROP_DTV_RF_TOP_M11DB    43
+
+#endif /* Si2148_DTV_RF_TOP_PROP */
+
+/* Si2148 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define   Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef    Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP
+  #define Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000704
+
+
+    typedef struct { /* Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+   } Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_struct;
+
+   /* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+    #define Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+    #define Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+
+   /* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+   #define  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -80
+    #define Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+    #define Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+
+#endif /* Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* Si2148 DTV_ZIF_DC_CANCELLER_BW property definition */
+#define   Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP 0x0712
+
+#ifdef    Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP
+  #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE 0x000712
+
+
+    typedef struct { /* Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_struct */
+      unsigned char   bandwidth;
+   } Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_struct;
+
+   /* DTV_ZIF_DC_CANCELLER_BW property, BANDWIDTH field definition (NO TITLE)*/
+   #define  Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB         0
+   #define  Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK        0xff
+   #define  Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_4_HZ       0
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_8_HZ       1
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15_HZ      2
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_30_HZ      3
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_61_HZ      4
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_121_HZ     5
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_243_HZ     6
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_486_HZ     7
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_972_HZ     8
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_1943_HZ    9
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_3888_HZ    10
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_7779_HZ    11
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15573_HZ   12
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_31207_HZ   13
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_62658_HZ   14
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_126303_HZ  15
+    #define Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+
+#endif /* Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP */
+
+/* Si2148 MASTER_IEN property definition */
+#define   Si2148_MASTER_IEN_PROP 0x0401
+
+#ifdef    Si2148_MASTER_IEN_PROP
+  #define Si2148_MASTER_IEN_PROP_CODE 0x000401
+
+
+    typedef struct { /* Si2148_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   tunien;
+   } Si2148_MASTER_IEN_PROP_struct;
+
+   /* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+   #define  Si2148_MASTER_IEN_PROP_ATVIEN_LSB         1
+   #define  Si2148_MASTER_IEN_PROP_ATVIEN_MASK        0x01
+   #define  Si2148_MASTER_IEN_PROP_ATVIEN_DEFAULT    0
+    #define Si2148_MASTER_IEN_PROP_ATVIEN_OFF  0
+    #define Si2148_MASTER_IEN_PROP_ATVIEN_ON   1
+
+   /* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+   #define  Si2148_MASTER_IEN_PROP_CTSIEN_LSB         7
+   #define  Si2148_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+   #define  Si2148_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+    #define Si2148_MASTER_IEN_PROP_CTSIEN_OFF  0
+    #define Si2148_MASTER_IEN_PROP_CTSIEN_ON   1
+
+   /* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+   #define  Si2148_MASTER_IEN_PROP_DTVIEN_LSB         2
+   #define  Si2148_MASTER_IEN_PROP_DTVIEN_MASK        0x01
+   #define  Si2148_MASTER_IEN_PROP_DTVIEN_DEFAULT    0
+    #define Si2148_MASTER_IEN_PROP_DTVIEN_OFF  0
+    #define Si2148_MASTER_IEN_PROP_DTVIEN_ON   1
+
+   /* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+   #define  Si2148_MASTER_IEN_PROP_ERRIEN_LSB         6
+   #define  Si2148_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+   #define  Si2148_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+    #define Si2148_MASTER_IEN_PROP_ERRIEN_OFF  0
+    #define Si2148_MASTER_IEN_PROP_ERRIEN_ON   1
+
+   /* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+   #define  Si2148_MASTER_IEN_PROP_TUNIEN_LSB         0
+   #define  Si2148_MASTER_IEN_PROP_TUNIEN_MASK        0x01
+   #define  Si2148_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+    #define Si2148_MASTER_IEN_PROP_TUNIEN_OFF  0
+    #define Si2148_MASTER_IEN_PROP_TUNIEN_ON   1
+
+#endif /* Si2148_MASTER_IEN_PROP */
+
+/* Si2148 TUNER_BLOCKED_VCO property definition */
+#define   Si2148_TUNER_BLOCKED_VCO_PROP 0x0504
+
+#ifdef    Si2148_TUNER_BLOCKED_VCO_PROP
+  #define Si2148_TUNER_BLOCKED_VCO_PROP_CODE 0x000504
+
+
+    typedef struct { /* Si2148_TUNER_BLOCKED_VCO_PROP_struct */
+               int    vco_code;
+   } Si2148_TUNER_BLOCKED_VCO_PROP_struct;
+
+   /* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+   #define  Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB         0
+   #define  Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK        0xffff
+   #define  Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+    #define Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MIN  -32768
+    #define Si2148_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MAX  32767
+
+#endif /* Si2148_TUNER_BLOCKED_VCO_PROP */
+
+/* Si2148 TUNER_IEN property definition */
+#define   Si2148_TUNER_IEN_PROP 0x0501
+
+#ifdef    Si2148_TUNER_IEN_PROP
+  #define Si2148_TUNER_IEN_PROP_CODE 0x000501
+
+
+    typedef struct { /* Si2148_TUNER_IEN_PROP_struct */
+      unsigned char   rssihien;
+      unsigned char   rssilien;
+      unsigned char   tcien;
+   } Si2148_TUNER_IEN_PROP_struct;
+
+   /* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_IEN_PROP_RSSIHIEN_LSB         2
+   #define  Si2148_TUNER_IEN_PROP_RSSIHIEN_MASK        0x01
+   #define  Si2148_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+    #define Si2148_TUNER_IEN_PROP_RSSIHIEN_DISABLE  0
+    #define Si2148_TUNER_IEN_PROP_RSSIHIEN_ENABLE   1
+
+   /* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_IEN_PROP_RSSILIEN_LSB         1
+   #define  Si2148_TUNER_IEN_PROP_RSSILIEN_MASK        0x01
+   #define  Si2148_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+    #define Si2148_TUNER_IEN_PROP_RSSILIEN_DISABLE  0
+    #define Si2148_TUNER_IEN_PROP_RSSILIEN_ENABLE   1
+
+   /* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_IEN_PROP_TCIEN_LSB         0
+   #define  Si2148_TUNER_IEN_PROP_TCIEN_MASK        0x01
+   #define  Si2148_TUNER_IEN_PROP_TCIEN_DEFAULT    1
+    #define Si2148_TUNER_IEN_PROP_TCIEN_DISABLE  0
+    #define Si2148_TUNER_IEN_PROP_TCIEN_ENABLE   1
+
+#endif /* Si2148_TUNER_IEN_PROP */
+
+/* Si2148 TUNER_INT_SENSE property definition */
+#define   Si2148_TUNER_INT_SENSE_PROP 0x0505
+
+#ifdef    Si2148_TUNER_INT_SENSE_PROP
+  #define Si2148_TUNER_INT_SENSE_PROP_CODE 0x000505
+
+
+    typedef struct { /* Si2148_TUNER_INT_SENSE_PROP_struct */
+      unsigned char   rssihnegen;
+      unsigned char   rssihposen;
+      unsigned char   rssilnegen;
+      unsigned char   rssilposen;
+      unsigned char   tcnegen;
+      unsigned char   tcposen;
+   } Si2148_TUNER_INT_SENSE_PROP_struct;
+
+   /* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB         2
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB         10
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB         1
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB         9
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_LSB         0
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT    0
+    #define Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_LSB         8
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_MASK        0x01
+   #define  Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT    1
+    #define Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE  0
+    #define Si2148_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE   1
+
+#endif /* Si2148_TUNER_INT_SENSE_PROP */
+
+/* Si2148 TUNER_LO_INJECTION property definition */
+#define   Si2148_TUNER_LO_INJECTION_PROP 0x0506
+
+#ifdef    Si2148_TUNER_LO_INJECTION_PROP
+  #define Si2148_TUNER_LO_INJECTION_PROP_CODE 0x000506
+
+
+    typedef struct { /* Si2148_TUNER_LO_INJECTION_PROP_struct */
+      unsigned char   band_1;
+      unsigned char   band_2;
+      unsigned char   band_3;
+   } Si2148_TUNER_LO_INJECTION_PROP_struct;
+
+   /* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_1_LSB         0
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_1_MASK        0x01
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+   /* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_2_LSB         1
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_2_MASK        0x01
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+   /* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_3_LSB         2
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_3_MASK        0x01
+   #define  Si2148_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+    #define Si2148_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+#endif /* Si2148_TUNER_LO_INJECTION_PROP */
+
+/* Si2148 TUNER_RETURN_LOSS property definition */
+#define   Si2148_TUNER_RETURN_LOSS_PROP 0x0507
+
+#ifdef    Si2148_TUNER_RETURN_LOSS_PROP
+  #define Si2148_TUNER_RETURN_LOSS_PROP_CODE 0x000507
+
+
+    typedef struct { /* Si2148_TUNER_RETURN_LOSS_PROP_struct */
+      unsigned char   config;
+      unsigned char   mode;
+   } Si2148_TUNER_RETURN_LOSS_PROP_struct;
+
+   /* TUNER_RETURN_LOSS property, CONFIG field definition (NO TITLE)*/
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_LSB         0
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_MASK        0xff
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_DEFAULT    127
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_27   27
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_31   31
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_35   35
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_39   39
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_43   43
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_47   47
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_51   51
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_59   59
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_67   67
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_75   75
+    #define Si2148_TUNER_RETURN_LOSS_PROP_CONFIG_127  127
+
+   /* TUNER_RETURN_LOSS property, MODE field definition (NO TITLE)*/
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_MODE_LSB         8
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_MODE_MASK        0xff
+   #define  Si2148_TUNER_RETURN_LOSS_PROP_MODE_DEFAULT    0
+    #define Si2148_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL  0
+    #define Si2148_TUNER_RETURN_LOSS_PROP_MODE_CABLE        1
+
+#endif /* Si2148_TUNER_RETURN_LOSS_PROP */
+
+typedef struct
+{
+	#ifdef    Si2148_ATV_ARTIFICIAL_SNOW_PROP
+			  Si2148_ATV_ARTIFICIAL_SNOW_PROP_struct           atv_artificial_snow;
+	#endif /* Si2148_ATV_ARTIFICIAL_SNOW_PROP */
+	#ifdef    Si2148_ATV_EXT_AGC_PROP
+			  Si2148_ATV_EXT_AGC_PROP_struct                   atv_ext_agc;
+	#endif /* Si2148_ATV_EXT_AGC_PROP */
+	#ifdef    Si2148_ATV_LIF_FREQ_PROP
+			  Si2148_ATV_LIF_FREQ_PROP_struct                  atv_lif_freq;
+	#endif /* Si2148_ATV_LIF_FREQ_PROP */
+	#ifdef    Si2148_ATV_LIF_OUT_PROP
+			  Si2148_ATV_LIF_OUT_PROP_struct                   atv_lif_out;
+	#endif /* Si2148_ATV_LIF_OUT_PROP */
+	#ifdef    Si2148_ATV_PGA_TARGET_PROP
+			  Si2148_ATV_PGA_TARGET_PROP_struct                atv_pga_target;
+	#endif /* Si2148_ATV_PGA_TARGET_PROP */
+	#ifdef    Si2148_CRYSTAL_TRIM_PROP
+			  Si2148_CRYSTAL_TRIM_PROP_struct                  crystal_trim;
+	#endif /* Si2148_CRYSTAL_TRIM_PROP */
+	#ifdef    Si2148_DTV_AGC_FREEZE_INPUT_PROP
+			  Si2148_DTV_AGC_FREEZE_INPUT_PROP_struct          dtv_agc_freeze_input;
+	#endif /* Si2148_DTV_AGC_FREEZE_INPUT_PROP */
+	#ifdef    Si2148_DTV_AGC_SPEED_PROP
+			  Si2148_DTV_AGC_SPEED_PROP_struct                 dtv_agc_speed;
+	#endif /* Si2148_DTV_AGC_SPEED_PROP */
+	#ifdef    Si2148_DTV_CONFIG_IF_PORT_PROP
+			  Si2148_DTV_CONFIG_IF_PORT_PROP_struct            dtv_config_if_port;
+	#endif /* Si2148_DTV_CONFIG_IF_PORT_PROP */
+	#ifdef    Si2148_DTV_EXT_AGC_PROP
+			  Si2148_DTV_EXT_AGC_PROP_struct                   dtv_ext_agc;
+	#endif /* Si2148_DTV_EXT_AGC_PROP */
+	#ifdef    Si2148_DTV_FILTER_SELECT_PROP
+			  Si2148_DTV_FILTER_SELECT_PROP_struct             dtv_filter_select;
+	#endif /* Si2148_DTV_FILTER_SELECT_PROP */
+	#ifdef    Si2148_DTV_IEN_PROP
+			  Si2148_DTV_IEN_PROP_struct                       dtv_ien;
+	#endif /* Si2148_DTV_IEN_PROP */
+	#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PROP
+			  Si2148_DTV_INITIAL_AGC_SPEED_PROP_struct         dtv_initial_agc_speed;
+	#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PROP */
+	#ifdef    Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+			  Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct  dtv_initial_agc_speed_period;
+	#endif /* Si2148_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+	#ifdef    Si2148_DTV_INTERNAL_ZIF_PROP
+			  Si2148_DTV_INTERNAL_ZIF_PROP_struct              dtv_internal_zif;
+	#endif /* Si2148_DTV_INTERNAL_ZIF_PROP */
+	#ifdef    Si2148_DTV_INT_SENSE_PROP
+			  Si2148_DTV_INT_SENSE_PROP_struct                 dtv_int_sense;
+	#endif /* Si2148_DTV_INT_SENSE_PROP */
+	#ifdef    Si2148_DTV_LIF_FREQ_PROP
+			  Si2148_DTV_LIF_FREQ_PROP_struct                  dtv_lif_freq;
+	#endif /* Si2148_DTV_LIF_FREQ_PROP */
+	#ifdef    Si2148_DTV_LIF_OUT_PROP
+			  Si2148_DTV_LIF_OUT_PROP_struct                   dtv_lif_out;
+	#endif /* Si2148_DTV_LIF_OUT_PROP */
+	#ifdef    Si2148_DTV_MODE_PROP
+			  Si2148_DTV_MODE_PROP_struct                      dtv_mode;
+	#endif /* Si2148_DTV_MODE_PROP */
+	#ifdef    Si2148_DTV_PGA_LIMITS_PROP
+			  Si2148_DTV_PGA_LIMITS_PROP_struct                dtv_pga_limits;
+	#endif /* Si2148_DTV_PGA_LIMITS_PROP */
+	#ifdef    Si2148_DTV_PGA_TARGET_PROP
+			  Si2148_DTV_PGA_TARGET_PROP_struct                dtv_pga_target;
+	#endif /* Si2148_DTV_PGA_TARGET_PROP */
+	#ifdef    Si2148_DTV_RF_TOP_PROP
+			  Si2148_DTV_RF_TOP_PROP_struct                    dtv_rf_top;
+	#endif /* Si2148_DTV_RF_TOP_PROP */
+	#ifdef    Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP
+			  Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP_struct        dtv_rsq_rssi_threshold;
+	#endif /* Si2148_DTV_RSQ_RSSI_THRESHOLD_PROP */
+	#ifdef    Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP
+			  Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP_struct       dtv_zif_dc_canceller_bw;
+	#endif /* Si2148_DTV_ZIF_DC_CANCELLER_BW_PROP */
+	#ifdef    Si2148_MASTER_IEN_PROP
+			  Si2148_MASTER_IEN_PROP_struct                    master_ien;
+	#endif /* Si2148_MASTER_IEN_PROP */
+	#ifdef    Si2148_TUNER_BLOCKED_VCO_PROP
+			  Si2148_TUNER_BLOCKED_VCO_PROP_struct             tuner_blocked_vco;
+	#endif /* Si2148_TUNER_BLOCKED_VCO_PROP */
+	#ifdef    Si2148_TUNER_IEN_PROP
+			  Si2148_TUNER_IEN_PROP_struct                     tuner_ien;
+	#endif /* Si2148_TUNER_IEN_PROP */
+	#ifdef    Si2148_TUNER_INT_SENSE_PROP
+			  Si2148_TUNER_INT_SENSE_PROP_struct               tuner_int_sense;
+	#endif /* Si2148_TUNER_INT_SENSE_PROP */
+	#ifdef    Si2148_TUNER_LO_INJECTION_PROP
+			  Si2148_TUNER_LO_INJECTION_PROP_struct            tuner_lo_injection;
+	#endif /* Si2148_TUNER_LO_INJECTION_PROP */
+	#ifdef    Si2148_TUNER_RETURN_LOSS_PROP
+			  Si2148_TUNER_RETURN_LOSS_PROP_struct             tuner_return_loss;
+	#endif /* Si2148_TUNER_RETURN_LOSS_PROP */
+} Si2148_PropObj;
+
+typedef struct L1_Si2146_Context
+{
+	L0_Context                 *i2c;
+	L0_Context                  i2cObj;
+	Si2146_CmdObj              *cmd;
+	Si2146_CmdObj               cmdObj;
+	Si2146_CmdReplyObj         *rsp;
+	Si2146_CmdReplyObj          rspObj;
+	Si2146_PropObj             *prop;
+	Si2146_PropObj              propObj;
+	Si2146_COMMON_REPLY_struct *status;
+	Si2146_COMMON_REPLY_struct  statusObj;
+	//chip rev constants for integrity checking
+	unsigned char chiprev;
+	unsigned char part;
+	// Last 2 digits of part number
+	unsigned char partMajorVersion;
+	unsigned char partMinorVersion;
+	unsigned char partRomid;
+	unsigned long newFrequency;
+	// Channel Scan Globals
+	// Global array to store the list of found channels
+	unsigned long ChannelList[160];
+	// ChannelScanPal needs to store the PAL type also so allocate 4 chars each for that
+	char ChannelType[160][4];
+	// Number of found channels from a channel scan
+	int ChannelListSize;
+	unsigned char addr;
+} L1_Si2146_Context;
+
+typedef struct L1_Si2148_Context
+{
+	L0_Context                 *i2c;
+	L0_Context                  i2cObj;
+	Si2148_CmdObj              *cmd;
+	Si2148_CmdObj               cmdObj;
+	Si2148_CmdReplyObj         *rsp;
+	Si2148_CmdReplyObj          rspObj;
+	Si2148_PropObj             *prop;
+	Si2148_PropObj              propObj;
+	Si2148_COMMON_REPLY_struct *status;
+	Si2148_COMMON_REPLY_struct  statusObj;
+	//chip rev constants for integrity checking
+	unsigned char chiprev;
+	unsigned char part;
+	// Last 2 digits of part number
+	unsigned char partMajorVersion;
+	unsigned char partMinorVersion;
+	unsigned char partRomid;
+	// Channel Scan Globals
+	// Global array to store the list of found channels
+	unsigned long ChannelList[160];
+	// ChannelScanPal needs to store the PAL type also so allocate 4 chars each for that
+	char ChannelType[160][4];
+	// Number of found channels from a channel scan
+	int ChannelListSize;
+	unsigned char addr;
+} L1_Si2148_Context;
+
+//Yann 2146/2148
+#define SiTuner 2148
+#if SiTuner==2146
+#define TER_TUNER_CONTEXT L1_Si2146_Context
+#else
+#define TER_TUNER_CONTEXT L1_Si2148_Context
+#endif
+
+typedef struct Si2168_L2_Context
+{
+	L1_Si2168_Context *demod;
+	TER_TUNER_CONTEXT *tuner_ter;
+	L1_Si2168_Context  demodObj;
+	TER_TUNER_CONTEXT  tuner_terObj;
+	int                first_init_done;
+	int                Si2168_init_done;
+	int                TER_init_done;
+	int                TER_tuner_init_done;
+	int                standard;
+	int                detected_rf;
+	int                previous_standard;
+	int                tuneUnitHz;
+	int                rangeMin;
+	int                rangeMax;
+	int                seekBWHz;
+	int                seekStepHz;
+	int                minSRbps;
+	int                maxSRbps;
+	int                minRSSIdBm;
+	int                maxRSSIdBm;
+	int                minSNRHalfdB;
+	int                maxSNRHalfdB;
+	int                seekAbort;
+	unsigned char      seekRunning;
+	int                center_rf;
+} Si2168_L2_Context;
+
+typedef struct SILABS_TER_TUNER_Config
+{
+	unsigned char nSel_dtv_out_type;
+	unsigned char nSel_dtv_agc_source;
+	int           nSel_dtv_lif_freq_offset;
+	unsigned char nSel_dtv_mode_bw;
+	unsigned char nSel_dtv_mode_invert_spectrum;
+	unsigned char nSel_dtv_mode_modulation;
+	unsigned char nSel_atv_video_mode_video_sys;
+	unsigned char nSel_atv_audio_mode_audio_sys;
+	unsigned char nSel_atv_atv_video_mode_tran;
+	unsigned char nSel_atv_video_mod_color;
+	unsigned char nSel_atv_mode_invert_spectrum;
+	unsigned char nSel_atv_mode_invert_signal;
+	char          nSel_atv_cvbs_out_fine_amp;
+	char          nSel_atv_cvbs_out_fine_offset;
+	unsigned char nSel_atv_sif_out_amp;
+	unsigned char nSel_atv_sif_out_offset;
+	unsigned char if_agc_speed;
+	char          nSel_dtv_rf_top;
+	char          nSel_atv_rf_top;
+	unsigned long nLocked_Freq;
+	unsigned long nCenter_Freq;
+	int           nCriteriaStep;
+	int           nLeftMax;
+	int           nRightMax;
+	int           nReal_Step;
+	int           nBeforeStep;
+} SILABS_TER_TUNER_Config;
+
+/*typedef struct SILABS_SAT_TUNER_Config
+{
+	int    RF;
+	int    IF;
+	int    minRF;
+	int    maxRF;
+	double xtal;
+	double LPF;
+	int    tunerBytesCount;
+	int    I2CMuxChannel;
+	double RefDiv_value;
+	int    Mash_Per;
+	CONNECTION_TYPE connType;
+	unsigned char tuner_log[40];
+	unsigned char tuner_read[7];
+	char          nSel_att_top;
+} SILABS_SAT_TUNER_Config;*/
+
+typedef struct SILABS_CARRIER_Config
+{
+	int                freq;
+	int                bandwidth;
+	int                stream;
+	int                symbol_rate;
+	int                constellation;
+} SILABS_CARRIER_Config;
+
+typedef struct SILABS_ANALOG_CARRIER_Config
+{
+	unsigned char      video_sys;
+	unsigned char      trans;
+	unsigned char      color;
+	unsigned char      invert_signal;
+	unsigned char      invert_spectrum;
+} SILABS_ANALOG_CARRIER_Config;
+
+typedef struct SILABS_ANALOG_SIF_Config
+{
+	unsigned char      stereo_sys;
+} SILABS_ANALOG_SIF_Config;
+
+typedef struct SILABS_FE_Context
+{
+	unsigned int       chip;
+	unsigned int       tuner_ter;
+	unsigned int       tuner_sat;
+	Si2168_L2_Context *Si2168_FE;
+	Si2168_L2_Context  Si2168_FE_Obj;
+	int                standard;
+	int                init_ok;
+	SILABS_TER_TUNER_Config      TER_Tuner_Cfg;
+	//SILABS_SAT_TUNER_Config      SAT_Tuner_Cfg;
+	SILABS_CARRIER_Config        Carrier_Cfg;
+	SILABS_ANALOG_CARRIER_Config Analog_Cfg;
+	SILABS_ANALOG_SIF_Config     Analog_Sif_Cfg;
+} SILABS_FE_Context;
+
+typedef struct CUSTOM_Status_Struct
+{
+	int       standard;
+	int      clock_mode;
+	int      demod_lock;
+	int      fec_lock;
+	int      fec_lock_in_range;
+	//double   c_n;
+	//double   ber;
+	//double   per;
+	//double   fer;
+	int      uncorrs;
+	int      RFagc;
+	int      IFagc;
+	int      RFlevel;
+	long     freq_offset;
+	long     timing_offset;
+	int      bandwidth_Hz;
+	int      stream;
+	int      fft_mode;
+	int      guard_interval;
+	int      constellation;
+	int      symbol_rate;
+	int      code_rate_hp;
+	int      code_rate_lp;
+	int      hierarchy;
+	int      spectral_inversion;
+	int      code_rate;
+	int      pilots;
+	int      cell_id;
+	//float    RSSI;
+	int      SSI;
+	int      SQI;
+	int      tuner_lock;
+	int      rotated;
+	int      pilot_pattern;
+	int      bw_ext;
+	int      num_plp;
+	int      tx_mode;
+	int      short_frame;
+	unsigned char attctrl;
+	// TUNER_STATUS
+	unsigned char   tcint;
+	unsigned char   rssilint;
+	unsigned char   rssihint;
+		   int    vco_code;
+	unsigned char   tc;
+	unsigned char   rssil;
+	unsigned char   rssih;
+		   char   rssi;
+	unsigned long   freq;
+	unsigned char   mode;
+	// ATV_STATUS & DTV_STATUS
+	unsigned char   chl;
+	// ATV_STATUS
+	int      ATV_Sync_Lock;
+	int      ATV_Master_Lock;
+	unsigned char   audio_chan_filt_bw;
+	unsigned char   snrl;
+	unsigned char   snrh;
+	unsigned char   video_snr;
+		   int    afc_freq;
+		   int    video_sc_spacing;
+	unsigned char   video_sys;
+	unsigned char   color;
+	unsigned char   trans;
+	unsigned char   audio_sys;
+	unsigned char   audio_demod_mode;
+	// DTV_STATUS
+	unsigned char   chlint;
+	unsigned char   bw;
+	unsigned char   modulation;
+	unsigned char   fef;
+} CUSTOM_Status_Struct;
+
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct firmware_struct {
+	unsigned char firmware_len;
+	unsigned char firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+#define Si2146_DTV_MODE_PROP_MODULATION_ATSC    0
+#define Si2146_DTV_MODE_PROP_MODULATION_QAM_US  1
+#define Si2146_DTV_MODE_PROP_MODULATION_DVBT    2
+#define Si2146_DTV_MODE_PROP_MODULATION_DVBC    3
+#define Si2146_DTV_MODE_PROP_MODULATION_ISDBT   4
+#define Si2146_DTV_MODE_PROP_MODULATION_ISDBC   5
+#define Si2146_DTV_MODE_PROP_MODULATION_DTMB    6
+
+#define L1_RF_TER_TUNER_MODULATION_DVBC  Si2146_DTV_MODE_PROP_MODULATION_DVBC
+#define L1_RF_TER_TUNER_MODULATION_DVBT  Si2146_DTV_MODE_PROP_MODULATION_DVBT
+#define L1_RF_TER_TUNER_MODULATION_DVBT2 Si2146_DTV_MODE_PROP_MODULATION_DVBT
+
+void MyDelay(int nTime);
+void Si2168_Initial(void);
+int Si2168_Data_Update(struct rtl2832_state* p_state,int nStandard,unsigned int nFreq,unsigned int nBandwidth,unsigned int nSymbolrate, int plp_id);
+int Si2168_Check_Lock(void);
+int Si2168_Check_CNR(void);
+int Si2168_Check_Status(void);
+
+#endif //__Si2168RTL_H__
diff --git a/drivers/media/usb/rtl2832u/tuner_base.h b/drivers/media/usb/rtl2832u/tuner_base.h
new file mode 100644
index 00000000..17eb68b5
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_base.h
@@ -0,0 +1,1723 @@
+#ifndef __TUNER_BASE_H
+#define __TUNER_BASE_H
+
+/**
+
+@file
+
+@brief   Tuner base module definition
+
+Tuner base module definitions contains tuner module structure, tuner funciton pointers, and tuner definitions.
+
+
+
+@par Example:
+@code
+
+
+#include "demod_xxx.h"
+#include "tuner_xxx.h"
+
+
+
+int
+CustomI2cRead(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	unsigned char *pReadingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C reading format:
+	// start_bit + (DeviceAddr | reading_bit) + reading_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+int
+CustomI2cWrite(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned char DeviceAddr,
+	const unsigned char *pWritingBytes,
+	unsigned long ByteNum
+	)
+{
+	// I2C writing format:
+	// start_bit + (DeviceAddr | writing_bit) + writing_byte * ByteNum + stop_bit
+
+	...
+
+	return FUNCTION_SUCCESS;
+
+error_status:
+	return FUNCTION_ERROR;
+}
+
+
+
+void
+CustomWaitMs(
+	BASE_INTERFACE_MODULE *pBaseInterface,
+	unsigned long WaitTimeMs
+	)
+{
+	// Wait WaitTimeMs milliseconds.
+
+	...
+
+	return;
+}
+
+
+
+int main(void)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+
+	XXX_DEMOD_MODULE *pDemod;
+	XXX_DEMOD_MODULE XxxDemodModuleMemory;
+
+	TUNER_MODULE *pTuner;
+	TUNER_MODULE TunerModuleMemory;
+
+	I2C_BRIDGE_MODULE I2cBridgeModuleMemory;
+
+	unsigned long RfFreqHz;
+
+	int TunerType;
+	unsigned char DeviceAddr;
+
+
+
+	// Build base interface module.
+	BuildBaseInterface(
+		&pBaseInterface,
+		&BaseInterfaceModuleMemory,
+		9,								// Set maximum I2C reading byte number with 9.
+		8,								// Set maximum I2C writing byte number with 8.
+		CustomI2cRead,					// Employ CustomI2cRead() as basic I2C reading function.
+		CustomI2cWrite,					// Employ CustomI2cWrite() as basic I2C writing function.
+		CustomWaitMs					// Employ CustomWaitMs() as basic waiting function.
+		);
+
+
+	// Build dmeod XXX module.
+	// Note: Demod module builder will set I2cBridgeModuleMemory for tuner I2C command forwarding.
+	//       Must execute demod builder to set I2cBridgeModuleMemory before use tuner functions.
+	BuildDemodXxxModule(
+		&pDemod,
+		&XxxDemodModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		...								// Other arguments by each demod module
+		)
+
+
+	// Build tuner XXX module.
+	BuildTunerXxxModule(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0,							// Tuner I2C device address is 0xc0 in 8-bit format.
+		...								// Other arguments by each demod module
+		);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	// Initialize tuner.
+	pTuner->Initialize(pTuner);
+
+
+	// Set tuner parameters. (RF frequency)
+	// Note: In the example, RF frequency is 474 MHz.
+	RfFreqHz = 474000000;
+
+	pTuner->SetIfFreqHz(pTuner, RfFreqHz);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	// Get tuenr type.
+	// Note: One can find tuner type in MODULE_TYPE enumeration.
+	pTuner->GetTunerType(pTuner, &TunerType);
+
+	// Get tuner I2C device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Get tuner parameters. (RF frequency)
+	pTuner->GetRfFreqHz(pTuner, &RfFreqHz);
+
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "foundation.h"
+
+
+
+
+
+/// tuner module pre-definition
+typedef struct TUNER_MODULE_TAG TUNER_MODULE;
+
+
+
+
+
+/**
+
+@brief   Tuner type getting function pointer
+
+One can use TUNER_FP_GET_TUNER_TYPE() to get tuner type.
+
+
+@param [in]    pTuner       The tuner module pointer
+@param [out]   pTunerType   Pointer to an allocated memory for storing tuner type
+
+
+@note
+	-# Tuner building function will set TUNER_FP_GET_TUNER_TYPE() with the corresponding function.
+
+
+@see   TUNER_TYPE
+
+*/
+typedef void
+(*TUNER_FP_GET_TUNER_TYPE)(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+
+
+
+
+/**
+
+@brief   Tuner I2C device address getting function pointer
+
+One can use TUNER_FP_GET_DEVICE_ADDR() to get tuner I2C device address.
+
+
+@param [in]    pTuner        The tuner module pointer
+@param [out]   pDeviceAddr   Pointer to an allocated memory for storing tuner I2C device address
+
+
+@retval   FUNCTION_SUCCESS   Get tuner device address successfully.
+@retval   FUNCTION_ERROR     Get tuner device address unsuccessfully.
+
+
+@note
+	-# Tuner building function will set TUNER_FP_GET_DEVICE_ADDR() with the corresponding function.
+
+*/
+typedef void
+(*TUNER_FP_GET_DEVICE_ADDR)(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+
+
+
+
+/**
+
+@brief   Tuner initializing function pointer
+
+One can use TUNER_FP_INITIALIZE() to initialie tuner.
+
+
+@param [in]   pTuner   The tuner module pointer
+
+
+@retval   FUNCTION_SUCCESS   Initialize tuner successfully.
+@retval   FUNCTION_ERROR     Initialize tuner unsuccessfully.
+
+
+@note
+	-# Tuner building function will set TUNER_FP_INITIALIZE() with the corresponding function.
+
+*/
+typedef int
+(*TUNER_FP_INITIALIZE)(
+	TUNER_MODULE *pTuner
+	);
+
+
+
+
+
+/**
+
+@brief   Tuner RF frequency setting function pointer
+
+One can use TUNER_FP_SET_RF_FREQ_HZ() to set tuner RF frequency in Hz.
+
+
+@param [in]   pTuner     The tuner module pointer
+@param [in]   RfFreqHz   RF frequency in Hz for setting
+
+
+@retval   FUNCTION_SUCCESS   Set tuner RF frequency successfully.
+@retval   FUNCTION_ERROR     Set tuner RF frequency unsuccessfully.
+
+
+@note
+	-# Tuner building function will set TUNER_FP_SET_RF_FREQ_HZ() with the corresponding function.
+
+*/
+typedef int
+(*TUNER_FP_SET_RF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+
+
+
+
+/**
+
+@brief   Tuner RF frequency getting function pointer
+
+One can use TUNER_FP_GET_RF_FREQ_HZ() to get tuner RF frequency in Hz.
+
+
+@param [in]   pTuner      The tuner module pointer
+@param [in]   pRfFreqHz   Pointer to an allocated memory for storing demod RF frequency in Hz
+
+
+@retval   FUNCTION_SUCCESS   Get tuner RF frequency successfully.
+@retval   FUNCTION_ERROR     Get tuner RF frequency unsuccessfully.
+
+
+@note
+	-# Tuner building function will set TUNER_FP_GET_RF_FREQ_HZ() with the corresponding function.
+
+*/
+typedef int
+(*TUNER_FP_GET_RF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// TDCG-G052D extra module
+typedef struct TDCGG052D_EXTRA_MODULE_TAG TDCGG052D_EXTRA_MODULE;
+struct TDCGG052D_EXTRA_MODULE_TAG
+{
+	// TDCG-G052D extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control;
+	unsigned char BandSwitch;
+	unsigned char Auxiliary;
+};
+
+
+
+
+
+// TDCH-G001D extra module
+typedef struct TDCHG001D_EXTRA_MODULE_TAG TDCHG001D_EXTRA_MODULE;
+struct TDCHG001D_EXTRA_MODULE_TAG
+{
+	// TDCH-G001D extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control;
+	unsigned char BandSwitch;
+	unsigned char Auxiliary;
+};
+
+
+
+
+
+// TDQE3-003A extra module
+#define TDQE3003A_CONTROL_BYTE_NUM		3
+
+typedef struct TDQE3003A_EXTRA_MODULE_TAG TDQE3003A_EXTRA_MODULE;
+struct TDQE3003A_EXTRA_MODULE_TAG
+{
+	// TDQE3-003A extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control[TDQE3003A_CONTROL_BYTE_NUM];
+};
+
+
+
+
+
+// DCT-7045 extra module
+typedef struct DCT7045_EXTRA_MODULE_TAG DCT7045_EXTRA_MODULE;
+struct DCT7045_EXTRA_MODULE_TAG
+{
+	// DCT-7045 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control;
+};
+
+
+
+
+
+/// MT2062 extra module
+typedef struct MT2062_EXTRA_MODULE_TAG MT2062_EXTRA_MODULE;
+
+// MT2062 handle openning function pointer
+typedef int
+(*MT2062_FP_OPEN_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2062 handle closing function pointer
+typedef int
+(*MT2062_FP_CLOSE_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2062 handle getting function pointer
+typedef void
+(*MT2062_FP_GET_HANDLE)(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	);
+
+// MT2062 IF frequency setting function pointer
+typedef int
+(*MT2062_FP_SET_IF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long IfFreqHz
+	);
+
+// MT2062 IF frequency getting function pointer
+typedef int
+(*MT2062_FP_GET_IF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	);
+
+// MT2062 extra module
+struct MT2062_EXTRA_MODULE_TAG
+{
+	// MT2062 extra variables
+	void *DeviceHandle;
+	int LoopThroughMode;
+
+	unsigned long IfFreqHz;
+
+	int IsIfFreqHzSet;
+
+	// MT2062 extra function pointers
+	MT2062_FP_OPEN_HANDLE      OpenHandle;
+	MT2062_FP_CLOSE_HANDLE     CloseHandle;
+	MT2062_FP_GET_HANDLE       GetHandle;
+	MT2062_FP_SET_IF_FREQ_HZ   SetIfFreqHz;
+	MT2062_FP_GET_IF_FREQ_HZ   GetIfFreqHz;
+};
+
+
+
+
+
+/// MxL5005S extra module
+#define INITCTRL_NUM		40
+#define CHCTRL_NUM			36
+#define MXLCTRL_NUM			189
+#define TUNER_REGS_NUM		104
+
+typedef struct MXL5005S_EXTRA_MODULE_TAG MXL5005S_EXTRA_MODULE;
+
+// MXL5005 Tuner Register Struct
+typedef struct _TunerReg_struct
+{
+	unsigned short 	Reg_Num ;							// Tuner Register Address
+	unsigned short	Reg_Val ;							// Current sofware programmed value waiting to be writen
+} TunerReg_struct ;
+
+// MXL5005 Tuner Control Struct
+typedef struct _TunerControl_struct {
+	unsigned short	Ctrl_Num ;							// Control Number
+	unsigned short	size ;								// Number of bits to represent Value
+	unsigned short 	addr[25] ;							// Array of Tuner Register Address for each bit position
+	unsigned short 	bit[25] ;							// Array of bit position in Register Address for each bit position
+	unsigned short 	val[25] ;							// Binary representation of Value
+} TunerControl_struct ;
+
+// MXL5005 Tuner Struct
+typedef struct _Tuner_struct
+{
+	unsigned char			Mode ;				// 0: Analog Mode ; 1: Digital Mode
+	unsigned char			IF_Mode ;			// for Analog Mode, 0: zero IF; 1: low IF
+	unsigned long			Chan_Bandwidth ;	// filter  channel bandwidth (6, 7, 8)
+	unsigned long			IF_OUT ;			// Desired IF Out Frequency
+	unsigned short			IF_OUT_LOAD ;		// IF Out Load Resistor (200/300 Ohms)
+	unsigned long			RF_IN ;				// RF Input Frequency
+	unsigned long			Fxtal ;				// XTAL Frequency
+	unsigned char			AGC_Mode ;			// AGC Mode 0: Dual AGC; 1: Single AGC
+	unsigned short			TOP ;				// Value: take over point
+	unsigned char			CLOCK_OUT ;			// 0: turn off clock out; 1: turn on clock out
+	unsigned char			DIV_OUT ;			// 4MHz or 16MHz
+	unsigned char			CAPSELECT ;			// 0: disable On-Chip pulling cap; 1: enable
+	unsigned char			EN_RSSI ;			// 0: disable RSSI; 1: enable RSSI
+	unsigned char			Mod_Type ;			// Modulation Type; 
+										// 0 - Default;	1 - DVB-T; 2 - ATSC; 3 - QAM; 4 - Analog Cable
+	unsigned char			TF_Type ;			// Tracking Filter Type
+										// 0 - Default; 1 - Off; 2 - Type C; 3 - Type C-H
+
+	// Calculated Settings
+	unsigned long			RF_LO ;				// Synth RF LO Frequency
+	unsigned long			IF_LO ;				// Synth IF LO Frequency
+	unsigned long			TG_LO ;				// Synth TG_LO Frequency
+
+	// Pointers to ControlName Arrays
+	unsigned short					Init_Ctrl_Num ;					// Number of INIT Control Names
+	TunerControl_struct		Init_Ctrl[INITCTRL_NUM] ;		// INIT Control Names Array Pointer
+	unsigned short					CH_Ctrl_Num ;					// Number of CH Control Names
+	TunerControl_struct		CH_Ctrl[CHCTRL_NUM] ;			// CH Control Name Array Pointer
+	unsigned short					MXL_Ctrl_Num ;					// Number of MXL Control Names
+	TunerControl_struct		MXL_Ctrl[MXLCTRL_NUM] ;			// MXL Control Name Array Pointer
+
+	// Pointer to Tuner Register Array
+	unsigned short					TunerRegs_Num ;		// Number of Tuner Registers
+	TunerReg_struct			TunerRegs[TUNER_REGS_NUM] ;			// Tuner Register Array Pointer
+} Tuner_struct ;
+
+// MxL5005S register setting function pointer
+typedef int
+(*MXL5005S_FP_SET_REGS_WITH_TABLE)(
+	TUNER_MODULE *pTuner,
+	unsigned char *pAddrTable,
+	unsigned char *pByteTable,
+	int TableLen
+	);
+
+// MxL5005S register mask bits setting function pointer
+typedef int
+(*MXL5005S_FP_SET_REG_MASK_BITS)(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned char WritingValue
+	);
+
+// MxL5005S spectrum mode setting function pointer
+typedef int
+(*MXL5005S_FP_SET_SPECTRUM_MODE)(
+	TUNER_MODULE *pTuner,
+	int SpectrumMode
+	);
+
+// MxL5005S bandwidth setting function pointer
+typedef int
+(*MXL5005S_FP_SET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+// MxL5005S extra module
+struct MXL5005S_EXTRA_MODULE_TAG
+{
+	// MxL5005S function pointers
+	MXL5005S_FP_SET_REGS_WITH_TABLE   SetRegsWithTable;
+	MXL5005S_FP_SET_REG_MASK_BITS     SetRegMaskBits;
+	MXL5005S_FP_SET_SPECTRUM_MODE     SetSpectrumMode;
+	MXL5005S_FP_SET_BANDWIDTH_HZ      SetBandwidthHz;
+
+
+	// MxL5005S extra data
+	unsigned char AgcMasterByte;			//   Variable name in MaxLinear source code: AGC_MASTER_BYTE
+
+	// MaxLinear defined struct
+	Tuner_struct MxlDefinedTunerStructure;
+};
+
+
+
+
+
+// TDVM-H715P extra module
+typedef struct TDVMH715P_EXTRA_MODULE_TAG TDVMH751P_EXTRA_MODULE;
+struct TDVMH715P_EXTRA_MODULE_TAG
+{
+	// TDVM-H715P extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control;
+	unsigned char BandSwitch;
+	unsigned char Auxiliary;
+};
+
+
+
+
+
+// UBA00AL extra module
+typedef struct UBA00AL_EXTRA_MODULE_TAG UBA00AL_EXTRA_MODULE;
+struct UBA00AL_EXTRA_MODULE_TAG
+{
+	// UBA00AL extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char BandSwitch;
+	unsigned char Control2;
+};
+
+
+
+
+
+/// MT2266 extra module
+typedef struct MT2266_EXTRA_MODULE_TAG MT2266_EXTRA_MODULE;
+
+// MT2266 handle openning function pointer
+typedef int
+(*MT2266_FP_OPEN_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2266 handle closing function pointer
+typedef int
+(*MT2266_FP_CLOSE_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2266 handle getting function pointer
+typedef void
+(*MT2266_FP_GET_HANDLE)(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	);
+
+// MT2266 bandwidth setting function pointer
+typedef int
+(*MT2266_FP_SET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+// MT2266 bandwidth getting function pointer
+typedef int
+(*MT2266_FP_GET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+// MT2266 extra module
+struct MT2266_EXTRA_MODULE_TAG
+{
+	// MT2266 extra variables
+	void *DeviceHandle;
+	unsigned long BandwidthHz;
+	int IsBandwidthHzSet;
+
+	// MT2266 extra function pointers
+	MT2266_FP_OPEN_HANDLE        OpenHandle;
+	MT2266_FP_CLOSE_HANDLE       CloseHandle;
+	MT2266_FP_GET_HANDLE         GetHandle;
+	MT2266_FP_SET_BANDWIDTH_HZ   SetBandwidthHz;
+	MT2266_FP_GET_BANDWIDTH_HZ   GetBandwidthHz;
+};
+
+
+
+
+
+// FC2580 extra module
+typedef struct FC2580_EXTRA_MODULE_TAG FC2580_EXTRA_MODULE;
+
+// FC2580 bandwidth mode setting function pointer
+typedef int
+(*FC2580_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// FC2580 bandwidth mode getting function pointer
+typedef int
+(*FC2580_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// FC2580 extra module
+struct FC2580_EXTRA_MODULE_TAG
+{
+	// FC2580 extra variables
+	unsigned long CrystalFreqHz;
+	int AgcMode;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// FC2580 extra function pointers
+	FC2580_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	FC2580_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+};
+
+
+
+
+
+/// TUA9001 extra module
+typedef struct TUA9001_EXTRA_MODULE_TAG TUA9001_EXTRA_MODULE;
+
+// Extra manipulaing function
+typedef int
+(*TUA9001_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+typedef int
+(*TUA9001_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+typedef int
+(*TUA9001_FP_GET_REG_BYTES_WITH_REG_ADDR)(
+	TUNER_MODULE *pTuner,
+	unsigned char DeviceAddr,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte,
+	unsigned char ByteNum
+	);
+
+typedef int
+(*TUA9001_FP_SET_SYS_REG_BYTE)(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char WritingByte
+	);
+
+typedef int
+(*TUA9001_FP_GET_SYS_REG_BYTE)(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char *pReadingByte
+	);
+
+// TUA9001 extra module
+struct TUA9001_EXTRA_MODULE_TAG
+{
+	// TUA9001 extra variables
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// TUA9001 extra function pointers
+	TUA9001_FP_SET_BANDWIDTH_MODE            SetBandwidthMode;
+	TUA9001_FP_GET_BANDWIDTH_MODE            GetBandwidthMode;
+	TUA9001_FP_GET_REG_BYTES_WITH_REG_ADDR   GetRegBytesWithRegAddr;
+	TUA9001_FP_SET_SYS_REG_BYTE              SetSysRegByte;
+	TUA9001_FP_GET_SYS_REG_BYTE              GetSysRegByte;
+};
+
+
+
+
+
+// DTT-75300 extra module
+typedef struct DTT75300_EXTRA_MODULE_TAG DTT75300_EXTRA_MODULE;
+struct DTT75300_EXTRA_MODULE_TAG
+{
+	// DTT-75300 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+	unsigned char Control4;
+};
+
+
+
+
+
+// MxL5007T extra module
+typedef struct MXL5007T_EXTRA_MODULE_TAG MXL5007T_EXTRA_MODULE;
+
+// MxL5007 TunerConfig Struct
+typedef struct _MxL5007_TunerConfigS
+{
+	int	I2C_Addr;
+	int	Mode;
+	int	IF_Diff_Out_Level;
+	int	Xtal_Freq;
+	int	IF_Freq;
+	int IF_Spectrum;
+	int	ClkOut_Setting;
+    int	ClkOut_Amp;
+	int BW_MHz;
+	unsigned int RF_Freq_Hz;
+
+	// Additional definition
+	TUNER_MODULE *pTuner;
+
+} MxL5007_TunerConfigS;
+
+// MxL5007T bandwidth mode setting function pointer
+typedef int
+(*MXL5007T_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// MxL5007T bandwidth mode getting function pointer
+typedef int
+(*MXL5007T_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// MxL5007T extra module
+struct MXL5007T_EXTRA_MODULE_TAG
+{
+	// MxL5007T extra variables
+	int LoopThroughMode;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// MxL5007T MaxLinear-defined structure
+	MxL5007_TunerConfigS *pTunerConfigS;
+	MxL5007_TunerConfigS TunerConfigSMemory;
+
+	// MxL5007T extra function pointers
+	MXL5007T_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	MXL5007T_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+};
+
+
+
+
+
+// VA1T1ED6093 extra module
+typedef struct VA1T1ED6093_EXTRA_MODULE_TAG VA1T1ED6093_EXTRA_MODULE;
+struct VA1T1ED6093_EXTRA_MODULE_TAG
+{
+	// VA1T1ED6093 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+/// TUA8010 extra module
+typedef struct TUA8010_EXTRA_MODULE_TAG TUA8010_EXTRA_MODULE;
+
+// Extra manipulaing function
+typedef int
+(*TUA8010_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+typedef int
+(*TUA8010_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+typedef int
+(*TUA8010_FP_GET_REG_BYTES_WITH_REG_ADDR)(
+	TUNER_MODULE *pTuner,
+	unsigned char DeviceAddr,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte,
+	unsigned char ByteNum
+	);
+
+// TUA8010 extra module
+struct TUA8010_EXTRA_MODULE_TAG
+{
+	// TUA8010 extra variables
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// TUA8010 extra function pointers
+	TUA8010_FP_SET_BANDWIDTH_MODE            SetBandwidthMode;
+	TUA8010_FP_GET_BANDWIDTH_MODE            GetBandwidthMode;
+	TUA8010_FP_GET_REG_BYTES_WITH_REG_ADDR   GetRegBytesWithRegAddr;
+};
+
+
+
+
+
+// E4000 extra module
+typedef struct E4000_EXTRA_MODULE_TAG E4000_EXTRA_MODULE;
+
+// E4000 register byte getting function pointer
+typedef int
+(*E4000_FP_GET_REG_BYTE)(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte
+	);
+
+// E4000 bandwidth Hz setting function pointer
+typedef int
+(*E4000_FP_SET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+// E4000 bandwidth Hz getting function pointer
+typedef int
+(*E4000_FP_GET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+// E4000 extra module
+struct E4000_EXTRA_MODULE_TAG
+{
+	// E4000 extra variables
+	unsigned long CrystalFreqHz;
+	int BandwidthHz;
+	int IsBandwidthHzSet;
+
+	// E4000 extra function pointers
+	E4000_FP_GET_REG_BYTE       GetRegByte;
+	E4000_FP_SET_BANDWIDTH_HZ   SetBandwidthHz;
+	E4000_FP_GET_BANDWIDTH_HZ   GetBandwidthHz;
+};
+
+
+
+
+
+// DCT-70704 extra module
+typedef struct DCT70704_EXTRA_MODULE_TAG DCT70704_EXTRA_MODULE;
+struct DCT70704_EXTRA_MODULE_TAG
+{
+	// DCT-70704 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char BandSwitch;
+	unsigned char Control2;
+};
+
+
+
+
+
+/// MT2063 extra module
+typedef struct MT2063_EXTRA_MODULE_TAG MT2063_EXTRA_MODULE;
+
+// MT2063 handle openning function pointer
+typedef int
+(*MT2063_FP_OPEN_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2063 handle closing function pointer
+typedef int
+(*MT2063_FP_CLOSE_HANDLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// MT2063 handle getting function pointer
+typedef void
+(*MT2063_FP_GET_HANDLE)(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	);
+
+// MT2063 IF frequency setting function pointer
+typedef int
+(*MT2063_FP_SET_IF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long IfFreqHz
+	);
+
+// MT2063 IF frequency getting function pointer
+typedef int
+(*MT2063_FP_GET_IF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	);
+
+// MT2063 bandwidth setting function pointer
+typedef int
+(*MT2063_FP_SET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+// MT2063 bandwidth getting function pointer
+typedef int
+(*MT2063_FP_GET_BANDWIDTH_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+// MT2063 extra module
+struct MT2063_EXTRA_MODULE_TAG
+{
+	// MT2063 extra variables
+	void *DeviceHandle;
+	int StandardMode;
+	unsigned long VgaGc;
+
+	unsigned long IfFreqHz;
+	unsigned long BandwidthHz;
+
+	int IsIfFreqHzSet;
+	int IsBandwidthHzSet;
+
+	// MT2063 extra function pointers
+	MT2063_FP_OPEN_HANDLE        OpenHandle;
+	MT2063_FP_CLOSE_HANDLE       CloseHandle;
+	MT2063_FP_GET_HANDLE         GetHandle;
+	MT2063_FP_SET_IF_FREQ_HZ     SetIfFreqHz;
+	MT2063_FP_GET_IF_FREQ_HZ     GetIfFreqHz;
+	MT2063_FP_SET_BANDWIDTH_HZ   SetBandwidthHz;
+	MT2063_FP_GET_BANDWIDTH_HZ   GetBandwidthHz;
+};
+
+
+
+
+
+// FC0012 extra module
+typedef struct FC0012_EXTRA_MODULE_TAG FC0012_EXTRA_MODULE;
+
+// FC0012 bandwidth mode setting function pointer
+typedef int
+(*FC0012_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// FC0012 bandwidth mode getting function pointer
+typedef int
+(*FC0012_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// FC0012 extra module
+struct FC0012_EXTRA_MODULE_TAG
+{
+	// FC0012 extra variables
+	unsigned long CrystalFreqHz;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// FC0012 extra function pointers
+	FC0012_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	FC0012_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+};
+
+
+
+
+
+// TDAG extra module
+typedef struct TDAG_EXTRA_MODULE_TAG TDAG_EXTRA_MODULE;
+struct TDAG_EXTRA_MODULE_TAG
+{
+	// TDAG extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// ADMTV804 extra module
+typedef struct ADMTV804_EXTRA_MODULE_TAG ADMTV804_EXTRA_MODULE;
+
+// ADMTV804 standard bandwidth mode setting function pointer
+typedef int
+(*ADMTV804_FP_SET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// ADMTV804 standard bandwidth mode getting function pointer
+typedef int
+(*ADMTV804_FP_GET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// ADMTV804 RF power level getting function pointer
+typedef int
+(*ADMTV804_FP_GET_RF_POWER_LEVEL)(
+	TUNER_MODULE *pTuner,
+	long *pRfPowerLevel
+	);
+
+// ADMTV804 extra module
+struct ADMTV804_EXTRA_MODULE_TAG
+{
+	// ADMTV804 extra variables (from ADMTV804 source code)
+	unsigned char REV_INFO;
+	unsigned char g_curBand;
+	unsigned char pddiv3;
+	unsigned char REG24;
+	unsigned char REG2B;
+	unsigned char REG2E;
+	unsigned char REG30;
+	unsigned char REG31;
+	unsigned char REG5A;
+	unsigned char REG61;  // V1.6 added 
+
+	// ADMTV804 extra variables
+	unsigned long CrystalFreqHz;
+	int StandardBandwidthMode;
+	int IsStandardBandwidthModeSet;
+	long RfPowerLevel;
+
+	// ADMTV804 extra function pointers
+	ADMTV804_FP_SET_STANDARD_BANDWIDTH_MODE   SetStandardBandwidthMode;
+	ADMTV804_FP_GET_STANDARD_BANDWIDTH_MODE   GetStandardBandwidthMode;
+	ADMTV804_FP_GET_RF_POWER_LEVEL            GetRfPowerLevel;
+};
+
+
+
+
+
+// MAX3543 extra module
+typedef struct MAX3543_EXTRA_MODULE_TAG MAX3543_EXTRA_MODULE;
+
+// MAX3543 bandwidth mode setting function pointer
+typedef int
+(*MAX3543_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// MAX3543 bandwidth mode getting function pointer
+typedef int
+(*MAX3543_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// MAX3543 extra module
+struct MAX3543_EXTRA_MODULE_TAG
+{
+	// MAX3543 extra variables (from MAX3543 source code)
+	unsigned short TFRomCoefs[3][4];
+	unsigned short denominator;   
+	unsigned long  fracscale ;
+	unsigned short regs[22];
+	unsigned short IF_Frequency;
+
+	int broadcast_standard;
+	int XTALSCALE;
+	int XTALREF;
+	int LOSCALE;
+
+
+	// MAX3543 extra variables
+	unsigned long CrystalFreqHz;
+	int StandardMode;
+	unsigned long IfFreqHz;
+	int OutputMode;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// MAX3543 extra function pointers
+	MAX3543_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	MAX3543_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+};
+
+
+
+
+
+// TDA18272 extra module
+typedef struct TDA18272_EXTRA_MODULE_TAG TDA18272_EXTRA_MODULE;
+
+// TDA18272 standard bandwidth mode setting function pointer
+typedef int
+(*TDA18272_FP_SET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int StandardBandwidthMode
+	);
+
+// TDA18272 standard bandwidth mode getting function pointer
+typedef int
+(*TDA18272_FP_GET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pStandardBandwidthMode
+	);
+
+// TDA18272 power mode setting function pointer
+typedef int
+(*TDA18272_FP_SET_POWER_MODE)(
+	TUNER_MODULE *pTuner,
+	int PowerMode
+	);
+
+// TDA18272 power mode getting function pointer
+typedef int
+(*TDA18272_FP_GET_POWER_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pPowerMode
+	);
+
+// TDA18272 IF frequency getting function pointer
+typedef int
+(*TDA18272_FP_GET_IF_FREQ_HZ)(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	);
+
+// TDA18272 extra module
+struct TDA18272_EXTRA_MODULE_TAG
+{
+	// TDA18272 extra variables
+	unsigned long CrystalFreqHz;
+	int UnitNo;
+	int IfOutputVppMode;
+	int StandardBandwidthMode;
+	int IsStandardBandwidthModeSet;
+	int PowerMode;
+	int IsPowerModeSet;
+
+	// TDA18272 extra function pointers
+	TDA18272_FP_SET_STANDARD_BANDWIDTH_MODE   SetStandardBandwidthMode;
+	TDA18272_FP_GET_STANDARD_BANDWIDTH_MODE   GetStandardBandwidthMode;
+	TDA18272_FP_SET_POWER_MODE                SetPowerMode;
+	TDA18272_FP_GET_POWER_MODE                GetPowerMode;
+	TDA18272_FP_GET_IF_FREQ_HZ                GetIfFreqHz;
+};
+
+
+
+
+
+// FC0013 extra module
+typedef struct FC0013_EXTRA_MODULE_TAG FC0013_EXTRA_MODULE;
+
+// FC0013 bandwidth mode setting function pointer
+typedef int
+(*FC0013_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// FC0013 bandwidth mode getting function pointer
+typedef int
+(*FC0013_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// FC0013 reset IQ LPF BW
+typedef int
+(*FC0013_FP_RC_CAL_RESET)(
+	TUNER_MODULE *pTuner
+	);
+
+// FC0013 increase IQ LPF BW
+typedef int
+(*FC0013_FP_RC_CAL_ADD)(
+	TUNER_MODULE *pTuner,
+	int RcValue
+	);
+
+// FC0013 extra module
+struct FC0013_EXTRA_MODULE_TAG
+{
+	// FC0013 extra variables
+	unsigned long CrystalFreqHz;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// FC0013 extra function pointers
+	FC0013_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	FC0013_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+	FC0013_FP_RC_CAL_RESET         RcCalReset;
+	FC0013_FP_RC_CAL_ADD           RcCalAdd;
+};
+
+
+
+
+
+// VA1E1ED2403 extra module
+typedef struct VA1E1ED2403_EXTRA_MODULE_TAG VA1E1ED2403_EXTRA_MODULE;
+struct VA1E1ED2403_EXTRA_MODULE_TAG
+{
+	// VA1E1ED2403 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// Avalon extra module
+#define AVALON_RF_REG_MAX_ADDR		0x60
+#define AVALON_BB_REG_MAX_ADDR		0x4f
+
+typedef struct _AVALON_CONFIG_STRUCT {
+	double RFChannelMHz;
+	double dIfFrequencyMHz;
+	double f_dac_MHz;
+	int TVStandard;
+} AVALON_CONFIG_STRUCT, *PAVALON_CONFIG_STRUCT;
+
+typedef struct AVALON_EXTRA_MODULE_TAG AVALON_EXTRA_MODULE;
+
+// AVALON standard bandwidth mode setting function pointer
+typedef int
+(*AVALON_FP_SET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int StandardBandwidthMode
+	);
+
+// AVALON standard bandwidth mode getting function pointer
+typedef int
+(*AVALON_FP_GET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pStandardBandwidthMode
+	);
+
+// AVALON extra module
+struct AVALON_EXTRA_MODULE_TAG
+{
+	// AVALON extra variables (from AVALON source code)
+	unsigned char g_avalon_rf_reg_work_table[AVALON_RF_REG_MAX_ADDR+1];
+	unsigned char g_avalon_bb_reg_work_table[AVALON_BB_REG_MAX_ADDR+1];
+
+	int
+	(*g_avalon_i2c_read_handler)(
+		TUNER_MODULE *pTuner,
+		unsigned char DeviceAddr,
+		unsigned char *pReadingBuffer,
+		unsigned short *pByteNum
+		);
+
+	int
+	(*g_avalon_i2c_write_handler)(
+		TUNER_MODULE *pTuner,
+		unsigned char DeviceAddr,
+		unsigned char *pWritingBuffer,
+		unsigned short *pByteNum
+		);
+
+	AVALON_CONFIG_STRUCT AvalonConfig;
+
+
+	// AVALON extra variables
+	unsigned char AtvDemodDeviceAddr;
+	unsigned long CrystalFreqHz;
+	unsigned long IfFreqHz;
+	int StandardBandwidthMode;
+	int IsStandardBandwidthModeSet;
+
+	// AVALON extra function pointers
+	AVALON_FP_SET_STANDARD_BANDWIDTH_MODE   SetStandardBandwidthMode;
+	AVALON_FP_GET_STANDARD_BANDWIDTH_MODE   GetStandardBandwidthMode;
+};
+
+
+
+
+
+// SutRx201 extra module
+typedef struct SUTRE201_EXTRA_MODULE_TAG SUTRE201_EXTRA_MODULE;
+
+// SUTRE201 standard bandwidth mode setting function pointer
+typedef int
+(*SUTRE201_FP_SET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int StandardBandwidthMode
+	);
+
+// SUTRE201 standard bandwidth mode getting function pointer
+typedef int
+(*SUTRE201_FP_GET_STANDARD_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pStandardBandwidthMode
+	);
+
+// SUTRE201 tuner enabling function pointer
+typedef int
+(*SUTRE201_FP_ENABLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// SUTRE201 tuner disabling function pointer
+typedef int
+(*SUTRE201_FP_DISABLE)(
+	TUNER_MODULE *pTuner
+	);
+
+// SUTRE201 tuner IF port mode setting function pointer
+typedef int
+(*SUTRE201_FP_SET_IF_PORT_MODE)(
+	TUNER_MODULE *pTuner,
+	int IfPortMode
+	);
+
+// SUTRE201 extra module
+struct SUTRE201_EXTRA_MODULE_TAG
+{
+	// SUTRE201 extra variables
+	unsigned long CrystalFreqHz;
+	unsigned long IfFreqHz;
+	int IfPortMode;
+	int CountryMode;
+	int StandardBandwidthMode;
+	int IsStandardBandwidthModeSet;
+
+	// SUTRE201 extra function pointers
+	SUTRE201_FP_SET_STANDARD_BANDWIDTH_MODE   SetStandardBandwidthMode;
+	SUTRE201_FP_GET_STANDARD_BANDWIDTH_MODE   GetStandardBandwidthMode;
+	SUTRE201_FP_ENABLE                        Enable;
+	SUTRE201_FP_DISABLE                       Disable;
+	SUTRE201_FP_SET_IF_PORT_MODE              SetIfPortMode;
+};
+
+
+
+
+
+// MR1300 extra module
+typedef struct MR1300_EXTRA_MODULE_TAG MR1300_EXTRA_MODULE;
+struct MR1300_EXTRA_MODULE_TAG
+{
+	// MR1300 extra data
+	unsigned long CrystalFreqHz;
+};
+
+
+
+
+
+// TDAC7 extra module
+typedef struct TDAC7_EXTRA_MODULE_TAG TDAC7_EXTRA_MODULE;
+struct TDAC7_EXTRA_MODULE_TAG
+{
+	// TDAC7 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// VA1T1ER2094 extra module
+typedef struct VA1T1ER2094_EXTRA_MODULE_TAG VA1T1ER2094_EXTRA_MODULE;
+struct VA1T1ER2094_EXTRA_MODULE_TAG
+{
+	// VA1T1ER2094 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// TDAC3 extra module
+typedef struct TDAC3_EXTRA_MODULE_TAG TDAC3_EXTRA_MODULE;
+struct TDAC3_EXTRA_MODULE_TAG
+{
+	// TDAC3 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// RT910 extra module
+#define RT910_INITIAL_TABLE_LENGTH     25
+typedef struct RT910_EXTRA_MODULE_TAG RT910_EXTRA_MODULE;
+
+// RT910 bandwidth mode setting function pointer
+typedef int
+(*RT910_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// RT910 bandwidth mode getting function pointer
+typedef int
+(*RT910_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// RT910 extra module
+struct RT910_EXTRA_MODULE_TAG
+{
+	// RT910 extra variables
+	unsigned long CrystalFreqHz;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+	unsigned char RT910RegsMap[RT910_INITIAL_TABLE_LENGTH];
+	unsigned char RT910BW8MCalib[RT910_INITIAL_TABLE_LENGTH];  // 80MHz for C.F. cali.
+
+
+	// RT910 extra function pointers
+	RT910_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	RT910_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+};
+
+
+
+
+
+// DTM4C20 extra module
+typedef struct DTM4C20_EXTRA_MODULE_TAG DTM4C20_EXTRA_MODULE;
+struct DTM4C20_EXTRA_MODULE_TAG
+{
+	// DTM4C20 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// GTFD32 extra module
+typedef struct GTFD32_EXTRA_MODULE_TAG GTFD32_EXTRA_MODULE;
+struct GTFD32_EXTRA_MODULE_TAG
+{
+	// GTFD32 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// GTLP10 extra module
+typedef struct GTLP10_EXTRA_MODULE_TAG GTLP10_EXTRA_MODULE;
+struct GTLP10_EXTRA_MODULE_TAG
+{
+	// GTLP10 extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// JSS66T extra module
+typedef struct JSS66T_EXTRA_MODULE_TAG JSS66T_EXTRA_MODULE;
+struct JSS66T_EXTRA_MODULE_TAG
+{
+	// JSS66T extra data
+	unsigned char DividerMsb;
+	unsigned char DividerLsb;
+	unsigned char Control1;
+	unsigned char Control2;
+	unsigned char Control3;
+};
+
+
+
+
+
+// FC0013B extra module
+typedef struct FC0013B_EXTRA_MODULE_TAG FC0013B_EXTRA_MODULE;
+
+// FC0013B bandwidth mode setting function pointer
+typedef int
+(*FC0013B_FP_SET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+// FC0013B bandwidth mode getting function pointer
+typedef int
+(*FC0013B_FP_GET_BANDWIDTH_MODE)(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+// FC0013B reset IQ LPF BW
+typedef int
+(*FC0013B_FP_RC_CAL_RESET)(
+	TUNER_MODULE *pTuner
+	);
+
+// FC0013B increase IQ LPF BW
+typedef int
+(*FC0013B_FP_RC_CAL_ADD)(
+	TUNER_MODULE *pTuner,
+	int RcValue
+	);
+
+// FC0013B extra module
+struct FC0013B_EXTRA_MODULE_TAG
+{
+	// FC0013B extra variables
+	unsigned long CrystalFreqHz;
+	int BandwidthMode;
+	int IsBandwidthModeSet;
+
+	// FC0013B extra function pointers
+	FC0013B_FP_SET_BANDWIDTH_MODE   SetBandwidthMode;
+	FC0013B_FP_GET_BANDWIDTH_MODE   GetBandwidthMode;
+	FC0013B_FP_RC_CAL_RESET         RcCalReset;
+	FC0013B_FP_RC_CAL_ADD           RcCalAdd;
+};
+
+
+
+
+
+/// Tuner module structure
+struct TUNER_MODULE_TAG
+{
+	// Private variables
+	int           TunerType;									///<   Tuner type
+	unsigned char DeviceAddr;									///<   Tuner I2C device address
+	unsigned long RfFreqHz;										///<   Tuner RF frequency in Hz
+
+	int IsRfFreqHzSet;											///<   Tuner RF frequency in Hz (setting status)
+
+	union														///<   Tuner extra module used by driving module
+	{
+		TDCGG052D_EXTRA_MODULE   Tdcgg052d;
+		TDCHG001D_EXTRA_MODULE   Tdchg001d;
+		TDQE3003A_EXTRA_MODULE   Tdqe3003a;
+		DCT7045_EXTRA_MODULE     Dct7045;
+		MT2062_EXTRA_MODULE      Mt2062;
+		MXL5005S_EXTRA_MODULE    Mxl5005s;
+		TDVMH751P_EXTRA_MODULE   Tdvmh751p;
+		UBA00AL_EXTRA_MODULE     Uba00al;
+		MT2266_EXTRA_MODULE      Mt2266;
+		FC2580_EXTRA_MODULE      Fc2580;
+		TUA9001_EXTRA_MODULE     Tua9001;
+		DTT75300_EXTRA_MODULE    Dtt75300;
+		MXL5007T_EXTRA_MODULE    Mxl5007t;
+		VA1T1ED6093_EXTRA_MODULE Va1t1ed6093;
+		TUA8010_EXTRA_MODULE     Tua8010;
+		E4000_EXTRA_MODULE       E4000;
+		DCT70704_EXTRA_MODULE    Dct70704;
+		MT2063_EXTRA_MODULE      Mt2063;
+		FC0012_EXTRA_MODULE      Fc0012;
+		TDAG_EXTRA_MODULE        Tdag;
+		ADMTV804_EXTRA_MODULE    Admtv804;
+		MAX3543_EXTRA_MODULE     Max3543;
+		TDA18272_EXTRA_MODULE    Tda18272;
+		FC0013_EXTRA_MODULE      Fc0013;
+		VA1E1ED2403_EXTRA_MODULE Va1e1ed2403;
+		AVALON_EXTRA_MODULE      Avalon;
+		SUTRE201_EXTRA_MODULE    Sutre201;
+		MR1300_EXTRA_MODULE      Mr1300;
+		TDAC7_EXTRA_MODULE       Tdac7;
+		VA1T1ER2094_EXTRA_MODULE Va1t1er2094;
+		TDAC3_EXTRA_MODULE       Tdac3;
+		RT910_EXTRA_MODULE       Rt910;
+		DTM4C20_EXTRA_MODULE     Dtm4c20;
+		GTFD32_EXTRA_MODULE      Gtfd32;
+		GTLP10_EXTRA_MODULE      Gtlp10;
+		JSS66T_EXTRA_MODULE      Jss66t;
+		FC0013B_EXTRA_MODULE     Fc0013b;
+	}
+	Extra;
+
+	BASE_INTERFACE_MODULE *pBaseInterface;						///<   Base interface module
+	I2C_BRIDGE_MODULE *pI2cBridge;								///<   I2C bridge module
+
+
+	// Tuner manipulating functions
+	TUNER_FP_GET_TUNER_TYPE    GetTunerType;				///<   Tuner type getting function pointer
+	TUNER_FP_GET_DEVICE_ADDR   GetDeviceAddr;				///<   Tuner I2C device address getting function pointer
+
+	TUNER_FP_INITIALIZE        Initialize;					///<   Tuner initializing function pointer
+	TUNER_FP_SET_RF_FREQ_HZ    SetRfFreqHz;					///<   Tuner RF frequency setting function pointer
+	TUNER_FP_GET_RF_FREQ_HZ    GetRfFreqHz;					///<   Tuner RF frequency getting function pointer
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_e4000.c b/drivers/media/usb/rtl2832u/tuner_e4000.c
new file mode 100644
index 00000000..d7501504
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_e4000.c
@@ -0,0 +1,2482 @@
+/**
+
+@file
+
+@brief   E4000 tuner module definition
+
+One can manipulate E4000 tuner through E4000 module.
+E4000 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_e4000.h"
+
+
+
+
+
+/**
+
+@brief   E4000 tuner module builder
+
+Use BuildE4000Module() to build E4000 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to E4000 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   E4000 I2C device address
+@param [in]   CrystalFreqHz                E4000 crystal frequency in Hz
+@param [in]   AgcMode                      E4000 AGC mode
+
+
+@note
+	-# One should call BuildE4000Module() to build E4000 module before using it.
+
+*/
+void
+BuildE4000Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	E4000_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.E4000);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_E4000;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = e4000_GetTunerType;
+	pTuner->GetDeviceAddr = e4000_GetDeviceAddr;
+
+	pTuner->Initialize    = e4000_Initialize;
+	pTuner->SetRfFreqHz   = e4000_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = e4000_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz    = CrystalFreqHz;
+	pExtra->IsBandwidthHzSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->GetRegByte     = e4000_GetRegByte;
+	pExtra->SetBandwidthHz = e4000_SetBandwidthHz;
+	pExtra->GetBandwidthHz = e4000_GetBandwidthHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+e4000_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+e4000_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+e4000_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	E4000_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.E4000);
+
+
+	// Initialize tuner.
+	// Note: Call E4000 source code functions.
+	if(tunerreset(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(Tunerclock(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(Qpeak(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(DCoffloop(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(GainControlinit(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+e4000_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	E4000_EXTRA_MODULE *pExtra;
+
+	int RfFreqKhz;
+	int CrystalFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.E4000);
+
+
+	// Set tuner RF frequency in KHz.
+	// Note: 1. RfFreqKhz = round(RfFreqHz / 1000)
+	//          CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	//       2. Call E4000 source code functions.
+	RfFreqKhz      = (int)((RfFreqHz + 500) / 1000);
+	CrystalFreqKhz = (int)((pExtra->CrystalFreqHz + 500) / 1000);
+
+	if(Gainmanual(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(E4000_gain_freq(pTuner, RfFreqKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(PLL(pTuner, CrystalFreqKhz, RfFreqKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(LNAfilter(pTuner, RfFreqKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(freqband(pTuner, RfFreqKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(DCoffLUT(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+	if(GainControlauto(pTuner) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+e4000_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get E4000 register byte.
+
+*/
+int
+e4000_GetRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte
+	)
+{
+	// Call I2CReadByte() to read tuner register.
+	if(I2CReadByte(pTuner, NO_USE, RegAddr, pReadingByte) != E4000_I2C_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set E4000 tuner bandwidth.
+
+*/
+int
+e4000_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	)
+{
+	E4000_EXTRA_MODULE *pExtra;
+
+	int BandwidthKhz;
+	int CrystalFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.E4000);
+
+
+	// Set tuner bandwidth Hz.
+	// Note: 1. BandwidthKhz = round(BandwidthHz / 1000)
+	//          CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	//       2. Call E4000 source code functions.
+	BandwidthKhz   = (int)((BandwidthHz + 500) / 1000);
+	CrystalFreqKhz = (int)((pExtra->CrystalFreqHz + 500) / 1000);
+
+	if(IFfilter(pTuner, BandwidthKhz, CrystalFreqKhz) != E4000_1_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner bandwidth Hz parameter.
+	pExtra->BandwidthHz      = BandwidthHz;
+	pExtra->IsBandwidthHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get E4000 tuner bandwidth.
+
+*/
+int
+e4000_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	)
+{
+	E4000_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.E4000);
+
+
+	// Get tuner bandwidth Hz from tuner module.
+	if(pExtra->IsBandwidthHzSet != YES)
+		goto error_status_get_tuner_bandwidth_hz;
+
+	*pBandwidthHz = pExtra->BandwidthHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_hz:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Function (implemeted for E4000)
+int
+I2CReadByte(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + stop_bit
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register byte.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + read_data + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, pReadingByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	return E4000_I2C_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return E4000_I2C_FAIL;
+}
+
+
+
+
+
+int
+I2CWriteByte(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegAddr,
+	unsigned char WritingByte
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + data + stop_bit
+	WritingBuffer[0] = RegAddr;
+	WritingBuffer[1] = WritingByte;
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return E4000_I2C_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return E4000_I2C_FAIL;
+}
+
+
+
+
+
+int
+I2CWriteArray(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegStartAddr,
+	unsigned char ByteNum,
+	unsigned char *pWritingBytes
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned int i;
+
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing buffer.
+	// Note: The I2C format of demod register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) + stop_bit
+	WritingBuffer[0] = RegStartAddr;
+
+	for(i = 0; i < ByteNum; i++)
+		WritingBuffer[LEN_1_BYTE + i] = pWritingBytes[i];
+
+
+	/// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, ByteNum + LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return E4000_I2C_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return E4000_I2C_FAIL;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by Elonics.
+
+
+
+
+
+// Elonics source code - E4000_API_rev2_04_realtek.cpp
+
+
+//****************************************************************************\
+//
+//  Filename    E4000_initialisation.c
+//  Revision    2.04
+//  
+// Description:
+//  Initialisation script for the Elonics E4000 revC tuner
+//   
+//  Copyright (c)  Elonics Ltd
+//
+//    Any software supplied free of charge for use with elonics
+//    evaluation kits is supplied without warranty and for
+//    evaluation purposes only. Incorporation of any of this
+//    code into products for open sale is permitted but only at
+//    the user's own risk. Elonics accepts no liability for the 
+//    integrity of this software whatsoever.
+//  
+//
+//****************************************************************************/
+//#include <stdio.h>
+//#include <stdlib.h>
+//
+// User defined variable definitions
+//
+/*
+int Ref_clk = 26000;   // Reference clock frequency(kHz).
+int Freq = 590000; // RF Frequency (kHz)
+int bandwidth = 8000;  //RF channel bandwith (kHz)
+*/
+//
+// API defined variable definitions
+//int VCO_freq;
+//unsigned char writearray[5];
+//unsigned char read1[1];
+//int status;
+//
+//
+// function definitions
+//
+/*
+int tunerreset ();
+int Tunerclock();
+int filtercal();
+int Qpeak();
+int PLL(int Ref_clk, int Freq);
+int LNAfilter(int Freq);
+int IFfilter(int bandwidth, int Ref_clk);
+int freqband(int Freq);
+int DCoffLUT();
+int DCoffloop();
+int commonmode();
+int GainControlinit();  
+*/
+//
+//****************************************************************************
+// --- Public functions ------------------------------------------------------
+/****************************************************************************\  
+*  Function: tunerreset
+*
+*  Detailed Description:
+*  The function resets the E4000 tuner. (Register 0x00).
+*
+\****************************************************************************/
+
+int tunerreset(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	writearray[0] = 64;
+	// For dummy I2C command, don't check executing status.
+	status=I2CWriteByte (pTuner, 200,2,writearray[0]);
+	status=I2CWriteByte (pTuner, 200,2,writearray[0]);
+	//printf("\nRegister 0=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 0;
+	status=I2CWriteByte (pTuner, 200,9,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 0;
+	status=I2CWriteByte (pTuner, 200,5,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 7;
+	status=I2CWriteByte (pTuner, 200,0,writearray[0]);
+	//printf("\nRegister 0=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: Tunerclock
+*
+*  Detailed Description:
+*  The function configures the E4000 clock. (Register 0x06, 0x7a).
+*  Function disables the clock - values can be modified to enable if required.
+\****************************************************************************/
+
+int Tunerclock(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	writearray[0] = 0;
+	status=I2CWriteByte(pTuner, 200,6,writearray[0]);
+	//printf("\nRegister 6=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 150;
+	status=I2CWriteByte(pTuner, 200,122,writearray[0]);
+	//printf("\nRegister 7a=%d", writearray[0]);
+	//**Modify commands above with value required if output clock is required, 
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;  
+}
+/****************************************************************************\  
+*  Function: filtercal
+*
+*  Detailed Description:
+*  Instructs RC filter calibration. (Register 0x7b).
+*
+\****************************************************************************/
+/*
+int filtercal(TUNER_MODULE *pTuner)
+{
+  //writearray[0] = 1;
+ //I2CWriteByte (pTuner, 200,123,writearray[0]);
+ //printf("\nRegister 7b=%d", writearray[0]);
+  //return;
+   return E4000_1_SUCCESS;  
+}
+*/
+/****************************************************************************\  
+*  Function: Qpeak()
+*
+*  Detailed Description:
+*  The function configures the E4000 gains. 
+*  Also sigma delta controller. (Register 0x82).
+*
+\****************************************************************************/
+
+int Qpeak(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	writearray[0] = 1;
+	writearray[1] = 254;
+	status=I2CWriteArray(pTuner, 200,126,2,writearray);
+	//printf("\nRegister 7e=%d", writearray[0]);
+	//printf("\nRegister 7f=%d", writearray[1]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CWriteByte (pTuner, 200,130,0);
+	//printf("\nRegister 82=0");
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CWriteByte (pTuner, 200,36,5);
+	//printf("\nRegister 24=5");
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 32;
+	writearray[1] = 1;
+	status=I2CWriteArray(pTuner, 200,135,2,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	//printf("\nRegister 87=%d", writearray[0]);
+	//printf("\nRegister 88=%d", writearray[1]);
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: E4000_gain_freq()
+*
+*  Detailed Description:
+*  The function configures the E4000 gains vs. freq 
+*  0xa3 to 0xa7. Also 0x24.
+*
+\****************************************************************************/
+int E4000_gain_freq(TUNER_MODULE *pTuner, int Freq)
+{
+	unsigned char writearray[5];
+	int status;
+
+	if (Freq<=350000)
+	{
+		writearray[0] = 0x10;
+		writearray[1] = 0x42;
+		writearray[2] = 0x09;
+		writearray[3] = 0x21;
+		writearray[4] = 0x94;
+	}
+	else if(Freq>=1000000)
+	{
+		writearray[0] = 0x10;
+		writearray[1] = 0x42;
+		writearray[2] = 0x09;
+		writearray[3] = 0x21;
+		writearray[4] = 0x94;
+	}
+	else 
+	{
+		writearray[0] = 0x10;
+		writearray[1] = 0x42;
+		writearray[2] = 0x09;
+		writearray[3] = 0x21;
+		writearray[4] = 0x94;
+	}
+	status=I2CWriteArray(pTuner, 200,163,5,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if (Freq<=350000)
+	{
+		writearray[0] = 94;
+		writearray[1] = 6;
+		status=I2CWriteArray(pTuner, 200,159,2,writearray);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+
+		writearray[0] = 0;
+		status=I2CWriteArray(pTuner, 200,136,1,writearray);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+	else 
+	{
+		writearray[0] = 127;
+		writearray[1] = 7;
+		status=I2CWriteArray(pTuner, 200,159,2,writearray);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+
+		writearray[0] = 1;
+		status=I2CWriteArray(pTuner, 200,136,1,writearray);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+
+	//printf("\nRegister 9f=%d", writearray[0]);
+	//printf("\nRegister a0=%d", writearray[1]);
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: DCoffloop
+*
+*  Detailed Description:
+*  Populates DC offset LUT. (Registers 0x2d, 0x70, 0x71).
+*  Turns on DC offset LUT and time varying DC offset.
+\****************************************************************************/
+int DCoffloop(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	//writearray[0]=0;
+	//I2CWriteByte(pTuner, 200,115,writearray[0]);
+	//printf("\nRegister 73=%d", writearray[0]);
+	writearray[0] = 31;
+	status=I2CWriteByte(pTuner, 200,45,writearray[0]);
+	//printf("\nRegister 2d=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 1;
+	writearray[1] = 1;
+	status=I2CWriteArray(pTuner, 200,112,2,writearray);
+	//printf("\nRegister 70=%d", writearray[0]);
+	//printf("\nRegister 71=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: commonmode
+*
+*  Detailed Description:
+*  Configures common mode voltage. (Registers 0x2f).
+*  
+\****************************************************************************/
+/*
+int commonmode(TUNER_MODULE *pTuner)
+{
+     //writearray[0] = 0;  
+     //I2CWriteByte(Device_address,47,writearray[0]);
+     //printf("\nRegister 0x2fh = %d", writearray[0]);
+     // Sets 550mV. Modify if alternative is desired.
+     return E4000_1_SUCCESS;
+}
+*/
+/****************************************************************************\  
+*  Function: GainControlinit
+*
+*  Detailed Description:
+*  Configures gain control mode. (Registers 0x1d, 0x1e, 0x1f, 0x20, 0x21, 
+*  0x1a, 0x74h, 0x75h).
+*  User may wish to modify values depending on usage scenario.
+*  Routine configures LNA: autonomous gain control
+*  IF PWM gain control. 
+*  PWM thresholds = default
+*  Mixer: switches when LNA gain =7.5dB
+*  Sensitivity / Linearity mode: manual switch
+*  
+\****************************************************************************/
+int GainControlinit(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	unsigned char read1[1];
+	int status;
+
+	unsigned char sum=255;
+
+	writearray[0] = 23;
+	status=I2CWriteByte(pTuner, 200,26,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	//printf("\nRegister 1a=%d", writearray[0]);
+
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 16;  
+	writearray[1] = 4;
+	writearray[2] = 26;  
+	writearray[3] = 15;  
+	writearray[4] = 167;  
+	status=I2CWriteArray(pTuner, 200,29,5,writearray);
+	//printf("\nRegister 1d=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 81;
+	status=I2CWriteByte(pTuner, 200,134,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	//printf("\nRegister 86=%d", writearray[0]);
+
+	//For Realtek - gain control logic
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if(read1[0]<=sum)
+	{
+		sum=read1[0];
+	}
+
+	status=I2CWriteByte(pTuner, 200,31,writearray[2]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if(read1[0] <= sum)
+	{
+		sum=read1[0];
+	}
+
+	status=I2CWriteByte(pTuner, 200,31,writearray[2]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if(read1[0] <= sum)
+	{
+		sum=read1[0];
+	}
+
+	status=I2CWriteByte(pTuner, 200,31,writearray[2]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if(read1[0] <= sum)
+	{
+		sum=read1[0];
+	}
+
+	status=I2CWriteByte(pTuner, 200,31,writearray[2]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CReadByte(pTuner, 201,27,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if (read1[0]<=sum)
+	{
+		sum=read1[0];
+	}
+
+	writearray[0]=sum;
+	status=I2CWriteByte(pTuner, 200,27,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	//printf("\nRegister 1b=%d", writearray[0]);
+	//printf("\nRegister 1e=%d", writearray[1]);
+	//printf("\nRegister 1f=%d", writearray[2]);
+	//printf("\nRegister 20=%d", writearray[3]);
+	//printf("\nRegister 21=%d", writearray[4]);
+	//writearray[0] = 3;
+	//writearray[1] = 252;
+	//writearray[2] = 3;  
+	//writearray[3] = 252; 
+	//I2CWriteArray(pTuner, 200,116,4,writearray);
+	//printf("\nRegister 74=%d", writearray[0]);
+	//printf("\nRegister 75=%d", writearray[1]);
+	//printf("\nRegister 76=%d", writearray[2]);
+	//printf("\nRegister 77=%d", writearray[3]);
+
+	return E4000_1_SUCCESS;
+}
+
+/****************************************************************************\  
+*  Main program
+*   
+*  
+*  
+\****************************************************************************/
+/*
+int main()
+{
+     tunerreset (); 
+     Tunerclock();
+     //filtercal();
+     Qpeak();
+     //PLL(Ref_clk, Freq);
+     //LNAfilter(Freq);
+     //IFfilter(bandwidth, Ref_clk);
+     //freqband(Freq);
+     //DCoffLUT();
+     DCoffloop();
+     //commonmode();
+     GainControlinit();
+//     system("PAUSE");
+  return(0);
+}
+*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Elonics source code - frequency_change_rev2.04_realtek.c
+
+
+//****************************************************************************\
+//
+//  Filename    E4000_freqchangerev2.04.c
+//  Revision    2.04
+//  
+// Description:
+//  Frequency change script for the Elonics E4000 revB tuner
+//   
+//  Copyright (c)  Elonics Ltd
+//
+//    Any software supplied free of charge for use with elonics
+//    evaluation kits is supplied without warranty and for
+//    evaluation purposes only. Incorporation of any of this
+//    code into products for open sale is permitted but only at
+//    the user's own risk. Elonics accepts no liability for the 
+//    integrity of this software whatsoever.
+//  
+//
+//****************************************************************************/
+//#include <stdio.h>
+//#include <stdlib.h>
+//
+// User defined variable definitions
+//
+/*
+int Ref_clk = 20000;   // Reference clock frequency(kHz).
+int Freq = 590000; // RF Frequency (kHz)
+int bandwidth = 8;  //RF channel bandwith (MHz)
+*/
+//
+// API defined variable definitions
+//int VCO_freq;
+//unsigned char writearray[5];
+//unsigned char read1[1];
+//int E4000_1_SUCCESS;
+//int E4000_1_FAIL;
+//int E4000_I2C_SUCCESS;
+//int status;
+//
+//
+// function definitions
+//
+/*
+int Gainmanual();
+int PLL(int Ref_clk, int Freq);
+int LNAfilter(int Freq);
+int IFfilter(int bandwidth, int Ref_clk);
+int freqband(int Freq);
+int DCoffLUT();
+int GainControlauto();  
+*/
+//
+//****************************************************************************
+// --- Public functions ------------------------------------------------------
+/****************************************************************************\  
+//****************************************************************************\  
+*  Function: Gainmanual
+*
+*  Detailed Description:
+*  Sets Gain control to serial interface control.
+*
+\****************************************************************************/
+int Gainmanual(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	writearray[0]=0;
+	status=I2CWriteByte(pTuner, 200,26,writearray[0]);
+	//printf("\nRegister 1a=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = 0;
+	status=I2CWriteByte (pTuner, 200,9,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+ 
+	writearray[0] = 0;
+	status=I2CWriteByte (pTuner, 200,5,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS; 
+}
+
+/****************************************************************************\  
+*  Function: PLL
+*
+*  Detailed Description:
+*  Configures E4000 PLL divider & sigma delta. 0x0d,0x09, 0x0a, 0x0b).
+*
+\****************************************************************************/
+int PLL(TUNER_MODULE *pTuner, int Ref_clk, int Freq)
+{
+	int VCO_freq;
+	unsigned char writearray[5];
+	int status;
+
+	unsigned char divider;
+	int intVCOfreq; 
+	int SigDel;
+	int SigDel2;
+	int SigDel3;  
+//	int harmonic_freq;
+//	int offset;
+
+	if (Freq<=72400)
+	{
+		writearray[4] = 15;
+		VCO_freq=Freq*48;
+	}
+	else if (Freq<=81200)
+    {
+		writearray[4] = 14;
+		VCO_freq=Freq*40;
+	}
+	else if (Freq<=108300)
+	{
+		writearray[4]=13;
+		VCO_freq=Freq*32;
+	}
+	else if (Freq<=162500)
+	{
+		writearray[4]=12;
+		VCO_freq=Freq*24;
+	}   
+	else if (Freq<=216600)       
+	{
+		writearray[4]=11;  
+		VCO_freq=Freq*16;
+	}
+	else if (Freq<=325000)
+	{
+		writearray[4]=10;
+		VCO_freq=Freq*12;
+	}
+	else if (Freq<=350000)
+	{
+		writearray[4]=9;
+		VCO_freq=Freq*8;  
+	}
+	else if (Freq<=432000)
+	{
+		writearray[4]=3;
+		VCO_freq=Freq*8;
+	}
+	else if (Freq<=667000)
+	{
+		writearray[4]=2; 
+		VCO_freq=Freq*6; 
+	}
+	else if (Freq<=1200000)
+	{
+		writearray[4]=1;
+		VCO_freq=Freq*4;
+	}
+	else
+	{
+		writearray[4]=0;
+		VCO_freq=Freq*2; 
+	}
+
+	//printf("\nVCOfreq=%d", VCO_freq);     
+//	divider =  VCO_freq * 1000 / Ref_clk;
+	divider =  VCO_freq / Ref_clk;
+	//printf("\ndivider=%d", divider); 
+	writearray[0]= divider;  
+//	intVCOfreq = divider * Ref_clk /1000;
+	intVCOfreq = divider * Ref_clk;
+	//printf("\ninteger VCO freq=%d", intVCOfreq);
+//	SigDel=65536 * 1000 * (VCO_freq - intVCOfreq) / Ref_clk;
+	SigDel=65536 * (VCO_freq - intVCOfreq) / Ref_clk;
+	//printf("\nSigma delta=%d", SigDel);
+	if (SigDel<=1024)
+	{
+		SigDel = 1024;
+	}
+	else if (SigDel>=64512)
+	{
+		SigDel=64512;
+	}
+	SigDel2 = SigDel / 256;
+	//printf("\nSigdel2=%d", SigDel2);
+	writearray[2] = (unsigned char)SigDel2;
+	SigDel3 = SigDel - (256 * SigDel2);
+	//printf("\nSig del3=%d", SigDel3);
+	writearray[1]= (unsigned char)SigDel3;
+	writearray[3]=(unsigned char)0;
+	status=I2CWriteArray(pTuner, 200,9,5,writearray);
+	//printf("\nRegister 9=%d", writearray[0]);
+	//printf("\nRegister a=%d", writearray[1]);
+	//printf("\nRegister b=%d", writearray[2]);
+	//printf("\nRegister d=%d", writearray[4]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	if (Freq<=82900)
+	{
+		writearray[0]=0;
+		writearray[2]=1;
+	}
+	else if (Freq<=89900)
+	{
+		writearray[0]=3;
+		writearray[2]=9;
+	}
+	else if (Freq<=111700)
+	{
+		writearray[0]=0;
+		writearray[2]=1;
+	}
+	else if (Freq<=118700)
+	{
+		writearray[0]=3;
+		writearray[2]=1;
+	}
+	else if (Freq<=140500)
+	{
+		writearray[0]=0;
+		writearray[2]=3;
+	}
+	else if (Freq<=147500)
+	{
+		writearray[0]=3;
+		writearray[2]=11;
+	}
+	else if (Freq<=169300)
+	{
+		writearray[0]=0;
+		writearray[2]=3;
+	}
+	else if (Freq<=176300)
+	{
+		writearray[0]=3;
+		writearray[2]=11;
+	}
+	else if (Freq<=198100)
+	{
+		writearray[0]=0;
+		writearray[2]=3;
+	}
+	else if (Freq<=205100)
+	{
+		writearray[0]=3;
+		writearray[2]=19;
+	}
+	else if (Freq<=226900)
+	{
+		writearray[0]=0;
+		writearray[2]=3;
+	}
+	else if (Freq<=233900)
+	{
+		writearray[0]=3;
+		writearray[2]=3;
+	}
+	else if (Freq<=350000)
+	{
+		writearray[0]=0;
+		writearray[2]=3;
+	}
+	else if (Freq<=485600)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=493600)
+	{
+		writearray[0]=3;
+		writearray[2]=5;
+	}
+	else if (Freq<=514400)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=522400)
+	{
+		writearray[0]=3;
+		writearray[2]=5;
+	}
+	else if (Freq<=543200)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=551200)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=572000)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=580000)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=600800)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=608800)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=629600)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=637600)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=658400)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=666400)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=687200)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=695200)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=716000)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=724000)
+	{
+		writearray[0]=3;
+		writearray[2]=13;
+	}
+	else if (Freq<=744800)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=752800)
+	{
+		writearray[0]=3;
+		writearray[2]=21;
+	}
+	else if (Freq<=773600)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=781600)
+	{
+		writearray[0]=3;
+		writearray[2]=21;
+	}
+	else if (Freq<=802400)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=810400)
+	{
+		writearray[0]=3;
+		writearray[2]=21;
+	}
+	else if (Freq<=831200)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=839200)
+	{
+		writearray[0]=3;
+		writearray[2]=21;
+	}
+	else if (Freq<=860000)
+	{
+		writearray[0]=0;
+		writearray[2]=5;
+	}
+	else if (Freq<=868000)
+	{
+		writearray[0]=3;
+		writearray[2]=21;
+	}
+	else
+	{
+		writearray[0]=0;
+		writearray[2]=7;
+	}
+
+	status=I2CWriteByte (pTuner, 200,7,writearray[2]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	status=I2CWriteByte (pTuner, 200,5,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS; 
+}
+
+/****************************************************************************\  
+*  Function: LNAfilter
+*
+*  Detailed Description:
+*  The function configures the E4000 LNA filter. (Register 0x10).
+*
+\****************************************************************************/
+
+int LNAfilter(TUNER_MODULE *pTuner, int Freq)
+{
+	unsigned char writearray[5];
+	int status;
+
+	if(Freq<=370000)
+	{
+		writearray[0]=0;
+	}
+	else if(Freq<=392500)
+	{
+		writearray[0]=1;
+	}
+	else if(Freq<=415000)
+	{
+		writearray[0] =2;
+	}
+	else if(Freq<=437500)
+	{
+		writearray[0]=3;
+	}
+	else if(Freq<=462500)
+	{
+		writearray[0]=4;
+	}
+	else if(Freq<=490000)
+	{
+		writearray[0]=5;
+	}
+	else if(Freq<=522500)
+	{
+		writearray[0]=6;
+	}
+	else if(Freq<=557500)
+	{
+		writearray[0]=7;
+	}
+	else if(Freq<=595000)
+	{
+		writearray[0]=8;
+	}
+	else if(Freq<=642500)
+	{
+		writearray[0]=9;
+	}
+	else if(Freq<=695000)
+	{
+		writearray[0]=10;
+	}
+	else if(Freq<=740000)
+	{
+		writearray[0]=11;
+	}
+	else if(Freq<=800000)
+	{
+		writearray[0]=12;
+	}
+	else if(Freq<=865000)
+	{
+		writearray[0] =13;
+	}
+	else if(Freq<=930000)
+	{
+		writearray[0]=14;
+	}
+	else if(Freq<=1000000)
+	{
+		writearray[0]=15;
+	}
+	else if(Freq<=1310000)
+	{
+		writearray[0]=0;
+	}
+	else if(Freq<=1340000)
+	{
+		writearray[0]=1;
+	}
+	else if(Freq<=1385000)
+	{
+		writearray[0]=2;
+	}
+	else if(Freq<=1427500)
+	{
+		writearray[0]=3;
+	}
+	else if(Freq<=1452500)
+	{
+		writearray[0]=4;
+	}
+	else if(Freq<=1475000)
+	{
+		writearray[0]=5;
+	}
+	else if(Freq<=1510000)
+	{
+		writearray[0]=6;
+	}
+	else if(Freq<=1545000)
+	{
+		writearray[0]=7;
+	}
+	else if(Freq<=1575000)
+	{
+		writearray[0] =8;
+	}
+	else if(Freq<=1615000)
+	{
+		writearray[0]=9;
+	}
+	else if(Freq<=1650000)
+	{
+		writearray[0] =10;
+	}
+	else if(Freq<=1670000)
+	{
+		writearray[0]=11;
+	}
+	else if(Freq<=1690000)
+	{
+		writearray[0]=12;
+	}
+	else if(Freq<=1710000)
+	{
+		writearray[0]=13;
+	}
+	else if(Freq<=1735000)
+	{
+		writearray[0]=14;
+	}
+	else
+	{
+		writearray[0]=15;
+	}
+	status=I2CWriteByte (pTuner, 200,16,writearray[0]);
+	//printf("\nRegister 10=%d", writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;   
+}
+/****************************************************************************\  
+*  Function: IFfilter
+*
+*  Detailed Description:
+*  The function configures the E4000 IF filter. (Register 0x11,0x12).
+*
+\****************************************************************************/
+int IFfilter(TUNER_MODULE *pTuner, int bandwidth, int Ref_clk)
+{
+	unsigned char writearray[5];
+	int status;
+
+	int IF_BW;
+
+	IF_BW = bandwidth / 2;
+	if(IF_BW<=2150)
+	{
+		writearray[0]=253;
+		writearray[1]=31;
+	}
+	else if(IF_BW<=2200)
+	{
+		writearray[0]=253;
+		writearray[1]=30;
+	}
+	else if(IF_BW<=2240)
+	{
+		writearray[0]=252;                  
+		writearray[1]=29;
+	}
+	else if(IF_BW<=2280)
+	{
+		writearray[0]=252;                  
+		writearray[1]=28;
+	}
+	else if(IF_BW<=2300)
+	{
+		writearray[0]=252;
+		writearray[1]=27;
+	}
+	else if(IF_BW<=2400)
+	{
+		writearray[0]=252;
+		writearray[1]=26;
+	}
+	else if(IF_BW<=2450)
+	{
+		writearray[0]=252;                  
+		writearray[1]=25;
+	}
+	else if(IF_BW<=2500)
+	{
+		writearray[0]=252;               
+		writearray[1]=24;
+	}
+	else if(IF_BW<=2550)
+	{
+		writearray[0]=252;                 
+		writearray[1]=23;
+	}
+	else if(IF_BW<=2600)
+	{
+		writearray[0]=252;                 
+		writearray[1]=22;
+	}
+	else if(IF_BW<=2700)
+	{
+		writearray[0]=252;                 
+		writearray[1]=21;
+	}
+	else if(IF_BW<=2750)
+	{
+		writearray[0]=252;                  
+		writearray[1]=20;
+	}
+	else if(IF_BW<=2800)
+	{
+		writearray[0]=252;
+		writearray[1]=19;
+	}
+	else if(IF_BW<=2900)
+	{
+		writearray[0]=251;                
+		writearray[1]=18;
+	}
+	else if(IF_BW<=2950)
+	{
+		writearray[0]=251;
+		writearray[1]=17;
+	}
+	else if(IF_BW<=3000)
+	{
+		writearray[0]=251;              
+		writearray[1]=16;
+	}
+	else if(IF_BW<=3100)
+	{
+		writearray[0]=251;                 
+		writearray[1]=15;
+	}
+	else if(IF_BW<=3200)
+	{
+		writearray[0]=250;
+		writearray[1]=14;
+	}
+	else if(IF_BW<=3300)
+	{
+		writearray[0]=250;                 
+		writearray[1]=13;
+	}
+	else if(IF_BW<=3400)
+	{
+		writearray[0]=249;                 
+		writearray[1]=12;
+	}
+	else if(IF_BW<=3600)
+	{
+		writearray[0]=249;
+		writearray[1]=11;
+	}
+	else if(IF_BW<=3700)
+	{
+		writearray[0]=249;
+		writearray[1]=10;
+	}
+	else if(IF_BW<=3800)
+	{
+		writearray[0]=248;
+		writearray[1]=9;
+	}
+	else if(IF_BW<=3900)
+	{
+		writearray[0]=248;
+		writearray[1]=8;
+	}
+	else if(IF_BW<=4100)
+	{
+		writearray[0]=248;
+		writearray[1]=7;
+	}
+	else if(IF_BW<=4300)
+	{
+		writearray[0]=247;
+		writearray[1]=6;
+	}
+	else if(IF_BW<=4400)
+	{
+		writearray[0]=247;
+		writearray[1]=5;
+	}
+	else if(IF_BW<=4600)
+	{
+		writearray[0]=247;
+		writearray[1]=4;
+	}
+	else if(IF_BW<=4800)
+	{
+		writearray[0]=246;
+		writearray[1]=3;
+	}
+	else if(IF_BW<=5000)
+	{
+		writearray[0]=246;
+		writearray[1]=2;
+	}
+	else if(IF_BW<=5300)
+	{
+		writearray[0]=245;
+		writearray[1]=1;
+	}
+	else if(IF_BW<=5500)
+	{
+		writearray[0]=245;
+		writearray[1]=0;
+	}
+	else
+	{
+		writearray[0]=0;
+		writearray[1]=32;
+	}
+	status=I2CWriteArray(pTuner, 200,17,2,writearray);
+	//printf("\nRegister 11=%d", writearray[0]);
+	//printf("\nRegister 12=%d", writearray[1]);             
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS; 
+}
+/****************************************************************************\  
+*  Function: freqband
+*
+*  Detailed Description:
+*  Configures the E4000 frequency band. (Registers 0x07, 0x78).
+*
+\****************************************************************************/
+int freqband(TUNER_MODULE *pTuner, int Freq)
+{      
+	unsigned char writearray[5];
+	int status;
+
+	if (Freq<=140000)
+	{
+		writearray[0] = 3;
+		status=I2CWriteByte(pTuner, 200,120,writearray[0]);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+	else if (Freq<=350000)
+	{
+		writearray[0] = 3;
+		status=I2CWriteByte(pTuner, 200,120,writearray[0]);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+	else if (Freq<=1000000)
+	{
+		writearray[0] = 3;
+		status=I2CWriteByte(pTuner, 200,120,writearray[0]);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+	else 
+	{
+		writearray[0] = 7;
+		status=I2CWriteByte(pTuner, 200,7,writearray[0]);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+
+		writearray[0] = 0;
+		status=I2CWriteByte(pTuner, 200,120,writearray[0]);
+		if(status != E4000_I2C_SUCCESS)
+		{
+			return E4000_1_FAIL;
+		}
+	}
+
+	return E4000_1_SUCCESS;  
+}
+/****************************************************************************\  
+*  Function: DCoffLUT
+*
+*  Detailed Description:
+*  Populates DC offset LUT. (Registers 0x50 - 0x53, 0x60 - 0x63).
+*
+\****************************************************************************/
+int DCoffLUT(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	unsigned char read1[1];
+	unsigned char IOFF;
+	unsigned char QOFF;
+	unsigned char RANGE1;
+//	unsigned char RANGE2;
+	unsigned char QRANGE;
+	unsigned char IRANGE;
+	writearray[0] = 0;
+	writearray[1] = 126;
+	writearray[2] = 36;
+	status=I2CWriteArray(pTuner, 200,21,3,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Sets mixer & IF stage 1 gain = 00 and IF stg 2+ to max gain.
+	writearray[0] = 1;
+	status=I2CWriteByte(pTuner, 200,41,writearray[0]);
+	// Instructs a DC offset calibration. 
+	status=I2CReadByte(pTuner, 201,42,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,43,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	QOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,44,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	RANGE1=read1[0];
+	//reads DC offset values back
+	if(RANGE1>=32)
+	{
+		RANGE1 = RANGE1 -32;
+	}
+	if(RANGE1>=16)
+	{
+		RANGE1 = RANGE1 - 16;
+	}
+	IRANGE=RANGE1;
+	QRANGE = (read1[0] - RANGE1) / 16;
+
+	writearray[0] = (IRANGE * 64) + IOFF;
+	status=I2CWriteByte(pTuner, 200,96,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = (QRANGE * 64) + QOFF;
+	status=I2CWriteByte(pTuner, 200,80,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Populate DC offset LUT
+	writearray[0] = 0;
+	writearray[1] = 127;
+	status=I2CWriteArray(pTuner, 200,21,2,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Sets mixer & IF stage 1 gain = 01 leaving IF stg 2+ at max gain.
+	writearray[0]= 1;
+	status=I2CWriteByte(pTuner, 200,41,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Instructs a DC offset calibration.
+	status=I2CReadByte(pTuner, 201,42,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,43,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	QOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,44,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	RANGE1=read1[0];
+	// Read DC offset values
+	if(RANGE1>=32)
+	{
+		RANGE1 = RANGE1 -32;
+	}
+	if(RANGE1>=16)
+    {
+		RANGE1 = RANGE1 - 16;
+	}
+	IRANGE = RANGE1;
+	QRANGE = (read1[0] - RANGE1) / 16;
+
+	writearray[0] = (IRANGE * 64) + IOFF;
+	status=I2CWriteByte(pTuner, 200,97,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = (QRANGE * 64) + QOFF;
+	status=I2CWriteByte(pTuner, 200,81,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Populate DC offset LUT
+	writearray[0] = 1;
+	status=I2CWriteByte(pTuner, 200,21,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Sets mixer & IF stage 1 gain = 11 leaving IF stg 2+ at max gain.
+	writearray[0] = 1;
+	status=I2CWriteByte(pTuner, 200,41,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Instructs a DC offset calibration.
+	status=I2CReadByte(pTuner, 201,42,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,43,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	QOFF=read1[0];
+	status=I2CReadByte(pTuner, 201,44,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	RANGE1 = read1[0];
+	// Read DC offset values
+	if(RANGE1>=32)
+	{
+		RANGE1 = RANGE1 -32;
+	}
+	if(RANGE1>=16)
+	{
+		RANGE1 = RANGE1 - 16;
+	}
+	IRANGE = RANGE1;
+	QRANGE = (read1[0] - RANGE1) / 16;
+	writearray[0] = (IRANGE * 64) + IOFF;
+	status=I2CWriteByte(pTuner, 200,99,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = (QRANGE * 64) + QOFF;
+	status=I2CWriteByte(pTuner, 200,83,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Populate DC offset LUT
+	writearray[0] = 126;
+	status=I2CWriteByte(pTuner, 200,22,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Sets mixer & IF stage 1 gain = 11 leaving IF stg 2+ at max gain.
+	writearray[0] = 1;
+	status=I2CWriteByte(pTuner, 200,41,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	// Instructs a DC offset calibration.
+	status=I2CReadByte(pTuner, 201,42,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	IOFF=read1[0];
+
+	status=I2CReadByte(pTuner, 201,43,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	QOFF=read1[0];
+	
+	status=I2CReadByte(pTuner, 201,44,read1);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+	RANGE1=read1[0];
+	
+	// Read DC offset values
+	if(RANGE1>=32)
+	{
+		RANGE1 = RANGE1 -32;
+	}
+	if(RANGE1>=16)
+	{
+		RANGE1 = RANGE1 - 16;
+	}
+	IRANGE = RANGE1;
+	QRANGE = (read1[0] - RANGE1) / 16;
+
+	writearray[0]=(IRANGE * 64) + IOFF;
+	status=I2CWriteByte(pTuner, 200,98,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	writearray[0] = (QRANGE * 64) + QOFF;
+	status=I2CWriteByte(pTuner, 200,82,writearray[0]);
+	// Populate DC offset LUT
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS; 
+}
+/****************************************************************************\  
+*  Function: GainControlinit
+*
+*  Detailed Description:
+*  Configures gain control mode. (Registers 0x1a)
+*
+\****************************************************************************/
+int GainControlauto(TUNER_MODULE *pTuner)
+{
+	unsigned char writearray[5];
+	int status;
+
+	writearray[0] = 23;
+	status=I2CWriteByte(pTuner, 200,26,writearray[0]);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS; 
+}
+/****************************************************************************\  
+*  Main program
+*   
+*  
+*  
+\****************************************************************************/
+/*
+int main()
+{
+     Gainmanual();
+     PLL(Ref_clk, Freq);
+     LNAfilter(Freq);
+     IFfilter(bandwidth, Ref_clk);
+     freqband(Freq);
+     DCoffLUT();
+     GainControlauto();
+  return(0);
+}
+*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Elonics source code - RT2832_SW_optimisation_rev2.c
+
+
+
+/****************************************************************************\  
+*  Function: E4000_sensitivity
+*
+*  Detailed Description:
+*  The function configures the E4000 for sensitivity mode.
+*
+\****************************************************************************/
+
+int E4000_sensitivity(TUNER_MODULE *pTuner, int Freq, int bandwidth)
+{
+	unsigned char writearray[2];
+	int status;
+	int IF_BW;
+
+	if(Freq<=700000)
+	{
+		writearray[0] = 0x07;
+	}
+	else
+	{
+		writearray[0] = 0x05;
+	}
+	status = I2CWriteArray(pTuner,200,36,1,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IF_BW = bandwidth / 2;
+	if(IF_BW<=2500)
+	{
+		writearray[0]=0xfc;
+		writearray[1]=0x17;
+	}
+    else if(IF_BW<=3000)
+	{
+		writearray[0]=0xfb;
+		writearray[1]=0x0f;
+	}
+	else if(IF_BW<=3500)
+	{
+		writearray[0]=0xf9;                  
+		writearray[1]=0x0b;
+	}
+	else if(IF_BW<=4000)
+	{
+		writearray[0]=0xf8;                  
+		writearray[1]=0x07;
+	}
+	status = I2CWriteArray(pTuner,200,17,2,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: E4000_linearity
+*
+*  Detailed Description:
+*  The function configures the E4000 for linearity mode.
+*
+\****************************************************************************/
+int E4000_linearity(TUNER_MODULE *pTuner, int Freq, int bandwidth)
+{
+	
+	unsigned char writearray[2];
+	int status;
+	int IF_BW;
+
+	if(Freq<=700000)
+	{
+		writearray[0] = 0x03;
+	}
+	else
+	{
+		writearray[0] = 0x01;
+	}
+	status = I2CWriteArray(pTuner,200,36,1,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IF_BW = bandwidth / 2;
+	if(IF_BW<=2500)
+	{
+		writearray[0]=0xfe;                 
+		writearray[1]=0x19;
+	}
+	else if(IF_BW<=3000)
+	{
+		writearray[0]=0xfd;                 
+		writearray[1]=0x11;
+	}
+	else if(IF_BW<=3500)
+	{
+		writearray[0]=0xfb;
+		writearray[1]=0x0d;
+	}
+	else if(IF_BW<=4000)
+	{
+		writearray[0]=0xfa;
+		writearray[1]=0x0a;
+	}
+	status = I2CWriteArray(pTuner,200,17,2,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;
+}
+/****************************************************************************\  
+*  Function: E4000_nominal
+*
+*  Detailed Description:
+*  The function configures the E4000 for nominal
+*
+\****************************************************************************/
+int E4000_nominal(TUNER_MODULE *pTuner, int Freq, int bandwidth)
+{
+	unsigned char writearray[2];
+	int status;
+	int IF_BW;
+
+	if(Freq<=700000)
+	{
+		writearray[0] = 0x03;
+	}
+	else
+	{
+		writearray[0] = 0x01;
+	}
+	status = I2CWriteArray(pTuner,200,36,1,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	IF_BW = bandwidth / 2;
+	if(IF_BW<=2500)
+	{
+		writearray[0]=0xfc;                 
+		writearray[1]=0x17;
+	}
+	else if(IF_BW<=3000)
+	{
+		writearray[0]=0xfb;                 
+		writearray[1]=0x0f;
+	}
+	else if(IF_BW<=3500)
+	{
+		writearray[0]=0xf9;
+		writearray[1]=0x0b;
+	}
+	else if(IF_BW<=4000)
+	{
+		writearray[0]=0xf8;
+		writearray[1]=0x07;
+	}
+	status = I2CWriteArray(pTuner,200,17,2,writearray);
+	if(status != E4000_I2C_SUCCESS)
+	{
+		return E4000_1_FAIL;
+	}
+
+	return E4000_1_SUCCESS;
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_e4000.h b/drivers/media/usb/rtl2832u/tuner_e4000.h
new file mode 100644
index 00000000..3d6c29c9
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_e4000.h
@@ -0,0 +1,295 @@
+#ifndef __TUNER_E4000_H
+#define __TUNER_E4000_H
+
+/**
+
+@file
+
+@brief   E4000 tuner module declaration
+
+One can manipulate E4000 tuner through E4000 module.
+E4000 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_e4000.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	E4000_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build E4000 tuner module.
+	BuildE4000Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xac,								// I2C device address is 0xac in 8-bit format.
+		CRYSTAL_FREQ_16384000HZ,			// Crystal frequency is 16.384 MHz.
+		E4000_AGC_INTERNAL					// The E4000 AGC mode is internal AGC mode.
+		);
+
+
+
+
+
+	// Get E4000 tuner extra module.
+	pTunerExtra = (T2266_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set E4000 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, E4000_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get E4000 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is implemented for E4000 source code.
+
+
+// Definition (implemeted for E4000)
+#define E4000_1_SUCCESS			1
+#define E4000_1_FAIL			0
+#define E4000_I2C_SUCCESS		1
+#define E4000_I2C_FAIL			0
+
+
+
+// Function (implemeted for E4000)
+int
+I2CReadByte(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte
+	);
+
+int
+I2CWriteByte(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegAddr,
+	unsigned char WritingByte
+	);
+
+int
+I2CWriteArray(
+	TUNER_MODULE *pTuner,
+	unsigned char NoUse,
+	unsigned char RegStartAddr,
+	unsigned char ByteNum,
+	unsigned char *pWritingBytes
+	);
+
+
+
+// Functions (from E4000 source code)
+int tunerreset (TUNER_MODULE *pTuner);
+int Tunerclock(TUNER_MODULE *pTuner);
+int Qpeak(TUNER_MODULE *pTuner);
+int DCoffloop(TUNER_MODULE *pTuner);
+int GainControlinit(TUNER_MODULE *pTuner);
+
+int Gainmanual(TUNER_MODULE *pTuner);
+int E4000_gain_freq(TUNER_MODULE *pTuner, int frequency);
+int PLL(TUNER_MODULE *pTuner, int Ref_clk, int Freq);
+int LNAfilter(TUNER_MODULE *pTuner, int Freq);
+int IFfilter(TUNER_MODULE *pTuner, int bandwidth, int Ref_clk);
+int freqband(TUNER_MODULE *pTuner, int Freq);
+int DCoffLUT(TUNER_MODULE *pTuner);
+int GainControlauto(TUNER_MODULE *pTuner);
+
+int E4000_sensitivity(TUNER_MODULE *pTuner, int Freq, int bandwidth);
+int E4000_linearity(TUNER_MODULE *pTuner, int Freq, int bandwidth);
+int E4000_high_linearity(TUNER_MODULE *pTuner);
+int E4000_nominal(TUNER_MODULE *pTuner, int Freq, int bandwidth);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is E4000 tuner API source code
+
+
+
+
+
+// Definitions
+
+// Bandwidth in Hz
+enum E4000_BANDWIDTH_HZ
+{
+	E4000_BANDWIDTH_6000000HZ = 6000000,
+	E4000_BANDWIDTH_7000000HZ = 7000000,
+	E4000_BANDWIDTH_8000000HZ = 8000000,
+};
+
+
+
+
+
+// Builder
+void
+BuildE4000Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+e4000_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+e4000_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+e4000_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+e4000_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+e4000_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+e4000_GetRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char *pReadingByte
+	);
+
+int
+e4000_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+int
+e4000_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_fc0012.c b/drivers/media/usb/rtl2832u/tuner_fc0012.c
new file mode 100644
index 00000000..9c81e20f
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc0012.c
@@ -0,0 +1,1056 @@
+/**
+
+@file
+
+@brief   FC0012 tuner module definition
+
+One can manipulate FC0012 tuner through FC0012 module.
+FC0012 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_fc0012.h"
+
+
+
+
+
+/**
+
+@brief   FC0012 tuner module builder
+
+Use BuildFc0012Module() to build FC0012 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to FC0012 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   FC0012 I2C device address
+@param [in]   CrystalFreqHz                FC0012 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildFc0012Module() to build FC0012 module before using it.
+
+*/
+void
+BuildFc0012Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	FC0012_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_FC0012;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = fc0012_GetTunerType;
+	pTuner->GetDeviceAddr = fc0012_GetDeviceAddr;
+
+	pTuner->Initialize    = fc0012_Initialize;
+	pTuner->SetRfFreqHz   = fc0012_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = fc0012_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz      = CrystalFreqHz;
+	pExtra->IsBandwidthModeSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode = fc0012_SetBandwidthMode;
+	pExtra->GetBandwidthMode = fc0012_GetBandwidthMode;
+
+
+	// Set tuner RF frequency and tuner bandwidth mode.
+	// Note: Need to give default tuner RF frequency and tuner bandwidth mode,
+	//       because FC0012 API use one funnction to set RF frequency and bandwidth mode.
+	pTuner->RfFreqHz      = FC0012_RF_FREQ_HZ_DEFAULT;
+	pExtra->BandwidthMode = FC0012_BANDWIDTH_MODE_DEFAULT;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+fc0012_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+fc0012_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+fc0012_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	FC0012_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Initialize tuner.
+	if(FC0012_Open(pTuner) != FC0012_FUNCTION_SUCCESS)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+fc0012_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	FC0012_EXTRA_MODULE *pExtra;
+	unsigned long RfFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Set tuner RF frequency in KHz.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	RfFreqKhz = (RfFreqHz + 500) / 1000;
+
+	if(FC0011_SetFrequency(pTuner, RfFreqKhz, (unsigned short)(pExtra->BandwidthMode)) != FC0012_FUNCTION_SUCCESS)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+fc0012_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set FC0012 tuner bandwidth mode.
+
+*/
+int
+fc0012_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	FC0012_EXTRA_MODULE *pExtra;
+	unsigned long RfFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Set tuner bandwidth mode.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	RfFreqKhz = (pTuner->RfFreqHz + 500) / 1000;
+
+	if(FC0011_SetFrequency(pTuner, RfFreqKhz, (unsigned short)BandwidthMode) != FC0012_FUNCTION_SUCCESS)
+		goto error_status_set_tuner_bandwidth_mode;
+
+
+	// Set tuner bandwidth mode parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get FC0012 tuner bandwidth mode.
+
+*/
+int
+fc0012_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	FC0012_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Get tuner bandwidth mode from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth_mode;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is implemented for FC0012 source code.
+
+
+// Read FC0012 register.
+int FC0012_Read(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char *pByte)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + stop_bit
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register byte.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + read_data + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, pByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	return FC0012_I2C_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return FC0012_I2C_ERROR;
+}
+
+
+
+
+
+// Write FC0012 register.
+int FC0012_Write(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char Byte)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + data + stop_bit
+	WritingBuffer[0] = RegAddr;
+	WritingBuffer[1] = Byte;
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return FC0012_I2C_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return FC0012_I2C_ERROR;
+}
+
+
+
+
+
+// Set FC0012 register mask bits.
+int
+fc0012_SetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned char WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingByte;
+	unsigned char WritingByte;
+
+	unsigned char Mask;
+	unsigned char Shift;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get tuner register byte according to register adddress.
+	if(FC0012_Read(pTuner, RegAddr, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	// Reserve byte unmask bit with mask and inlay writing value into it.
+	WritingByte = ReadingByte & (~Mask);
+	WritingByte |= (WritingValue << Shift) & Mask;
+
+
+	// Write tuner register byte with writing byte.
+	if(FC0012_Write(pTuner, RegAddr, WritingByte) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Get FC0012 register mask bits.
+int
+fc0012_GetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned char *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingByte;
+
+	unsigned char Mask;
+	unsigned char Shift;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get tuner register byte according to register adddress.
+	if(FC0012_Read(pTuner, RegAddr, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	// Get register bits from reading byte with mask and shift
+	*pReadingValue = (ReadingByte & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by fitipower.
+
+
+
+
+
+// fitipower source code - FC0012_Tuner_Code.cpp
+
+
+//===========================================================
+//	Fitipower Integrated Technology Inc.
+//
+//	FC0012 Tuner Code
+//
+//	Version 1.2e
+//
+//	Date: 2009/09/15
+//
+//	Copyright 2008, All rights reversed.
+//
+//	Compile in Visual Studio 2005 C++ Win32 Console
+//
+//---------------------------------------------------------------------
+//	Modify History: 
+//		2009-05-11: Change to recieve 28.8 MHz clock
+//		2009-05-14: fix frequency lock problem on 111MHz~148MHz
+//		2009-05-15: remove the limitation of Xin range
+//		2009-07-30: Add VHF filter control
+//					Add VHF frequency offset
+//					Add reference RSSI function
+//					Change register[0x07] to 0x20
+//		2009-09-15: update VCO re-calibration function
+//---------------------------------------------------------------------
+//=====================================================================
+
+// Data Format:
+// BYTE: unsigned char, 1 byte, 8 bits
+// WORD: unsighed short, 2 bytes, 16 bits
+// DWORD: unsigned int, 4 bytes, 32 bits
+
+// include header, just for testing.
+//#include "stdafx.h"
+//#include "stdlib.h"
+//#include <complex>
+
+//void FC0012_Write(unsigned char address, unsigned char data);
+//unsigned char FC0012_Read(unsigned char address);
+//void FC0012_Open();
+//void FC0012_Close();
+//void FC0012_SetFrequency(unsigned int Frequency, unsigned short Bandwidth);
+
+/*
+// Console main function, just for testing
+int main(int argc, const char* argv[])
+{
+	printf("\n");
+
+	if ( argc > 1 )
+	{
+		for( int i = 1; i < argc; i++ )
+		{
+			FC0012_SetFrequency( atoi(argv[i]), 6);
+		}	
+	}
+
+	return 0;
+}
+
+// FC0012 I2C Write Function
+void FC0012_Write(unsigned char address, unsigned char data)
+{
+	// depend on driver function in demodulator vendor.
+}
+
+// FC0012 I2C Read Function
+unsigned char FC0012_Read(unsigned char address)
+{
+	// depend on driver function in demodulator vendor.
+	unsigned char value = 0;
+	// value = ........
+	return value;
+}
+*/
+
+// FC0012 Open Function, includes enable/reset pin control and registers initialization.
+int FC0012_Open(TUNER_MODULE *pTuner)
+{
+	FC0012_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+
+	// Enable FC0012 Power
+//	(...)
+	// FC0012 Enable = High
+//	(...)
+	// FC0012 Reset = High -> Low
+//	(...)
+
+    //================================ Initial FC0012 Tuner Register
+    if(FC0012_Write(pTuner, 0x01, 0x05) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x02, 0x10) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x03, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x04, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+	
+	
+	//===================================== Arios Modify - 2009-10-23
+	// modify for Realtek CNR test
+    if(FC0012_Write(pTuner, 0x05, 0x0F) != FC0012_I2C_SUCCESS) goto error_status;
+	//===================================== Arios Modify - 2009-10-23
+
+	
+    if(FC0012_Write(pTuner, 0x06, 0x00) != FC0012_I2C_SUCCESS) goto error_status;      // divider 2, VCO slow.
+
+	switch(pExtra->CrystalFreqHz)      // Gain Shift: 15	// Set bit 5 to 1 for 28.8 MHz clock input (2009/05/12)
+	{
+		default:
+		case CRYSTAL_FREQ_28800000HZ:
+
+			if(FC0012_Write(pTuner, 0x07, 0x20) != FC0012_I2C_SUCCESS) goto error_status;
+
+			break;
+
+
+		case CRYSTAL_FREQ_27000000HZ:
+
+			if(FC0012_Write(pTuner, 0x07, 0x20) != FC0012_I2C_SUCCESS) goto error_status;
+
+			break;
+
+
+		case CRYSTAL_FREQ_36000000HZ:
+
+			if(FC0012_Write(pTuner, 0x07, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+
+			break;
+	}
+
+	if(FC0012_Write(pTuner, 0x08, 0xFF) != FC0012_I2C_SUCCESS) goto error_status;      // AGC Clock divide by 256, AGC gain 1/256, Loop Bw 1/8
+    if(FC0012_Write(pTuner, 0x09, 0x6E) != FC0012_I2C_SUCCESS) goto error_status;      // Disable LoopThrough
+    if(FC0012_Write(pTuner, 0x0A, 0xB8) != FC0012_I2C_SUCCESS) goto error_status;      // Disable LO Test Buffer
+    if(FC0012_Write(pTuner, 0x0B, 0x82) != FC0012_I2C_SUCCESS) goto error_status;      // Output Clock is same as clock frequency
+
+	//--------------------------------------------------------------------------
+	// reg[12] need to be changed if the system is in AGC Up-Down mode
+	//--------------------------------------------------------------------------
+//	if(FC0012_Write(pTuner, 0x0C, 0xF8) != FC0012_I2C_SUCCESS) goto error_status;      
+
+	// Modified for up-dowm AGC by Realtek.
+	if(FC0012_Write(pTuner, 0x0C, 0xFC) != FC0012_I2C_SUCCESS) goto error_status;      
+
+	// 0x0D, val=0x2 for DVBT
+	if(FC0012_Write(pTuner, 0x0D, 0x02) != FC0012_I2C_SUCCESS) goto error_status;      // AGC Not Forcing & LNA Forcing 
+	
+	// Modified for 2836B DTMB by Realtek.
+//	if(FC0012_Write(pTuner, 0x0D, 0x06) != FC0012_I2C_SUCCESS) goto error_status;      // AGC Not Forcing & LNA Forcing 
+    
+	if(FC0012_Write(pTuner, 0x0E, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x0F, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x10, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+	if(FC0012_Write(pTuner, 0x11, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+	if(FC0012_Write(pTuner, 0x12, 0x1F) != FC0012_I2C_SUCCESS) goto error_status;	   // Set to maximum gain
+
+	
+	//===================================== Arios Modify - 2009-10-23
+	// modify for Realtek CNR test
+//    if(FC0012_Write(pTuner, 0x13, 0x10) != FC0012_I2C_SUCCESS) goto error_status;	   // Enable IX2, Set to High Gain
+    if(FC0012_Write(pTuner, 0x13, 0x08) != FC0012_I2C_SUCCESS) goto error_status;	   // Enable IX2, Set to Middle Gain
+//    if(FC0012_Write(pTuner, 0x13, 0x00) != FC0012_I2C_SUCCESS) goto error_status;	   // Enable IX2, Set to Low Gain
+	//===================================== Arios Modify - 2009-10-23
+
+    if(FC0012_Write(pTuner, 0x14, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x15, 0x04) != FC0012_I2C_SUCCESS) goto error_status;	   // Enable LNA COMPS
+
+	return FC0012_FUNCTION_SUCCESS;
+
+error_status:
+	return FC0012_FUNCTION_ERROR;
+}
+
+
+/*
+// FC0012 Close Function, control enable/reset and power.
+void FC0012_Close()
+{
+	// FC0012 Enable = Low
+	// (...)
+	// FC0012 Reset = Low -> High
+	// (...)
+	// Disable FC0012 Power
+	// (...)
+}
+
+void Delay(unsigned int)
+{
+	// delay function
+}
+
+
+//===================================== RSSI & LNA Control			2009/07/30
+// better ACI Performance for D-Book & field-test
+void FC0012_RSSI()
+{
+	unsigned char Input_Power;
+
+	Delay(200);								// Delay 200 ms
+
+
+	switch( FC0012_Read(0x13) )					// Read FC0012 LNA gain setting
+	{
+		case 0x10:								// High gain 19.7 dB
+			if( Input_Power > -40 )				// if intput power level is bigger than -40 dBm
+				FC0012_Write(0x13, 0x17);		// Switch to 17.9 dB
+			break;
+
+		case 0x17:								// High gain 17.9 dB
+			if( Input_Power > -15 )				// if intput power level is bigger than -15 dBm
+				FC0012_Write(0x13, 0x08);		// Switch to 7.1 dB		
+			else if( Input_Power < -45 )		// if intput power level is smaller than -45 dBm
+				FC0012_Write(0x13, 0x10);		// Switch to 19.7 dB
+			break;
+
+		case 0x08:								// Middle gain 7.1 dB
+			if( Input_Power > -5 )				// if intput power level is bigger than -5 dBm
+				FC0012_Write(0x13, 0x02);		// Switch to -9.9 dB
+			else if( Input_Power < -20 )		// if intput power level is smaller than -20 dBm
+				FC0012_Write(0x13, 0x17);		// Switch to 17.9 dB
+			break;
+
+		case 0x02:								// Low gain -9.9 dB
+			if( Input_Power < -12 )				// if intput power level is smaller than -12 dBm
+				FC0012_Write(0x13, 0x08);		// Switch to 7.1 dB
+			break;
+	}
+
+}
+
+
+
+
+//===================================== Frequency Control  2009/07/30
+// Frequency unit: KHz, bandwidth unit: MHz
+void FC0012_Frequency_Control(unsigned int Frequency, unsigned short Bandwidth)
+{
+	if( Frequency < 260000 && Frequency > 150000 )
+	{
+		// set GPIO6 = low
+
+		//	1. Set tuner frequency
+		//	2. if the program quality is not good enough, switch to frequency + 500kHz
+		//	3. if the program quality is still no good, switch to frequency - 500kHz
+	}
+	else
+	{
+		// set GPIO6 = high
+
+		// set tuner frequency
+	}
+}
+*/
+
+
+
+// FC0012 frequency/bandwidth setting function.
+// Frequency unit: KHz, bandwidth unit: MHz
+int FC0011_SetFrequency(TUNER_MODULE *pTuner, unsigned long Frequency, unsigned short Bandwidth)
+{
+//    bool VCO1 = false;
+//    unsigned int doubleVCO;
+//    unsigned short xin, xdiv;
+//	unsigned char reg[21], am, pm, multi;
+    int VCO1 = FC0012_FALSE;
+    unsigned long doubleVCO;
+    unsigned short xin, xdiv;
+	unsigned char reg[21], am, pm, multi;
+	unsigned char read_byte;
+
+	FC0012_EXTRA_MODULE *pExtra;
+	unsigned long CrystalFreqKhz;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0012);
+
+	// Get tuner crystal frequency in KHz.
+	// Note: CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	CrystalFreqKhz = (pExtra->CrystalFreqHz + 500) / 1000;
+
+
+	//===================================== Select frequency divider and the frequency of VCO
+	if (Frequency * 96 < 3560000)
+    {
+        multi = 96;
+        reg[5] = 0x82;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 64 < 3560000)
+    {
+        multi = 64;
+        reg[5] = 0x82;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 48 < 3560000)
+    {
+        multi = 48;
+        reg[5] = 0x42;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 32 < 3560000)
+    {
+        multi = 32;
+        reg[5] = 0x42;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 24 < 3560000)
+    {
+        multi = 24;
+        reg[5] = 0x22;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 16 < 3560000)
+    {
+        multi = 16;
+        reg[5] = 0x22;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 12 < 3560000)
+    {
+        multi = 12;
+        reg[5] = 0x12;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 8 < 3560000)
+    {
+        multi = 8;
+        reg[5] = 0x12;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 6 < 3560000)
+    {
+        multi = 6;
+        reg[5] = 0x0A;
+        reg[6] = 0x00;
+    }
+    else
+    {
+        multi = 4;
+        reg[5] = 0x0A;
+        reg[6] = 0x02;
+    }
+
+    doubleVCO = Frequency * multi;
+
+
+
+	//===================================== Arios Modify - 2009-10-23
+	// modify for Realtek CNR test
+    reg[6] = reg[6] | 0x08;
+//	VCO1 = true;
+	VCO1 = FC0012_TRUE;
+	/*
+    if (doubleVCO >= 3060000)
+    {
+        reg[6] = reg[6] | 0x08;
+//        VCO1 = true;
+        VCO1 = FC0012_TRUE;
+    }
+	*/
+	//===================================== Arios Modify - 2009-10-23
+
+	//===================================== From divided value (XDIV) determined the FA and FP value 
+//	xdiv = (unsigned short)(doubleVCO / 14400);		// implement round function, 2009-05-01 by Arios
+//	if( (doubleVCO - xdiv * 14400) >= 7200 )
+	xdiv = (unsigned short)(doubleVCO / (CrystalFreqKhz / 2));		// implement round function, 2009-05-01 by Arios
+	if( (doubleVCO - xdiv * (CrystalFreqKhz / 2)) >= (CrystalFreqKhz / 4) )
+		xdiv = xdiv + 1;
+
+	pm = (unsigned char)( xdiv / 8 );			
+    am = (unsigned char)( xdiv - (8 * pm));		
+
+    if (am < 2)
+    {
+        reg[1] = am + 8;
+        reg[2] = pm - 1;
+    }
+    else
+    {
+        reg[1] = am;
+        reg[2] = pm;
+    }
+
+	//===================================== From VCO frequency determines the XIN ( fractional part of Delta Sigma PLL) and divided value (XDIV).
+//	xin = (unsigned short)(doubleVCO - ((unsigned short)(doubleVCO / 14400)) * 14400);						
+//	xin = ((xin << 15)/14400);															
+	xin = (unsigned short)(doubleVCO - ((unsigned short)(doubleVCO / (CrystalFreqKhz / 2))) * (CrystalFreqKhz / 2));						
+	xin = ((xin << 15)/(unsigned short)(CrystalFreqKhz / 2));															
+
+//	if( xin >= (unsigned short) pow( (double)2, (double)14) )
+//		xin = xin + (unsigned short) pow( (double)2, (double)15);
+	if( xin >= (unsigned short) 16384 )
+		xin = xin + (unsigned short) 32768;
+
+	reg[3] = (unsigned char)(xin >> 8);			
+	reg[4] = (unsigned char)(xin & 0x00FF);		
+
+	
+	//===================================== Only for testing, 2009-05-01 by Arios
+//	printf("Frequency: %d, Fa: %d, Fp: %d, Xin:%d \n", Frequency, am, pm, xin);
+
+	//===================================== Set Bandwidth
+    switch(Bandwidth)
+    {
+        case 6: 
+			reg[6] = 0x80 | reg[6];
+            break;
+        case 7: 
+			reg[6] = ~0x80 & reg[6];
+            reg[6] = 0x40 | reg[6];
+            break;
+        case 8:
+        default: 
+			reg[6] = ~0xC0 & reg[6];
+            break;
+    }
+
+	//===================================== Write registers 
+    if(FC0012_Write(pTuner, 0x01, reg[1]) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x02, reg[2]) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x03, reg[3]) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x04, reg[4]) != FC0012_I2C_SUCCESS) goto error_status;
+
+	//===================================== Arios Modify - 2009-10-23
+	// modify for Realtek CNR Test
+	reg[5] = reg[5] | 0x07;
+    if(FC0012_Write(pTuner, 0x05, reg[5]) != FC0012_I2C_SUCCESS) goto error_status;
+	//===================================== Arios Modify - 2009-10-23
+    
+    if(FC0012_Write(pTuner, 0x06, reg[6]) != FC0012_I2C_SUCCESS) goto error_status;
+
+	//===================================== VCO Calibration
+    if(FC0012_Write(pTuner, 0x0E, 0x80) != FC0012_I2C_SUCCESS) goto error_status;
+    if(FC0012_Write(pTuner, 0x0E, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+
+	//===================================== VCO Re-Calibration if needed
+	if(FC0012_Write(pTuner, 0x0E, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+//    reg[14] = 0x3F & FC0012_Read(0x0E);
+	if(FC0012_Read(pTuner, 0x0E, &read_byte) != FC0012_I2C_SUCCESS) goto error_status;
+    reg[14] = 0x3F & read_byte;
+
+	if (VCO1)
+    {
+        if (reg[14] > 0x3C)				// modify 2009-09-15
+        {
+            reg[6] = ~0x08 & reg[6];
+
+            if(FC0012_Write(pTuner, 0x06, reg[6]) != FC0012_I2C_SUCCESS) goto error_status;
+
+            if(FC0012_Write(pTuner, 0x0E, 0x80) != FC0012_I2C_SUCCESS) goto error_status;
+            if(FC0012_Write(pTuner, 0x0E, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+        }
+    }
+    else
+    {
+        if (reg[14] < 0x02)				// modify 2009-09-15
+        {
+            reg[6] = 0x08 | reg[6];
+
+            if(FC0012_Write(pTuner, 0x06, reg[6]) != FC0012_I2C_SUCCESS) goto error_status;
+
+            if(FC0012_Write(pTuner, 0x0E, 0x80) != FC0012_I2C_SUCCESS) goto error_status;
+            if(FC0012_Write(pTuner, 0x0E, 0x00) != FC0012_I2C_SUCCESS) goto error_status;
+        }
+    }
+
+	return FC0012_FUNCTION_SUCCESS;
+
+error_status:
+	return FC0012_FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_fc0012.h b/drivers/media/usb/rtl2832u/tuner_fc0012.h
new file mode 100644
index 00000000..82e6bb2d
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc0012.h
@@ -0,0 +1,292 @@
+#ifndef __TUNER_FC0012_H
+#define __TUNER_FC0012_H
+
+/**
+
+@file
+
+@brief   FC0012 tuner module declaration
+
+One can manipulate FC0012 tuner through FC0012 module.
+FC0012 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_fc0012.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	FC0012_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build FC0012 tuner module.
+	BuildFc0012Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc6,								// I2C device address is 0xc6 in 8-bit format.
+		CRYSTAL_FREQ_36000000HZ				// Crystal frequency is 36.0 MHz.
+		);
+
+
+
+
+
+	// Get FC0012 tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0012);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set FC0012 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, FC0012_BANDWIDTH_6000000HZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get FC0012 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is implemented for FC0012 source code.
+
+
+// Definitions
+enum FC0012_TRUE_FALSE_STATUS
+{
+	FC0012_FALSE,
+	FC0012_TRUE,
+};
+
+
+enum FC0012_I2C_STATUS
+{
+	FC0012_I2C_SUCCESS,
+	FC0012_I2C_ERROR,
+};
+
+
+enum FC0012_FUNCTION_STATUS
+{
+	FC0012_FUNCTION_SUCCESS,
+	FC0012_FUNCTION_ERROR,
+};
+
+
+
+// Functions
+int FC0012_Read(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char *pByte);
+int FC0012_Write(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char Byte);
+
+int
+fc0012_SetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned char WritingValue
+	);
+
+int
+fc0012_GetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned char *pReadingValue
+	);
+
+int FC0012_Open(TUNER_MODULE *pTuner);
+int FC0011_SetFrequency(TUNER_MODULE *pTuner, unsigned long Frequency, unsigned short Bandwidth);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is FC0012 tuner API source code
+
+
+
+
+
+// Definitions
+
+// Bandwidth mode
+enum FC0012_BANDWIDTH_MODE
+{
+	FC0012_BANDWIDTH_6000000HZ = 6,
+	FC0012_BANDWIDTH_7000000HZ = 7,
+	FC0012_BANDWIDTH_8000000HZ = 8,
+};
+
+
+// Default for initialing
+#define FC0012_RF_FREQ_HZ_DEFAULT			50000000
+#define FC0012_BANDWIDTH_MODE_DEFAULT		FC0012_BANDWIDTH_6000000HZ
+
+
+// Tuner LNA
+enum FC0012_LNA_GAIN_VALUE
+{
+	FC0012_LNA_GAIN_LOW    = 0x0,
+	FC0012_LNA_GAIN_MIDDLE = 0x1,
+	FC0012_LNA_GAIN_HIGH   = 0x2,
+};
+
+
+
+
+
+// Builder
+void
+BuildFc0012Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+fc0012_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+fc0012_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+fc0012_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+fc0012_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+fc0012_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+fc0012_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+fc0012_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_fc0013.c b/drivers/media/usb/rtl2832u/tuner_fc0013.c
new file mode 100644
index 00000000..63a68502
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc0013.c
@@ -0,0 +1,1261 @@
+/**
+
+@file
+
+@brief   FC0013 tuner module definition
+
+One can manipulate FC0013 tuner through FC0013 module.
+FC0013 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_fc0013.h"
+
+
+
+
+
+/**
+
+@brief   FC0013 tuner module builder
+
+Use BuildFc0013Module() to build FC0013 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to FC0013 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   FC0013 I2C device address
+@param [in]   CrystalFreqHz                FC0013 crystal frequency in Hz
+
+
+@note
+	-# One should call BuildFc0013Module() to build FC0013 module before using it.
+
+*/
+void
+BuildFc0013Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	)
+{
+	TUNER_MODULE *pTuner;
+	FC0013_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_FC0013;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = fc0013_GetTunerType;
+	pTuner->GetDeviceAddr = fc0013_GetDeviceAddr;
+
+	pTuner->Initialize    = fc0013_Initialize;
+	pTuner->SetRfFreqHz   = fc0013_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = fc0013_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz      = CrystalFreqHz;
+	pExtra->IsBandwidthModeSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode = fc0013_SetBandwidthMode;
+	pExtra->GetBandwidthMode = fc0013_GetBandwidthMode;
+	pExtra->RcCalReset       = fc0013_RcCalReset;
+	pExtra->RcCalAdd         = fc0013_RcCalAdd;
+
+
+	// Set tuner RF frequency and tuner bandwidth mode.
+	// Note: Need to give default tuner RF frequency and tuner bandwidth mode,
+	//       because FC0013 API use one funnction to set RF frequency and bandwidth mode.
+	pTuner->RfFreqHz      = FC0013_RF_FREQ_HZ_DEFAULT;
+	pExtra->BandwidthMode = FC0013_BANDWIDTH_MODE_DEFAULT;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+fc0013_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+fc0013_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+fc0013_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	FC0013_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Initialize tuner.
+	if(FC0013_Open(pTuner) != FC0013_FUNCTION_SUCCESS)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+fc0013_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	FC0013_EXTRA_MODULE *pExtra;
+	unsigned long RfFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Set tuner RF frequency in KHz.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	RfFreqKhz = (RfFreqHz + 500) / 1000;
+
+	if(FC0013_SetFrequency(pTuner, RfFreqKhz, (unsigned short)(pExtra->BandwidthMode)) != FC0013_FUNCTION_SUCCESS)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+fc0013_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set FC0013 tuner bandwidth mode.
+
+*/
+int
+fc0013_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	FC0013_EXTRA_MODULE *pExtra;
+	unsigned long RfFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Set tuner bandwidth mode.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	RfFreqKhz = (pTuner->RfFreqHz + 500) / 1000;
+
+	if(FC0013_SetFrequency(pTuner, RfFreqKhz, (unsigned short)BandwidthMode) != FC0013_FUNCTION_SUCCESS)
+		goto error_status_set_tuner_bandwidth_mode;
+
+
+	// Set tuner bandwidth mode parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get FC0013 tuner bandwidth mode.
+
+*/
+int
+fc0013_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	FC0013_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Get tuner bandwidth mode from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth_mode;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is implemented for FC0013 source code.
+
+
+// Read FC0013 register.
+int FC0013_Read(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char *pByte)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + stop_bit
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register byte.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + read_data + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, pByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	return FC0013_I2C_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return FC0013_I2C_ERROR;
+}
+
+
+
+
+
+// Write FC0013 register.
+int FC0013_Write(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char Byte)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + data + stop_bit
+	WritingBuffer[0] = RegAddr;
+	WritingBuffer[1] = Byte;
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return FC0013_I2C_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return FC0013_I2C_ERROR;
+}
+
+
+
+
+
+// Set FC0013 register mask bits.
+int
+fc0013_SetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned char WritingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingByte;
+	unsigned char WritingByte;
+
+	unsigned char Mask;
+	unsigned char Shift;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get tuner register byte according to register adddress.
+	if(FC0013_Read(pTuner, RegAddr, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	// Reserve byte unmask bit with mask and inlay writing value into it.
+	WritingByte = ReadingByte & (~Mask);
+	WritingByte |= (WritingValue << Shift) & Mask;
+
+
+	// Write tuner register byte with writing byte.
+	if(FC0013_Write(pTuner, RegAddr, WritingByte) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// Get FC0013 register mask bits.
+int
+fc0013_GetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned char *pReadingValue
+	)
+{
+	int i;
+
+	unsigned char ReadingByte;
+
+	unsigned char Mask;
+	unsigned char Shift;
+
+
+	// Generate mask and shift according to MSB and LSB.
+	Mask = 0;
+
+	for(i = Lsb; i < (Msb + 1); i++)
+		Mask |= 0x1 << i;
+
+	Shift = Lsb;
+
+
+	// Get tuner register byte according to register adddress.
+	if(FC0013_Read(pTuner, RegAddr, &ReadingByte) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	// Get register bits from reading byte with mask and shift
+	*pReadingValue = (ReadingByte & Mask) >> Shift;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by fitipower.
+
+
+
+
+
+// fitipower source code - FC0013_Tuner_Code.cpp
+
+
+//=====================================================================
+//	Fitipower Integrated Technology Inc.
+//
+//	FC0013 Tuner Code
+//
+//	Version 0.7
+//
+//	Date: 2010/12/23
+//
+//	Copyright 2010, All rights reversed.
+//
+//	Compile in Visual Studio 2005 C++ Win32 Console
+//=====================================================================
+
+// Data Format:
+// BYTE: unsigned char, 1 byte, 8 bits
+// WORD: unsighed short, 2 bytes, 16 bits
+// DWORD: unsigned int, 4 bytes, 32 bits
+
+// include header, just for testing.
+//#include "stdafx.h"
+//#include "stdlib.h"
+//#include <complex>
+//#include <stdio.h>
+//#include <dos.h>
+//#include <conio.h>
+//#include "I2C.h"
+
+//#define Crystal_Frequency 28800			// FC0013 Crystal Clock (kHz)
+
+
+//void FC0013_Write(unsigned char address, unsigned char data);
+//unsigned char FC0013_Read(unsigned char address);
+//void FC0013_Open();
+//void FC0013_Close();
+//void FC0013_RSSI();
+//void FC0013_Band_Selection(bool Band_Selection_DVBT);
+//void FC0013_SetFrequency(unsigned int Frequency, unsigned short Bandwidth);
+
+//unsigned char FC0013_RSSI_Calibration_Value;
+/*
+// Console main function, just for testing
+int main(int argc, const char* argv[])
+{
+	printf("\n");
+
+	if ( argc > 1 )
+	{
+		for( int i = 1; i < argc; i++ )
+		{
+			FC0013_SetFrequency( atoi(argv[i]), 8 );
+		}	
+	}
+
+	return 0;
+}
+
+void Delay(unsigned int)
+{
+	// delay function
+}
+
+// FC0013 I2C Write Function
+void FC0013_Write(unsigned char address, unsigned char data)
+{
+	// depend on driver function in demodulator vendor.
+	I2C_Write(address, data);
+}
+
+// FC0013 I2C Read Function
+unsigned char FC0013_Read(unsigned char address)
+{
+	// depend on driver function in demodulator vendor.
+	return return I2C_Read(address);
+}
+*/
+// FC0013 Open Function, includes enable/reset pin control and registers initialization.
+//void FC0013_Open() 
+int FC0013_Open(TUNER_MODULE *pTuner)
+{
+	// Enable FC0013 Power
+	// (...)
+	// FC0013 Enable = High
+	// (...)
+	// FC0013 Reset = High -> Low
+	// (...)
+
+    //================================ update base on new FC0013 register bank
+	if(FC0013_Write(pTuner, 0x01, 0x09) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x02, 0x16) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x03, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x04, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x05, 0x17) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x06, 0x02) != FC0013_I2C_SUCCESS) goto error_status;
+//	if(FC0013_Write(pTuner, 0x07, 0x27) != FC0013_I2C_SUCCESS) goto error_status;		// 28.8MHz, GainShift: 15               
+	if(FC0013_Write(pTuner, 0x07, 0x2A) != FC0013_I2C_SUCCESS) goto error_status;		// 28.8MHz, modified by Realtek               
+	if(FC0013_Write(pTuner, 0x08, 0xFF) != FC0013_I2C_SUCCESS) goto error_status;      
+	if(FC0013_Write(pTuner, 0x09, 0x6F) != FC0013_I2C_SUCCESS) goto error_status;		// Enable Loop Through
+	if(FC0013_Write(pTuner, 0x0A, 0xB8) != FC0013_I2C_SUCCESS) goto error_status;      
+	if(FC0013_Write(pTuner, 0x0B, 0x82) != FC0013_I2C_SUCCESS) goto error_status;      
+
+	if(FC0013_Write(pTuner, 0x0C, 0xFE) != FC0013_I2C_SUCCESS) goto error_status;   // Modified for up-dowm AGC by Realtek(for master, and for 2836BU dongle).
+//	if(FC0013_Write(pTuner, 0x0C, 0xFC) != FC0013_I2C_SUCCESS) goto error_status;   // Modified for up-dowm AGC by Realtek(for slave, and for 2832 mini dongle).
+
+//	if(FC0013_Write(pTuner, 0x0D, 0x09) != FC0013_I2C_SUCCESS) goto error_status;      
+	if(FC0013_Write(pTuner, 0x0D, 0x01) != FC0013_I2C_SUCCESS) goto error_status;   // Modified for AGC non-forcing by Realtek.
+
+	if(FC0013_Write(pTuner, 0x0E, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x0F, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x10, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x11, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x12, 0x00) != FC0013_I2C_SUCCESS) goto error_status;      
+	if(FC0013_Write(pTuner, 0x13, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+
+	if(FC0013_Write(pTuner, 0x14, 0x50) != FC0013_I2C_SUCCESS) goto error_status;		// DVB-T, High Gain
+//	if(FC0013_Write(pTuner, 0x14, 0x48) != FC0013_I2C_SUCCESS) goto error_status;		// DVB-T, Middle Gain
+//	if(FC0013_Write(pTuner, 0x14, 0x40) != FC0013_I2C_SUCCESS) goto error_status;		// DVB-T, Low Gain
+
+	if(FC0013_Write(pTuner, 0x15, 0x01) != FC0013_I2C_SUCCESS) goto error_status;
+
+
+	return FC0013_FUNCTION_SUCCESS;
+
+error_status:
+	return FC0013_FUNCTION_ERROR;
+}
+
+/*
+// FC0013 Close Function, control enable/reset and power.
+void FC0013_Close()
+{
+	// FC0013 Enable = Low
+	// (...)
+	// FC0013 Reset = Low -> High
+	// (...)
+	// Disable FC0013 Power
+	// (...)
+}
+
+
+void FC0013_Band_Selection(bool Band_Selection_DVBT)
+{
+	if( Band_Selection_DVBT == true )
+	{
+	    FC0013_Write(0x14, (FC0013_Read(0x14) & 0x9F) | 0x40);
+	}
+	else
+	{
+		FC0013_Write(0x14, (FC0013_Read(0x14) & 0x9F) | 0x20);
+	}
+}
+
+
+// Get RSSI ADC value
+unsigned char Get_RSSI_Value()
+{
+	return 0x00;	// return RSSI value
+}
+
+
+// RSSI Calibration Function
+void FC0013_RSSI_Calibration()
+{
+	FC0013_Write(0x09, ( FC0013_Read(0x09) | 0x10 ) );		// set the register 9 bit4 EN_CAL_RSSI as 1
+	FC0013_Write(0x06, ( FC0013_Read(0x06) | 0x01 ) );		// set the register 6 bit 0 LNA_POWER_DOWN as 1
+
+	Delay(100);												// delay 100ms
+
+	FC0013_RSSI_Calibration_Value = Get_RSSI_Value();		// read DC value from RSSI pin as rssi_calibration
+
+	FC0013_Write(0x09, ( FC0013_Read(0x09) & 0xEF ) );		// set the register 9 bit4 EN_CAL_RSSI as 0
+	FC0013_Write(0x06, ( FC0013_Read(0x06) & 0xFE ) );		// set the register 6 bit 0 LNA_POWER_DOWN as 0
+}
+
+
+// RSSI & LNA Control, call this function if FC0013 is in the External RSSI ADC mode.
+void FC0013_RSSI()
+{
+	unsigned char Input_Power = 0;									// Get Input power information from RSSI
+																	// it should be the difference between RSSI ADC value and RSSI calibration value
+	unsigned char LNA_value;
+	unsigned char RSSI_Value, RSSI_Difference;
+
+	Delay(500);														// Delay 500 ms
+
+	RSSI_Value = Get_RSSI_Value();									// Get RSSI Value from demodulator ADC
+
+	if( RSSI_Value < FC0013_RSSI_Calibration_Value )				// adjust RSSI Calibration Value
+		FC0013_RSSI_Calibration_Value = RSSI_Value;
+
+	RSSI_Difference = RSSI_Value - FC0013_RSSI_Calibration_Value;	// Calculate voltage difference of RSSI
+
+	LNA_value = FC0013_Read(0x14);
+
+	//------------------------------------------------ arios modify 2010-12-24
+	// " | 0x07" ==> " | 0x27"   (make sure reg[0x07] bit5 = 1)
+	// " | 0x0F" ==> " | 0x2F"   (make sure reg[0x07] bit5 = 1)
+	// add default in switch case
+	switch( (LNA_value & 0x1F) )
+	{
+		case 0x10:
+			if( RSSI_Difference > 6 )									
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x17);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x27);
+			}
+			break;
+
+		case 0x17:													
+			if( RSSI_Difference > 40 )									
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x08);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x27);
+			}
+			else if( RSSI_Difference < 3 )							
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x10);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x2F);
+			}
+			break;
+
+		case 0x08:													
+			if( RSSI_Difference > 40 )									
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x02);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x27);
+			}
+			else if( RSSI_Difference < 7 )							
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x17);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x27);
+			}
+			break;
+
+		case 0x02:													
+			if( RSSI_Difference < 2 )									
+			{
+				FC0013_Write(0x14, (LNA_value & 0xE0) | 0x08);		
+				FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x27);
+			}
+			break;
+
+		default:
+			FC0013_Write(0x14, (LNA_value & 0xE0) | 0x10);		
+			FC0013_Write(0x07, (FC0013_Read(0x07) & 0xF0) | 0x2F);
+			break;
+	}
+}
+*/
+
+
+// Set VHF Track depends on input frequency
+// Frequency Unit: KHz
+int FC0013_SetVhfTrack(TUNER_MODULE *pTuner, unsigned long FrequencyKHz)
+{
+	unsigned char read_byte;
+
+    if (FrequencyKHz <= 177500)	// VHF Track: 7
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x1C) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 184500)	// VHF Track: 6
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x18) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 191500)	// VHF Track: 5
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x14) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 198500)	// VHF Track: 4
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x10) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 205500)	// VHF Track: 3
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x0C) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 212500)	// VHF Track: 2
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x08) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 219500)	// VHF Track: 2
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x08) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+    else if (FrequencyKHz <= 226500)	// VHF Track: 1
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x04) != FC0013_I2C_SUCCESS) goto error_status;
+    }
+    else	// VHF Track: 1
+    {
+		if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x04) != FC0013_I2C_SUCCESS) goto error_status;
+
+    }
+	
+	//------------------------------------------------ arios modify 2010-12-24
+	// " | 0x10" ==> " | 0x30"   (make sure reg[0x07] bit5 = 1)
+
+	// Enable VHF filter.
+	if(FC0013_Read(pTuner, 0x07, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x07, read_byte | 0x10) != FC0013_I2C_SUCCESS) goto error_status;
+
+	// Disable UHF & GPS.
+	if(FC0013_Read(pTuner, 0x14, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x14, read_byte & 0x1F) != FC0013_I2C_SUCCESS) goto error_status;
+
+
+	return FC0013_FUNCTION_SUCCESS;
+
+error_status:
+	return FC0013_FUNCTION_ERROR;
+}
+
+
+
+// FC0013 frequency/bandwidth setting function.
+// Frequency unit: KHz, bandwidth unit: MHz
+//void FC0013_SetFrequency(unsigned int Frequency, unsigned short Bandwidth)
+int FC0013_SetFrequency(TUNER_MODULE *pTuner, unsigned long Frequency, unsigned short Bandwidth)
+{
+//    bool VCO1 = false;
+//    unsigned int doubleVCO;
+//    unsigned short xin, xdiv;
+//	unsigned char reg[21], am, pm, multi;
+    int VCO1 = FC0013_FALSE;
+    unsigned long doubleVCO;
+    unsigned short xin, xdiv;
+	unsigned char reg[21], am, pm, multi;
+
+	unsigned char read_byte;
+
+	FC0013_EXTRA_MODULE *pExtra;
+	unsigned long CrystalFreqKhz;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+	// Get tuner crystal frequency in KHz.
+	// Note: CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	CrystalFreqKhz = (pExtra->CrystalFreqHz + 500) / 1000;
+
+	// modified 2011-02-09: for D-Book test
+	// set VHF_Track = 7
+	if(FC0013_Read(pTuner, 0x1D, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+	
+	// VHF Track: 7
+    if(FC0013_Write(pTuner, 0x1D, (read_byte & 0xE3) | 0x1C) != FC0013_I2C_SUCCESS) goto error_status;
+
+
+	if( Frequency < 300000 )   
+	{
+		// Set VHF Track.
+		if(FC0013_SetVhfTrack(pTuner, Frequency) != FC0013_I2C_SUCCESS) goto error_status;
+
+		// Enable VHF filter.
+		if(FC0013_Read(pTuner, 0x07, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x07, read_byte | 0x10) != FC0013_I2C_SUCCESS) goto error_status;
+		
+		// Disable UHF & disable GPS.
+		if(FC0013_Read(pTuner, 0x14, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x14, read_byte & 0x1F) != FC0013_I2C_SUCCESS) goto error_status;
+	}
+	else if ( (Frequency >= 300000) && (Frequency <= 862000) )
+	{
+		// Disable VHF filter.
+		if(FC0013_Read(pTuner, 0x07, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x07, read_byte & 0xEF) != FC0013_I2C_SUCCESS) goto error_status;
+		
+		// enable UHF & disable GPS.
+		if(FC0013_Read(pTuner, 0x14, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x14, (read_byte & 0x1F) | 0x40) != FC0013_I2C_SUCCESS) goto error_status;
+	}
+	else if (Frequency > 862000)
+	{
+		// Disable VHF filter
+		if(FC0013_Read(pTuner, 0x07, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x07, read_byte & 0xEF) != FC0013_I2C_SUCCESS) goto error_status;
+		
+		// Disable UHF & enable GPS
+		if(FC0013_Read(pTuner, 0x14, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x14, (read_byte & 0x1F) | 0x20) != FC0013_I2C_SUCCESS) goto error_status;	
+	}
+
+	if (Frequency * 96 < 3560000)
+    {
+        multi = 96;
+        reg[5] = 0x82;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 64 < 3560000)
+    {
+        multi = 64;
+        reg[5] = 0x02;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 48 < 3560000)
+    {
+        multi = 48;
+        reg[5] = 0x42;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 32 < 3560000)
+    {
+        multi = 32;
+        reg[5] = 0x82;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 24 < 3560000)
+    {
+        multi = 24;
+        reg[5] = 0x22;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 16 < 3560000)
+    {
+        multi = 16;
+        reg[5] = 0x42;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 12 < 3560000)
+    {
+        multi = 12;
+        reg[5] = 0x12;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 8 < 3560000)
+    {
+        multi = 8;
+        reg[5] = 0x22;
+        reg[6] = 0x02;
+    }
+    else if (Frequency * 6 < 3560000)
+    {
+        multi = 6;
+        reg[5] = 0x0A;
+        reg[6] = 0x00;
+    }
+    else if (Frequency * 4 < 3800000)
+    {
+        multi = 4;
+        reg[5] = 0x12;
+        reg[6] = 0x02;
+    }
+	else
+	{
+        Frequency = Frequency / 2;
+		multi = 4;
+        reg[5] = 0x0A;
+        reg[6] = 0x02;
+	}
+
+    doubleVCO = Frequency * multi;
+
+    reg[6] = reg[6] | 0x08;
+//	VCO1 = true;
+	VCO1 = FC0013_TRUE;
+
+	// Calculate VCO parameters: ap & pm & xin.
+//	xdiv = (unsigned short)(doubleVCO / (Crystal_Frequency/2));
+	xdiv = (unsigned short)(doubleVCO / (CrystalFreqKhz/2));
+//	if( (doubleVCO - xdiv * (Crystal_Frequency/2)) >= (Crystal_Frequency/4) )
+	if( (doubleVCO - xdiv * (CrystalFreqKhz/2)) >= (CrystalFreqKhz/4) )
+	{
+		xdiv = xdiv + 1;
+	}
+
+	pm = (unsigned char)( xdiv / 8 );			
+    am = (unsigned char)( xdiv - (8 * pm));		
+
+    if (am < 2)
+    {
+        reg[1] = am + 8;
+        reg[2] = pm - 1;
+    }
+    else
+    {
+        reg[1] = am;
+        reg[2] = pm;
+    }
+
+//	xin = (unsigned short)(doubleVCO - ((unsigned short)(doubleVCO / (Crystal_Frequency/2))) * (Crystal_Frequency/2));						
+	xin = (unsigned short)(doubleVCO - ((unsigned short)(doubleVCO / (CrystalFreqKhz/2))) * (CrystalFreqKhz/2));						
+//	xin = ((xin << 15)/(Crystal_Frequency/2));															
+	xin = (unsigned short)((xin << 15)/(CrystalFreqKhz/2));															
+
+//	if( xin >= (unsigned short) pow( (double)2, (double)14) )
+//	{
+//		xin = xin + (unsigned short) pow( (double)2, (double)15);
+//	}
+	if( xin >= (unsigned short) 16384 )
+		xin = xin + (unsigned short) 32768;
+
+	reg[3] = (unsigned char)(xin >> 8);			
+	reg[4] = (unsigned char)(xin & 0x00FF);
+	
+	
+	//===================================== Only for testing 
+//	printf("Frequency: %d, Fa: %d, Fp: %d, Xin:%d \n", Frequency, am, pm, xin);
+
+	
+	// Set Low-Pass Filter Bandwidth.
+    switch(Bandwidth)
+    {
+        case 6: 
+			reg[6] = 0x80 | reg[6];
+            break;
+        case 7: 
+			reg[6] = ~0x80 & reg[6];
+            reg[6] = 0x40 | reg[6];
+            break;
+        case 8:
+        default: 
+			reg[6] = ~0xC0 & reg[6];
+            break;
+    }
+
+	reg[5] = reg[5] | 0x07;
+
+	if(FC0013_Write(pTuner, 0x01, reg[1]) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x02, reg[2]) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x03, reg[3]) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x04, reg[4]) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x05, reg[5]) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x06, reg[6]) != FC0013_I2C_SUCCESS) goto error_status;
+
+	if (multi == 64)
+	{
+//		FC0013_Write(0x11, FC0013_Read(0x11) | 0x04);
+		if(FC0013_Read(pTuner, 0x11, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x11, read_byte | 0x04) != FC0013_I2C_SUCCESS) goto error_status;
+	}
+	else
+	{
+//		FC0013_Write(0x11, FC0013_Read(0x11) & 0xFB);
+		if(FC0013_Read(pTuner, 0x11, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+		if(FC0013_Write(pTuner, 0x11, read_byte & 0xFB) != FC0013_I2C_SUCCESS) goto error_status;
+	}
+
+	if(FC0013_Write(pTuner, 0x0E, 0x80) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x0E, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+
+	if(FC0013_Write(pTuner, 0x0E, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+//	reg[14] = 0x3F & FC0013_Read(0x0E);
+	if(FC0013_Read(pTuner, 0x0E, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+	reg[14] = 0x3F & read_byte;
+
+	if (VCO1)
+    {
+        if (reg[14] > 0x3C)				
+        {
+            reg[6] = ~0x08 & reg[6];
+
+			if(FC0013_Write(pTuner, 0x06, reg[6]) != FC0013_I2C_SUCCESS) goto error_status;
+
+			if(FC0013_Write(pTuner, 0x0E, 0x80) != FC0013_I2C_SUCCESS) goto error_status;
+			if(FC0013_Write(pTuner, 0x0E, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+        }
+    }
+	else
+    {
+        if (reg[14] < 0x02)				
+        {
+            reg[6] = 0x08 | reg[6];
+
+			if(FC0013_Write(pTuner, 0x06, reg[6]) != FC0013_I2C_SUCCESS) goto error_status;
+
+			if(FC0013_Write(pTuner, 0x0E, 0x80) != FC0013_I2C_SUCCESS) goto error_status;
+			if(FC0013_Write(pTuner, 0x0E, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+        }
+    }
+
+
+	return FC0013_FUNCTION_SUCCESS;
+
+error_status:
+	return FC0013_FUNCTION_ERROR;
+}
+
+
+
+
+
+// Reset IQ LPF Bandwidth
+int
+fc0013_RcCalReset(
+	TUNER_MODULE *pTuner
+	)
+{
+	// not forcing RC_cal and ADC_Ext enable
+	if(FC0013_Write(pTuner, 0x0D, 0x01) != FC0013_I2C_SUCCESS) goto error_status;
+	if(FC0013_Write(pTuner, 0x10, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+ 	
+
+	return FC0013_FUNCTION_SUCCESS;
+
+
+error_status:
+	return FC0013_FUNCTION_ERROR;
+}
+
+
+
+
+
+// Increase IQ LPF bandwidth
+int
+fc0013_RcCalAdd(
+	TUNER_MODULE *pTuner,
+	int RcValue
+	)
+{
+	unsigned char read_byte;
+	unsigned char rc_cal;
+	int WriteValue;
+	
+	FC0013_EXTRA_MODULE *pExtra;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc0013);
+
+
+	// Push RC_cal value Get RC_cal value
+	if(FC0013_Write(pTuner, 0x10, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+
+	//Get RC_cal value
+	if(FC0013_Read(pTuner, 0x10, &read_byte) != FC0013_I2C_SUCCESS) goto error_status;
+
+	rc_cal = read_byte & 0x0F;
+
+	WriteValue = (int)rc_cal + RcValue;
+
+
+	// Forcing RC_cal
+	if(FC0013_Write(pTuner, 0x0D, 0x11) != FC0013_I2C_SUCCESS) goto error_status;
+
+	// Modify RC_cal value
+    if( WriteValue > 15 )
+    {   
+        if(FC0013_Write(pTuner, 0x10, 0x0F) != FC0013_I2C_SUCCESS) goto error_status;
+    }
+    else if( WriteValue < 0 )
+    {
+        if(FC0013_Write(pTuner, 0x10, 0x00) != FC0013_I2C_SUCCESS) goto error_status;
+    }
+    else
+    {
+        if(FC0013_Write(pTuner, 0x10, (unsigned char)WriteValue) != FC0013_I2C_SUCCESS) goto error_status;
+    }
+
+
+	return FC0013_FUNCTION_SUCCESS;
+
+
+error_status:
+	return FC0013_FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_fc0013.h b/drivers/media/usb/rtl2832u/tuner_fc0013.h
new file mode 100644
index 00000000..f9f08019
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc0013.h
@@ -0,0 +1,307 @@
+#ifndef __TUNER_FC0013_H
+#define __TUNER_FC0013_H
+
+/**
+
+@file
+
+@brief   FC0013 tuner module declaration
+
+One can manipulate FC0013 tuner through FC0013 module.
+FC0013 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_fc0013.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	FC0013_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build FC0013 tuner module.
+	BuildFc0013Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc6,								// I2C device address is 0xc6 in 8-bit format.
+		CRYSTAL_FREQ_36000000HZ				// Crystal frequency is 36.0 MHz.
+		);
+
+
+
+
+
+	// Get FC0013 tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Fc0013);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set FC0013 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, FC0013_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get FC0013 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is implemented for FC0013 source code.
+
+
+// Definitions
+enum FC0013_TRUE_FALSE_STATUS
+{
+	FC0013_FALSE,
+	FC0013_TRUE,
+};
+
+
+enum FC0013_I2C_STATUS
+{
+	FC0013_I2C_SUCCESS,
+	FC0013_I2C_ERROR,
+};
+
+
+enum FC0013_FUNCTION_STATUS
+{
+	FC0013_FUNCTION_SUCCESS,
+	FC0013_FUNCTION_ERROR,
+};
+
+
+
+// Functions
+int FC0013_Read(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char *pByte);
+int FC0013_Write(TUNER_MODULE *pTuner, unsigned char RegAddr, unsigned char Byte);
+
+int
+fc0013_SetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	const unsigned char WritingValue
+	);
+
+int
+fc0013_GetRegMaskBits(
+	TUNER_MODULE *pTuner,
+	unsigned char RegAddr,
+	unsigned char Msb,
+	unsigned char Lsb,
+	unsigned char *pReadingValue
+	);
+
+int FC0013_Open(TUNER_MODULE *pTuner);
+int FC0013_SetFrequency(TUNER_MODULE *pTuner, unsigned long Frequency, unsigned short Bandwidth);
+
+// Set VHF Track depends on input frequency
+int FC0013_SetVhfTrack(TUNER_MODULE *pTuner, unsigned long Frequency);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is FC0013 tuner API source code
+
+
+
+
+
+// Definitions
+
+// Bandwidth mode
+enum FC0013_BANDWIDTH_MODE
+{
+	FC0013_BANDWIDTH_6000000HZ = 6,
+	FC0013_BANDWIDTH_7000000HZ = 7,
+	FC0013_BANDWIDTH_8000000HZ = 8,
+};
+
+
+// Default for initialing
+#define FC0013_RF_FREQ_HZ_DEFAULT			50000000
+#define FC0013_BANDWIDTH_MODE_DEFAULT		FC0013_BANDWIDTH_8000000HZ
+
+
+// Tuner LNA
+enum FC0013_LNA_GAIN_VALUE
+{
+	FC0013_LNA_GAIN_LOW     = 0x00,	// -6.3dB
+	FC0013_LNA_GAIN_MIDDLE  = 0x08,	//  7.1dB
+	FC0013_LNA_GAIN_HIGH_17 = 0x11,	// 19.1dB
+	FC0013_LNA_GAIN_HIGH_19 = 0x10,	// 19.7dB
+};
+
+
+
+
+
+// Builder
+void
+BuildFc0013Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+fc0013_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+fc0013_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+fc0013_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+fc0013_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+fc0013_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+fc0013_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+fc0013_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+int
+fc0013_RcCalReset(
+	TUNER_MODULE *pTuner
+	);
+
+int
+fc0013_RcCalAdd(
+	TUNER_MODULE *pTuner,
+	int RcValue
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_fc2580.c b/drivers/media/usb/rtl2832u/tuner_fc2580.c
new file mode 100644
index 00000000..2d4ccc9d
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc2580.c
@@ -0,0 +1,932 @@
+/**
+
+@file
+
+@brief   FC2580 tuner module definition
+
+One can manipulate FC2580 tuner through FC2580 module.
+FC2580 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_fc2580.h"
+
+
+
+
+
+/**
+
+@brief   FC2580 tuner module builder
+
+Use BuildFc2580Module() to build FC2580 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to FC2580 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   FC2580 I2C device address
+@param [in]   CrystalFreqHz                FC2580 crystal frequency in Hz
+@param [in]   AgcMode                      FC2580 AGC mode
+
+
+@note
+	-# One should call BuildFc2580Module() to build FC2580 module before using it.
+
+*/
+void
+BuildFc2580Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int AgcMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	FC2580_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge     = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc2580);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_FC2580;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = fc2580_GetTunerType;
+	pTuner->GetDeviceAddr = fc2580_GetDeviceAddr;
+
+	pTuner->Initialize    = fc2580_Initialize;
+	pTuner->SetRfFreqHz   = fc2580_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = fc2580_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz      = CrystalFreqHz;
+	pExtra->AgcMode            = AgcMode;
+	pExtra->IsBandwidthModeSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode = fc2580_SetBandwidthMode;
+	pExtra->GetBandwidthMode = fc2580_GetBandwidthMode;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+fc2580_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+fc2580_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+fc2580_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	FC2580_EXTRA_MODULE *pExtra;
+	int AgcMode;
+	unsigned int CrystalFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Get AGC mode.
+	AgcMode = pExtra->AgcMode;
+
+	// Initialize tuner with AGC mode.
+	// Note: CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	CrystalFreqKhz = (unsigned int)((pExtra->CrystalFreqHz + 500) / 1000);
+
+	if(fc2580_set_init(pTuner, AgcMode, CrystalFreqKhz) != FC2580_FCI_SUCCESS)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+fc2580_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	FC2580_EXTRA_MODULE *pExtra;
+	unsigned int RfFreqKhz;
+	unsigned int CrystalFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Set tuner RF frequency in KHz.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	//       CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	RfFreqKhz = (unsigned int)((RfFreqHz + 500) / 1000);
+	CrystalFreqKhz = (unsigned int)((pExtra->CrystalFreqHz + 500) / 1000);
+
+	if(fc2580_set_freq(pTuner, RfFreqKhz, CrystalFreqKhz) != FC2580_FCI_SUCCESS)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+fc2580_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set FC2580 tuner bandwidth mode.
+
+*/
+int
+fc2580_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	FC2580_EXTRA_MODULE *pExtra;
+	unsigned int CrystalFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Set tuner bandwidth mode.
+	// Note: CrystalFreqKhz = round(CrystalFreqHz / 1000)
+	CrystalFreqKhz = (unsigned int)((pExtra->CrystalFreqHz + 500) / 1000);
+
+	if(fc2580_set_filter(pTuner, (unsigned char)BandwidthMode, CrystalFreqKhz) != FC2580_FCI_SUCCESS)
+		goto error_status_set_tuner_bandwidth_mode;
+
+
+	// Set tuner bandwidth mode parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get FC2580 tuner bandwidth mode.
+
+*/
+int
+fc2580_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	FC2580_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Fc2580);
+
+
+	// Get tuner bandwidth mode from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth_mode;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by FCI.
+
+
+
+
+
+// FCI source code - fc2580_driver_v14011_r.c
+
+
+/*==============================================================================
+    FILE NAME   : FC2580_driver_v1400_r.c
+    
+    VERSION     : 1.400_r
+    
+    UPDATE      : September 22. 2008
+				
+==============================================================================*/ 
+
+/*==============================================================================
+
+  Chip ID of FC2580 is 0x56 or 0xAC(including I2C write bit)
+
+==============================================================================*/
+
+//#include "fc2580_driver_v1400_r.h"
+
+//fc2580_band_type curr_band = FC2580_NO_BAND;
+//unsigned int freq_xtal = 16384;
+
+
+/*==============================================================================
+		milisecond delay function					EXTERNAL FUNCTION
+
+  This function is a generic function which write a byte into fc2580's
+ specific address.
+
+  <input parameter>
+
+  a
+	length of wanted delay in milisecond unit
+
+==============================================================================*/
+void fc2580_wait_msec(TUNER_MODULE *pTuner, int a)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+	// Get base interface.
+	pBaseInterface = pTuner->pBaseInterface;
+
+
+	// Wait time in millisecond.
+	pBaseInterface->WaitMs(pBaseInterface, (unsigned long)a);
+
+
+	return;
+}
+
+/*==============================================================================
+
+           fc2580 i2c write
+
+  This function is a generic function which write a byte into fc2580's
+ specific address.
+
+  <input parameter>
+
+  addr
+	fc2580's memory address\
+	type : byte
+
+  data
+	target data
+	type : byte
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_i2c_write( TUNER_MODULE *pTuner, unsigned char addr, unsigned char data )
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBytes[LEN_2_BYTE];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + data + stop_bit
+	WritingBytes[0] = addr;
+	WritingBytes[1] = data;
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBytes, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return FC2580_FCI_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return FC2580_FCI_FAIL;
+};
+
+/*==============================================================================
+
+           fc2580 i2c read
+
+  This function is a generic function which gets called to read data from
+ fc2580's target memory address.
+
+  <input parameter>
+
+  addr
+	fc2580's memory address
+	type : byte
+
+
+  <return value>
+  data
+	a byte of data read out of target address 'addr'
+	type : byte
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_i2c_read( TUNER_MODULE *pTuner, unsigned char addr, unsigned char *read_data )
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + stop_bit
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &addr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register byte.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + read_data + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, read_data, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	return FC2580_FCI_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return FC2580_FCI_FAIL;
+};
+
+
+
+/*==============================================================================
+       fc2580 I2C Test
+
+  This function is a generic function which tests I2C interface's availability
+
+  by reading out it's I2C id data from reg. address '0x01'.
+
+  <input parameter>
+
+  None
+  
+  <return value>
+  int
+	1 : success - communication is avilable
+	0 : fail - communication is unavailable
+  
+
+==============================================================================*/
+//int fc2580_i2c_test( void )
+//{
+//	return ( fc2580_i2c_read( 0x01 ) == 0x56 )? 0x01 : 0x00;
+//}
+
+
+
+
+/*==============================================================================
+       fc2580 initial setting
+
+  This function is a generic function which gets called to initialize
+
+  fc2580 in DVB-H mode or L-Band TDMB mode
+
+  <input parameter>
+
+  ifagc_mode
+    type : integer
+	1 : Internal AGC
+	2 : Voltage Control Mode
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_init( TUNER_MODULE *pTuner, int ifagc_mode, unsigned int freq_xtal )
+{
+	fc2580_fci_result_type result = FC2580_FCI_SUCCESS;
+
+	result &= fc2580_i2c_write(pTuner, 0x00, 0x00);	/*** Confidential ***/
+	result &= fc2580_i2c_write(pTuner, 0x12, 0x86);
+	result &= fc2580_i2c_write(pTuner, 0x14, 0x5C);
+	result &= fc2580_i2c_write(pTuner, 0x16, 0x3C);
+	result &= fc2580_i2c_write(pTuner, 0x1F, 0xD2);
+	result &= fc2580_i2c_write(pTuner, 0x09, 0xD7);
+	result &= fc2580_i2c_write(pTuner, 0x0B, 0xD5);
+	result &= fc2580_i2c_write(pTuner, 0x0C, 0x32);
+	result &= fc2580_i2c_write(pTuner, 0x0E, 0x43);
+	result &= fc2580_i2c_write(pTuner, 0x21, 0x0A);
+	result &= fc2580_i2c_write(pTuner, 0x22, 0x82);
+	if( ifagc_mode == 1 )
+	{
+		result &= fc2580_i2c_write(pTuner, 0x45, 0x10);	//internal AGC
+		result &= fc2580_i2c_write(pTuner, 0x4C, 0x00);	//HOLD_AGC polarity
+	}
+	else if( ifagc_mode == 2 )
+	{
+		result &= fc2580_i2c_write(pTuner, 0x45, 0x20);	//Voltage Control Mode
+		result &= fc2580_i2c_write(pTuner, 0x4C, 0x02);	//HOLD_AGC polarity
+	}
+	result &= fc2580_i2c_write(pTuner, 0x3F, 0x88);
+	result &= fc2580_i2c_write(pTuner, 0x02, 0x0E);
+	result &= fc2580_i2c_write(pTuner, 0x58, 0x14);
+	result &= fc2580_set_filter(pTuner, 8, freq_xtal);	//BW = 7.8MHz
+
+	return result;
+}
+
+
+/*==============================================================================
+       fc2580 frequency setting
+
+  This function is a generic function which gets called to change LO Frequency
+
+  of fc2580 in DVB-H mode or L-Band TDMB mode
+
+  <input parameter>
+  freq_xtal: kHz
+
+  f_lo
+	Value of target LO Frequency in 'kHz' unit
+	ex) 2.6GHz = 2600000
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_freq( TUNER_MODULE *pTuner, unsigned int f_lo, unsigned int freq_xtal )
+{
+	unsigned int f_diff, f_diff_shifted, n_val, k_val;
+	unsigned int f_vco, r_val, f_comp;
+	unsigned char pre_shift_bits = 4;// number of preshift to prevent overflow in shifting f_diff to f_diff_shifted
+	unsigned char data_0x18;
+	unsigned char data_0x02 = (USE_EXT_CLK<<5)|0x0E;
+	
+	fc2580_band_type band = ( f_lo > 1000000 )? FC2580_L_BAND : ( f_lo > 400000 )? FC2580_UHF_BAND : FC2580_VHF_BAND;
+
+	fc2580_fci_result_type result = FC2580_FCI_SUCCESS;
+
+	f_vco = ( band == FC2580_UHF_BAND )? f_lo * 4 : (( band == FC2580_L_BAND )? f_lo * 2 : f_lo * 12);
+	r_val = ( f_vco >= 2*76*freq_xtal )? 1 : ( f_vco >= 76*freq_xtal )? 2 : 4;
+	f_comp = freq_xtal/r_val;
+	n_val =	( f_vco / 2 ) / f_comp;
+	
+	f_diff = f_vco - 2* f_comp * n_val;
+	f_diff_shifted = f_diff << ( 20 - pre_shift_bits );
+	k_val = f_diff_shifted / ( ( 2* f_comp ) >> pre_shift_bits );
+	
+	if( f_diff_shifted - k_val * ( ( 2* f_comp ) >> pre_shift_bits ) >= ( f_comp >> pre_shift_bits ) )
+	k_val = k_val + 1;
+	
+	if( f_vco >= BORDER_FREQ )	//Select VCO Band
+		data_0x02 = data_0x02 | 0x08;	//0x02[3] = 1;
+	else
+		data_0x02 = data_0x02 & 0xF7;	//0x02[3] = 0;
+	
+//	if( band != curr_band ) {
+		switch(band)
+		{
+			case FC2580_UHF_BAND:
+				data_0x02 = (data_0x02 & 0x3F);
+
+				result &= fc2580_i2c_write(pTuner, 0x25, 0xF0);
+				result &= fc2580_i2c_write(pTuner, 0x27, 0x77);
+				result &= fc2580_i2c_write(pTuner, 0x28, 0x53);
+				result &= fc2580_i2c_write(pTuner, 0x29, 0x60);
+				result &= fc2580_i2c_write(pTuner, 0x30, 0x09);
+				result &= fc2580_i2c_write(pTuner, 0x50, 0x8C);
+				result &= fc2580_i2c_write(pTuner, 0x53, 0x50);
+
+				if( f_lo < 538000 )
+					result &= fc2580_i2c_write(pTuner, 0x5F, 0x13);
+				else					
+					result &= fc2580_i2c_write(pTuner, 0x5F, 0x15);
+
+				if( f_lo < 538000 )
+				{
+					result &= fc2580_i2c_write(pTuner, 0x61, 0x07);
+					result &= fc2580_i2c_write(pTuner, 0x62, 0x06);
+					result &= fc2580_i2c_write(pTuner, 0x67, 0x06);
+					result &= fc2580_i2c_write(pTuner, 0x68, 0x08);
+					result &= fc2580_i2c_write(pTuner, 0x69, 0x10);
+					result &= fc2580_i2c_write(pTuner, 0x6A, 0x12);
+				}
+				else if( f_lo < 794000 )
+				{
+					result &= fc2580_i2c_write(pTuner, 0x61, 0x03);
+					result &= fc2580_i2c_write(pTuner, 0x62, 0x03);
+					result &= fc2580_i2c_write(pTuner, 0x67, 0x03);  //ACI improve
+					result &= fc2580_i2c_write(pTuner, 0x68, 0x05);  //ACI improve
+					result &= fc2580_i2c_write(pTuner, 0x69, 0x0C);
+					result &= fc2580_i2c_write(pTuner, 0x6A, 0x0E);
+				}
+				else
+				{
+					result &= fc2580_i2c_write(pTuner, 0x61, 0x07);
+					result &= fc2580_i2c_write(pTuner, 0x62, 0x06);
+					result &= fc2580_i2c_write(pTuner, 0x67, 0x07);
+					result &= fc2580_i2c_write(pTuner, 0x68, 0x09);
+					result &= fc2580_i2c_write(pTuner, 0x69, 0x10);
+					result &= fc2580_i2c_write(pTuner, 0x6A, 0x12);
+				}
+
+				result &= fc2580_i2c_write(pTuner, 0x63, 0x15);
+
+				result &= fc2580_i2c_write(pTuner, 0x6B, 0x0B);
+				result &= fc2580_i2c_write(pTuner, 0x6C, 0x0C);
+				result &= fc2580_i2c_write(pTuner, 0x6D, 0x78);
+				result &= fc2580_i2c_write(pTuner, 0x6E, 0x32);
+				result &= fc2580_i2c_write(pTuner, 0x6F, 0x14);
+				result &= fc2580_set_filter(pTuner, 8, freq_xtal);	//BW = 7.8MHz
+				break;
+			case FC2580_VHF_BAND:
+				data_0x02 = (data_0x02 & 0x3F) | 0x80;
+				result &= fc2580_i2c_write(pTuner, 0x27, 0x77);
+				result &= fc2580_i2c_write(pTuner, 0x28, 0x33);
+				result &= fc2580_i2c_write(pTuner, 0x29, 0x40);
+				result &= fc2580_i2c_write(pTuner, 0x30, 0x09);
+				result &= fc2580_i2c_write(pTuner, 0x50, 0x8C);
+				result &= fc2580_i2c_write(pTuner, 0x53, 0x50);
+				result &= fc2580_i2c_write(pTuner, 0x5F, 0x0F);
+				result &= fc2580_i2c_write(pTuner, 0x61, 0x07);
+				result &= fc2580_i2c_write(pTuner, 0x62, 0x00);
+				result &= fc2580_i2c_write(pTuner, 0x63, 0x15);
+				result &= fc2580_i2c_write(pTuner, 0x67, 0x03);
+				result &= fc2580_i2c_write(pTuner, 0x68, 0x05);
+				result &= fc2580_i2c_write(pTuner, 0x69, 0x10);
+				result &= fc2580_i2c_write(pTuner, 0x6A, 0x12);
+				result &= fc2580_i2c_write(pTuner, 0x6B, 0x08);
+				result &= fc2580_i2c_write(pTuner, 0x6C, 0x0A);
+				result &= fc2580_i2c_write(pTuner, 0x6D, 0x78);
+				result &= fc2580_i2c_write(pTuner, 0x6E, 0x32);
+				result &= fc2580_i2c_write(pTuner, 0x6F, 0x54);
+				result &= fc2580_set_filter(pTuner, 7, freq_xtal);	//BW = 6.8MHz
+				break;
+			case FC2580_L_BAND:
+				data_0x02 = (data_0x02 & 0x3F) | 0x40;
+				result &= fc2580_i2c_write(pTuner, 0x2B, 0x70);
+				result &= fc2580_i2c_write(pTuner, 0x2C, 0x37);
+				result &= fc2580_i2c_write(pTuner, 0x2D, 0xE7);
+				result &= fc2580_i2c_write(pTuner, 0x30, 0x09);
+				result &= fc2580_i2c_write(pTuner, 0x44, 0x20);
+				result &= fc2580_i2c_write(pTuner, 0x50, 0x8C);
+				result &= fc2580_i2c_write(pTuner, 0x53, 0x50);
+				result &= fc2580_i2c_write(pTuner, 0x5F, 0x0F);
+				result &= fc2580_i2c_write(pTuner, 0x61, 0x0F);
+				result &= fc2580_i2c_write(pTuner, 0x62, 0x00);
+				result &= fc2580_i2c_write(pTuner, 0x63, 0x13);
+				result &= fc2580_i2c_write(pTuner, 0x67, 0x00);
+				result &= fc2580_i2c_write(pTuner, 0x68, 0x02);
+				result &= fc2580_i2c_write(pTuner, 0x69, 0x0C);
+				result &= fc2580_i2c_write(pTuner, 0x6A, 0x0E);
+				result &= fc2580_i2c_write(pTuner, 0x6B, 0x08);
+				result &= fc2580_i2c_write(pTuner, 0x6C, 0x0A);
+				result &= fc2580_i2c_write(pTuner, 0x6D, 0xA0);
+				result &= fc2580_i2c_write(pTuner, 0x6E, 0x50);
+				result &= fc2580_i2c_write(pTuner, 0x6F, 0x14);
+				result &= fc2580_set_filter(pTuner, 1, freq_xtal);	//BW = 1.53MHz
+				break;
+			default:
+				break;
+		}
+//		curr_band = band;
+//	}
+
+	//A command about AGC clock's pre-divide ratio
+	if( freq_xtal >= 28000 )
+		result &= fc2580_i2c_write(pTuner, 0x4B, 0x22 );
+
+	//Commands about VCO Band and PLL setting.
+	result &= fc2580_i2c_write(pTuner, 0x02, data_0x02);
+	data_0x18 = ( ( r_val == 1 )? 0x00 : ( ( r_val == 2 )? 0x10 : 0x20 ) ) + (unsigned char)(k_val >> 16);
+	result &= fc2580_i2c_write(pTuner, 0x18, data_0x18);						//Load 'R' value and high part of 'K' values
+	result &= fc2580_i2c_write(pTuner, 0x1A, (unsigned char)( k_val >> 8 ) );	//Load middle part of 'K' value
+	result &= fc2580_i2c_write(pTuner, 0x1B, (unsigned char)( k_val ) );		//Load lower part of 'K' value
+	result &= fc2580_i2c_write(pTuner, 0x1C, (unsigned char)( n_val ) );		//Load 'N' value
+
+	//A command about UHF LNA Load Cap
+	if( band == FC2580_UHF_BAND )
+		result &= fc2580_i2c_write(pTuner, 0x2D, ( f_lo <= (unsigned int)794000 )? 0x9F : 0x8F );	//LNA_OUT_CAP
+	
+
+	return result;
+}
+
+
+/*==============================================================================
+       fc2580 filter BW setting
+
+  This function is a generic function which gets called to change Bandwidth
+
+  frequency of fc2580's channel selection filter
+
+  <input parameter>
+  freq_xtal: kHz
+
+  filter_bw
+    1 : 1.53MHz(TDMB)
+	6 : 6MHz   (Bandwidth 6MHz)
+	7 : 6.8MHz (Bandwidth 7MHz)
+	8 : 7.8MHz (Bandwidth 8MHz)
+	
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_filter( TUNER_MODULE *pTuner, unsigned char filter_bw, unsigned int freq_xtal )
+{
+	unsigned char	cal_mon, i;
+	fc2580_fci_result_type result = FC2580_FCI_SUCCESS;
+
+	if(filter_bw == 1)
+	{
+		result &= fc2580_i2c_write(pTuner, 0x36, 0x1C);
+		result &= fc2580_i2c_write(pTuner, 0x37, (unsigned char)(4151*freq_xtal/1000000) );
+		result &= fc2580_i2c_write(pTuner, 0x39, 0x00);
+		result &= fc2580_i2c_write(pTuner, 0x2E, 0x09);
+	}
+	if(filter_bw == 6)
+	{
+		result &= fc2580_i2c_write(pTuner, 0x36, 0x18);
+		result &= fc2580_i2c_write(pTuner, 0x37, (unsigned char)(4400*freq_xtal/1000000) );
+		result &= fc2580_i2c_write(pTuner, 0x39, 0x00);
+		result &= fc2580_i2c_write(pTuner, 0x2E, 0x09);
+	}
+	else if(filter_bw == 7)
+	{
+		result &= fc2580_i2c_write(pTuner, 0x36, 0x18);
+		result &= fc2580_i2c_write(pTuner, 0x37, (unsigned char)(3910*freq_xtal/1000000) );
+		result &= fc2580_i2c_write(pTuner, 0x39, 0x80);
+		result &= fc2580_i2c_write(pTuner, 0x2E, 0x09);
+	}
+	else if(filter_bw == 8)
+	{
+		result &= fc2580_i2c_write(pTuner, 0x36, 0x18);
+		result &= fc2580_i2c_write(pTuner, 0x37, (unsigned char)(3300*freq_xtal/1000000) );
+		result &= fc2580_i2c_write(pTuner, 0x39, 0x80);
+		result &= fc2580_i2c_write(pTuner, 0x2E, 0x09);
+	}
+
+	
+	for(i=0; i<5; i++)
+	{
+		fc2580_wait_msec(pTuner, 5);//wait 5ms
+		result &= fc2580_i2c_read(pTuner, 0x2F, &cal_mon);
+		if( (cal_mon & 0xC0) != 0xC0)
+		{
+			result &= fc2580_i2c_write(pTuner, 0x2E, 0x01);
+			result &= fc2580_i2c_write(pTuner, 0x2E, 0x09);
+		}
+		else
+			break;
+	}
+
+	result &= fc2580_i2c_write(pTuner, 0x2E, 0x01);
+
+	return result;
+}
+
+/*==============================================================================
+       fc2580 RSSI function
+
+  This function is a generic function which returns fc2580's
+  
+  current RSSI value.
+
+  <input parameter>
+	none
+
+  <return value>
+  int
+  	rssi : estimated input power.
+
+==============================================================================*/
+//int fc2580_get_rssi(void) {
+//	
+//	unsigned char s_lna, s_rfvga, s_cfs, s_ifvga;
+//	int ofs_lna, ofs_rfvga, ofs_csf, ofs_ifvga, rssi;
+//
+//	fc2580_i2c_read(0x71, &s_lna );
+//	fc2580_i2c_read(0x72, &s_rfvga );
+//	fc2580_i2c_read(0x73, &s_cfs );
+//	fc2580_i2c_read(0x74, &s_ifvga );
+//	
+//
+//	ofs_lna = 
+//			(curr_band==FC2580_UHF_BAND)?
+//				(s_lna==0)? 0 :
+//				(s_lna==1)? -6 :
+//				(s_lna==2)? -17 :
+//				(s_lna==3)? -22 : -30 :
+//			(curr_band==FC2580_VHF_BAND)?
+//				(s_lna==0)? 0 :
+//				(s_lna==1)? -6 :
+//				(s_lna==2)? -19 :
+//				(s_lna==3)? -24 : -32 :
+//			(curr_band==FC2580_L_BAND)?
+//				(s_lna==0)? 0 :
+//				(s_lna==1)? -6 :
+//				(s_lna==2)? -11 :
+//				(s_lna==3)? -16 : -34 :
+//			0;//FC2580_NO_BAND
+//	ofs_rfvga = -s_rfvga+((s_rfvga>=11)? 1 : 0) + ((s_rfvga>=18)? 1 : 0);
+//	ofs_csf = -6*s_cfs;
+//	ofs_ifvga = s_ifvga/4;
+//
+//	return rssi = ofs_lna+ofs_rfvga+ofs_csf+ofs_ifvga+OFS_RSSI;
+//				
+//}
+
+/*==============================================================================
+       fc2580 Xtal frequency Setting
+
+  This function is a generic function which sets 
+  
+  the frequency of xtal.
+  
+  <input parameter>
+  
+  frequency
+  	frequency value of internal(external) Xtal(clock) in kHz unit.
+
+==============================================================================*/
+//void fc2580_set_freq_xtal(unsigned int frequency) {
+//
+//	freq_xtal = frequency;
+//
+//}
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_fc2580.h b/drivers/media/usb/rtl2832u/tuner_fc2580.h
new file mode 100644
index 00000000..906357d4
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_fc2580.h
@@ -0,0 +1,461 @@
+#ifndef __TUNER_FC2580_H
+#define __TUNER_FC2580_H
+
+/**
+
+@file
+
+@brief   FC2580 tuner module declaration
+
+One can manipulate FC2580 tuner through FC2580 module.
+FC2580 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_fc2580.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	FC2580_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build FC2580 tuner module.
+	BuildFc2580Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xac,								// I2C device address is 0xac in 8-bit format.
+		CRYSTAL_FREQ_16384000HZ,			// Crystal frequency is 16.384 MHz.
+		FC2580_AGC_INTERNAL					// The FC2580 AGC mode is internal AGC mode.
+		);
+
+
+
+
+
+	// Get FC2580 tuner extra module.
+	pTunerExtra = (T2266_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set FC2580 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, FC2580_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get FC2580 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is source code provided by FCI.
+
+
+
+
+
+// FCI source code - fc2580_driver_v1400_r.h
+
+
+/*==============================================================================
+    FILE NAME   : FC2580_driver_v1400_r.h  
+    
+    VERSION     : 1.400_r
+    
+    UPDATE      : September 22. 2008
+				
+==============================================================================*/ 
+
+/*==============================================================================
+
+  Chip ID of FC2580 is 0x56 or 0xAC(including I2C write bit)
+
+==============================================================================*/
+
+
+#define	BORDER_FREQ	2600000	//2.6GHz : The border frequency which determines whether Low VCO or High VCO is used
+#define USE_EXT_CLK	0	//0 : Use internal XTAL Oscillator / 1 : Use External Clock input
+#define OFS_RSSI 57
+
+typedef enum {
+	FC2580_UHF_BAND,
+	FC2580_L_BAND,
+	FC2580_VHF_BAND,
+	FC2580_NO_BAND
+} fc2580_band_type;
+
+typedef enum {
+	FC2580_FCI_FAIL,
+	FC2580_FCI_SUCCESS
+} fc2580_fci_result_type;
+
+/*==============================================================================
+		i2c command write							EXTERNAL FUNCTION
+
+  This function is a generic function which write a byte into fc2580's
+ specific address.
+
+  <input parameter>
+
+  slave_id
+	i2c id of slave chip
+	type : byte
+	
+  addr
+	memory address of slave chip
+	type : byte
+
+  data
+	target data
+	type : byte
+
+==============================================================================*/
+//extern fc2580_fci_result_type i2c_write( unsigned char slave_id, unsigned char addr, unsigned char *data, unsigned char n );
+
+/*==============================================================================
+		i2c command write							EXTERNAL FUNCTION
+
+  This function is a generic function which gets called to read data from
+ slave chip's target memory address.
+
+  <input parameter>
+
+  slave_id
+	i2c id of slave chip
+	type : byte
+	
+  addr
+	memory address of slave chip
+	type : byte
+
+  <return value>
+  data
+	a byte of data read out of target address 'addr' of slave chip
+	type : byte
+
+==============================================================================*/
+//extern fc2580_fci_result_type i2c_read( unsigned char slave_id, unsigned char addr, unsigned char *read_data, unsigned char n );
+
+/*==============================================================================
+		milisecond delay function					EXTERNAL FUNCTION
+
+  This function is a generic function which write a byte into fc2580's
+ specific address.
+
+  <input parameter>
+
+  a
+	length of wanted delay in milisecond unit
+
+==============================================================================*/
+extern void fc2580_wait_msec(TUNER_MODULE *pTuner, int a);
+
+
+
+/*==============================================================================
+       fc2580 i2c command write
+
+  This function is a generic function which write a byte into fc2580's
+ specific address.
+
+  <input parameter>
+
+  addr
+	fc2580's memory address
+	type : byte
+
+  data
+	target data
+	type : byte
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_i2c_write( TUNER_MODULE *pTuner, unsigned char addr, unsigned char data );
+
+/*==============================================================================
+       fc2580 i2c data read
+
+  This function is a generic function which gets called to read data from
+ fc2580's target memory address.
+
+  <input parameter>
+
+  addr
+	fc2580's memory address
+	type : byte
+
+
+  <return value>
+  data
+	a byte of data read out of target address 'addr'
+	type : byte
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_i2c_read( TUNER_MODULE *pTuner, unsigned char addr, unsigned char *read_data );
+
+/*==============================================================================
+       fc2580 initial setting
+
+  This function is a generic function which gets called to initialize
+
+  fc2580 in DVB-H mode or L-Band TDMB mode
+
+  <input parameter>
+
+  ifagc_mode
+    type : integer
+	1 : Internal AGC
+	2 : Voltage Control Mode
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_init( TUNER_MODULE *pTuner, int ifagc_mode, unsigned int freq_xtal );
+
+/*==============================================================================
+       fc2580 frequency setting
+
+  This function is a generic function which gets called to change LO Frequency
+
+  of fc2580 in DVB-H mode or L-Band TDMB mode
+
+  <input parameter>
+
+  f_lo
+	Value of target LO Frequency in 'kHz' unit
+	ex) 2.6GHz = 2600000
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_freq( TUNER_MODULE *pTuner, unsigned int f_lo, unsigned int freq_xtal );
+
+
+/*==============================================================================
+       fc2580 filter BW setting
+
+  This function is a generic function which gets called to change Bandwidth
+
+  frequency of fc2580's channel selection filter
+
+  <input parameter>
+
+  filter_bw
+    1 : 1.53MHz(TDMB)
+	6 : 6MHz
+	7 : 7MHz
+	8 : 7.8MHz
+
+
+==============================================================================*/
+fc2580_fci_result_type fc2580_set_filter( TUNER_MODULE *pTuner, unsigned char filter_bw, unsigned int freq_xtal );
+
+/*==============================================================================
+       fc2580 RSSI function
+
+  This function is a generic function which returns fc2580's
+  
+  current RSSI value.
+
+  
+  
+
+==============================================================================*/
+//int fc2580_get_rssi(void); 
+
+/*==============================================================================
+       fc2580 Xtal frequency Setting
+
+  This function is a generic function which sets 
+  
+  the frequency of xtal.
+  
+  <input parameter>
+  
+  frequency
+  	frequency value of internal(external) Xtal(clock) in kHz unit.
+
+==============================================================================*/
+//void fc2580_set_freq_xtal(unsigned int frequency);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is FC2580 tuner API source code
+
+
+
+
+
+// Definitions
+
+// AGC mode
+enum FC2580_AGC_MODE
+{
+	FC2580_AGC_INTERNAL = 1,
+	FC2580_AGC_EXTERNAL = 2,
+};
+
+
+// Bandwidth mode
+enum FC2580_BANDWIDTH_MODE
+{
+	FC2580_BANDWIDTH_1530000HZ = 1,
+	FC2580_BANDWIDTH_6000000HZ = 6,
+	FC2580_BANDWIDTH_7000000HZ = 7,
+	FC2580_BANDWIDTH_8000000HZ = 8,
+};
+
+
+
+
+
+// Builder
+void
+BuildFc2580Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int AgcMode
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+fc2580_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+fc2580_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+fc2580_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+fc2580_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+fc2580_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+fc2580_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+fc2580_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_max3543.c b/drivers/media/usb/rtl2832u/tuner_max3543.c
new file mode 100644
index 00000000..33ec6858
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_max3543.c
@@ -0,0 +1,1441 @@
+/**
+
+@file
+
+@brief   MAX3543 tuner module definition
+
+One can manipulate MAX3543 tuner through MAX3543 module.
+MAX3543 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_max3543.h"
+
+
+
+
+
+/**
+
+@brief   MAX3543 tuner module builder
+
+Use BuildMax3543Module() to build MAX3543 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to MAX3543 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   MAX3543 I2C device address
+@param [in]   CrystalFreqHz                MAX3543 crystal frequency in Hz
+@param [in]   StandardMode                 MAX3543 standard mode
+@param [in]   IfFreqHz                     MAX3543 IF frequency in Hz
+@param [in]   OutputMode                   MAX3543 output mode
+
+
+@note
+	-# One should call BuildMax3543Module() to build MAX3543 module before using it.
+
+*/
+void
+BuildMax3543Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int StandardMode,
+	unsigned long IfFreqHz,
+	int OutputMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_MAX3543;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->RfFreqHz      = MAX3543_RF_FREQ_HZ_DEFAULT;
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = max3543_GetTunerType;
+	pTuner->GetDeviceAddr = max3543_GetDeviceAddr;
+
+	pTuner->Initialize    = max3543_Initialize;
+	pTuner->SetRfFreqHz   = max3543_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = max3543_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz      = CrystalFreqHz;
+	pExtra->StandardMode       = StandardMode;
+	pExtra->IfFreqHz           = IfFreqHz;
+	pExtra->OutputMode         = OutputMode;
+	pExtra->BandwidthMode      = MAX3543_BANDWIDTH_MODE_DEFAULT;
+	pExtra->IsBandwidthModeSet = NO;
+
+	pExtra->broadcast_standard = StandardMode;
+
+	switch(CrystalFreqHz)
+	{
+		default:
+		case CRYSTAL_FREQ_16000000HZ:
+
+			switch(IfFreqHz)
+			{
+				default:
+				case IF_FREQ_36170000HZ:
+					
+					pExtra->XTALSCALE = 8;
+					pExtra->XTALREF = 128;
+					pExtra->LOSCALE = 65;
+
+					break;
+			}
+	}
+
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode = max3543_SetBandwidthMode;
+	pExtra->GetBandwidthMode = max3543_GetBandwidthMode;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+max3543_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+max3543_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+max3543_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	// Initializing tuner.
+	// Note: Call MAX3543 source code function.
+	if(MAX3543_Init(pTuner) != MAX3543_SUCCESS)
+		goto error_status_execute_function;
+
+	// Set tuner standard mode and output mode.
+	// Note: Call MAX3543 source code function.
+	if(MAX3543_Standard(pTuner, pExtra->StandardMode, pExtra->OutputMode) != MAX3543_SUCCESS)
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+max3543_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	MAX3543_EXTRA_MODULE *pExtra;
+
+	unsigned long FreqUnit;
+	unsigned short CalculatedValue;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	// Calculate frequency unit.
+	FreqUnit = MAX3543_CONST_1_MHZ / pExtra->LOSCALE;
+
+	// Set tuner RF frequency in KHz.
+	// Note: 1. CalculatedValue = round(RfFreqHz / FreqUnit)
+	//       2. Call MAX3543 source code function.
+	CalculatedValue = (unsigned short)((RfFreqHz + (FreqUnit / 2)) / FreqUnit);
+
+	if(MAX3543_SetFrequency(pTuner, CalculatedValue) != MAX3543_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+max3543_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set MAX3543 tuner bandwidth mode.
+
+*/
+int
+max3543_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	MAX3543_EXTRA_MODULE *pExtra;
+
+	unsigned short BandwidthModeUshort;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	// Set tuner bandwidth mode.
+	// Note: Call MAX3543 source code function.
+	BandwidthModeUshort = (unsigned short)BandwidthMode;
+
+	if(MAX3543_ChannelBW(pTuner, BandwidthModeUshort) != MAX3543_SUCCESS)
+		goto error_status_execute_function;
+
+
+	// Set tuner bandwidth Hz parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MAX3543 tuner bandwidth mode.
+
+*/
+int
+max3543_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	// Get tuner bandwidth Hz from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth_mode;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Function (implemeted for MAX3543)
+int
+Max3543_Read(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned short *pData
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingByte;
+	unsigned char ReadingByte;
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + stop_bit
+	WritingByte = (unsigned char)RegAddr;
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &WritingByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register byte.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + read_data + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, &ReadingByte, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	*pData = (unsigned short)ReadingByte;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return MAX3543_ERROR;
+}
+
+
+
+
+
+int
+Max3543_Write(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned short Data
+	)
+{
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[LEN_2_BYTE];
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr + data + stop_bit
+	WritingBuffer[0] = (unsigned char)RegAddr;
+	WritingBuffer[1] = (unsigned char)Data;
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_set_tuner_registers:
+	return MAX3543_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by MAXIM.
+
+
+
+
+
+// MAXIM source code - Max3543_Driver.c
+
+
+/*
+------------------------------------------------------------------------- 
+| MAX3543 Tuner Driver                                               
+| Author: Paul Nichol                                                       
+|                                                                           
+| Version: 1.0.3                                                            
+| Date:    12/09/09                                                         
+|                                                                           
+|                                                                           
+| Copyright (C) 2009 Maxim Integrated Products.                             
+| PLEASE READ THE ATTACHED LICENSE CAREFULLY BEFORE USING THIS SOFTWARE.
+| BY USING THE SOFTWARE OF MAXIM INTEGRATED PRODUCTS, INC, YOU ARE AGREEING 
+| TO BE BOUND BY THE TERMS OF THE ATTACHED LICENSE, WHICH INCLUDES THE SOFTWARE
+| LICENSE AND SOFTWARE WARRANTY DISCLAIMER, EVEN WITHOUT YOUR SIGNATURE. 
+| IF YOU DO NOT AGREE TO THE TERMS OF THIS AGREEMENT, DO NOT USE THIS SOFTWARE.
+|
+| IMPORTANT: This code is operate the Max3543 Multi-Band Terrestrial        
+| Hybrid Tuner.  Routines include: initializing, tuning, reading the        
+| ROM table, reading the lock detect status and tuning the tracking         
+| filter.  Only integer math is used in this program and no floating point
+| variables are used.  Your MCU must be capable of processing unsigned 32 bit integer
+| math to use this routine.  (That is: two 16 bit numbers multiplied resulting in a 
+| 32 bit result, or a 32 bit number divided by a 16 bit number).
+|                                                                           
+-------------------------------------------------------------------------- 
+*/
+
+
+//#include <stdio.h>
+//#include <string.h>
+///#include <stdlib.h>
+//#include "mxmdef.h"
+//#include "Max3543_Driver.h"
+    
+/*
+double debugreg[10];
+UINT_16 TFRomCoefs[3][4];
+UINT_16 denominator;   
+UINT_32 fracscale ;
+UINT_16 regs[22];
+UINT_16 IF_Frequency;
+*/
+
+/* table of fixed coefficients for the tracking filter equations. */
+
+const
+static UINT_16 co[6][5]={{ 26, 6,  68, 20, 45 },  /* VHF LO TFS */
+                        { 16, 8,  88, 40, 0 },  /* VHF LO TFP */
+                        { 27, 10, 54, 30,20 },  /* VHF HI TFS */
+                        { 18, 10, 41, 20, 0 },  /* VHF HI TFP */
+                        { 32, 10, 34, 8, 10 },  /* UHF TFS */
+                        { 13, 15, 21, 16, 0 }}; /* UHF TFP */
+
+
+
+//int MAX3543_Init(TUNER_MODULE *pTuner, UINT_16 RfFreq)
+int MAX3543_Init(TUNER_MODULE *pTuner)
+{  
+	/* 
+		Initialize every register. Don't rely on MAX3543 power on reset.  
+	   Call before using the other routines in this file.                
+   */  
+   UINT_16 RegNumber;
+   
+	MAX3543_EXTRA_MODULE *pExtra;
+
+	unsigned long FreqUnit;
+	unsigned short CalculatedValue;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+   /*Initialize the registers in the MAX3543:*/
+
+
+
+	pExtra->regs[REG3543_VCO]				=	0x4c;
+	pExtra->regs[REG3543_NDIV]			=	0x2B;
+	pExtra->regs[REG3543_FRAC2]			=	0x8E; 
+	pExtra->regs[REG3543_FRAC1]			=	0x26;
+	pExtra->regs[REG3543_FRAC0]			=	0x66;
+	pExtra->regs[REG3543_MODE]			=	0xd8;
+	pExtra->regs[REG3543_TFS]				=	0x00;
+	pExtra->regs[REG3543_TFP]				= 	0x00;
+	pExtra->regs[REG3543_SHDN]			=	0x00;
+	pExtra->regs[REG3543_REF]				=	0x0a;
+	pExtra->regs[REG3543_VAS]				=	0x17;
+	pExtra->regs[REG3543_PD_CFG1]		=	0x43;
+	pExtra->regs[REG3543_PD_CFG2]		=	0x01;
+	pExtra->regs[REG3543_FILT_CF]		=	0x25;
+	pExtra->regs[REG3543_ROM_ADDR]		=	0x00;
+	pExtra->regs[REG3543_IRHR]			=	0x80;
+	pExtra->regs[REG3543_BIAS_ADJ]		=	0x57;
+	pExtra->regs[REG3543_TEST1]			=	0x40;
+	pExtra->regs[REG3543_ROM_WRITE]		=	0x00;
+
+	
+
+   /* Write each register out to the MAX3543: */
+	for (RegNumber=0;RegNumber<=MAX3543_NUMREGS;RegNumber++)
+	{
+//      Max3543_Write(RegNumber, regs[RegNumber]);
+	  if(Max3543_Write(pTuner, RegNumber, pExtra->regs[RegNumber]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+	}
+
+	/* First read calibration constants from MAX3543 and store in global
+      variables for use when setting RF tracking filter */   
+//	MAX3543_ReadROM();
+	if(MAX3543_ReadROM(pTuner) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+   /* Define the IF frequency used.
+		If using non-floating point math, enter the IF Frequency multiplied 
+	   by the factor LOSCALE here as an integer.
+		i.e. IF_Frequency = 1445;
+		If using floating point math, use the scalefrq macro:
+		i.e. IF_Frequency = scalefrq(36.125); 
+	*/
+//	IF_Frequency = scalefrq(36.125); 
+
+
+	// Calculate frequency unit.
+	FreqUnit = MAX3543_CONST_1_MHZ / pExtra->LOSCALE;
+
+	// Set tuner RF frequency in KHz.
+	// Note: 1. CalculatedValue = round(RfFreqHz / FreqUnit)
+	//       2. Call MAX3543 source code function.
+	CalculatedValue = (unsigned short)((pExtra->IfFreqHz + (FreqUnit / 2)) / FreqUnit);
+	pExtra->IF_Frequency = CalculatedValue;
+
+
+	/* Calculate the denominator just once since it is dependant on the xtal freq only.
+	   The denominator is used to calculate the N+FractionalN ratio.  
+	*/
+	pExtra->denominator = pExtra->XTALREF * 4 * pExtra->LOSCALE;   
+
+   /* The fracscale is used to calculate the fractional remainder of the N+FractionalN ratio.  */
+	pExtra->fracscale = 2147483648/pExtra->denominator;
+
+
+//   Note: Set standard mode, channel bandwith, and RF frequency in other functions.
+
+//   MAX3543_Standard(DVB_T, IFOUT1_DIFF_DTVOUT);
+
+//   MAX3543_ChannelBW(BW8MHZ);
+   // Note: Set bandwidth with 8 MHz for QAM.
+   MAX3543_ChannelBW(pTuner, MAX3543_BANDWIDTH_MODE_DEFAULT);
+
+//   MAX3543_SetFrequency(RfFreq);	
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+/* Set the channel bandwidth.  Call with arguments: BW7MHZ or BW8MHZ */
+int MAX3543_ChannelBW(TUNER_MODULE *pTuner, UINT_16 bw)
+{
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+   pExtra->regs[REG3543_MODE] = (pExtra->regs[REG3543_MODE] & 0xef) | (bw<<4);
+//	Max3543_Write(REG3543_MODE, regs[REG3543_MODE]);
+	if(Max3543_Write(pTuner, REG3543_MODE, pExtra->regs[REG3543_MODE]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+/* 
+	Set the broadcast standared and RF signal path.
+	This routine must be called prior to tuning (Set_Frequency() ) 
+	such as in MAX3543_Init() or when necessary to change modes.
+
+	This sub routine has 2 input/function
+	1. bcstd:it set MAX3543 to optimized power detector/bias setting for each standard (dvb-t,pal?, currently it has 4 choice:
+      1.1 bcstd=DVBT, optimized for DVB-T
+      1.2 bcstd=DVBC, optimized for DVB-C
+      1.3 bcstd=ATV1, optimized for PAL/SECAM - B/G/D/K/I
+      1.4 bcstd=ATV2, optimized for SECAM-L
+	2. outputmode: this setting has to match you hardware signal path, it has 3 choice:
+      2.1 outputmode=IFOUT1_DIFF_IFOUT_DIFF
+            signal path: IFOUT1 (pin6/7) driving a diff input IF filter (ie LC filter or 6966 SAW), 
+            then go back to IFVGA input (pin 10/11) and IF output of MAX3543 is pin 15/16. 
+            this is common seting for all DTV_only demod and hybrid demod
+      2.2 outputmode=IFOUT1_SE_IFOUT_DIFF
+            signal path: IFOUT1 (pin6) driving a single-ended input IF filter (ie 7251 SAW)
+            then go back to IFVGA input (pin 10/11) and IF output of MAX3543 is pin 15/16. 
+            this is common seting for all DTV_only demod and hybrid demod
+      2.3 outputmode=IFOUT2
+            signal path: IFOUT2 (pin14) is MAX3543 IF output, normally it drives a ATV demod. 
+            The IFVGA is shutoff
+            this is common setting for separate ATV demod app
+*/
+
+int MAX3543_Standard(TUNER_MODULE *pTuner, standard bcstd, outputmode outmd)
+{
+	char IFSEL;
+	char LNA2G;   
+	char SDIVG;
+	char WPDA;
+	char NPDA; 
+	char RFIFD; 
+	char MIXGM;
+	char LNA2B;
+	char MIXB;
+
+   
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	pExtra->broadcast_standard = bcstd;   /* used later in tuning */
+
+
+	switch ( bcstd )
+      {
+         case DVB_T:
+				LNA2G = 1;
+				WPDA = 4;
+				NPDA = 3;
+				RFIFD = 1;
+				MIXGM = 1;
+				LNA2B = 1;
+				MIXB = 1;
+            break;
+			case DVB_C:
+				LNA2G = 1;
+				WPDA = 3;
+				NPDA = 3;
+				RFIFD = 1;
+				MIXGM = 1;
+				LNA2B = 1;
+				MIXB = 1;
+            break;
+			case ATV:
+				LNA2G = 0;
+				WPDA = 3;
+				NPDA = 5;
+				RFIFD = 2;
+				MIXGM = 0;
+				LNA2B = 3;
+				MIXB = 3;
+            break;
+			case ATV_SECAM_L:
+				LNA2G = 0;
+				WPDA = 3;
+				NPDA = 3;
+				RFIFD = 2;
+				MIXGM = 0;
+				LNA2B = 3;
+				MIXB = 3;
+            break;
+			default:
+				return MAX3543_ERROR;
+		}
+
+	   /* the outmd must be set after the standard mode bits are set. 
+		   Please do not change order.  */
+		switch ( outmd )
+      {
+			case IFOUT1_DIFF_DTVOUT:
+				IFSEL = 0;
+				SDIVG = 0;
+				break;
+			case IFOUT1_SE_DTVOUT:
+				IFSEL = 1;
+				SDIVG = 0;
+				break;
+			case IFOUT2:
+				IFSEL = 2;
+				SDIVG = 1;
+				NPDA = 3;
+				LNA2G = 1;   /* overrites value chosen above for this case */
+				RFIFD = 3;   /* overrites value chosen above for this case */
+				break;
+			default:
+				return MAX3543_ERROR;
+		}	
+	
+
+	/* Mask in each set of bits into the register variables */
+   pExtra->regs[REG3543_MODE] = (pExtra->regs[REG3543_MODE] & 0x7c) | IFSEL | (LNA2G<<7);
+   pExtra->regs[REG3543_SHDN] = (pExtra->regs[REG3543_SHDN] & 0xf7) | (SDIVG<<3);
+   pExtra->regs[REG3543_PD_CFG1] = (pExtra->regs[REG3543_PD_CFG1] & 0x88) | (WPDA<<4) | NPDA;
+   pExtra->regs[REG3543_PD_CFG2] = (pExtra->regs[REG3543_PD_CFG2] & 0xfc) | RFIFD;
+   pExtra->regs[REG3543_BIAS_ADJ] = (pExtra->regs[REG3543_BIAS_ADJ] & 0x13) | (MIXGM<<6) | (LNA2B<<4) | (MIXB<<2);
+
+	/* Send each register variable: */
+//   Max3543_Write(REG3543_MODE, regs[REG3543_MODE]);
+   if(Max3543_Write(pTuner, REG3543_MODE, pExtra->regs[REG3543_MODE]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+//   Max3543_Write(REG3543_SHDN, regs[REG3543_SHDN]);
+   if(Max3543_Write(pTuner, REG3543_SHDN, pExtra->regs[REG3543_SHDN]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+//   Max3543_Write(REG3543_PD_CFG1, regs[REG3543_PD_CFG1]);
+   if(Max3543_Write(pTuner, REG3543_PD_CFG1, pExtra->regs[REG3543_PD_CFG1]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+//   Max3543_Write(REG3543_PD_CFG2, regs[REG3543_PD_CFG2]);
+   if(Max3543_Write(pTuner, REG3543_PD_CFG2, pExtra->regs[REG3543_PD_CFG2]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+//   Max3543_Write(REG3543_BIAS_ADJ, regs[REG3543_BIAS_ADJ]);
+   if(Max3543_Write(pTuner, REG3543_BIAS_ADJ, pExtra->regs[REG3543_BIAS_ADJ]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+
+/*This will set the LO Frequency and all other tuning related register bits.
+
+  NOTE!!!!  The frequency passed to this routine must be scaled by th factor 
+				LOSCALE.  For example if the frequency was 105.25 MHz you multiply
+				this by LOSCALE which results in a whole number frequency.
+				For example if LOSCALE = 20, then 105.25 * 20 = 2105.
+				You would then call: MAX3543_SetFrequency(2105);
+*/
+int MAX3543_SetFrequency(TUNER_MODULE *pTuner, UINT_16 RF_Frequency)		
+{
+	UINT_16 RDiv, NewR, NDiv, Vdiv;
+	UINT_32 Num;
+	UINT_16 LO_Frequency;
+	UINT_16 Rem;
+   UINT_32 FracN;
+
+
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+   LO_Frequency = RF_Frequency + pExtra->IF_Frequency ;
+   
+	/* Determine VCO Divider */
+	if (LO_Frequency < scalefrq(138))  /* 138MHz scaled UHF band */
+	{
+		Vdiv = 3;  /*  divide by 32   */
+	}
+	else if ( LO_Frequency < scalefrq(275))                   /* VHF Band */
+	{
+		Vdiv = 2;  /*  divide by 16   */
+	}
+	else if (LO_Frequency < scalefrq(550))
+	{
+		Vdiv = 1;  /*  divide by 8   */
+	}
+	else
+	{	
+		Vdiv = 0;  /*  divide by 4   */
+	}
+   
+
+	/* calculate the r-divider from the RDIV bits: 
+	 RDIV bits   RDIV
+		00				1
+		01				2
+		10				4
+		11				8
+	*/
+	RDiv = 1<<((pExtra->regs[REG3543_FRAC2] & 0x30) >> 4);  
+   
+	/* Set the R-Divider based on the frequency if in DVB mode.
+      Otherwise set the R-Divider to 2.
+	   Only send RDivider if it needs to change from the current state. 
+	*/
+	NewR = 0;
+	if ((pExtra->broadcast_standard == DVB_T || pExtra->broadcast_standard == DVB_C) )
+	{
+		if ((LO_Frequency <= scalefrq(275)) && (RDiv == 1))
+			NewR = 2;
+		else if ((LO_Frequency > scalefrq(275)) && (RDiv == 2))
+			NewR = 1;
+	}
+	else if (RDiv == 1) 
+		NewR = 2;
+
+	if (NewR != 0){
+		RDiv = NewR;
+		pExtra->regs[REG3543_FRAC2] = (pExtra->regs[REG3543_FRAC2] & 0xcf) | ((NewR-1) <<4);  
+//		Max3543_Write(REG3543_FRAC2, regs[REG3543_FRAC2]);
+		if(Max3543_Write(pTuner, REG3543_FRAC2, pExtra->regs[REG3543_FRAC2]) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;
+	}
+
+	/* Update the VDIV bits in the VCO variable.
+	   we will write this variable out to the VCO register during the MAX3543_SeedVCO routine.
+		We can write over all the other bits (D<7:2>) in that register variable because they
+		will be filled in: MAX3543_SeedVCO later.
+	*/
+	pExtra->regs[REG3543_VCO] = Vdiv;
+
+	/* now convert the Vdiv bits into the multiplier for use in the equation:
+		Vdiv   Mult
+			0      4
+			1      8
+			2      16
+			3      32
+	*/
+	Vdiv = 1<<(Vdiv+2);
+
+
+	//#ifdef HAVE_32BIT_MATH
+
+	/* Calculate Numerator and Denominator for N+FN calculation  */
+	Num = LO_Frequency * RDiv * Vdiv * pExtra->XTALSCALE;
+
+
+	NDiv = (UINT_16) (Num/(UINT_32)pExtra->denominator);   /* Note: this is an integer division, returns 16 bit value. */
+
+//   Max3543_Write(REG3543_NDIV,NDiv); 
+   if(Max3543_Write(pTuner, REG3543_NDIV,NDiv) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner; 
+
+	/* Calculate whole number remainder from division of Num by denom: 
+	   Returns 16 bit value.  */
+	Rem = (UINT_16)(Num - (UINT_32) NDiv * (UINT_32) pExtra->denominator); 
+
+	/* FracN = Rem * 2^20/Denom, Scale 2^20/Denom 2048 X larger for more accuracy. */   
+   /* fracscale = 2^31/denom.  2048 = 2^31/2^20  */
+   FracN =(Rem*pExtra->fracscale)/2048;  
+
+
+
+	/* Optional - Seed the VCO to cause it to tune faster.  
+		(LO_Frequency/LOSCALE) * Vdiv = the unscaled VCO Frequency.
+		It is unscaled to prevent overflow when it is multiplied by vdiv.
+	*/
+//   MAX3543_SeedVCO((LO_Frequency/LOSCALE) * Vdiv);
+   if(MAX3543_SeedVCO(pTuner, (LO_Frequency/pExtra->LOSCALE) * Vdiv) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+
+	pExtra->regs[REG3543_FRAC2] = (pExtra->regs[REG3543_FRAC2] & 0xf0) | ((UINT_16)(FracN >> 16) & 0xf);
+//   Max3543_Write(REG3543_FRAC2, regs[REG3543_FRAC2]); 
+   if(Max3543_Write(pTuner, REG3543_FRAC2, pExtra->regs[REG3543_FRAC2]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner; 
+
+//   Max3543_Write(REG3543_FRAC1,(UINT_16)(FracN >> 8) & 0xff); 
+   if(Max3543_Write(pTuner, REG3543_FRAC1,(UINT_16)(FracN >> 8) & 0xff) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner; 
+
+//   Max3543_Write(REG3543_FRAC0, (UINT_16) FracN & 0xff); 
+   if(Max3543_Write(pTuner, REG3543_FRAC0, (UINT_16) FracN & 0xff) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner; 
+
+   /* Program tracking filters and other frequency dependent registers */
+//   MAX3543_SetTrackingFilter(RF_Frequency);
+   if(MAX3543_SetTrackingFilter(pTuner, RF_Frequency) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+
+
+/*As you tune in frequency, the tracking filter needs
+to be set as a function of frequency.  Stored in the ROM on the
+IC are two end points for the VHFL, VHFH, and UHF frequency bands. 
+This routine performs the necessary function to calculate the
+needed series and parallel capacitor values from these two end
+points for the current frequency.  Once the value is calculated, 
+it is loaded into the Tracking Filter Caps register and the 
+internal capacitors are switched in tuning the tracking 
+filter.
+*/
+int MAX3543_SetTrackingFilter(TUNER_MODULE *pTuner, UINT_16 RF_Frequency)
+{
+	/*  Calculate the series and parallel capacitor values for the given frequency  */
+	/*  band.  These values are then written to the registers.  This causes the     */
+	/*  MAX3543's internal series and parallel capacitors to change thus tuning the */
+	/*  tracking filter to the proper frequency.                                    */
+   
+   UINT_16 TFB, tfs, tfp, RFin, HRF;
+  
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+	
+   /*  Set the TFB Bits (Tracking Filter Band) for the given frequency. */
+	if (RF_Frequency < scalefrq(196))  /* VHF Low Band */
+   {
+        TFB = VHF_L;  
+   }
+   else if (RF_Frequency < scalefrq(440)) /* VHF High  196-440 MHz */
+   {
+        TFB = VHF_H;
+   }
+   else{    /* UHF */
+        TFB = UHF;
+	}
+
+   /*  Set the RFIN bit.  RFIN selects a input low pass filter */
+	if (RF_Frequency < scalefrq(345)){  /* 345 MHz is the change over point. */
+		RFin = 0;
+	}
+	else{
+      RFin = 1;
+	}
+
+	if (RF_Frequency < scalefrq(110)){  /* 110 MHz is the change over point. */
+		HRF = 1;
+	}
+	else{
+      HRF = 0;
+	}
+
+	/* Write the TFB<1:0> Bits and the RFIN bit into the IFOVLD register */
+	/* TFB sets the tracking filter band in the chip, RFIN selects the RF input */
+   pExtra->regs[REG3543_MODE] = (pExtra->regs[REG3543_MODE] & 0x93 ) | (TFB << 2) | (RFin << 6) | (HRF<<5); 
+//   Max3543_Write(REG3543_MODE,(regs[REG3543_MODE])) ;
+   if(Max3543_Write(pTuner, REG3543_MODE,(pExtra->regs[REG3543_MODE])) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+   tfs = tfs_i(pExtra->TFRomCoefs[TFB][SER0], pExtra->TFRomCoefs[TFB][SER1],  RF_Frequency/pExtra->LOSCALE, co[TFB*2]);
+   tfp = tfs_i(pExtra->TFRomCoefs[TFB][PAR0], pExtra->TFRomCoefs[TFB][PAR1],  RF_Frequency/pExtra->LOSCALE, co[(TFB*2)+1]);
+
+	/* Write the TFS Bits into the Tracking Filter Series Capacitor register */
+	if (tfs > 255)   /* 255 = 8 bits of TFS */
+		tfs = 255;
+	if (tfs < 0)
+		tfs = 0;
+   pExtra->regs[REG3543_TFS] = tfs;
+
+	/* Write the TFP Bits into the Tracking Filter Parallel Capacitor register */
+	if (tfp > 63)   /* 63 = 6 bits of TFP  */
+		tfp = 63;
+	if (tfp < 0)
+		tfp = 0;
+   pExtra->regs[REG3543_TFP] = (pExtra->regs[REG3543_TFP] & 0xc0 ) | tfp;
+
+	   /*  Send registers that have been changed */
+   /*  Maxim evkit I2c communication... Replace by microprocessor specific code */
+//   Max3543_Write(REG3543_TFS,(regs[REG3543_TFS])) ;
+   if(Max3543_Write(pTuner, REG3543_TFS,(pExtra->regs[REG3543_TFS])) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+//   Max3543_Write(REG3543_TFP,(regs[REG3543_TFP])) ;
+   if(Max3543_Write(pTuner, REG3543_TFP,(pExtra->regs[REG3543_TFP])) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+
+
+
+
+/* calculate aproximation for Max3540 tracking filter useing integer math only */
+
+UINT_16 tfs_i(UINT_16 S0, UINT_16 S1, UINT_16 FreqRF, const UINT_16 c[5])
+{  UINT_16 i,y,y1,y2,y3,y4,y5,y6,y7,add;
+   UINT_32 res;
+
+/* y=4*((64*c[0])+c[1]*S0)-((64*c[2]-(S1*c[3]))*(FreqRF))/250;   */
+   y1=64*c[0];
+   y2=c[1]*S0;
+   y3=4*(y1+y2);
+   y4=S1*c[3];
+   y5=64*c[2];
+   y6=y5-y4;
+   y7=(y6*(FreqRF))/250;
+   if (y7<y3)
+   { y= y3-y7;
+                    /* above sequence has been choosen to avoid overflows */
+     y=(10*y)/111;                /* approximation for nom*10*LN(10)/256 */
+     add=y; res=100+y;
+     for (i=2; i<12; i++)  
+     { 
+       add=(add*y)/(i*100);       /* this only works with 32bit math */
+       res+=add;
+     }
+   }
+   else 
+     res=0;
+   if (((UINT_32)res+50*1)>((UINT_32)100*c[4])) res=(res+50*1)/100-c[4];
+   else res=0;
+
+   if (res<255) return (UINT_16) res; else return 255;
+}
+
+/*
+   As soon as you program the Frac0 register, a state machine is started to find the
+	correct VCO for the N and Fractional-N values entered.
+	If the VASS bit is set, the search routine will start from the band and	
+	sub-band that is currently programmed into the VCO register (VCO and VSUB bits = seed). 
+	If you seed the register with	bands close to where the auto routine will 
+	finally select, the search routine will finish much faster.
+	This routine determines the best seed to use for the VCO and VSUB values.
+	If VASS is cleared, the search will start as the lowest VCO and search up.
+	This takes much longer.  Make sure VASS is set before using this routine.
+	For the seed value to be read in the VCO register, it must be there prior to
+	setting the Frac0 register.  So call this just before setting the Fractional-N
+	registers.  The VASS bit is bit 5 of register 10 (or REG3543_VAS).
+*/
+int MAX3543_SeedVCO(TUNER_MODULE *pTuner, UINT_16 Fvco){
+   /* Fvco is the VCO frequency in MHz and is not scaled by LOSCALE  */
+	UINT_16 VCO;
+	UINT_16 VSUB;
+
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	if (Fvco  <= 2750)
+	{
+		/* The VCO seed: */
+
+		VCO = 0;
+		/* Determine the VCO sub-band (VSUB) seed:  */
+	   if (Fvco  < 2068)
+         VSUB = 0;
+		else if (Fvco  < 2101)
+         VSUB = 1;
+		else if (Fvco  < 2137)
+         VSUB = 2;
+		else if (Fvco  < 2174)
+         VSUB = 3;
+		else if (Fvco  < 2215)
+         VSUB = 4;
+		else if (Fvco  < 2256)
+         VSUB = 5;
+		else if (Fvco  < 2300)
+         VSUB = 6;
+		else if (Fvco  < 2347)
+         VSUB = 7;
+		else if (Fvco  < 2400)
+         VSUB = 8;
+		else if (Fvco  < 2453)
+         VSUB = 9;
+		else if (Fvco  < 2510)
+         VSUB = 10;
+		else if (Fvco  < 2571)
+         VSUB = 11;
+		else if (Fvco  < 2639)
+         VSUB = 12;
+		else if (Fvco  < 2709)
+         VSUB = 13;
+		else if (Fvco  < 2787)
+         VSUB = 14;
+	}
+	else if (Fvco  <= 3650)
+	{
+		/* The VCO seed: */
+		VCO = 1;
+		/* Determine the VCO sub-band (VSUB) seed:  */
+	   if (Fvco  <= 2792)
+         VSUB = 1;
+		else if (Fvco  <= 2839)
+         VSUB = 2;
+		else if (Fvco  <= 2890)
+         VSUB = 3;
+		else if (Fvco  <= 2944)
+         VSUB = 4;
+		else if (Fvco  <= 3000)
+         VSUB = 5;
+		else if (Fvco  <= 3059)
+         VSUB = 6;
+		else if (Fvco  <= 3122)
+         VSUB = 7;
+		else if (Fvco  <= 3194)
+         VSUB = 8;
+		else if (Fvco  <= 3266)
+         VSUB = 9;
+		else if (Fvco  <= 3342)
+         VSUB = 10;
+		else if (Fvco  <= 3425)
+         VSUB = 11;
+		else if (Fvco  <= 3516)
+         VSUB = 12;
+		else if (Fvco  <= 3612)
+         VSUB = 13;
+		else if (Fvco  <= 3715)
+         VSUB = 14;
+	}
+	else
+	{
+		/* The VCO seed: */
+		VCO = 2;
+		/* Determine the VCO sub-band (VSUB) seed:  */
+	   if (Fvco  <= 3658)
+         VSUB = 0;
+		else if (Fvco  <= 3716)
+         VSUB = 2;
+		else if (Fvco  <= 3776)
+         VSUB = 2;
+		else if (Fvco  <= 3840)
+         VSUB = 3;
+		else if (Fvco  <= 3909)
+         VSUB = 4;
+		else if (Fvco  <= 3980)
+         VSUB = 5;
+		else if (Fvco  <= 4054)
+         VSUB = 6;
+		else if (Fvco  <= 4134)
+         VSUB = 7;
+		else if (Fvco  <= 4226)
+         VSUB = 8;
+		else if (Fvco  <= 4318)
+         VSUB = 9;
+		else if (Fvco  <= 4416)
+         VSUB = 10;
+		else if (Fvco  <= 4520)
+         VSUB = 11;
+		else if (Fvco  <= 4633)
+         VSUB = 12;
+		else if (Fvco  <= 4751)
+         VSUB = 13;
+		else if (Fvco  <= 4876)
+         VSUB = 14;
+		else 
+         VSUB = 15;
+	}
+	/* VCO = D<7:6>, VSUB = D<5:2> */
+	pExtra->regs[REG3543_VCO] = (pExtra->regs[REG3543_VCO] & 3) | (VSUB<<2) | (VCO<<6);
+	/* Program the VCO register with the seed: */
+//	Max3543_Write(REG3543_VCO, regs[REG3543_VCO]);
+	if(Max3543_Write(pTuner, REG3543_VCO, pExtra->regs[REG3543_VCO]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+
+
+/* Returns the lock detect status.  This is accomplished by 
+   examining the ADC value read from the MAX3543.  The ADC
+	value is the tune voltage digitized.  If it is too close to
+	ground or Vcc, the part is unlocked.  The ADC ranges from 0-7.
+	Values 1 to 6 are considered locked.  0 or 7 is unlocked.
+	Returns True for locked, fase for unlocked.
+*/
+int MAX3543_LockDetect(TUNER_MODULE *pTuner, int *pAnswer)
+{
+//   BOOL vcoselected;
+   int vcoselected;
+	UINT_16 tries = 65535;
+	char adc;
+	unsigned short Data;
+
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	/* The ADC will not be stable until the VCO is selected.
+	   usually the selection process will take 25ms or less but
+		it could theoretically take 100ms.  Set tries to some number
+		of your processor clocks corresponding to 100ms.
+		You have to take into account all instructions processed
+		in determining this time.  I am picking a value out of the air
+		for now.
+	*/
+	vcoselected = MAX_FALSE;
+	while ((--tries > 0) && (vcoselected == MAX_FALSE))
+	{
+//		if ((Max3543_Read(REG3543_VAS_STATUS) & 1) == 1)
+		if(Max3543_Read(pTuner, REG3543_VAS_STATUS, &Data) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;
+		if ((Data & 1) == 1)
+			vcoselected = MAX_TRUE;
+	}
+	/* open the ADC latch:  ADL=0, ADE=1  */
+	pExtra->regs[REG3543_VAS] = (pExtra->regs[REG3543_VAS] & 0xf3) | 4;  
+//	Max3543_Write(REG3543_VAS, regs[REG3543_VAS]); 
+	if(Max3543_Write(pTuner, REG3543_VAS, pExtra->regs[REG3543_VAS]) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner; 
+
+	/* ADC = 3 LSBs of Gen Status Register:  */
+//	adc = Max3543_Read(REG3543_GEN_STATUS) & 0x7;
+	if(Max3543_Read(pTuner, REG3543_GEN_STATUS, &Data) != MAX3543_SUCCESS)
+		  goto error_status_access_tuner;
+	adc = Data & 0x7;
+
+
+
+
+	/* locked if ADC within range of 1-6: */
+	if ((adc<1 ) || (adc>6))
+		return MAX_FALSE;
+	else
+		return MAX_TRUE;
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+}
+
+
+
+int MAX3543_ReadROM(TUNER_MODULE *pTuner)
+{
+	unsigned short Data;
+
+   /* Read the ROM table, extract tracking filter ROM coefficients,
+		IRHR and CFSET constants.  
+		This is to be called after the Max3543 powers up.              
+	*/
+	UINT_16 rom_data[11];
+	UINT_16 i;
+
+	MAX3543_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Max3543);
+
+
+	for (i=0; i <= 10; i++)     
+	{
+//		Max3543_Write(REG3543_ROM_ADDR,i);   /*Select ROM Row by setting address register */
+		if(Max3543_Write(pTuner, REG3543_ROM_ADDR,i) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;   /*Select ROM Row by setting address register */
+
+//		rom_data[i] = Max3543_Read(REG3543_ROM_READ);  /* Read from ROMR Register */
+		if(Max3543_Read(pTuner, REG3543_ROM_READ, &Data) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;
+		rom_data[i] = Data;  /* Read from ROMR Register */
+	}
+
+
+	/* The ROM address must be returned to 0 for normal operation or the part will not be biased properly. */
+//	Max3543_Write(REG3543_ROM_ADDR,0);   
+	if(Max3543_Write(pTuner, REG3543_ROM_ADDR,0) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;   
+
+	/* Copy all of ROM Row 10 to Filt_CF register. */
+//	Max3543_Write(REG3543_FILT_CF,rom_data[10]);   
+	if(Max3543_Write(pTuner, REG3543_FILT_CF,rom_data[10]) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;   
+
+	/* Copy the IRHR ROM value to the IRHR register: */
+//	Max3543_Write(REG3543_IRHR, rom_data[0xb]);
+	if(Max3543_Write(pTuner, REG3543_IRHR, rom_data[0xb]) != MAX3543_SUCCESS)
+			goto error_status_access_tuner;
+
+
+	/* assemble the broken up word pairs from the ROM table  into complete ROM coefficients:  */
+	pExtra->TFRomCoefs[VHF_L][SER0] = (rom_data[1] & 0xFC) >> 2;  /*'LS0 )*/
+	pExtra->TFRomCoefs[VHF_L][SER1] = ((rom_data[1] & 0x3 ) << 4) + ((rom_data[2] & 0xf0) >> 4);  /* 'LS1*/
+	pExtra->TFRomCoefs[VHF_L][PAR0] = ((rom_data[2] & 0xf) << 2) + ((rom_data[3] & 0xc0) >> 6);  /*'LP0*/
+	pExtra->TFRomCoefs[VHF_L][PAR1] = rom_data[3] & 0x3f;  /*LP1 */
+
+	pExtra->TFRomCoefs[VHF_H][SER0] = ((rom_data[4] & 0xfc) >> 2);  /*'HS0 */
+	pExtra->TFRomCoefs[VHF_H][SER1] = ((rom_data[4] & 0x3) << 4) + ((rom_data[5] & 0xF0) >> 4);  /*'HS1 */
+	pExtra->TFRomCoefs[VHF_H][PAR0] = ((rom_data[5] & 0xf) << 2) + ((rom_data[6] & 0xc0) >> 6);  /*'HP0 */
+	pExtra->TFRomCoefs[VHF_H][PAR1] = rom_data[6] & 0x3F;  /*'HP1 */
+
+	pExtra->TFRomCoefs[UHF][SER0] =  ((rom_data[7]  & 0xFC) >> 2);  /*'US0 */
+	pExtra->TFRomCoefs[UHF][SER1] = ((rom_data[7] & 0x3) << 4) + ((rom_data[8] & 0xf0) >> 4 );  /*'US1 */
+	pExtra->TFRomCoefs[UHF][PAR0] = ((rom_data[8] & 0xF) << 2) + ((rom_data[9] & 0xc0) >> 6);  /*'UP0 */
+	pExtra->TFRomCoefs[UHF][PAR1] = rom_data[9] & 0x3f;  /*'UP1 */
+
+
+	return MAX3543_SUCCESS;
+
+
+error_status_access_tuner:
+	return MAX3543_ERROR;
+ }
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_max3543.h b/drivers/media/usb/rtl2832u/tuner_max3543.h
new file mode 100644
index 00000000..a65d8bac
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_max3543.h
@@ -0,0 +1,572 @@
+#ifndef __TUNER_MAX3543_H
+#define __TUNER_MAX3543_H
+
+/**
+
+@file
+
+@brief   MAX3543 tuner module declaration
+
+One can manipulate MAX3543 tuner through MAX3543 module.
+MAX3543 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_max3543.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE         *pTuner;
+	MAX3543_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build MAX3543 tuner module.
+	BuildMax3543Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0,								// I2C device address is 0xac in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,			// Crystal frequency is 16.0 MHz.
+		MAX3543_STANDARD_DVBT,				// The MAX3543 standard mode is DVB-T.
+		IF_FREQ_36170000HZ,					// The MAX3543 IF frequency is 36.17 MHz.
+		MAX3543_SAW_INPUT_SE				// The MAX3543 SAW input type is single-ended.
+		);
+
+
+
+
+
+	// Get MAX3543 tuner extra module.
+	pTunerExtra = (MAX3543_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set MAX3543 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, MAX3543_BANDWIDTH_7MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get MAX3543 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is implemented for MAX3543 source code.
+
+
+// Definition (implemeted for MAX3543)
+
+// Function return status
+#define MAX3543_SUCCESS		1
+#define MAX3543_ERROR		0
+
+
+
+// Function (implemeted for MAX3543)
+int
+Max3543_Read(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned short *pData
+	);
+
+int
+Max3543_Write(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned short Data
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by Analog Devices.
+
+
+
+
+
+// MAXIM source code - mxmdef.h
+
+
+
+//#ifndef MXMDEF_H
+//#define MXMDEF_H
+
+#define MAX_PATH          260
+/*
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL    0
+#else
+#define NULL    ((void *)0)
+#endif
+#endif
+
+#ifndef FALSE
+#define FALSE               0
+#endif
+
+#ifndef TRUE
+#define TRUE                1
+#endif
+*/
+
+#define MAX_FALSE		0
+#define MAX_TRUE		1
+
+
+typedef unsigned long       DWORD;
+
+//#endif /* _WINDEF_ */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// MAXIM source code - Max3543_Driver.h
+
+
+
+ /*
+------------------------------------------------------
+| Max3543_Driver.h, v 1.0.3, 12/9/2009, Paul Nichol    
+| Description: Max3543 Driver Includes.                
+|                                                      
+| Copyright (C) 2009 Maxim Integrated Products         
+|                                                      
+------------------------------------------------------
+*/
+
+
+
+
+//#ifndef Max3543_Driver_H
+
+/* integer only mode = 1, floating point mode = 0 */
+//#define intmode 0
+
+
+//#define Max3543_Driver_H
+
+
+#define MAX3543_ADDR 0xc0
+
+#define MAX3543_NUMREGS 0x15
+
+
+/* Register Address offsets.  Used when sending or indexing registers.  */
+#define REG3543_VCO 0
+#define REG3543_NDIV 0x1
+#define REG3543_FRAC2 0x2
+#define REG3543_FRAC1 0x3
+#define REG3543_FRAC0 0x4
+#define REG3543_MODE 0x5
+#define REG3543_TFS 0x6
+#define REG3543_TFP 0x7
+#define REG3543_SHDN 0x8
+#define REG3543_REF 0x9
+#define REG3543_VAS 0xa
+#define REG3543_PD_CFG1 0xb
+#define REG3543_PD_CFG2 0xc
+#define REG3543_FILT_CF 0xd
+#define REG3543_ROM_ADDR 0xe
+#define REG3543_IRHR 0xf
+#define REG3543_ROM_READ 0x10
+#define REG3543_VAS_STATUS 0x11
+#define REG3543_GEN_STATUS 0x12
+#define REG3543_BIAS_ADJ 0x13
+#define REG3543_TEST1 0x14
+#define REG3543_ROM_WRITE 0x15
+
+/* Band constants: */
+#define VHF_L 0
+#define VHF_H 1
+#define UHF 2
+
+/* Channel Bandwidth: */
+#define BW7MHZ 0
+#define BW8MHZ 1
+
+#define SER0 0
+#define SER1 1
+#define PAR0 2
+#define PAR1 3
+
+
+
+
+typedef enum  {IFOUT1_DIFF_DTVOUT, IFOUT1_SE_DTVOUT,IFOUT2} outputmode;
+
+typedef enum {DVB_T, DVB_C, ATV, ATV_SECAM_L} standard;
+
+//standard broadcast_standard;
+
+
+
+/* Note:
+   The SetFrequency() routine must make it's calculations without
+	overflowing 32 bit accumulators.  This is a difficult balance of LO, IF and Xtal frequencies.
+	Scaling factors are applied to these frequencies to keep the numbers below the 32 bit result during
+	caltculations.   The calculations have been checked for only the following combinations of frequencies
+	and settings: Xtal freqencies of 16.0MHz, 20.25 MHz, 20.48 MHz; IF Frequencies of 30.0 MHz and 30.15MHz;
+	R-Dividers /1 and /2.  Any combination of the above numbers may be used.
+	If other combinations or frequencies are needed, the scaling factors: LOSCALE and XTALSCALE must be
+	recalculated.  This has been done in a spreadsheet calc.xls.  Without checking these
+	scale factors carefully, there could be overflow and tuning errors or amplitude losses due to an
+	incorrect tracking filter setting.
+*/
+
+/* Scaling factor for the IF and RF freqencies.
+	Freqencies passed to functions must be multiplied by this factor.
+	(See Note above).
+*/
+//#define LOSCALE 40         
+
+/* Scaling factor for Xtal frequency.  
+   Use 32 for 16.0MHz, 25 for 20.48 and 4 for 20.25MHz.
+	(See Note above).
+*/
+//#define XTALSCALE 4      
+
+//#if intmode
+	/* Macros used for scaling frequency constants.  */
+	/* Use this form if using floating point math. */
+
+#define scalefrq(x) ( (UINT_32) ( ( (UINT_16) x) * (UINT_16) pExtra->LOSCALE ) ) 
+//	#define scalextal(x) ( (UINT_32) ( ( (UINT_16) x ) * (UINT_16) XTALSCALE ) ) 
+
+
+	/* Note, this is a scaling factor for the Xtal Reference applied to the MAX3543 Xtal Pin.
+		The only valid frequencies are 16.0, 20.25 or 20.48MHz and only with the following conditions:
+		RDiv = /1 or RDiv = /2, IF = 36.0MHz, IF = 36.15 MHz. 
+		(See Note above).
+	*/
+//	#define XTALREF 81
+	/* 20.25 * XTALSCALE = 81, where XTALSCALE=4
+		Use this form if NOT using floating point math.
+	*/
+//#else
+	/* Macros used for scaling frequency constants.  */
+	/* Use this form if NOT using floating point math. */
+//		#define scalefrq(x)  ( (unsigned short) ( ( (float) x ) * (float) LOSCALE ) ) 
+//		#define scalextal(x) ( (unsigned short) ( ( (float) x ) * (float) XTALSCALE ) )
+
+	/* Note, this is a scaling factor for the Xtal Reference applied to the MAX3543 Xtal Pin.
+		The only valid frequencies are 16.0, 20.25 or 20.48MHz and only with the following conditions:
+		RDiv = /1 or RDiv = /2, IF = 36.0MHz, IF = 36.15 MHz. 
+		(See Note above).
+	*/
+//	#define XTALREF scalextal(20.25)
+	/* Use this form if NOT using floating point math. */
+	/* #define XTALREF 81          
+	/* (XTALSCALE * Reference frequency 20.24 * 4 = 81) */
+//#endif
+
+
+
+
+#define ATV_SINGLE 2
+
+typedef  short INT_16;          /* compiler type for 16 bit integer */
+typedef  unsigned short UINT_16; /* compiler type for 16 bit unsigned integer */
+typedef  unsigned long UINT_32;  /* compiler type for 32 bit unsigned integer */
+
+typedef enum {IFOUT_1,IFOUT_2} outmd;
+
+//int MAX3543_Init(TUNER_MODULE *pTuner, UINT_16 RfFreq);
+int MAX3543_Init(TUNER_MODULE *pTuner);
+int MAX3543_SetFrequency(TUNER_MODULE *pTuner, UINT_16 RF_Frequency);
+//unsigned short MAX3543_Read(UINT_16 reg);
+//void MAX3543_Write(UINT_16 reg, UINT_16 value);
+int MAX3543_LockDetect(TUNER_MODULE *pTuner, int *pAnswer);
+int MAX3543_Standard(TUNER_MODULE *pTuner, standard bcstd, outputmode outmd);
+int MAX3543_ChannelBW(TUNER_MODULE *pTuner, UINT_16 bw);
+int MAX3543_SetTrackingFilter(TUNER_MODULE *pTuner, UINT_16 RF_Frequency);
+int MAX3543_ReadROM(TUNER_MODULE *pTuner);
+UINT_16 tfs_i(UINT_16 S0, UINT_16 S1, UINT_16 FreqRF, const UINT_16 c[5]);
+int MAX3543_SeedVCO(TUNER_MODULE *pTuner, UINT_16 Fvco);
+
+
+/******* External functions called by Max3543 code *******/
+
+
+		/*   The implementation of these functions is left for the end user.  */
+		/*   This is because of the many different microcontrollers and serial */
+		/*   I/O methods that can be used.  */
+
+//    void  Max3543_Write(unsigned short RegAddr, unsigned short data);
+
+		/*   This function sends out a byte of data using the following format.    */
+		/*   Start, IC_address, ACK, Register Address, Ack, Data, Ack, Stop */
+
+		/*   IC_address is 0xC0 or 0xC4 depending on JP8 of the Max3543 evkit board. */
+		/*   0xC0 if the ADDR pin of the Max3543 is low, x0C4 if the pin is high. */
+		/*   The register address is the Index into the register /*
+		/*   you wish to fill.*/
+
+//    unsigned short Max3543_Read(unsigned short reg);
+
+    /*   This reads and returns a byte from the Max3543.    */
+    /*   The read sequence is: */
+    /*   Start, IC_address, ACK, Register Address, ack, Start, DeviceReadAddress, ack, */
+	 /*   Data, NAck, Stop */
+    /*   Note that there is a IC_Address (0xC0 or 0xC4 as above) and a Device Read */
+	 /*   Address which is the IC_Address + 1  (0xC1 or 0xC5).    */
+    /*   There are also two start conditions in the read back sequence. */
+    /*   The Register Address is an index into the register you */
+	 /*   wish to read back. */
+
+
+//#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is MAX3543 tuner API source code
+
+
+
+
+
+// Definitions
+
+// Standard mode
+enum MAX3543_STANDARD_MODE
+{
+	MAX3543_STANDARD_DVBT = DVB_T,
+	MAX3543_STANDARD_QAM  = DVB_C,
+};
+
+
+// Bandwidth mode
+enum MAX3543_BANDWIDTH_MODE
+{
+	MAX3543_BANDWIDTH_7000000HZ = BW7MHZ,
+	MAX3543_BANDWIDTH_8000000HZ = BW8MHZ,
+};
+
+
+// SAW input type
+enum MAX3543_SAW_INPUT_TYPE
+{
+	MAX3543_SAW_INPUT_DIFF = IFOUT1_DIFF_DTVOUT,
+	MAX3543_SAW_INPUT_SE   = IFOUT1_SE_DTVOUT,
+};
+
+
+
+// Default for initialing
+#define MAX3543_RF_FREQ_HZ_DEFAULT			474000000
+#define MAX3543_BANDWIDTH_MODE_DEFAULT		MAX3543_BANDWIDTH_8000000HZ
+
+
+// Definition for RF frequency setting.
+#define MAX3543_CONST_1_MHZ		1000000
+
+
+
+
+
+// Builder
+void
+BuildMax3543Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int StandardMode,
+	unsigned long IfFreqHz,
+	int OutputMode
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+max3543_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+max3543_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+max3543_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+max3543_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+max3543_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+max3543_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+max3543_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_mt2063.c b/drivers/media/usb/rtl2832u/tuner_mt2063.c
new file mode 100644
index 00000000..2ca161e8
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mt2063.c
@@ -0,0 +1,5264 @@
+/**
+
+@file
+
+@brief   MT2063 tuner module definition
+
+One can manipulate MT2063 tuner through MT2063 module.
+MT2063 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_mt2063.h"
+
+
+
+
+
+/**
+
+@brief   MT2063 tuner module builder
+
+Use BuildMt2063Module() to build MT2063 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to MT2063 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   MT2063 I2C device address
+@param [in]   IfFreqHz                     MT2063 output IF frequency in Hz
+@param [in]   StandardMode                 Standard mode
+@param [in]   IfVgaGainControl             IF VGA gain control
+
+
+@note
+	-# One should call BuildMt2063Module() to build MT2063 module before using it.
+
+*/
+void
+BuildMt2063Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	int StandardMode,
+	unsigned long VgaGc
+	)
+{
+	TUNER_MODULE *pTuner;
+	MT2063_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_MT2063;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = mt2063_GetTunerType;
+	pTuner->GetDeviceAddr = mt2063_GetDeviceAddr;
+
+	pTuner->Initialize    = mt2063_Initialize;
+	pTuner->SetRfFreqHz   = mt2063_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = mt2063_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->StandardMode     = StandardMode;
+	pExtra->VgaGc            = VgaGc;
+	pExtra->IsIfFreqHzSet    = NO;
+	pExtra->IsBandwidthHzSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->OpenHandle     = mt2063_OpenHandle;
+	pExtra->CloseHandle    = mt2063_CloseHandle;
+	pExtra->GetHandle      = mt2063_GetHandle;
+	pExtra->SetIfFreqHz    = mt2063_SetIfFreqHz;
+	pExtra->GetIfFreqHz    = mt2063_GetIfFreqHz;
+	pExtra->SetBandwidthHz = mt2063_SetBandwidthHz;
+	pExtra->GetBandwidthHz = mt2063_GetBandwidthHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+mt2063_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+mt2063_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+mt2063_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Re-initialize tuner.
+	Status = MT2063_ReInit(DeviceHandle);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_execute_function;
+
+
+	// Set tuner output bandwidth.
+//	Status = MT2063_SetParam(DeviceHandle, MT2063_OUTPUT_BW, MT2063_BANDWIDTH_6MHZ);
+
+//	if(MT_IS_ERROR(Status))
+//		goto error_status_execute_function;
+
+
+	// Set tuner parameters according to standard mode.
+	switch(pExtra->StandardMode)
+	{
+		default:
+		case MT2063_STANDARD_DVBT:
+
+			Status = MT2063_SetParam(DeviceHandle, MT2063_RCVR_MODE, MT2063_OFFAIR_COFDM);
+
+			if(MT_IS_ERROR(Status))
+				goto error_status_execute_function;
+
+			break;
+
+
+		case MT2063_STANDARD_QAM:
+
+			Status = MT2063_SetParam(DeviceHandle, MT2063_RCVR_MODE, MT2063_CABLE_QAM);
+
+			if(MT_IS_ERROR(Status))
+				goto error_status_execute_function;
+
+			break;
+	}
+
+
+	// Set tuner VGAGC with IF AGC gain control setting value.
+	Status = MT2063_SetParam(DeviceHandle, MT2063_VGAGC, (UData_t)(pExtra->VgaGc));
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_execute_function;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+mt2063_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Set tuner RF frequency in Hz.
+	Status = MT2063_Tune(DeviceHandle, RfFreqHz);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+mt2063_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Open MT2063 tuner handle.
+
+*/
+int
+mt2063_OpenHandle(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	unsigned char DeviceAddr;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner I2C device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Open MT2063 handle.
+	// Note: 1. Must take tuner extra module DeviceHandle as handle input argument.
+	//       2. Take pTuner as user-defined data input argument.
+	Status = MT2063_Open(DeviceAddr, &pExtra->DeviceHandle, pTuner);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_open_mt2063_handle;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_open_mt2063_handle:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Close MT2063 tuner handle.
+
+*/
+int
+mt2063_CloseHandle(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Close MT2063 handle.
+	Status = MT2063_Close(DeviceHandle);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_open_mt2063_handle;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_open_mt2063_handle:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MT2063 tuner handle.
+
+*/
+void
+mt2063_GetHandle(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	*pDeviceHandle = pExtra->DeviceHandle;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set MT2063 tuner IF frequency in Hz.
+
+*/
+int
+mt2063_SetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long IfFreqHz
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+	unsigned int IfFreqHzUint;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Set tuner output IF frequency.
+	IfFreqHzUint = (unsigned int)IfFreqHz;
+	Status = MT2063_SetParam(DeviceHandle, MT2063_OUTPUT_FREQ, IfFreqHzUint);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_execute_function;
+
+
+	// Set tuner IF frequnecy parameter in tuner extra module.
+	pExtra->IfFreqHz      = IfFreqHz;
+	pExtra->IsIfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_execute_function:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MT2063 tuner IF frequency in Hz.
+
+*/
+int
+mt2063_GetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+
+	// Get tuner IF frequency in Hz from tuner extra module.
+	if(pExtra->IsIfFreqHzSet != YES)
+		goto error_status_get_demod_if_frequency;
+
+	*pIfFreqHz = pExtra->IfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_demod_if_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set MT2063 tuner bandwidth in Hz.
+
+*/
+// Note: The function MT2063_SetParam() only sets software bandwidth variables,
+//       so execute MT2063_Tune() after this function.
+int
+mt2063_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+//	unsigned long BandwidthHzWithShift;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Set tuner bandwidth in Hz with shift.
+//	BandwidthHzWithShift = BandwidthHz - MT2063_BANDWIDTH_SHIFT_HZ;
+//	Status = MT2063_SetParam(DeviceHandle, MT2063_OUTPUT_BW, BandwidthHzWithShift);
+	Status = MT2063_SetParam(DeviceHandle, MT2063_OUTPUT_BW, BandwidthHz);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_set_tuner_bandwidth;
+
+
+	// Set tuner bandwidth parameter.
+	pExtra->BandwidthHz      = BandwidthHz;
+	pExtra->IsBandwidthHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MT2063 tuner bandwidth in Hz.
+
+*/
+int
+mt2063_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	)
+{
+	MT2063_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2063);
+
+
+	// Get tuner bandwidth in Hz from tuner module.
+	if(pExtra->IsBandwidthHzSet != YES)
+		goto error_status_get_tuner_bandwidth;
+
+	*pBandwidthHz = pExtra->BandwidthHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Microtune source code - mt_userdef.c
+
+
+/*****************************************************************************
+**
+**  Name: mt_userdef.c
+**
+**  Description:    User-defined MicroTuner software interface 
+**
+**  Functions
+**  Requiring
+**  Implementation: MT_WriteSub
+**                  MT_ReadSub
+**                  MT_Sleep
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_userdef.c,v 1.2 2008/11/05 13:46:20 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt_userdef.c,v $
+**	               
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+//#include "mt_userdef.h"
+
+
+/*****************************************************************************
+**
+**  Name: MT_WriteSub
+**
+**  Description:    Write values to device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to write data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2063_WriteSub(Handle_t hUserData, 
+                    UData_t addr, 
+                    U8Data subAddress, 
+                    U8Data *pData, 
+                    UData_t cnt)
+{
+//    UData_t status = MT_OK;                  /* Status to be returned        */
+    /*
+    **  ToDo:  Add code here to implement a serial-bus write
+    **         operation to the MTxxxx tuner.  If successful,
+    **         return MT_OK.
+    */
+/*  return status;  */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned int i, j;
+
+	unsigned char RegStartAddr;
+	unsigned char *pWritingBytes;
+	unsigned long ByteNum;
+
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+
+
+
+	// Get tuner module, base interface, and I2C bridge.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+	pI2cBridge     = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Get regiser start address, writing bytes, and byte number.
+	RegStartAddr  = subAddress;
+	pWritingBytes = pData;
+	ByteNum       = (unsigned long)cnt;
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set tuner register bytes with writing bytes.
+	// Note: Set tuner register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = RegStartAddr + i;
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of tuner register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) +
+		//       stop_bit
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set tuner register bytes with writing buffer.
+		if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, WritingByteNum + LEN_1_BYTE) != 
+			FUNCTION_SUCCESS)
+			goto error_status_set_tuner_registers;
+	}
+
+
+	return MT_OK;
+
+
+error_status_set_tuner_registers:
+	return MT_COMM_ERR;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_ReadSub
+**
+**  Description:    Read values from device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to read data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2063_ReadSub(Handle_t hUserData, 
+                   UData_t addr, 
+                   U8Data subAddress, 
+                   U8Data *pData, 
+                   UData_t cnt)
+{
+//    UData_t status = MT_OK;                        /* Status to be returned        */
+
+    /*
+    **  ToDo:  Add code here to implement a serial-bus read
+    **         operation to the MTxxxx tuner.  If successful,
+    **         return MT_OK.
+    */
+/*  return status;  */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned int i;
+
+	unsigned char RegStartAddr;
+	unsigned char *pReadingBytes;
+	unsigned long ByteNum;
+
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+
+	// Get tuner module, base interface, and I2C bridge.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+	pI2cBridge     = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Get regiser start address, writing bytes, and byte number.
+	RegStartAddr  = subAddress;
+	pReadingBytes = pData;
+	ByteNum       = (unsigned long)cnt;
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get tuner register bytes.
+	// Note: Get tuner register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = RegStartAddr + i;
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set tuner register reading address.
+		// Note: The I2C format of tuner register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegReadingAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_tuner_register_reading_address;
+
+		// Get tuner register bytes.
+		// Note: The I2C format of tuner register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_tuner_registers;
+	}
+
+
+	return MT_OK;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return MT_COMM_ERR;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_Sleep
+**
+**  Description:    Delay execution for "nMinDelayTime" milliseconds
+**
+**  Parameters:     hUserData     - User-specific I/O parameter that was
+**                                  passed to tuner's Open function.
+**                  nMinDelayTime - Delay time in milliseconds
+**
+**  Returns:        None.
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code that
+**                  blocks execution for the specified period of time. 
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+void MT2063_Sleep(Handle_t hUserData, 
+              UData_t nMinDelayTime)
+{
+    /*
+    **  ToDo:  Add code here to implement a OS blocking
+    **         for a period of "nMinDelayTime" milliseconds.
+    */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get tuner module, base interface.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+
+
+	// Wait nMinDelayTime milliseconds.
+	pBaseInterface->WaitMs(pBaseInterface, nMinDelayTime);
+
+
+	return;
+}
+
+
+#if defined(MT2060_CNT)
+#if MT2060_CNT > 0
+/*****************************************************************************
+**
+**  Name: MT_TunerGain  (MT2060 only)
+**
+**  Description:    Measure the relative tuner gain using the demodulator
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  pMeas      - Tuner gain (1/100 of dB scale).
+**                               ie. 1234 = 12.34 (dB)
+**
+**  Returns:        status:
+**                      MT_OK  - No errors
+**                      user-defined errors could be set
+**
+**  Notes:          This is a callback function that is called from the
+**                  the 1st IF location routine.  You MUST provide
+**                  code that measures the relative tuner gain in a dB
+**                  (not linear) scale.  The return value is an integer
+**                  value scaled to 1/100 of a dB.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-16-2004    DAD    Original
+**   N/A   11-30-2004    DAD    Renamed from MT_DemodInputPower.  This name
+**                              better describes what this function does.
+**
+*****************************************************************************/
+UData_t MT_TunerGain(Handle_t hUserData,
+                     SData_t* pMeas)
+{
+    UData_t status = MT_OK;                        /* Status to be returned        */
+
+    /*
+    **  ToDo:  Add code here to return the gain / power level measured
+    **         at the input to the demodulator.
+    */
+
+
+
+    return (status);
+}
+#endif
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt_2063.c
+
+
+/*****************************************************************************
+**
+**  Name: mt2063.c
+**
+**  Copyright 2007-2008 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt2063.c
+**
+**  Description:    Microtune MT2063 B0, B1 & B3 Tuner software interface
+**                  Supports tuners with Part/Rev code: 0x9B - 0x9E.
+**
+**  Functions
+**  Implemented:    UData_t  MT2063_Open
+**                  UData_t  MT2063_Close
+**                  UData_t  MT2063_ClearPowerMaskBits
+**                  UData_t  MT2063_GetGPIO
+**                  UData_t  MT2063_GetLocked
+**                  UData_t  MT2063_GetParam
+**                  UData_t  MT2063_GetPowerMaskBits
+**                  UData_t  MT2063_GetReg
+**                  UData_t  MT2063_GetTemp
+**                  UData_t  MT2063_GetUserData
+**                  UData_t  MT2063_ReInit
+**                  UData_t  MT2063_SetGPIO
+**                  UData_t  MT2063_SetParam
+**                  UData_t  MT2063_SetPowerMaskBits
+**                  UData_t  MT2063_SetReg
+**                  UData_t  MT2063_Tune
+**
+**  References:     AN-00189: MT2063 Programming Procedures Application Note
+**                  MicroTune, Inc.
+**                  AN-00010: MicroTuner Serial Interface Application Note
+**                  MicroTune, Inc.
+**
+**  Exports:        None
+**
+**  Dependencies:   MT_ReadSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Read byte(s) of data from the two-wire bus.
+**
+**                  MT_WriteSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Write byte(s) of data to the two-wire bus.
+**
+**                  MT_Sleep(hUserData, nMinDelayTime);
+**                  - Delay execution for nMinDelayTime milliseconds
+**
+**  CVS ID:         $Id: mt2063.c,v 1.6 2009/04/29 09:58:14 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt2063.c,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   N/A   08-01-2007    PINZ   Ver 1.01: Changed Analog &DVB-T settings and added
+**                                        SAW-less receiver mode.
+**   148   09-04-2007    RSK    Ver 1.02: Corrected logic of Reg 3B Reference
+**   153   09-07-2007    RSK    Ver 1.03: Lock Time improvements
+**   150   09-10-2007    RSK    Ver 1.04: Added GetParam/SetParam support for
+**                                        LO1 and LO2 freq for PHY-21 cal.
+**   154   09-13-2007    RSK    Ver 1.05: Get/SetParam changes for LOx_FREQ
+**   155   10-01-2007    DAD    Ver 1.06: Add receiver mode for SECAM positive
+**                                        modulation
+**                                        (MT2063_ANALOG_TV_POS_NO_RFAGC_MODE)
+**   N/A   10-22-2007    PINZ   Ver 1.07: Changed some Registers at init to have
+**                                        the same settings as with MT Launcher
+**   N/A   10-30-2007    PINZ             Add SetParam VGAGC & VGAOI
+**                                        Add SetParam DNC_OUTPUT_ENABLE
+**                                        Removed VGAGC from receiver mode,
+**                                        default now 3
+**   N/A   10-31-2007    PINZ   Ver 1.08: Add SetParam TAGC, removed from rcvr-mode
+**                                        Add SetParam AMPGC, removed from rcvr-mode
+**                                        Corrected names of GCU values
+**                                        reorganized receiver modes, removed,
+**                                        (MT2063_ANALOG_TV_POS_NO_RFAGC_MODE)
+**                                        Actualized Receiver-Mode values
+**   N/A   11-12-2007    PINZ   Ver 1.09: Actualized Receiver-Mode values
+**   N/A   11-27-2007    PINZ             Improved buffered writing
+**         01-03-2008    PINZ   Ver 1.10: Added a trigger of BYPATNUP for
+**                                        correct wakeup of the LNA after shutdown
+**                                        Set AFCsd = 1 as default
+**                                        Changed CAP1sel default
+**         01-14-2008    PINZ   Ver 1.11: Updated gain settings, default for VGAGC 3
+**   173 M 01-23-2008    RSK    Ver 1.12: Read LO1C and LO2C registers from HW
+**                                        in GetParam.
+**         03-18-2008    PINZ   Ver 1.13: Added Support for MT2063 B3
+**         04-10-2008    PINZ   Ver 1.14: Use software-controlled ClearTune
+**                                        cross-over frequency values.
+**                                        Documentation Updates
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   189 S 05-13-2008    PINZ   Ver 1.16: Correct location for ExtSRO control.
+**                                        Add control to avoid DECT freqs.
+**                                        Updated Receivermodes for MT2063 B3
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         07-10-2008    PINZ   Ver 1.19: Documentation Updates, Add a GetParam
+**                                        for each SetParam (LNA_RIN, TGTs)
+**         08-05-2008    PINZ   Ver 1.20: Disable SDEXT pin while MT2063_ReInit
+**                                        with MT2063B3
+**         09-18-2008    PINZ   Ver 1.22: Updated values for CTFILT_SW
+**   205 M 10-01-2008    JWS    Ver 1.23: Use DMAX when LO2 FracN is near 4096
+**       M 10-24-2008    JWS    Ver 1.25: Use DMAX when LO1 FracN is 32
+**         11-05-2008    PINZ   Ver 1.26: Minor code fixes
+**         01-07-2009    PINZ   Ver 1.27: Changed value of MT2063_ALL_SD in .h
+**         01-20-2009    PINZ   Ver 1.28: Fixed a compare to avoid compiler warning
+**         02-16-2009    PINZ   Ver 1.29: Several fixes to improve compiler behavior
+**   N/A I 02-26-2009    PINZ   Ver 1.30: RCVRmode 2: acfifmax 29->0, pd2tgt 33->34
+**                                        RCVRmode 4: acfifmax 29->0, pd2tgt 30->34
+**   N/A I 03-02-2009    PINZ   Ver 1.31: new default Fout 43.75 -> 36.125MHz
+**                                        new default Output-BW 6 -> 8MHz
+**                                        new default Stepsize 50 -> 62.5kHz
+**                                        new default Fin 651 -> 666 MHz
+**                                        Changed order of receiver-mode init
+**   N/A I 03-19-2009    PINZ   Ver 1.32: Add GetParam VERSION (of API)
+**                                        Add GetParam IC_REV
+**   N/A I 04-22-2009    PINZ   Ver 1.33: Small fix in GetParam PD1/PD2
+**   N/A I 04-29-2009    PINZ   Ver 1.34: Optimized ReInit function
+**
+*****************************************************************************/
+//#include "mt2063.h"
+//#include "mt_spuravoid.h"
+//#include <stdlib.h>               /*  for NULL      */
+#define MT_NULL			0
+
+/*  Version of this module                          */
+#define MT2063_VERSION 10304             /*  Version 01.34 */
+
+
+/*
+**  The expected version of MT_AvoidSpursData_t
+**  If the version is different, an updated file is needed from Microtune
+*/
+/* Expecting version 1.21 of the Spur Avoidance API */
+#define EXPECTED_MT_AVOID_SPURS_INFO_VERSION  010201
+
+#if MT2063_AVOID_SPURS_INFO_VERSION < EXPECTED_MT_AVOID_SPURS_INFO_VERSION
+#error Contact Microtune for a newer version of MT_SpurAvoid.c
+#elif MT2063_AVOID_SPURS_INFO_VERSION > EXPECTED_MT_AVOID_SPURS_INFO_VERSION
+#error Contact Microtune for a newer version of mt2063.c
+#endif
+
+#ifndef MT2063_CNT
+#error You must define MT2063_CNT in the "mt_userdef.h" file
+#endif
+
+
+/*
+**  Two-wire serial bus subaddresses of the tuner registers.
+**  Also known as the tuner's register addresses.
+*/
+enum MT2063_Register_Offsets
+{
+    PART_REV = 0,   /*  0x00: Part/Rev Code         */
+    LO1CQ_1,        /*  0x01: LO1C Queued Byte 1    */
+    LO1CQ_2,        /*  0x02: LO1C Queued Byte 2    */
+    LO2CQ_1,        /*  0x03: LO2C Queued Byte 1    */
+    LO2CQ_2,        /*  0x04: LO2C Queued Byte 2    */
+    LO2CQ_3,        /*  0x05: LO2C Queued Byte 3    */
+    RSVD_06,        /*  0x06: Reserved              */
+    LO_STATUS,      /*  0x07: LO Status             */
+    FIFFC,          /*  0x08: FIFF Center           */
+    CLEARTUNE,      /*  0x09: ClearTune Filter      */
+    ADC_OUT,        /*  0x0A: ADC_OUT               */
+    LO1C_1,         /*  0x0B: LO1C Byte 1           */
+    LO1C_2,         /*  0x0C: LO1C Byte 2           */
+    LO2C_1,         /*  0x0D: LO2C Byte 1           */
+    LO2C_2,         /*  0x0E: LO2C Byte 2           */
+    LO2C_3,         /*  0x0F: LO2C Byte 3           */
+    RSVD_10,        /*  0x10: Reserved              */
+    PWR_1,          /*  0x11: PWR Byte 1            */
+    PWR_2,          /*  0x12: PWR Byte 2            */
+    TEMP_STATUS,    /*  0x13: Temp Status           */
+    XO_STATUS,      /*  0x14: Crystal Status        */
+    RF_STATUS,      /*  0x15: RF Attn Status        */
+    FIF_STATUS,     /*  0x16: FIF Attn Status       */
+    LNA_OV,         /*  0x17: LNA Attn Override     */
+    RF_OV,          /*  0x18: RF Attn Override      */
+    FIF_OV,         /*  0x19: FIF Attn Override     */
+    LNA_TGT,        /*  0x1A: Reserved              */
+    PD1_TGT,        /*  0x1B: Pwr Det 1 Target      */
+    PD2_TGT,        /*  0x1C: Pwr Det 2 Target      */
+    RSVD_1D,        /*  0x1D: Reserved              */
+    RSVD_1E,        /*  0x1E: Reserved              */
+    RSVD_1F,        /*  0x1F: Reserved              */
+    RSVD_20,        /*  0x20: Reserved              */
+    BYP_CTRL,       /*  0x21: Bypass Control        */
+    RSVD_22,        /*  0x22: Reserved              */
+    RSVD_23,        /*  0x23: Reserved              */
+    RSVD_24,        /*  0x24: Reserved              */
+    RSVD_25,        /*  0x25: Reserved              */
+    RSVD_26,        /*  0x26: Reserved              */
+    RSVD_27,        /*  0x27: Reserved              */
+    FIFF_CTRL,      /*  0x28: FIFF Control          */
+    FIFF_OFFSET,    /*  0x29: FIFF Offset           */
+    CTUNE_CTRL,     /*  0x2A: Reserved              */
+    CTUNE_OV,       /*  0x2B: Reserved              */
+    CTRL_2C,        /*  0x2C: Reserved              */
+    FIFF_CTRL2,     /*  0x2D: Fiff Control          */
+    RSVD_2E,        /*  0x2E: Reserved              */
+    DNC_GAIN,       /*  0x2F: DNC Control           */
+    VGA_GAIN,       /*  0x30: VGA Gain Ctrl         */
+    RSVD_31,        /*  0x31: Reserved              */
+    TEMP_SEL,       /*  0x32: Temperature Selection */
+    RSVD_33,        /*  0x33: Reserved              */
+    FN_CTRL,        /*  0x34: FracN Control         */
+    RSVD_35,        /*  0x35: Reserved              */
+    RSVD_36,        /*  0x36: Reserved              */
+    RSVD_37,        /*  0x37: Reserved              */
+    RSVD_38,        /*  0x38: Reserved              */
+    RSVD_39,        /*  0x39: Reserved              */
+    RSVD_3A,        /*  0x3A: Reserved              */
+    RSVD_3B,        /*  0x3B: Reserved              */
+    RSVD_3C,        /*  0x3C: Reserved              */
+    END_REGS
+};
+
+
+/*
+** Constants used by the tuning algorithm
+*/
+#define REF_FREQ          (16000000)  /* Reference oscillator Frequency (in Hz) */
+#define IF1_BW            (22000000)  /* The IF1 filter bandwidth (in Hz) */
+#define TUNE_STEP_SIZE       (62500)  /* Tune in steps of 62.5 kHz */
+#define SPUR_STEP_HZ        (250000)  /* Step size (in Hz) to move IF1 when avoiding spurs */
+#define ZIF_BW             (2000000)  /* Zero-IF spur-free bandwidth (in Hz) */
+#define MAX_HARMONICS_1         (15)  /* Highest intra-tuner LO Spur Harmonic to be avoided */
+#define MAX_HARMONICS_2          (5)  /* Highest inter-tuner LO Spur Harmonic to be avoided */
+#define MIN_LO_SEP         (1000000)  /* Minimum inter-tuner LO frequency separation */
+#define LO1_FRACN_AVOID          (0)  /* LO1 FracN numerator avoid region (in Hz) */
+#define LO2_FRACN_AVOID     (199999)  /* LO2 FracN numerator avoid region (in Hz) */
+#define MIN_FIN_FREQ      (44000000)  /* Minimum input frequency (in Hz) */
+#define MAX_FIN_FREQ    (1100000000)  /* Maximum input frequency (in Hz) */
+#define DEF_FIN_FREQ     (666000000)  /* Default frequency at initialization (in Hz) */
+#define MIN_FOUT_FREQ     (36000000)  /* Minimum output frequency (in Hz) */
+#define MAX_FOUT_FREQ     (57000000)  /* Maximum output frequency (in Hz) */
+#define MIN_DNC_FREQ    (1293000000)  /* Minimum LO2 frequency (in Hz) */
+#define MAX_DNC_FREQ    (1614000000)  /* Maximum LO2 frequency (in Hz) */
+#define MIN_UPC_FREQ    (1396000000)  /* Minimum LO1 frequency (in Hz) */
+#define MAX_UPC_FREQ    (2750000000U) /* Maximum LO1 frequency (in Hz) */
+
+
+typedef struct
+{
+    Handle_t    handle;
+    Handle_t    hUserData;
+    UData_t     address;
+    UData_t     version;
+    UData_t     tuner_id;
+    MT2063_AvoidSpursData_t AS_Data;
+    UData_t     f_IF1_actual;
+    UData_t     rcvr_mode;
+    UData_t     ctfilt_sw;
+    UData_t     CTFiltMax[31];
+    UData_t     num_regs;
+    U8Data      reg[END_REGS];
+}  MT2063_Info_t;
+
+static UData_t nMaxTuners = MT2063_CNT;
+static MT2063_Info_t MT2063_Info[MT2063_CNT];
+static MT2063_Info_t *Avail[MT2063_CNT];
+static UData_t nOpenTuners = 0;
+
+
+/*
+**  Constants for setting receiver modes.
+**  (6 modes defined at this time, enumerated by MT2063_RCVR_MODES)
+**  (DNC1GC & DNC2GC are the values, which are used, when the specific
+**   DNC Output is selected, the other is always off)
+**
+**   If PAL-L or L' is received, set:
+**       MT2063_SetParam(hMT2063,MT2063_TAGC,1);
+**
+**                --------------+----------------------------------------------
+**                 Mode 0 :     | MT2063_CABLE_QAM
+**                 Mode 1 :     | MT2063_CABLE_ANALOG
+**                 Mode 2 :     | MT2063_OFFAIR_COFDM
+**                 Mode 3 :     | MT2063_OFFAIR_COFDM_SAWLESS
+**                 Mode 4 :     | MT2063_OFFAIR_ANALOG
+**                 Mode 5 :     | MT2063_OFFAIR_8VSB
+**                --------------+----+----+----+----+-----+-----+--------------
+**                 Mode         |  0 |  1 |  2 |  3 |  4  |  5  |
+**                --------------+----+----+----+----+-----+-----+
+**
+**
+*/
+static const U8Data RFAGCEN[]  = {  0,   0,   0,   0,   0,   0 };
+static const U8Data LNARIN[]   = {  0,   0,   3,   3,   3,   3 };
+static const U8Data FIFFQEN[]  = {  1,   1,   1,   1,   1,   1 };
+static const U8Data FIFFQ[]    = {  0,   0,   0,   0,   0,   0 };
+static const U8Data DNC1GC[]   = {  0,   0,   0,   0,   0,   0 };
+static const U8Data DNC2GC[]   = {  0,   0,   0,   0,   0,   0 };
+static const U8Data ACLNAMAX[] = { 31,  31,  31,  31,  31,  31 };
+static const U8Data LNATGT[]   = { 44,  43,  43,  43,  43,  43 };
+static const U8Data RFOVDIS[]  = {  0,   0,   0,   0,   0,   0 };
+static const U8Data ACRFMAX[]  = { 31,  31,  31,  31,  31,  31 };
+static const U8Data PD1TGT[]   = { 36,  36,  38,  38,  36,  38 };
+static const U8Data FIFOVDIS[] = {  0,   0,   0,   0,   0,   0 };
+static const U8Data ACFIFMAX[] = { 29,   0,  29,  29,   0,  29 };
+static const U8Data PD2TGT[]   = { 40,  34,  38,  42,  34,  38 };
+
+
+static const UData_t df_dosc[] = {
+     55000, 127000, 167000, 210000,  238000, 267000, 312000, 350000,
+    372000, 396000, 410000, 421000,  417000, 408000, 387000, 278000,
+    769000, 816000, 824000, 848000,  903000, 931000, 934000, 961000,
+    969000, 987000,1005000,1017000, 1006000, 840000, 850000, 0
+    };
+
+
+/*  Forward declaration(s):  */
+static UData_t CalcLO1Mult(UData_t *Div, UData_t *FracN, UData_t f_LO, UData_t f_LO_Step, UData_t f_Ref);
+static UData_t CalcLO2Mult(UData_t *Div, UData_t *FracN, UData_t f_LO, UData_t f_LO_Step, UData_t f_Ref);
+static UData_t fLO_FractionalTerm(UData_t f_ref, UData_t num, UData_t denom);
+static UData_t FindClearTuneFilter(MT2063_Info_t* pInfo, UData_t f_in);
+
+
+/******************************************************************************
+**
+**  Name: MT2063_Open
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     MT2063_Addr  - Serial bus address of the tuner.
+**                  hMT2063      - Tuner handle passed back.
+**                  hUserData    - User-defined data, if needed for the
+**                                 MT_ReadSub() & MT_WriteSub functions.
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_ARG_NULL       - Null pointer argument passed
+**                      MT_COMM_ERR       - Serial bus communications error
+**                      MT_TUNER_CNT_ERR  - Too many tuners open
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_Open(UData_t MT2063_Addr,
+                    Handle_t* hMT2063,
+                    Handle_t hUserData)
+{
+    UData_t status = MT_OK;                        /*  Status to be returned.  */
+    SData_t i;
+    MT2063_Info_t* pInfo = MT_NULL;
+
+    /*  Check the argument before using  */
+    if (hMT2063 == MT_NULL)
+        return (UData_t)MT_ARG_NULL;
+
+    /*  Default tuner handle to NULL.  If successful, it will be reassigned  */
+    *hMT2063 = MT_NULL;
+
+    /*
+    **  If this is our first tuner, initialize the address fields and
+    **  the list of available control blocks.
+    */
+    if (nOpenTuners == 0)
+    {
+        for (i=MT2063_CNT-1; i>=0; i--)
+        {
+            MT2063_Info[i].handle = MT_NULL;
+            MT2063_Info[i].address = (UData_t)MAX_UDATA;
+            MT2063_Info[i].rcvr_mode = MT2063_CABLE_QAM;
+            MT2063_Info[i].hUserData = MT_NULL;
+            Avail[i] = &MT2063_Info[i];
+        }
+    }
+
+    /*
+    **  Look for an existing MT2063_State_t entry with this address.
+    */
+    for (i=MT2063_CNT-1; i>=0; i--)
+    {
+        /*
+        **  If an open'ed handle provided, we'll re-initialize that structure.
+        **
+        **  We recognize an open tuner because the address and hUserData are
+        **  the same as one that has already been opened
+        */
+        if ((MT2063_Info[i].address == MT2063_Addr) &&
+            (MT2063_Info[i].hUserData == hUserData))
+        {
+            pInfo = &MT2063_Info[i];
+            break;
+        }
+    }
+
+    /*  If not found, choose an empty spot.  */
+    if (pInfo == MT_NULL)
+    {
+        /*  Check to see that we're not over-allocating  */
+        if (nOpenTuners == MT2063_CNT)
+            return (UData_t)MT_TUNER_CNT_ERR;
+
+        /* Use the next available block from the list */
+        pInfo = Avail[nOpenTuners];
+        nOpenTuners++;
+    }
+
+    if (MT_NO_ERROR(status))
+        status |= MT2063_RegisterTuner(&pInfo->AS_Data);
+
+    if (MT_NO_ERROR(status))
+    {
+        pInfo->handle    = (Handle_t) pInfo;
+        pInfo->hUserData = hUserData;
+        pInfo->address   = MT2063_Addr;
+        pInfo->rcvr_mode = MT2063_CABLE_QAM;
+//        status |= MT2063_ReInit((Handle_t) pInfo);
+    }
+
+    if (MT_IS_ERROR(status))
+        /*  MT2063_Close handles the un-registration of the tuner  */
+        (void)MT2063_Close((Handle_t) pInfo);
+    else
+        *hMT2063 = pInfo->handle;
+
+    return (UData_t)(status);
+}
+
+
+static UData_t IsValidHandle(MT2063_Info_t* handle)
+{
+    return (UData_t)(((handle != MT_NULL) && (handle->handle == handle)) ? 1 : 0);
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2063_Close
+**
+**  Description:    Release the handle to the tuner.
+**
+**  Parameters:     hMT2063      - Handle to the MT2063 tuner
+**
+**  Returns:        status:
+**                      MT_OK         - No errors
+**                      MT_INV_HANDLE - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_Close(Handle_t hMT2063)
+{
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) hMT2063;
+
+    if (!IsValidHandle(pInfo))
+        return (UData_t)MT_INV_HANDLE;
+
+    /* Unregister tuner with SpurAvoidance routines (if needed) */
+    MT2063_UnRegisterTuner(&pInfo->AS_Data);
+
+    /* Now remove the tuner from our own list of tuners */
+    pInfo->handle    = MT_NULL;
+    pInfo->address   = (UData_t)MAX_UDATA;
+    pInfo->hUserData = MT_NULL;
+    nOpenTuners--;
+    Avail[nOpenTuners] = pInfo; /* Return control block to available list */
+
+    return (UData_t)MT_OK;
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2063_GetGPIO
+**
+**  Description:    Get the current MT2063 GPIO value.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  gpio_id      - Selects GPIO0, GPIO1 or GPIO2
+**                  attr         - Selects input readback, I/O direction or
+**                                 output value (MT2063_GPIO_IN,
+**                                 MT2063_GPIO_DIR or MT2063_GPIO_OUT)
+**                  *value       - current setting of GPIO pin
+**
+**  Usage:          status = MT2063_GetGPIO(hMT2063, MT2063_GPIO0,
+**                                          MT2063_GPIO_OUT, &value);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the serial bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_GetGPIO(Handle_t h,
+                       MT2063_GPIO_ID gpio_id,
+                       MT2063_GPIO_Attr attr,
+                       UData_t* value)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data  regno;
+    SData_t shift;
+    const U8Data GPIOreg[3] = {RF_STATUS, FIF_OV, RF_OV};
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    if (value == MT_NULL)
+        return (UData_t)MT_ARG_NULL;
+
+    regno = GPIOreg[attr];
+
+    /*  We'll read the register just in case the write didn't work last time */
+    status = MT2063_ReadSub(pInfo->hUserData, pInfo->address, regno, &pInfo->reg[regno], 1);
+
+    shift = (SData_t)(gpio_id - MT2063_GPIO0 + 5);
+    *value = (pInfo->reg[regno] >> shift) & 1;
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetLocked
+**
+**  Description:    Checks to see if LO1 and LO2 are locked.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_UPC_UNLOCK    - Upconverter PLL unlocked
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_ReadSub    - Read byte(s) of data from the serial bus
+**                  MT_Sleep      - Delay execution for x milliseconds
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetLocked(Handle_t h)
+{
+    const UData_t nMaxWait = 100;            /*  wait a maximum of 100 msec   */
+    const UData_t nPollRate = 2;             /*  poll status bits every 2 ms */
+    const UData_t nMaxLoops = nMaxWait / nPollRate;
+    const U8Data LO1LK = 0x80;
+    U8Data LO2LK = 0x08;
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    UData_t nDelays = 0;
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    /*  LO2 Lock bit was in a different place for B0 version  */
+    if (pInfo->tuner_id == MT2063_B0)
+        LO2LK = 0x40;
+
+    do
+    {
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, LO_STATUS, &pInfo->reg[LO_STATUS], 1);
+
+        if (MT_IS_ERROR(status))
+            return (UData_t)(status);
+
+        if ((pInfo->reg[LO_STATUS] & (LO1LK | LO2LK)) == (LO1LK | LO2LK))
+            return (UData_t)(status);
+
+        MT2063_Sleep(pInfo->hUserData, nPollRate);       /*  Wait between retries  */
+    }
+    while (++nDelays < nMaxLoops);
+
+    if ((pInfo->reg[LO_STATUS] & LO1LK) == 0x00)
+        status |= MT_UPC_UNLOCK;
+    if ((pInfo->reg[LO_STATUS] & LO2LK) == 0x00)
+        status |= MT_DNC_UNLOCK;
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetParam
+**
+**  Description:    Gets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm - mostly for testing purposes.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2063_Param)
+**                  pValue      - ptr to returned value
+**
+**                  param                     Description
+**                  ----------------------    --------------------------------
+**                  MT2063_VERSION            Version of the API
+**                  MT2063_IC_ADDR            Serial Bus address of this tuner
+**                  MT2063_IC_REV             Tuner revision code
+**                  MT2063_MAX_OPEN           Max # of MT2063's allowed open
+**                  MT2063_NUM_OPEN           # of MT2063's open
+**                  MT2063_SRO_FREQ           crystal frequency
+**                  MT2063_STEPSIZE           minimum tuning step size
+**                  MT2063_INPUT_FREQ         input center frequency
+**                  MT2063_LO1_FREQ           LO1 Frequency
+**                  MT2063_LO1_STEPSIZE       LO1 minimum step size
+**                  MT2063_LO1_FRACN_AVOID    LO1 FracN keep-out region
+**                  MT2063_IF1_ACTUAL         Current 1st IF in use
+**                  MT2063_IF1_REQUEST        Requested 1st IF
+**                  MT2063_IF1_CENTER         Center of 1st IF SAW filter
+**                  MT2063_IF1_BW             Bandwidth of 1st IF SAW filter
+**                  MT2063_ZIF_BW             zero-IF bandwidth
+**                  MT2063_LO2_FREQ           LO2 Frequency
+**                  MT2063_LO2_STEPSIZE       LO2 minimum step size
+**                  MT2063_LO2_FRACN_AVOID    LO2 FracN keep-out region
+**                  MT2063_OUTPUT_FREQ        output center frequency
+**                  MT2063_OUTPUT_BW          output bandwidth
+**                  MT2063_LO_SEPARATION      min inter-tuner LO separation
+**                  MT2063_AS_ALG             ID of avoid-spurs algorithm in use
+**                  MT2063_MAX_HARM1          max # of intra-tuner harmonics
+**                  MT2063_MAX_HARM2          max # of inter-tuner harmonics
+**                  MT2063_EXCL_ZONES         # of 1st IF exclusion zones
+**                  MT2063_NUM_SPURS          # of spurs found/avoided
+**                  MT2063_SPUR_AVOIDED       >0 spurs avoided
+**                  MT2063_SPUR_PRESENT       >0 spurs in output (mathematically)
+**                  MT2063_RCVR_MODE          Predefined modes.
+**                  MT2063_LNA_RIN            Get LNA RIN value
+**                  MT2063_LNA_TGT            Get target power level at LNA
+**                  MT2063_PD1_TGT            Get target power level at PD1
+**                  MT2063_PD2_TGT            Get target power level at PD2
+**                  MT2063_ACLNA              LNA attenuator gain code
+**                  MT2063_ACRF               RF attenuator gain code
+**                  MT2063_ACFIF              FIF attenuator gain code
+**                  MT2063_ACLNA_MAX          LNA attenuator limit
+**                  MT2063_ACRF_MAX           RF attenuator limit
+**                  MT2063_ACFIF_MAX          FIF attenuator limit
+**                  MT2063_PD1                Actual value of PD1
+**                  MT2063_PD2                Actual value of PD2
+**                  MT2063_DNC_OUTPUT_ENABLE  DNC output selection
+**                  MT2063_VGAGC              VGA gain code
+**                  MT2063_VGAOI              VGA output current
+**                  MT2063_TAGC               TAGC setting
+**                  MT2063_AMPGC              AMP gain code
+**                  MT2063_AVOID_DECT         Avoid DECT Frequencies
+**                  MT2063_CTFILT_SW          Cleartune filter selection
+**
+**  Usage:          status |= MT2063_GetParam(hMT2063,
+**                                            MT2063_IF1_ACTUAL,
+**                                            &f_IF1_Actual);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  See Also:       MT2063_SetParam, MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   154   09-13-2007    RSK    Ver 1.05: Get/SetParam changes for LOx_FREQ
+**         10-31-2007    PINZ   Ver 1.08: Get/SetParam add VGAGC, VGAOI, AMPGC, TAGC
+**   173 M 01-23-2008    RSK    Ver 1.12: Read LO1C and LO2C registers from HW
+**                                        in GetParam.
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   175 I 16-06-2008    PINZ   Ver 1.16: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         07-10-2008    PINZ   Ver 1.19: Documentation Updates, Add a GetParam
+**                                        for each SetParam (LNA_RIN, TGTs)
+**   N/A I 03-19-2009    PINZ   Ver 1.32: Add GetParam VERSION (of API)
+**                                        Add GetParam IC_REV
+**   N/A I 04-22-2009    PINZ   Ver 1.33: Small fix in GetParam PD1/PD2
+****************************************************************************/
+UData_t MT2063_GetParam(Handle_t     h,
+                        MT2063_Param param,
+                        UData_t*     pValue)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+    UData_t Div;
+    UData_t Num;
+    UData_t i;
+    U8Data reg;
+
+    if (pValue == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (MT_NO_ERROR(status))
+    {
+        *pValue = 0;
+
+        switch (param)
+        {
+        /*  version of the API, e.g. 10302 = 1.32 */
+        case MT2063_VERSION:
+            *pValue = pInfo->version;
+            break;
+
+        /*  Serial Bus address of this tuner      */
+        case MT2063_IC_ADDR:
+            *pValue = pInfo->address;
+            break;
+
+        /*  tuner revision code (see enum  MT2063_REVCODE for values) */
+        case MT2063_IC_REV:
+            *pValue = pInfo->tuner_id;
+            break;
+
+        /*  Max # of MT2063's allowed to be open  */
+        case MT2063_MAX_OPEN:
+            *pValue = nMaxTuners;
+            break;
+
+        /*  # of MT2063's open                    */
+        case MT2063_NUM_OPEN:
+            *pValue = nOpenTuners;
+            break;
+
+        /*  crystal frequency                     */
+        case MT2063_SRO_FREQ:
+            *pValue = pInfo->AS_Data.f_ref;
+            break;
+
+        /*  minimum tuning step size              */
+        case MT2063_STEPSIZE:
+            *pValue = pInfo->AS_Data.f_LO2_Step;
+            break;
+
+        /*  input center frequency                */
+        case MT2063_INPUT_FREQ:
+            *pValue = pInfo->AS_Data.f_in;
+            break;
+
+        /*  LO1 Frequency                         */
+        case MT2063_LO1_FREQ:
+            {
+                /* read the actual tuner register values for LO1C_1 and LO1C_2 */
+                status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, LO1C_1, &pInfo->reg[LO1C_1], 2);
+                Div = pInfo->reg[LO1C_1];
+                Num = pInfo->reg[LO1C_2] & 0x3F;
+                pInfo->AS_Data.f_LO1 = (pInfo->AS_Data.f_ref * Div) + fLO_FractionalTerm(pInfo->AS_Data.f_ref, Num, 64);
+                *pValue = pInfo->AS_Data.f_LO1;
+            }
+            break;
+
+        /*  LO1 minimum step size                 */
+        case MT2063_LO1_STEPSIZE:
+            *pValue = pInfo->AS_Data.f_LO1_Step;
+            break;
+
+        /*  LO1 FracN keep-out region             */
+        case MT2063_LO1_FRACN_AVOID:
+            *pValue = pInfo->AS_Data.f_LO1_FracN_Avoid;
+            break;
+
+        /*  Current 1st IF in use                 */
+        case MT2063_IF1_ACTUAL:
+            *pValue = pInfo->f_IF1_actual;
+            break;
+
+        /*  Requested 1st IF                      */
+        case MT2063_IF1_REQUEST:
+            *pValue = pInfo->AS_Data.f_if1_Request;
+            break;
+
+        /*  Center of 1st IF SAW filter           */
+        case MT2063_IF1_CENTER:
+            *pValue = pInfo->AS_Data.f_if1_Center;
+            break;
+
+        /*  Bandwidth of 1st IF SAW filter        */
+        case MT2063_IF1_BW:
+            *pValue = pInfo->AS_Data.f_if1_bw;
+            break;
+
+        /*  zero-IF bandwidth                     */
+        case MT2063_ZIF_BW:
+            *pValue = pInfo->AS_Data.f_zif_bw;
+            break;
+
+        /*  LO2 Frequency                         */
+        case MT2063_LO2_FREQ:
+            {
+                /* Read the actual tuner register values for LO2C_1, LO2C_2 and LO2C_3 */
+                status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, LO2C_1, &pInfo->reg[LO2C_1], 3);
+                Div =  (pInfo->reg[LO2C_1] & 0xFE ) >> 1;
+                Num = ((pInfo->reg[LO2C_1] & 0x01 ) << 12) | (pInfo->reg[LO2C_2] << 4) | (pInfo->reg[LO2C_3] & 0x00F);
+                pInfo->AS_Data.f_LO2 = (pInfo->AS_Data.f_ref * Div) + fLO_FractionalTerm(pInfo->AS_Data.f_ref, Num, 8191);
+                *pValue = pInfo->AS_Data.f_LO2;
+            }
+            break;
+
+        /*  LO2 minimum step size                 */
+        case MT2063_LO2_STEPSIZE:
+            *pValue = pInfo->AS_Data.f_LO2_Step;
+            break;
+
+        /*  LO2 FracN keep-out region             */
+        case MT2063_LO2_FRACN_AVOID:
+            *pValue = pInfo->AS_Data.f_LO2_FracN_Avoid;
+            break;
+
+        /*  output center frequency               */
+        case MT2063_OUTPUT_FREQ:
+            *pValue = pInfo->AS_Data.f_out;
+            break;
+
+        /*  output bandwidth                      */
+        case MT2063_OUTPUT_BW:
+            *pValue = pInfo->AS_Data.f_out_bw - 750000;
+            break;
+
+        /*  min inter-tuner LO separation         */
+        case MT2063_LO_SEPARATION:
+            *pValue = pInfo->AS_Data.f_min_LO_Separation;
+            break;
+
+        /*  ID of avoid-spurs algorithm in use    */
+        case MT2063_AS_ALG:
+            *pValue = pInfo->AS_Data.nAS_Algorithm;
+            break;
+
+        /*  max # of intra-tuner harmonics        */
+        case MT2063_MAX_HARM1:
+            *pValue = pInfo->AS_Data.maxH1;
+            break;
+
+        /*  max # of inter-tuner harmonics        */
+        case MT2063_MAX_HARM2:
+            *pValue = pInfo->AS_Data.maxH2;
+            break;
+
+        /*  # of 1st IF exclusion zones           */
+        case MT2063_EXCL_ZONES:
+            *pValue = pInfo->AS_Data.nZones;
+            break;
+
+        /*  # of spurs found/avoided              */
+        case MT2063_NUM_SPURS:
+            *pValue = pInfo->AS_Data.nSpursFound;
+            break;
+
+        /*  >0 spurs avoided                      */
+        case MT2063_SPUR_AVOIDED:
+            *pValue = pInfo->AS_Data.bSpurAvoided;
+            break;
+
+        /*  >0 spurs in output (mathematically)   */
+        case MT2063_SPUR_PRESENT:
+            *pValue = pInfo->AS_Data.bSpurPresent;
+            break;
+
+        /*  Predefined receiver setup combination */
+        case MT2063_RCVR_MODE:
+            *pValue = pInfo->rcvr_mode;
+            break;
+
+        case MT2063_PD1:
+        case MT2063_PD2:
+            {
+                reg = pInfo->reg[BYP_CTRL] | ( (param == MT2063_PD1 ? 0x01 : 0x03) & 0x03 );  /* PD1 vs PD2 */
+
+                /* Initiate ADC output to reg 0x0A */
+                if (reg != pInfo->reg[BYP_CTRL])
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, BYP_CTRL, &reg, 1);
+
+                if (MT_IS_ERROR(status))
+                    return (UData_t)(status);
+
+                for (i=0; i<8; i++) {
+                    status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, ADC_OUT, &pInfo->reg[ADC_OUT], 1);
+
+                    if (MT_NO_ERROR(status))
+                        *pValue += (pInfo->reg[ADC_OUT] >> 2);   /*  only want 6 MSB's out of 8  */
+                    else
+                        break;  /* break for-loop */
+                }
+                *pValue /= (i+1);     /*  divide by number of reads  */
+
+                /* Restore value of Register BYP_CTRL */
+                if (reg != pInfo->reg[BYP_CTRL])
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, BYP_CTRL, &pInfo->reg[BYP_CTRL], 1);
+            }
+            break;
+
+
+        /*  Get LNA RIN value                  */
+        case MT2063_LNA_RIN:
+            status |= (pInfo->reg[CTRL_2C] & 0x03);
+            break;
+
+        /*  Get LNA target value                  */
+        case MT2063_LNA_TGT:
+            status |= (pInfo->reg[LNA_TGT] & 0x3f);
+            break;
+
+        /*  Get PD1 target value                  */
+        case MT2063_PD1_TGT:
+            status |= (pInfo->reg[PD1_TGT] & 0x3f);
+            break;
+
+        /*  Get PD2 target value                  */
+        case MT2063_PD2_TGT:
+            status |= (pInfo->reg[PD2_TGT] & 0x3f);
+            break;
+
+        /*  Get LNA attenuator code                */
+        case MT2063_ACLNA:
+            {
+                status |= MT2063_GetReg(pInfo, XO_STATUS, &reg);
+                *pValue = reg & 0x1f;
+            }
+            break;
+
+        /*  Get RF attenuator code                */
+        case MT2063_ACRF:
+            {
+                status |= MT2063_GetReg(pInfo, RF_STATUS, &reg);
+                *pValue = reg & 0x1f;
+            }
+            break;
+
+        /*  Get FIF attenuator code               */
+        case MT2063_ACFIF:
+            {
+                status |= MT2063_GetReg(pInfo, FIF_STATUS, &reg);
+                *pValue = reg & 0x1f;
+            }
+            break;
+
+        /*  Get LNA attenuator limit              */
+        case MT2063_ACLNA_MAX:
+            status |= (pInfo->reg[LNA_OV] & 0x1f);
+            break;
+
+        /*  Get RF attenuator limit               */
+        case MT2063_ACRF_MAX:
+            status |= (pInfo->reg[RF_OV] & 0x1f);
+            break;
+
+        /*  Get FIF attenuator limit               */
+        case MT2063_ACFIF_MAX:
+            status |= (pInfo->reg[FIF_OV] & 0x1f);
+            break;
+
+        /*  Get current used DNC output */
+        case MT2063_DNC_OUTPUT_ENABLE:
+            {
+                if ( (pInfo->reg[DNC_GAIN] & 0x03) == 0x03)   /* if DNC1 is off */
+                {
+                    if ( (pInfo->reg[VGA_GAIN] & 0x03) == 0x03) /* if DNC2 is off */
+                        *pValue = (UData_t)MT2063_DNC_NONE;
+                    else
+                        *pValue = (UData_t)MT2063_DNC_2;
+                }
+                else /* DNC1 is on */
+                {
+                    if ( (pInfo->reg[VGA_GAIN] & 0x03) == 0x03) /* if DNC2 is off */
+                        *pValue = (UData_t)MT2063_DNC_1;
+                    else
+                        *pValue = (UData_t)MT2063_DNC_BOTH;
+                }
+            }
+            break;
+
+       /*  Get VGA Gain Code */
+        case MT2063_VGAGC:
+           *pValue = ( (pInfo->reg[VGA_GAIN] & 0x0C) >> 2 );
+            break;
+
+       /*  Get VGA bias current */
+        case MT2063_VGAOI:
+            *pValue = (pInfo->reg[RSVD_31] & 0x07);
+            break;
+
+       /*  Get TAGC setting */
+        case MT2063_TAGC:
+            *pValue = (pInfo->reg[RSVD_1E] & 0x03);
+            break;
+
+       /*  Get AMP Gain Code */
+        case MT2063_AMPGC:
+           *pValue = (pInfo->reg[TEMP_SEL] & 0x03);
+            break;
+
+       /*  Avoid DECT Frequencies  */
+        case MT2063_AVOID_DECT:
+            *pValue = pInfo->AS_Data.avoidDECT;
+            break;
+
+       /*  Cleartune filter selection: 0 - by IC (default), 1 - by software  */
+        case MT2063_CTFILT_SW:
+            *pValue = pInfo->ctfilt_sw;
+            break;
+
+        case MT2063_EOP:
+        default:
+            status |= MT_ARG_RANGE;
+        }
+    }
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetReg
+**
+**  Description:    Gets an MT2063 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  reg         - MT2063 register/subaddress location
+**                  *val        - MT2063 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  Use this function if you need to read a register from
+**                  the MT2063.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data*  val)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (val == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, reg, &pInfo->reg[reg], 1);
+        if (MT_NO_ERROR(status))
+            *val = pInfo->reg[reg];
+    }
+
+    return (UData_t)(status);
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2063_GetTemp
+**
+**  Description:    Get the MT2063 Temperature register.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  *value       - value read from the register
+**
+**                                    Binary
+**                  Value Returned    Value    Approx Temp
+**                  ---------------------------------------------
+**                  MT2063_T_0C       0000         0C
+**                  MT2063_T_10C      0001        10C
+**                  MT2063_T_20C      0010        20C
+**                  MT2063_T_30C      0011        30C
+**                  MT2063_T_40C      0100        40C
+**                  MT2063_T_50C      0101        50C
+**                  MT2063_T_60C      0110        60C
+**                  MT2063_T_70C      0111        70C
+**                  MT2063_T_80C      1000        80C
+**                  MT2063_T_90C      1001        90C
+**                  MT2063_T_100C     1010       100C
+**                  MT2063_T_110C     1011       110C
+**                  MT2063_T_120C     1100       120C
+**                  MT2063_T_130C     1101       130C
+**                  MT2063_T_140C     1110       140C
+**                  MT2063_T_150C     1111       150C
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_GetTemp(Handle_t h, MT2063_Temperature* value)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    if (value == MT_NULL)
+        return (UData_t)MT_ARG_NULL;
+
+    if ((MT_NO_ERROR(status)) && ((pInfo->reg[TEMP_SEL] & 0xE0) != 0x00))
+    {
+        pInfo->reg[TEMP_SEL] &= (0x1F);
+        status |= MT2063_WriteSub(pInfo->hUserData,
+                              pInfo->address,
+                              TEMP_SEL,
+                              &pInfo->reg[TEMP_SEL],
+                              1);
+    }
+
+    if (MT_NO_ERROR(status))
+        status |= MT2063_ReadSub(pInfo->hUserData,
+                             pInfo->address,
+                             TEMP_STATUS,
+                             &pInfo->reg[TEMP_STATUS],
+                             1);
+
+    if (MT_NO_ERROR(status))
+        *value = (MT2063_Temperature) (pInfo->reg[TEMP_STATUS] >> 4);
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetUserData
+**
+**  Description:    Gets the user-defined data item.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  The hUserData parameter is a user-specific argument
+**                  that is stored internally with the other tuner-
+**                  specific information.
+**
+**                  For example, if additional arguments are needed
+**                  for the user to identify the device communicating
+**                  with the tuner, this argument can be used to supply
+**                  the necessary information.
+**
+**                  The hUserData parameter is initialized in the tuner's
+**                  Open function to NULL.
+**
+**  See Also:       MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetUserData(Handle_t h,
+                           Handle_t* hUserData)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (hUserData == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    if (MT_NO_ERROR(status))
+        *hUserData = pInfo->hUserData;
+
+    return (UData_t)(status);
+}
+
+
+
+/******************************************************************************
+**
+**  Name: MT2063_SetReceiverMode
+**
+**  Description:    Set the MT2063 receiver mode
+**
+**   --------------+----------------------------------------------
+**    Mode 0 :     | MT2063_CABLE_QAM
+**    Mode 1 :     | MT2063_CABLE_ANALOG
+**    Mode 2 :     | MT2063_OFFAIR_COFDM
+**    Mode 3 :     | MT2063_OFFAIR_COFDM_SAWLESS
+**    Mode 4 :     | MT2063_OFFAIR_ANALOG
+**    Mode 5 :     | MT2063_OFFAIR_8VSB
+**   --------------+----+----+----+----+-----+--------------------
+**  (DNC1GC & DNC2GC are the values, which are used, when the specific
+**   DNC Output is selected, the other is always off)
+**
+**                |<----------   Mode  -------------->|
+**    Reg Field   |  0  |  1  |  2  |  3  |  4  |  5  |
+**    ------------+-----+-----+-----+-----+-----+-----+
+**    RFAGCen     | OFF | OFF | OFF | OFF | OFF | OFF |
+**    LNARin      |   0 |   0 |   3 |   3 |  3  |  3  |
+**    FIFFQen     |   1 |   1 |   1 |   1 |  1  |  1  |
+**    FIFFq       |   0 |   0 |   0 |   0 |  0  |  0  |
+**    DNC1gc      |   0 |   0 |   0 |   0 |  0  |  0  |
+**    DNC2gc      |   0 |   0 |   0 |   0 |  0  |  0  |
+**    LNA max Atn |  31 |  31 |  31 |  31 | 31  | 31  |
+**    LNA Target  |  44 |  43 |  43 |  43 | 43  | 43  |
+**    ign  RF Ovl |   0 |   0 |   0 |   0 |  0  |  0  |
+**    RF  max Atn |  31 |  31 |  31 |  31 | 31  | 31  |
+**    PD1 Target  |  36 |  36 |  38 |  38 | 36  | 38  |
+**    ign FIF Ovl |   0 |   0 |   0 |   0 |  0  |  0  |
+**    FIF max Atn |  29 |   0 |  29 |  29 |  0  | 29  |
+**    PD2 Target  |  40 |  34 |  38 |  42 | 34  | 38  |
+**
+**
+**  Parameters:     pInfo       - ptr to MT2063_Info_t structure
+**                  Mode        - desired reciever mode
+**
+**  Usage:          status = MT2063_SetReceiverMode(hMT2063, Mode);
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_COMM_ERR       - Serial bus communications error
+**
+**  Dependencies:   MT2063_SetReg - Write a byte of data to a HW register.
+**                  Assumes that the tuner cache is valid.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   N/A   01-10-2007    PINZ   Added additional GCU Settings, FIFF Calib will be triggered
+**   155   10-01-2007    DAD    Ver 1.06: Add receiver mode for SECAM positive
+**                                        modulation
+**                                        (MT2063_ANALOG_TV_POS_NO_RFAGC_MODE)
+**   N/A   10-22-2007    PINZ   Ver 1.07: Changed some Registers at init to have
+**                                        the same settings as with MT Launcher
+**   N/A   10-30-2007    PINZ             Add SetParam VGAGC & VGAOI
+**                                        Add SetParam DNC_OUTPUT_ENABLE
+**                                        Removed VGAGC from receiver mode,
+**                                        default now 1
+**   N/A   10-31-2007    PINZ   Ver 1.08: Add SetParam TAGC, removed from rcvr-mode
+**                                        Add SetParam AMPGC, removed from rcvr-mode
+**                                        Corrected names of GCU values
+**                                        reorganized receiver modes, removed,
+**                                        (MT2063_ANALOG_TV_POS_NO_RFAGC_MODE)
+**                                        Actualized Receiver-Mode values
+**   N/A   11-12-2007    PINZ   Ver 1.09: Actualized Receiver-Mode values
+**   N/A   11-27-2007    PINZ             Improved buffered writing
+**         01-03-2008    PINZ   Ver 1.10: Added a trigger of BYPATNUP for
+**                                        correct wakeup of the LNA after shutdown
+**                                        Set AFCsd = 1 as default
+**                                        Changed CAP1sel default
+**         01-14-2008    PINZ   Ver 1.11: Updated gain settings
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**         11-05-2008    PINZ   Ver 1.25: Bugfix, update rcvr_mode var earlier.
+**   N/A I 02-26-2009    PINZ   Ver 1.30: RCVRmode 2: acfifmax 29->0, pd2tgt 33->34
+**                                        RCVRmode 4: acfifmax 29->0, pd2tgt 30->34
+**
+******************************************************************************/
+static UData_t MT2063_SetReceiverMode(MT2063_Info_t* pInfo, MT2063_RCVR_MODES Mode)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data  val;
+    UData_t longval;
+
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    if (Mode >= MT2063_NUM_RCVR_MODES)
+        status = MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+        pInfo->rcvr_mode = Mode;
+
+    /* RFAGCen */
+    if (MT_NO_ERROR(status))
+    {
+        val = (pInfo->reg[PD1_TGT] & (U8Data)~0x40) | (RFAGCEN[Mode] ? 0x40 : 0x00);
+        if( pInfo->reg[PD1_TGT] != val )
+        {
+            status |= MT2063_SetReg(pInfo, PD1_TGT, val);
+        }
+    }
+
+    /* LNARin */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_LNA_RIN, LNARIN[Mode]);
+    }
+
+    /* FIFFQEN and FIFFQ */
+    if (MT_NO_ERROR(status))
+    {
+        val = (pInfo->reg[FIFF_CTRL2] & (U8Data)~0xF0) | (FIFFQEN[Mode] << 7) | (FIFFQ[Mode] << 4);
+        if( pInfo->reg[FIFF_CTRL2] != val )
+        {
+            status |= MT2063_SetReg(pInfo, FIFF_CTRL2, val);
+            /* trigger FIFF calibration, needed after changing FIFFQ */
+            val = (pInfo->reg[FIFF_CTRL] | (U8Data)0x01);
+            status |= MT2063_SetReg(pInfo, FIFF_CTRL, val);
+            val = (pInfo->reg[FIFF_CTRL] & (U8Data)~0x01);
+            status |= MT2063_SetReg(pInfo, FIFF_CTRL, val);
+        }
+    }
+
+    /* DNC1GC & DNC2GC */
+    status |= MT2063_GetParam(pInfo, MT2063_DNC_OUTPUT_ENABLE, &longval);
+    status |= MT2063_SetParam(pInfo, MT2063_DNC_OUTPUT_ENABLE, longval);
+
+    /* acLNAmax */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_ACLNA_MAX, ACLNAMAX[Mode]);
+    }
+
+    /* LNATGT */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_LNA_TGT, LNATGT[Mode]);
+    }
+
+    /* ACRF */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_ACRF_MAX, ACRFMAX[Mode]);
+    }
+
+    /* PD1TGT */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_PD1_TGT, PD1TGT[Mode]);
+    }
+
+    /* FIFATN */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_ACFIF_MAX, ACFIFMAX[Mode]);
+    }
+
+    /* PD2TGT */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_SetParam(pInfo, MT2063_PD2_TGT, PD2TGT[Mode]);
+    }
+
+    /* Ignore ATN Overload */
+    if (MT_NO_ERROR(status))
+    {
+        val = (pInfo->reg[LNA_TGT] & (U8Data)~0x80) | (RFOVDIS[Mode] ? 0x80 : 0x00);
+        if( pInfo->reg[LNA_TGT] != val )
+        {
+            status |= MT2063_SetReg(pInfo, LNA_TGT, val);
+        }
+    }
+
+    /* Ignore FIF Overload */
+    if (MT_NO_ERROR(status))
+    {
+        val = (pInfo->reg[PD1_TGT] & (U8Data)~0x80) | (FIFOVDIS[Mode] ? 0x80 : 0x00);
+        if( pInfo->reg[PD1_TGT] != val )
+        {
+            status |= MT2063_SetReg(pInfo, PD1_TGT, val);
+        }
+    }
+
+
+    return (UData_t)(status);
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2063_ReInit
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   148   09-04-2007    RSK    Ver 1.02: Corrected logic of Reg 3B Reference
+**   153   09-07-2007    RSK    Ver 1.03: Lock Time improvements
+**   N/A   10-31-2007    PINZ   Ver 1.08: Changed values suitable to rcvr-mode 0
+**   N/A   11-12-2007    PINZ   Ver 1.09: Changed values suitable to rcvr-mode 0
+**   N/A   01-03-2007    PINZ   Ver 1.10: Added AFCsd = 1 into defaults
+**   N/A   01-04-2007    PINZ   Ver 1.10: Changed CAP1sel default
+**         01-14-2008    PINZ   Ver 1.11: Updated gain settings
+**         03-18-2008    PINZ   Ver 1.13: Added Support for B3
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         08-05-2008    PINZ   Ver 1.20: Disable SDEXT pin while MT2063_ReInit
+**                                        with MT2063B3
+**   N/A I 03-02-2009    PINZ   Ver 1.31: new default Fout 43.75 -> 36.125MHz
+**                                        new default Output-BW 6 -> 8MHz
+**                                        new default Stepsize 50 -> 62.5kHz
+**                                        new default Fin 651 -> 666 MHz
+**                                        Changed order of receiver-mode init
+**   N/A I 04-29-2009    PINZ   Ver 1.34: Optimized ReInit function
+**
+******************************************************************************/
+UData_t MT2063_ReInit(Handle_t h)
+{
+    U8Data all_resets = 0xF0;                /* reset/load bits */
+    UData_t status = MT_OK;                  /* Status to be returned */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+    UData_t rev=0;
+
+    U8Data MT2063B0_defaults[] = { /* Reg,  Value */
+                                     0x19, 0x05,
+                                     0x1B, 0x1D,
+                                     0x1C, 0x1F,
+                                     0x1D, 0x0F,
+                                     0x1E, 0x3F,
+                                     0x1F, 0x0F,
+                                     0x20, 0x3F,
+                                     0x22, 0x21,
+                                     0x23, 0x3F,
+                                     0x24, 0x20,
+                                     0x25, 0x3F,
+                                     0x27, 0xEE,
+                                     0x2C, 0x27,  /*  bit at 0x20 is cleared below  */
+                                     0x30, 0x03,
+                                     0x2C, 0x07,  /*  bit at 0x20 is cleared here   */
+                                     0x2D, 0x87,
+                                     0x2E, 0xAA,
+                                     0x28, 0xE1,  /*  Set the FIFCrst bit here      */
+                                     0x28, 0xE0,  /*  Clear the FIFCrst bit here    */
+                                     0x00 };
+
+    /* writing 0x05 0xf0 sw-resets all registers, so we write only needed changes */
+    U8Data MT2063B1_defaults[] = { /* Reg,  Value */
+                                     0x05, 0xF0,
+                                     0x11, 0x10,  /* New Enable AFCsd */
+                                     0x19, 0x05,
+                                     0x1A, 0x6C,
+                                     0x1B, 0x24,
+                                     0x1C, 0x28,
+                                     0x1D, 0x8F,
+                                     0x1E, 0x14,
+                                     0x1F, 0x8F,
+                                     0x20, 0x57,
+                                     0x22, 0x21,  /* New - ver 1.03 */
+                                     0x23, 0x3C,  /* New - ver 1.10 */
+                                     0x24, 0x20,  /* New - ver 1.03 */
+                                     0x2C, 0x24,  /*  bit at 0x20 is cleared below  */
+                                     0x2D, 0x87,  /*  FIFFQ=0  */
+                                     0x2F, 0xF3,
+                                     0x30, 0x0C,  /* New - ver 1.11 */
+                                     0x31, 0x1B,  /* New - ver 1.11 */
+                                     0x2C, 0x04,  /*  bit at 0x20 is cleared here  */
+                                     0x28, 0xE1,  /*  Set the FIFCrst bit here      */
+                                     0x28, 0xE0,  /*  Clear the FIFCrst bit here    */
+                                     0x00 };
+
+    /* writing 0x05 0xf0 sw-resets all registers, so we write only needed changes */
+    U8Data MT2063B3_defaults[] = { /* Reg,  Value */
+                                     0x05, 0xF0,
+                                     0x11, 0x13,  /*  disable SDEXT/INTsd for init */
+                                     0x2C, 0x24,  /*  bit at 0x20 is cleared below  */
+                                     0x2C, 0x04,  /*  bit at 0x20 is cleared here  */
+                                     0x28, 0xE1,  /*  Set the FIFCrst bit here      */
+                                     0x28, 0xE0,  /*  Clear the FIFCrst bit here    */
+                                     0x00 };
+
+    U8Data *def=MT2063B3_defaults;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    /*  Read the Part/Rev code from the tuner */
+    if (MT_NO_ERROR(status))
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, PART_REV, pInfo->reg, 1);
+
+    /*  Read the Part/Rev codes (2nd byte) from the tuner */
+    if (MT_NO_ERROR(status))
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, RSVD_3B, &pInfo->reg[RSVD_3B], 2);
+
+    if (MT_NO_ERROR(status)) { /* Check the part/rev code */
+        switch (pInfo->reg[PART_REV]) {
+            case 0x9e : {
+                if ( (pInfo->reg[RSVD_3C] & 0x18) == 0x08 ) {
+                    rev = MT2063_XX;
+                    status |= MT_TUNER_ID_ERR;
+                }
+                else {
+                    rev = MT2063_B3;
+                    def = MT2063B3_defaults;
+                }
+                break;
+            }
+            case 0x9c : {
+                rev = MT2063_B1;
+                def = MT2063B1_defaults;
+                break;
+            }
+            case 0x9b : {
+                rev = MT2063_B0;
+                def = MT2063B0_defaults;
+                break;
+            }
+            default : {
+                rev = MT2063_XX;
+                status |= MT_TUNER_ID_ERR;
+                break;
+            }
+        }
+    }
+
+    if (MT_NO_ERROR(status)  /* Check the 2nd part/rev code */
+        && ((pInfo->reg[RSVD_3B] & 0x80) != 0x00))    /* b7 != 0 ==> NOT MT2063 */
+            status |= MT_TUNER_ID_ERR;      /*  Wrong tuner Part/Rev code */
+
+    /*  Reset the tuner  */
+    if (MT_NO_ERROR(status))
+        status |= MT2063_WriteSub(pInfo->hUserData,
+                              pInfo->address,
+                              LO2CQ_3,
+                              &all_resets,
+                              1);
+
+    while (MT_NO_ERROR(status) && *def)
+    {
+        U8Data reg = *def++;
+        U8Data val = *def++;
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, reg, &val, 1);
+    }
+
+    /*  Wait for FIFF location to complete.  */
+    if (MT_NO_ERROR(status))
+    {
+        UData_t FCRUN = 1;
+        SData_t maxReads = 10;
+        while (MT_NO_ERROR(status) && (FCRUN != 0) && (maxReads-- > 0))
+        {
+            MT2063_Sleep(pInfo->hUserData, 2);
+            status |= MT2063_ReadSub(pInfo->hUserData,
+                                pInfo->address,
+                                XO_STATUS,
+                                &pInfo->reg[XO_STATUS],
+                                1);
+            FCRUN = (pInfo->reg[XO_STATUS] & 0x40) >> 6;
+        }
+
+        if (FCRUN != 0)
+            status |= MT_TUNER_INIT_ERR | MT_TUNER_TIMEOUT;
+
+        if (MT_NO_ERROR(status))  /* Re-read FIFFC value */
+            status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, FIFFC, &pInfo->reg[FIFFC], 1);
+    }
+
+    /* Read back all the registers from the tuner */
+    if (MT_NO_ERROR(status))
+        status |= MT2063_ReadSub(pInfo->hUserData,
+                             pInfo->address,
+                             PART_REV,
+                             pInfo->reg,
+                             END_REGS);
+
+    if (MT_NO_ERROR(status))
+    {
+        /*  Initialize the tuner state.  */
+        pInfo->version = MT2063_VERSION;
+        pInfo->tuner_id = rev;
+        pInfo->AS_Data.f_ref = REF_FREQ;
+        pInfo->AS_Data.f_if1_Center = (pInfo->AS_Data.f_ref / 8) * ((UData_t) pInfo->reg[FIFFC] + 640);
+        pInfo->AS_Data.f_if1_bw = IF1_BW;
+        pInfo->AS_Data.f_out = 36125000;
+        pInfo->AS_Data.f_out_bw = 8000000;
+        pInfo->AS_Data.f_zif_bw = ZIF_BW;
+        pInfo->AS_Data.f_LO1_Step = pInfo->AS_Data.f_ref / 64;
+        pInfo->AS_Data.f_LO2_Step = TUNE_STEP_SIZE;
+        pInfo->AS_Data.maxH1 = MAX_HARMONICS_1;
+        pInfo->AS_Data.maxH2 = MAX_HARMONICS_2;
+        pInfo->AS_Data.f_min_LO_Separation = MIN_LO_SEP;
+        pInfo->AS_Data.f_if1_Request = pInfo->AS_Data.f_if1_Center;
+        pInfo->AS_Data.f_LO1 = 2181000000U;
+        pInfo->AS_Data.f_LO2 = 1486249786;
+        pInfo->f_IF1_actual = pInfo->AS_Data.f_if1_Center;
+        pInfo->AS_Data.f_in = pInfo->AS_Data.f_LO1 - pInfo->f_IF1_actual;
+        pInfo->AS_Data.f_LO1_FracN_Avoid = LO1_FRACN_AVOID;
+        pInfo->AS_Data.f_LO2_FracN_Avoid = LO2_FRACN_AVOID;
+        pInfo->num_regs = END_REGS;
+        pInfo->AS_Data.avoidDECT = MT_AVOID_BOTH;
+        pInfo->ctfilt_sw = 1;
+    }
+
+    if (MT_NO_ERROR(status))
+    {
+        pInfo->CTFiltMax[ 0] =   69422000;
+        pInfo->CTFiltMax[ 1] =  106211000;
+        pInfo->CTFiltMax[ 2] =  140427000;
+        pInfo->CTFiltMax[ 3] =  177240000;
+        pInfo->CTFiltMax[ 4] =  213091000;
+        pInfo->CTFiltMax[ 5] =  241378000;
+        pInfo->CTFiltMax[ 6] =  274596000;
+        pInfo->CTFiltMax[ 7] =  309696000;
+        pInfo->CTFiltMax[ 8] =  342398000;
+        pInfo->CTFiltMax[ 9] =  378728000;
+        pInfo->CTFiltMax[10] =  416053000;
+        pInfo->CTFiltMax[11] =  456693000;
+        pInfo->CTFiltMax[12] =  496105000;
+        pInfo->CTFiltMax[13] =  534448000;
+        pInfo->CTFiltMax[14] =  572893000;
+        pInfo->CTFiltMax[15] =  603218000;
+        pInfo->CTFiltMax[16] =  632650000;
+        pInfo->CTFiltMax[17] =  668229000;
+        pInfo->CTFiltMax[18] =  710828000;
+        pInfo->CTFiltMax[19] =  735135000;
+        pInfo->CTFiltMax[20] =  765601000;
+        pInfo->CTFiltMax[21] =  809919000;
+        pInfo->CTFiltMax[22] =  842538000;
+        pInfo->CTFiltMax[23] =  863353000;
+        pInfo->CTFiltMax[24] =  911285000;
+        pInfo->CTFiltMax[25] =  942310000;
+        pInfo->CTFiltMax[26] =  977602000;
+        pInfo->CTFiltMax[27] = 1015100000;
+        pInfo->CTFiltMax[28] = 1053415000;
+        pInfo->CTFiltMax[29] = 1098330000;
+        pInfo->CTFiltMax[30] = 1138990000;
+    }
+
+    /*
+    **   Fetch the FCU osc value and use it and the fRef value to
+    **   scale all of the Band Max values
+    */
+    if (MT_NO_ERROR(status))
+    {
+        UData_t fcu_osc;
+        UData_t i;
+
+        pInfo->reg[CTUNE_CTRL] = 0x0A;
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, CTUNE_CTRL, &pInfo->reg[CTUNE_CTRL], 1);
+
+        /*  Read the ClearTune filter calibration value  */
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, FIFFC, &pInfo->reg[FIFFC], 1);
+        fcu_osc = pInfo->reg[FIFFC];
+
+        pInfo->reg[CTUNE_CTRL] = 0x00;
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, CTUNE_CTRL, &pInfo->reg[CTUNE_CTRL], 1);
+
+        /*  Adjust each of the values in the ClearTune filter cross-over table  */
+        for (i = 0; i < 31; i++)
+        {
+            if (fcu_osc>127) pInfo->CTFiltMax[i] += ( fcu_osc - 128 ) * df_dosc[i];
+            else             pInfo->CTFiltMax[i] -= ( 128 - fcu_osc ) * df_dosc[i];
+        }
+    }
+
+    /*
+    **   Set the default receiver mode
+    **
+    */
+
+//    if (MT_NO_ERROR(status) )
+//    {
+//        status |= MT2063_SetParam(h,MT2063_RCVR_MODE,MT2063_CABLE_QAM);
+//    }
+
+
+    /*
+    **   Tune to the default frequency
+    **
+    */
+
+//    if (MT_NO_ERROR(status) )
+//    {
+//        status |= MT2063_Tune(h,DEF_FIN_FREQ);
+//    }
+
+    /*
+    **   Enable SDEXT pin again
+    **
+    */
+
+    if ( (MT_NO_ERROR(status)) && (pInfo->tuner_id >= MT2063_B3) )
+    {
+        status |= MT2063_SetReg(h,PWR_1,0x1b);
+    }
+
+    return (UData_t)(status);
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2063_SetGPIO
+**
+**  Description:    Modify the MT2063 GPIO value.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  gpio_id      - Selects GPIO0, GPIO1 or GPIO2
+**                  attr         - Selects input readback, I/O direction or
+**                                 output value
+**                  value        - value to set GPIO pin 15, 14 or 19
+**
+**  Usage:          status = MT2063_SetGPIO(hMT2063, MT2063_GPIO1, MT2063_GPIO_OUT, 1);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_WriteSub - Write byte(s) of data to the two-wire-bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_SetGPIO(Handle_t h, MT2063_GPIO_ID gpio_id,
+                                   MT2063_GPIO_Attr attr,
+                                   UData_t value)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data regno;
+    SData_t shift;
+    const U8Data GPIOreg[3] = {0x15, 0x19, 0x18};
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    regno = GPIOreg[attr];
+
+    shift = (SData_t)(gpio_id - MT2063_GPIO0 + 5);
+
+    if (value & 0x01)
+        pInfo->reg[regno] |= (0x01 << shift);
+    else
+        pInfo->reg[regno] &= ~(0x01 << shift);
+    status = MT2063_WriteSub(pInfo->hUserData, pInfo->address, regno, &pInfo->reg[regno], 1);
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetParam
+**
+**  Description:    Sets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm.  You can override many of the tuning
+**                  algorithm defaults using this function.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2063_Param)
+**                  nValue      - value to be set
+**
+**                  param                     Description
+**                  ----------------------    --------------------------------
+**                  MT2063_SRO_FREQ           crystal frequency
+**                  MT2063_STEPSIZE           minimum tuning step size
+**                  MT2063_LO1_FREQ           LO1 frequency
+**                  MT2063_LO1_STEPSIZE       LO1 minimum step size
+**                  MT2063_LO1_FRACN_AVOID    LO1 FracN keep-out region
+**                  MT2063_IF1_REQUEST        Requested 1st IF
+**                  MT2063_ZIF_BW             zero-IF bandwidth
+**                  MT2063_LO2_FREQ           LO2 frequency
+**                  MT2063_LO2_STEPSIZE       LO2 minimum step size
+**                  MT2063_LO2_FRACN_AVOID    LO2 FracN keep-out region
+**                  MT2063_OUTPUT_FREQ        output center frequency
+**                  MT2063_OUTPUT_BW          output bandwidth
+**                  MT2063_LO_SEPARATION      min inter-tuner LO separation
+**                  MT2063_MAX_HARM1          max # of intra-tuner harmonics
+**                  MT2063_MAX_HARM2          max # of inter-tuner harmonics
+**                  MT2063_RCVR_MODE          Predefined modes
+**                  MT2063_LNA_RIN            Set LNA Rin (*)
+**                  MT2063_LNA_TGT            Set target power level at LNA (*)
+**                  MT2063_PD1_TGT            Set target power level at PD1 (*)
+**                  MT2063_PD2_TGT            Set target power level at PD2 (*)
+**                  MT2063_ACLNA_MAX          LNA attenuator limit (*)
+**                  MT2063_ACRF_MAX           RF attenuator limit (*)
+**                  MT2063_ACFIF_MAX          FIF attenuator limit (*)
+**                  MT2063_DNC_OUTPUT_ENABLE  DNC output selection
+**                  MT2063_VGAGC              VGA gain code
+**                  MT2063_VGAOI              VGA output current
+**                  MT2063_TAGC               TAGC setting
+**                  MT2063_AMPGC              AMP gain code
+**                  MT2063_AVOID_DECT         Avoid DECT Frequencies
+**                  MT2063_CTFILT_SW          Cleartune filter selection
+**
+**                  (*) This parameter is set by MT2063_RCVR_MODE, do not call
+**                      additionally.
+**
+**  Usage:          status |= MT2063_SetParam(hMT2063,
+**                                            MT2063_STEPSIZE,
+**                                            50000);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**                                         or set value out of range
+**                                         or non-writable parameter
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  See Also:       MT2063_GetParam, MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   154   09-13-2007    RSK    Ver 1.05: Get/SetParam changes for LOx_FREQ
+**         10-31-2007    PINZ   Ver 1.08: Get/SetParam add VGAGC, VGAOI, AMPGC, TAGC
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   175 I 06-06-2008    PINZ   Ver 1.16: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         01-20-2009    PINZ   Ver 1.28: Fixed a compare to avoid compiler warning
+**
+****************************************************************************/
+UData_t MT2063_SetParam(Handle_t     h,
+                        MT2063_Param param,
+                        UData_t      nValue)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data val=0;
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (MT_NO_ERROR(status))
+    {
+        switch (param)
+        {
+        /*  crystal frequency                     */
+        case MT2063_SRO_FREQ:
+            pInfo->AS_Data.f_ref = nValue;
+            pInfo->AS_Data.f_LO1_FracN_Avoid = 0;
+            pInfo->AS_Data.f_LO2_FracN_Avoid = nValue / 80 - 1;
+            pInfo->AS_Data.f_LO1_Step = nValue / 64;
+            pInfo->AS_Data.f_if1_Center = (pInfo->AS_Data.f_ref / 8) * (pInfo->reg[FIFFC] + 640);
+            break;
+
+        /*  minimum tuning step size              */
+        case MT2063_STEPSIZE:
+            pInfo->AS_Data.f_LO2_Step = nValue;
+            break;
+
+
+        /*  LO1 frequency                         */
+        case MT2063_LO1_FREQ:
+            {
+                /* Note: LO1 and LO2 are BOTH written at toggle of LDLOos  */
+                /* Capture the Divider and Numerator portions of other LO  */
+                U8Data tempLO2CQ[3];
+                U8Data tempLO2C[3];
+                U8Data tmpOneShot;
+                UData_t Div, FracN;
+                U8Data restore = 0;
+
+                /* Buffer the queue for restoration later and get actual LO2 values. */
+                status |= MT2063_ReadSub (pInfo->hUserData, pInfo->address, LO2CQ_1, &(tempLO2CQ[0]), 3);
+                status |= MT2063_ReadSub (pInfo->hUserData, pInfo->address, LO2C_1,  &(tempLO2C[0]),  3);
+
+                /* clear the one-shot bits */
+                tempLO2CQ[2] = tempLO2CQ[2] & 0x0F;
+                tempLO2C[2]  = tempLO2C[2]  & 0x0F;
+
+                /* only write the queue values if they are different from the actual. */
+                if( ( tempLO2CQ[0] != tempLO2C[0] ) ||
+                    ( tempLO2CQ[1] != tempLO2C[1] ) ||
+                    ( tempLO2CQ[2] != tempLO2C[2] )   )
+                {
+                    /* put actual LO2 value into queue (with 0 in one-shot bits) */
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO2CQ_1, &(tempLO2C[0]),  3);
+
+                    if( status == MT_OK )
+                    {
+                        /* cache the bytes just written. */
+                        pInfo->reg[LO2CQ_1] = tempLO2C[0];
+                        pInfo->reg[LO2CQ_2] = tempLO2C[1];
+                        pInfo->reg[LO2CQ_3] = tempLO2C[2];
+                    }
+                    restore = 1;
+                }
+
+                /* Calculate the Divider and Numberator components of LO1 */
+                status = CalcLO1Mult(&Div, &FracN, nValue, pInfo->AS_Data.f_ref/64, pInfo->AS_Data.f_ref);
+                pInfo->reg[LO1CQ_1] = (U8Data)(Div & 0x00FF);
+                pInfo->reg[LO1CQ_2] = (U8Data)(FracN);
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO1CQ_1, &pInfo->reg[LO1CQ_1],  2);
+
+                /* set the one-shot bit to load the pair of LO values */
+                tmpOneShot = tempLO2CQ[2] | 0xE0;
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO2CQ_3, &tmpOneShot,  1);
+
+                /* only restore the queue values if they were different from the actual. */
+                if( restore )
+                {
+                    /* put actual LO2 value into queue (0 in one-shot bits) */
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO2CQ_1, &(tempLO2CQ[0]),  3);
+
+                    /* cache the bytes just written. */
+                    pInfo->reg[LO2CQ_1] = tempLO2CQ[0];
+                    pInfo->reg[LO2CQ_2] = tempLO2CQ[1];
+                    pInfo->reg[LO2CQ_3] = tempLO2CQ[2];
+                }
+
+                status |= MT2063_GetParam( pInfo->hUserData,  MT2063_LO1_FREQ, &pInfo->AS_Data.f_LO1 );
+            }
+            break;
+
+        /*  LO1 minimum step size                 */
+        case MT2063_LO1_STEPSIZE:
+            pInfo->AS_Data.f_LO1_Step = nValue;
+            break;
+
+        /*  LO1 FracN keep-out region             */
+        case MT2063_LO1_FRACN_AVOID:
+            pInfo->AS_Data.f_LO1_FracN_Avoid = nValue;
+            break;
+
+        /*  Requested 1st IF                      */
+        case MT2063_IF1_REQUEST:
+            pInfo->AS_Data.f_if1_Request = nValue;
+            break;
+
+        /*  zero-IF bandwidth                     */
+        case MT2063_ZIF_BW:
+            pInfo->AS_Data.f_zif_bw = nValue;
+            break;
+
+        /*  LO2 frequency                         */
+        case MT2063_LO2_FREQ:
+            {
+                /* Note: LO1 and LO2 are BOTH written at toggle of LDLOos  */
+                /* Capture the Divider and Numerator portions of other LO  */
+                U8Data  tempLO1CQ[2];
+                U8Data  tempLO1C[2];
+                UData_t Div2;
+                UData_t FracN2;
+                U8Data  tmpOneShot;
+                U8Data  restore = 0;
+
+                /* Buffer the queue for restoration later and get actual LO2 values. */
+                status |= MT2063_ReadSub (pInfo->hUserData, pInfo->address, LO1CQ_1, &(tempLO1CQ[0]), 2);
+                status |= MT2063_ReadSub (pInfo->hUserData, pInfo->address, LO1C_1,  &(tempLO1C[0]),  2);
+
+                /* only write the queue values if they are different from the actual. */
+                if( (tempLO1CQ[0] != tempLO1C[0]) || (tempLO1CQ[1] != tempLO1C[1])   )
+                {
+                    /* put actual LO1 value into queue */
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO1CQ_1, &(tempLO1C[0]),  2);
+
+                    /* cache the bytes just written. */
+                    pInfo->reg[LO1CQ_1] = tempLO1C[0];
+                    pInfo->reg[LO1CQ_2] = tempLO1C[1];
+                    restore = 1;
+                }
+
+                /* Calculate the Divider and Numberator components of LO2 */
+                status |= CalcLO2Mult(&Div2, &FracN2, nValue, pInfo->AS_Data.f_ref/8191, pInfo->AS_Data.f_ref);
+                pInfo->reg[LO2CQ_1] = (U8Data)((Div2 << 1) | ((FracN2 >> 12) & 0x01) ) & 0xFF;
+                pInfo->reg[LO2CQ_2] = (U8Data)((FracN2 >> 4) & 0xFF);
+                pInfo->reg[LO2CQ_3] = (U8Data)((FracN2 & 0x0F) );
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO1CQ_1, &pInfo->reg[LO1CQ_1],  3);
+
+                /* set the one-shot bit to load the LO values */
+                tmpOneShot = pInfo->reg[LO2CQ_3] | 0xE0;
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO2CQ_3, &tmpOneShot,  1);
+
+                /* only restore LO1 queue value if they were different from the actual. */
+                if( restore )
+                {
+                    /* put previous LO1 queue value back into queue */
+                    status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO1CQ_1, &(tempLO1CQ[0]),  2);
+
+                    /* cache the bytes just written. */
+                    pInfo->reg[LO1CQ_1] = tempLO1CQ[0];
+                    pInfo->reg[LO1CQ_2] = tempLO1CQ[1];
+                }
+
+                status |= MT2063_GetParam( pInfo->hUserData,  MT2063_LO2_FREQ, &pInfo->AS_Data.f_LO2 );
+            }
+            break;
+
+        /*  LO2 minimum step size                 */
+        case MT2063_LO2_STEPSIZE:
+            pInfo->AS_Data.f_LO2_Step = nValue;
+            break;
+
+        /*  LO2 FracN keep-out region             */
+        case MT2063_LO2_FRACN_AVOID:
+            pInfo->AS_Data.f_LO2_FracN_Avoid = nValue;
+            break;
+
+        /*  output center frequency               */
+        case MT2063_OUTPUT_FREQ:
+            pInfo->AS_Data.f_out = nValue;
+            break;
+
+        /*  output bandwidth                      */
+        case MT2063_OUTPUT_BW:
+            pInfo->AS_Data.f_out_bw = nValue + 750000;
+            break;
+
+        /*  min inter-tuner LO separation         */
+        case MT2063_LO_SEPARATION:
+            pInfo->AS_Data.f_min_LO_Separation = nValue;
+            break;
+
+        /*  max # of intra-tuner harmonics        */
+        case MT2063_MAX_HARM1:
+            pInfo->AS_Data.maxH1 = nValue;
+            break;
+
+        /*  max # of inter-tuner harmonics        */
+        case MT2063_MAX_HARM2:
+            pInfo->AS_Data.maxH2 = nValue;
+            break;
+
+        case MT2063_RCVR_MODE:
+            status |= MT2063_SetReceiverMode(pInfo, (MT2063_RCVR_MODES)nValue);
+            break;
+
+        /* Set LNA Rin -- nValue is desired value */
+        case MT2063_LNA_RIN:
+            val = (U8Data)( ( pInfo->reg[CTRL_2C] & (U8Data)~0x03) | (nValue & 0x03) );
+            if( pInfo->reg[CTRL_2C] != val )
+            {
+                status |= MT2063_SetReg(pInfo, CTRL_2C, val);
+            }
+            break;
+
+        /* Set target power level at LNA -- nValue is desired value */
+        case MT2063_LNA_TGT:
+            val = (U8Data)( ( pInfo->reg[LNA_TGT] & (U8Data)~0x3F) | (nValue & 0x3F) );
+            if( pInfo->reg[LNA_TGT] != val )
+            {
+                status |= MT2063_SetReg(pInfo, LNA_TGT, val);
+            }
+            break;
+
+        /* Set target power level at PD1 -- nValue is desired value */
+        case MT2063_PD1_TGT:
+            val = (U8Data)( ( pInfo->reg[PD1_TGT] & (U8Data)~0x3F) | (nValue & 0x3F) );
+            if( pInfo->reg[PD1_TGT] != val )
+            {
+                status |= MT2063_SetReg(pInfo, PD1_TGT, val);
+            }
+            break;
+
+        /* Set target power level at PD2 -- nValue is desired value */
+        case MT2063_PD2_TGT:
+            val = (U8Data)( ( pInfo->reg[PD2_TGT] & (U8Data)~0x3F) | (nValue & 0x3F) );
+            if( pInfo->reg[PD2_TGT] != val )
+            {
+                status |= MT2063_SetReg(pInfo, PD2_TGT, val);
+            }
+            break;
+
+        /* Set LNA atten limit -- nValue is desired value */
+        case MT2063_ACLNA_MAX:
+            val = (U8Data)( ( pInfo->reg[LNA_OV] & (U8Data)~0x1F) | (nValue & 0x1F) );
+            if( pInfo->reg[LNA_OV] != val )
+            {
+                status |= MT2063_SetReg(pInfo, LNA_OV, val);
+            }
+            break;
+
+        /* Set RF atten limit -- nValue is desired value */
+        case MT2063_ACRF_MAX:
+            val = (U8Data)( ( pInfo->reg[RF_OV] & (U8Data)~0x1F) | (nValue & 0x1F) );
+            if( pInfo->reg[RF_OV] != val )
+            {
+                status |= MT2063_SetReg(pInfo, RF_OV, val);
+            }
+            break;
+
+        /* Set FIF atten limit -- nValue is desired value, max. 5 if no B3 */
+        case MT2063_ACFIF_MAX:
+            if ( (pInfo->tuner_id == MT2063_B0 || pInfo->tuner_id == MT2063_B1)  && nValue > 5)
+                nValue = 5;
+            val = (U8Data)( ( pInfo->reg[FIF_OV] & (U8Data)~0x1F) | (nValue & 0x1F) );
+            if( pInfo->reg[FIF_OV] != val )
+            {
+                status |= MT2063_SetReg(pInfo, FIF_OV, val);
+            }
+            break;
+
+        case MT2063_DNC_OUTPUT_ENABLE:
+            /* selects, which DNC output is used */
+            switch ((MT2063_DNC_Output_Enable)nValue)
+            {
+               case MT2063_DNC_NONE :
+               {
+                  val = (pInfo->reg[DNC_GAIN] & 0xFC ) | 0x03; /* Set DNC1GC=3 */
+                  if (pInfo->reg[DNC_GAIN] != val)
+                      status |= MT2063_SetReg(h, DNC_GAIN, val);
+
+                  val = (pInfo->reg[VGA_GAIN] & 0xFC ) | 0x03; /* Set DNC2GC=3 */
+                  if (pInfo->reg[VGA_GAIN] != val)
+                      status |= MT2063_SetReg(h, VGA_GAIN, val);
+
+                  val = (pInfo->reg[RSVD_20] & ~0x40);   /* Set PD2MUX=0 */
+                  if (pInfo->reg[RSVD_20] != val)
+                      status |= MT2063_SetReg(h, RSVD_20, val);
+
+                  break;
+               }
+               case MT2063_DNC_1 :
+               {
+                  val = (pInfo->reg[DNC_GAIN] & 0xFC ) | (DNC1GC[pInfo->rcvr_mode] & 0x03); /* Set DNC1GC=x */
+                  if (pInfo->reg[DNC_GAIN] != val)
+                      status |= MT2063_SetReg(h, DNC_GAIN, val);
+
+                  val = (pInfo->reg[VGA_GAIN] & 0xFC ) | 0x03; /* Set DNC2GC=3 */
+                  if (pInfo->reg[VGA_GAIN] != val)
+                      status |= MT2063_SetReg(h, VGA_GAIN, val);
+
+                  val = (pInfo->reg[RSVD_20] & ~0x40);   /* Set PD2MUX=0 */
+                  if (pInfo->reg[RSVD_20] != val)
+                      status |= MT2063_SetReg(h, RSVD_20, val);
+
+                  break;
+               }
+               case MT2063_DNC_2 :
+               {
+                  val = (pInfo->reg[DNC_GAIN] & 0xFC ) | 0x03; /* Set DNC1GC=3 */
+                  if (pInfo->reg[DNC_GAIN] != val)
+                      status |= MT2063_SetReg(h, DNC_GAIN, val);
+
+                  val = (pInfo->reg[VGA_GAIN] & 0xFC ) | (DNC2GC[pInfo->rcvr_mode] & 0x03); /* Set DNC2GC=x */
+                  if (pInfo->reg[VGA_GAIN] != val)
+                      status |= MT2063_SetReg(h, VGA_GAIN, val);
+
+                  val = (pInfo->reg[RSVD_20] | 0x40);   /* Set PD2MUX=1 */
+                  if (pInfo->reg[RSVD_20] != val)
+                      status |= MT2063_SetReg(h, RSVD_20, val);
+
+                  break;
+               }
+               case MT2063_DNC_BOTH :
+               {
+                  val = (pInfo->reg[DNC_GAIN] & 0xFC ) | (DNC1GC[pInfo->rcvr_mode] & 0x03); /* Set DNC1GC=x */
+                  if (pInfo->reg[DNC_GAIN] != val)
+                      status |= MT2063_SetReg(h, DNC_GAIN, val);
+
+                  val = (pInfo->reg[VGA_GAIN] & 0xFC ) | (DNC2GC[pInfo->rcvr_mode] & 0x03); /* Set DNC2GC=x */
+                  if (pInfo->reg[VGA_GAIN] != val)
+                      status |= MT2063_SetReg(h, VGA_GAIN, val);
+
+                  val = (pInfo->reg[RSVD_20] | 0x40);   /* Set PD2MUX=1 */
+                  if (pInfo->reg[RSVD_20] != val)
+                      status |= MT2063_SetReg(h, RSVD_20, val);
+
+                  break;
+               }
+               default : break;
+            }
+            break;
+
+        case MT2063_VGAGC:
+            /* Set VGA gain code */
+            val = (U8Data)( (pInfo->reg[VGA_GAIN] & (U8Data)~0x0C) | ( (nValue & 0x03) << 2) );
+            if( pInfo->reg[VGA_GAIN] != val )
+            {
+                status |= MT2063_SetReg(pInfo, VGA_GAIN, val);
+            }
+            break;
+
+        case MT2063_VGAOI:
+            /* Set VGA bias current */
+            val = (U8Data)( (pInfo->reg[RSVD_31] & (U8Data)~0x07) | (nValue & 0x07) );
+            if( pInfo->reg[RSVD_31] != val )
+            {
+                status |= MT2063_SetReg(pInfo, RSVD_31, val);
+            }
+            break;
+
+        case MT2063_TAGC:
+            /* Set TAGC */
+            val = (U8Data)( (pInfo->reg[RSVD_1E] & (U8Data)~0x03) | (nValue & 0x03) );
+            if( pInfo->reg[RSVD_1E] != val )
+            {
+                status |= MT2063_SetReg(pInfo, RSVD_1E, val);
+            }
+            break;
+
+        case MT2063_AMPGC:
+            /* Set Amp gain code */
+            val = (U8Data)( (pInfo->reg[TEMP_SEL] & (U8Data)~0x03) | (nValue & 0x03) );
+            if( pInfo->reg[TEMP_SEL] != val )
+            {
+                status |= MT2063_SetReg(pInfo, TEMP_SEL, val);
+            }
+            break;
+
+        /*  Avoid DECT Frequencies                */
+        case MT2063_AVOID_DECT:
+            {
+                MT_DECT_Avoid_Type newAvoidSetting = (MT_DECT_Avoid_Type) nValue;
+                if (newAvoidSetting <= MT_AVOID_BOTH)
+                {
+                    pInfo->AS_Data.avoidDECT = newAvoidSetting;
+                }
+            }
+            break;
+
+       /*  Cleartune filter selection: 0 - by IC (default), 1 - by software  */
+        case MT2063_CTFILT_SW:
+            pInfo->ctfilt_sw = (nValue & 0x01);
+            break;
+
+        /*  These parameters are read-only  */
+        case MT2063_VERSION:
+        case MT2063_IC_ADDR:
+        case MT2063_IC_REV:
+        case MT2063_MAX_OPEN:
+        case MT2063_NUM_OPEN:
+        case MT2063_INPUT_FREQ:
+        case MT2063_IF1_ACTUAL:
+        case MT2063_IF1_CENTER:
+        case MT2063_IF1_BW:
+        case MT2063_AS_ALG:
+        case MT2063_EXCL_ZONES:
+        case MT2063_SPUR_AVOIDED:
+        case MT2063_NUM_SPURS:
+        case MT2063_SPUR_PRESENT:
+        case MT2063_PD1:
+        case MT2063_PD2:
+        case MT2063_ACLNA:
+        case MT2063_ACRF:
+        case MT2063_ACFIF:
+        case MT2063_EOP:
+        default:
+            status |= MT_ARG_RANGE;
+        }
+    }
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetPowerMaskBits
+**
+**  Description:    Sets the power-down mask bits for various sections of
+**                  the MT2063
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to be set.
+**
+**                  See definition of MT2063_Mask_Bits type for description
+**                  of each of the power bits.
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SetPowerMaskBits(Handle_t h, MT2063_Mask_Bits Bits)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        Bits = (MT2063_Mask_Bits)(Bits & MT2063_ALL_SD);  /* Only valid bits for this tuner */
+        if ((Bits & 0xFF00) != 0)
+        {
+            pInfo->reg[PWR_2] |= (U8Data)((Bits & 0xFF00) >> 8);
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_2, &pInfo->reg[PWR_2], 1);
+        }
+        if ((Bits & 0xFF) != 0)
+        {
+            pInfo->reg[PWR_1] |= ((U8Data)Bits & 0xFF);
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_1, &pInfo->reg[PWR_1], 1);
+        }
+    }
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_ClearPowerMaskBits
+**
+**  Description:    Clears the power-down mask bits for various sections of
+**                  the MT2063
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to be cleared.
+**
+**                  See definition of MT2063_Mask_Bits type for description
+**                  of each of the power bits.
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_ClearPowerMaskBits(Handle_t h, MT2063_Mask_Bits Bits)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        Bits = (MT2063_Mask_Bits)(Bits & MT2063_ALL_SD);  /* Only valid bits for this tuner */
+        if ((Bits & 0xFF00) != 0)
+        {
+            pInfo->reg[PWR_2] &= ~(U8Data)(Bits >> 8);
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_2, &pInfo->reg[PWR_2], 1);
+        }
+        if ((Bits & 0xFF) != 0)
+        {
+            pInfo->reg[PWR_1] &= ~(U8Data)(Bits & 0xFF);
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_1, &pInfo->reg[PWR_1], 1);
+        }
+    }
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetPowerMaskBits
+**
+**  Description:    Returns a mask of the enabled power shutdown bits
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to currently set.
+**
+**                  See definition of MT2063_Mask_Bits type for description
+**                  of each of the power bits.
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Output argument is NULL
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetPowerMaskBits(Handle_t h, MT2063_Mask_Bits *Bits)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        if (Bits == MT_NULL)
+            status |= MT_ARG_NULL;
+
+        if (MT_NO_ERROR(status))
+            status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, PWR_1, &pInfo->reg[PWR_1], 2);
+
+        if (MT_NO_ERROR(status))
+        {
+            *Bits = (MT2063_Mask_Bits)(((SData_t)pInfo->reg[PWR_2] << 8) + pInfo->reg[PWR_1]);
+            *Bits = (MT2063_Mask_Bits)(*Bits & MT2063_ALL_SD);  /* Only valid bits for this tuner */
+        }
+    }
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_EnableExternalShutdown
+**
+**  Description:    Enables or disables the operation of the external
+**                  shutdown pin
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Enabled     - 0 = disable the pin, otherwise enable it
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_EnableExternalShutdown(Handle_t h, U8Data Enabled)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        if (Enabled == 0)
+            pInfo->reg[PWR_1] &= ~0x08;  /* Turn off the bit */
+        else
+            pInfo->reg[PWR_1] |= 0x08;   /* Turn the bit on */
+
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_1, &pInfo->reg[PWR_1], 1);
+    }
+
+    return (UData_t)(status);
+}
+
+/****************************************************************************
+**
+**  Name: MT2063_SoftwareShutdown
+**
+**  Description:    Enables or disables software shutdown function.  When
+**                  Shutdown==1, any section whose power mask is set will be
+**                  shutdown.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Shutdown    - 1 = shutdown the masked sections, otherwise
+**                                power all sections on
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**         01-03-2008    PINZ   Ver 1.xx: Added a trigger of BYPATNUP for
+**                              correct wakeup of the LNA
+**
+****************************************************************************/
+UData_t MT2063_SoftwareShutdown(Handle_t h, U8Data Shutdown)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        if (Shutdown == 1)
+            pInfo->reg[PWR_1] |= 0x04;   /* Turn the bit on */
+        else
+            pInfo->reg[PWR_1] &= ~0x04;  /* Turn off the bit */
+
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, PWR_1, &pInfo->reg[PWR_1], 1);
+
+        if (Shutdown != 1)
+        {
+            pInfo->reg[BYP_CTRL] = (pInfo->reg[BYP_CTRL] & 0x9F) | 0x40;
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, BYP_CTRL, &pInfo->reg[BYP_CTRL], 1);
+            pInfo->reg[BYP_CTRL] = (pInfo->reg[BYP_CTRL] & 0x9F);
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, BYP_CTRL, &pInfo->reg[BYP_CTRL], 1);
+        }
+    }
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetExtSRO
+**
+**  Description:    Sets the external SRO driver.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Ext_SRO_Setting - external SRO drive setting
+**
+**       (default)    MT2063_EXT_SRO_OFF  - ext driver off
+**                    MT2063_EXT_SRO_BY_1 - ext driver = SRO frequency
+**                    MT2063_EXT_SRO_BY_2 - ext driver = SRO/2 frequency
+**                    MT2063_EXT_SRO_BY_4 - ext driver = SRO/4 frequency
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  The Ext_SRO_Setting settings default to OFF
+**                  Use this function if you need to override the default
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   189 S 05-13-2008    RSK    Ver 1.16: Correct location for ExtSRO control.
+**
+****************************************************************************/
+UData_t MT2063_SetExtSRO(Handle_t h,
+                         MT2063_Ext_SRO Ext_SRO_Setting)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+    else
+    {
+        pInfo->reg[CTRL_2C] = (pInfo->reg[CTRL_2C] & 0x3F) | ((U8Data)Ext_SRO_Setting << 6);
+        status = MT2063_WriteSub(pInfo->hUserData, pInfo->address, CTRL_2C, &pInfo->reg[CTRL_2C], 1);
+    }
+
+    return (UData_t)(status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetReg
+**
+**  Description:    Sets an MT2063 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  reg         - MT2063 register/subaddress location
+**                  val         - MT2063 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  Use this function if you need to override a default
+**                  register value
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data   val)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, reg, &val, 1);
+        if (MT_NO_ERROR(status))
+            pInfo->reg[reg] = val;
+    }
+
+    return (UData_t)(status);
+}
+
+
+static UData_t Round_fLO(UData_t f_LO, UData_t f_LO_Step, UData_t f_ref)
+{
+    return (UData_t)(  f_ref * (f_LO / f_ref)
+        + f_LO_Step * (((f_LO % f_ref) + (f_LO_Step / 2)) / f_LO_Step)  );
+}
+
+
+/****************************************************************************
+**
+**  Name: fLO_FractionalTerm
+**
+**  Description:    Calculates the portion contributed by FracN / denom.
+**
+**                  This function preserves maximum precision without
+**                  risk of overflow.  It accurately calculates
+**                  f_ref * num / denom to within 1 HZ with fixed math.
+**
+**  Parameters:     num       - Fractional portion of the multiplier
+**                  denom     - denominator portion of the ratio
+**                              This routine successfully handles denom values
+**                              up to and including 2^18.
+**                  f_Ref     - SRO frequency.  This calculation handles
+**                              f_ref as two separate 14-bit fields.
+**                              Therefore, a maximum value of 2^28-1
+**                              may safely be used for f_ref.  This is
+**                              the genesis of the magic number "14" and the
+**                              magic mask value of 0x03FFF.
+**
+**  Returns:        f_ref * num / denom
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+static UData_t fLO_FractionalTerm( UData_t f_ref,
+                                   UData_t num,
+                                   UData_t denom )
+{
+    UData_t t1     = (f_ref >> 14) * num;
+    UData_t term1  = t1 / denom;
+    UData_t loss   = t1 % denom;
+    UData_t term2  = ( ((f_ref & 0x00003FFF) * num + (loss<<14)) + (denom/2) )  / denom;
+    return (UData_t)(  ((term1 << 14) + term2)  );
+}
+
+
+/****************************************************************************
+**
+**  Name: CalcLO1Mult
+**
+**  Description:    Calculates Integer divider value and the numerator
+**                  value for a FracN PLL.
+**
+**                  This function assumes that the f_LO and f_Ref are
+**                  evenly divisible by f_LO_Step.
+**
+**  Parameters:     Div       - OUTPUT: Whole number portion of the multiplier
+**                  FracN     - OUTPUT: Fractional portion of the multiplier
+**                  f_LO      - desired LO frequency.
+**                  f_LO_Step - Minimum step size for the LO (in Hz).
+**                  f_Ref     - SRO frequency.
+**                  f_Avoid   - Range of PLL frequencies to avoid near
+**                              integer multiples of f_Ref (in Hz).
+**
+**  Returns:        Recalculated LO frequency.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+static UData_t CalcLO1Mult(UData_t *Div,
+                           UData_t *FracN,
+                           UData_t  f_LO,
+                           UData_t  f_LO_Step,
+                           UData_t  f_Ref)
+{
+    /*  Calculate the whole number portion of the divider */
+    *Div = f_LO / f_Ref;
+
+    /*  Calculate the numerator value (round to nearest f_LO_Step) */
+    *FracN = (64 * (((f_LO % f_Ref) + (f_LO_Step / 2)) / f_LO_Step) + (f_Ref / f_LO_Step / 2)) / (f_Ref / f_LO_Step);
+
+    return (UData_t)(  (f_Ref * (*Div)) + fLO_FractionalTerm( f_Ref, *FracN, 64 )  );
+}
+
+
+/****************************************************************************
+**
+**  Name: CalcLO2Mult
+**
+**  Description:    Calculates Integer divider value and the numerator
+**                  value for a FracN PLL.
+**
+**                  This function assumes that the f_LO and f_Ref are
+**                  evenly divisible by f_LO_Step.
+**
+**  Parameters:     Div       - OUTPUT: Whole number portion of the multiplier
+**                  FracN     - OUTPUT: Fractional portion of the multiplier
+**                  f_LO      - desired LO frequency.
+**                  f_LO_Step - Minimum step size for the LO (in Hz).
+**                  f_Ref     - SRO frequency.
+**                  f_Avoid   - Range of PLL frequencies to avoid near
+**                              integer multiples of f_Ref (in Hz).
+**
+**  Returns:        Recalculated LO frequency.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   205 M 10-01-2008    JWS    Ver 1.22: Use DMAX when LO2 FracN is near 4096
+**
+****************************************************************************/
+static UData_t CalcLO2Mult(UData_t *Div,
+                           UData_t *FracN,
+                           UData_t  f_LO,
+                           UData_t  f_LO_Step,
+                           UData_t  f_Ref)
+{
+    UData_t denom = 8191;
+
+    /*  Calculate the whole number portion of the divider */
+    *Div = f_LO / f_Ref;
+
+    /*  Calculate the numerator value (round to nearest f_LO_Step) */
+    *FracN = (8191 * (((f_LO % f_Ref) + (f_LO_Step / 2)) / f_LO_Step) + (f_Ref / f_LO_Step / 2)) / (f_Ref / f_LO_Step);
+
+    /*
+    ** FracN values close to 1/2 (4096) will be forced to 4096.  The tuning code must
+    ** then set the DMAX bit for the affected LO(s).
+    */
+    if ((*FracN >= 4083) && (*FracN <= 4107))
+    {
+        *FracN = 4096;
+        denom = 8192;
+    }
+
+    return (UData_t)(  (f_Ref * (*Div)) + fLO_FractionalTerm( f_Ref, *FracN, denom )  );
+}
+
+/****************************************************************************
+**
+**  Name: FindClearTuneFilter
+**
+**  Description:    Calculate the corrrect ClearTune filter to be used for
+**                  a given input frequency.
+**
+**  Parameters:     pInfo       - ptr to tuner data structure
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Returns:        ClearTune filter number (0-31)
+**
+**  Dependencies:   MUST CALL MT2064_Open BEFORE FindClearTuneFilter!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**         04-10-2008   PINZ    Ver 1.14: Use software-controlled ClearTune
+**                                        cross-over frequency values.
+**
+****************************************************************************/
+static UData_t FindClearTuneFilter(MT2063_Info_t* pInfo, UData_t f_in)
+{
+    UData_t RFBand;
+    UData_t idx;                  /*  index loop                      */
+
+    /*
+    **  Find RF Band setting
+    */
+    RFBand = 31;                        /*  def when f_in > all    */
+    for (idx=0; idx<31; ++idx)
+    {
+        if (pInfo->CTFiltMax[idx] >= f_in)
+        {
+            RFBand = idx;
+            break;
+        }
+    }
+    return (UData_t)(RFBand);
+}
+
+
+
+/****************************************************************************
+**
+**  Name: MT2063_Tune
+**
+**  Description:    Change the tuner's tuned frequency to RFin.
+**
+**  Parameters:     h           - Open handle to the tuner (from MT2063_Open).
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_UPC_UNLOCK    - Upconverter PLL unlocked
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_SPUR_CNT_MASK - Count of avoided LO spurs
+**                      MT_SPUR_PRESENT  - LO spur possible in output
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_FOUT_RANGE    - Output freq out of range
+**                      MT_UPC_RANGE     - Upconverter freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2063_Open BEFORE MT2063_Tune!
+**
+**                  MT_ReadSub       - Read data from the two-wire serial bus
+**                  MT_WriteSub      - Write data to the two-wire serial bus
+**                  MT_Sleep         - Delay execution for x milliseconds
+**                  MT2063_GetLocked - Checks to see if LO1 and LO2 are locked
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**         04-10-2008   PINZ    Ver 1.05: Use software-controlled ClearTune
+**                                        cross-over frequency values.
+**   175 I 16-06-2008   PINZ    Ver 1.16: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**   205 M 10-01-2008    JWS    Ver 1.22: Use DMAX when LO2 FracN is near 4096
+**       M 10-24-2008    JWS    Ver 1.25: Use DMAX when LO1 FracN is 32
+**
+****************************************************************************/
+UData_t MT2063_Tune(Handle_t h,
+                    UData_t f_in)     /* RF input center frequency   */
+{
+    MT2063_Info_t* pInfo = (MT2063_Info_t*) h;
+
+    UData_t status = MT_OK;       /*  status of operation             */
+    UData_t LO1;                  /*  1st LO register value           */
+    UData_t Num1;                 /*  Numerator for LO1 reg. value    */
+    UData_t f_IF1;                /*  1st IF requested                */
+    UData_t LO2;                  /*  2nd LO register value           */
+    UData_t Num2;                 /*  Numerator for LO2 reg. value    */
+    UData_t ofLO1, ofLO2;         /*  last time's LO frequencies      */
+    U8Data  fiffc = 0x80;         /*  FIFF center freq from tuner     */
+    UData_t fiffof;               /*  Offset from FIFF center freq    */
+    const U8Data LO1LK = 0x80;    /*  Mask for LO1 Lock bit           */
+    U8Data LO2LK = 0x08;          /*  Mask for LO2 Lock bit           */
+    U8Data val;
+    UData_t RFBand;
+    U8Data oFN;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        return (UData_t)MT_INV_HANDLE;
+
+    /*  Check the input and output frequency ranges                   */
+    if ((f_in < MIN_FIN_FREQ) || (f_in > MAX_FIN_FREQ))
+        status |= MT_FIN_RANGE;
+
+    if ((pInfo->AS_Data.f_out < MIN_FOUT_FREQ) || (pInfo->AS_Data.f_out > MAX_FOUT_FREQ))
+        status |= MT_FOUT_RANGE;
+
+    /*
+    **  Save original LO1 and LO2 register values
+    */
+    ofLO1 = pInfo->AS_Data.f_LO1;
+    ofLO2 = pInfo->AS_Data.f_LO2;
+
+    /*
+    **  Find and set RF Band setting
+    */
+    if (pInfo->ctfilt_sw == 1)
+    {
+        val = ( pInfo->reg[CTUNE_CTRL] | 0x08 );
+        if( pInfo->reg[CTUNE_CTRL] != val )
+        {
+            status |= MT2063_SetReg(pInfo, CTUNE_CTRL, val);
+        }
+
+        RFBand = FindClearTuneFilter(pInfo, f_in);
+        val  = (U8Data)( (pInfo->reg[CTUNE_OV] & ~0x1F) | RFBand );
+        if (pInfo->reg[CTUNE_OV] != val)
+        {
+            status |= MT2063_SetReg(pInfo, CTUNE_OV, val);
+        }
+    }
+
+    /*
+    **  Read the FIFF Center Frequency from the tuner
+    */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2063_ReadSub(pInfo->hUserData, pInfo->address, FIFFC, &pInfo->reg[FIFFC], 1);
+        fiffc = pInfo->reg[FIFFC];
+    }
+
+    /*
+    **  Assign in the requested values
+    */
+    pInfo->AS_Data.f_in = f_in;
+    /*  Request a 1st IF such that LO1 is on a step size */
+    pInfo->AS_Data.f_if1_Request = Round_fLO(pInfo->AS_Data.f_if1_Request + f_in, pInfo->AS_Data.f_LO1_Step, pInfo->AS_Data.f_ref) - f_in;
+
+    /*
+    **  Calculate frequency settings.  f_IF1_FREQ + f_in is the
+    **  desired LO1 frequency
+    */
+    MT2063_ResetExclZones(&pInfo->AS_Data);
+
+    f_IF1 = MT2063_ChooseFirstIF(&pInfo->AS_Data);
+    pInfo->AS_Data.f_LO1 = Round_fLO(f_IF1 + f_in, pInfo->AS_Data.f_LO1_Step, pInfo->AS_Data.f_ref);
+    pInfo->AS_Data.f_LO2 = Round_fLO(pInfo->AS_Data.f_LO1 - pInfo->AS_Data.f_out - f_in, pInfo->AS_Data.f_LO2_Step, pInfo->AS_Data.f_ref);
+
+    /*
+    ** Check for any LO spurs in the output bandwidth and adjust
+    ** the LO settings to avoid them if needed
+    */
+    status |= MT2063_AvoidSpurs(h, &pInfo->AS_Data);
+
+    /*
+    ** MT_AvoidSpurs spurs may have changed the LO1 & LO2 values.
+    ** Recalculate the LO frequencies and the values to be placed
+    ** in the tuning registers.
+    */
+    pInfo->AS_Data.f_LO1 = CalcLO1Mult(&LO1, &Num1, pInfo->AS_Data.f_LO1, pInfo->AS_Data.f_LO1_Step, pInfo->AS_Data.f_ref);
+    pInfo->AS_Data.f_LO2 = Round_fLO(pInfo->AS_Data.f_LO1 - pInfo->AS_Data.f_out - f_in, pInfo->AS_Data.f_LO2_Step, pInfo->AS_Data.f_ref);
+    pInfo->AS_Data.f_LO2 = CalcLO2Mult(&LO2, &Num2, pInfo->AS_Data.f_LO2, pInfo->AS_Data.f_LO2_Step, pInfo->AS_Data.f_ref);
+
+    /*
+    **  Check the upconverter and downconverter frequency ranges
+    */
+    if ((pInfo->AS_Data.f_LO1 < MIN_UPC_FREQ) || (pInfo->AS_Data.f_LO1 > MAX_UPC_FREQ))
+        status |= MT_UPC_RANGE;
+
+    if ((pInfo->AS_Data.f_LO2 < MIN_DNC_FREQ) || (pInfo->AS_Data.f_LO2 > MAX_DNC_FREQ))
+        status |= MT_DNC_RANGE;
+
+    /*  LO2 Lock bit was in a different place for B0 version  */
+    if (pInfo->tuner_id == MT2063_B0)
+        LO2LK = 0x40;
+
+    /*
+    **  If we have the same LO frequencies and we're already locked,
+    **  then skip re-programming the LO registers.
+    */
+    if ((ofLO1 != pInfo->AS_Data.f_LO1)
+        || (ofLO2 != pInfo->AS_Data.f_LO2)
+        || ((pInfo->reg[LO_STATUS] & (LO1LK | LO2LK)) != (LO1LK | LO2LK)))
+    {
+        /*
+        **  Calculate the FIFFOF register value
+        **
+        **            IF1_Actual
+        **  FIFFOF = ------------ - 8 * FIFFC - 4992
+        **             f_ref/64
+        */
+        fiffof = (pInfo->AS_Data.f_LO1 - f_in) / (pInfo->AS_Data.f_ref / 64) - 8 * (UData_t)fiffc - 4992;
+        if (fiffof > 0xFF)
+            fiffof = 0xFF;
+
+        /*
+        **  Place all of the calculated values into the local tuner
+        **  register fields.
+        */
+        if (MT_NO_ERROR(status))
+        {
+            oFN = pInfo->reg[FN_CTRL];  /* save current FN_CTRL settings */
+
+            /*
+            ** If either FracN is 4096 (or was rounded to there) then set its
+            ** DMAX bit, otherwise clear it.
+            */
+            if (Num1 == 32)
+                pInfo->reg[FN_CTRL] |= 0x20;
+            else
+                pInfo->reg[FN_CTRL] &= ~0x20;
+            if (Num2 == 4096)
+                pInfo->reg[FN_CTRL] |= 0x02;
+            else
+                pInfo->reg[FN_CTRL] &= ~0x02;
+
+            pInfo->reg[LO1CQ_1] = (U8Data)(LO1 & 0xFF);             /* DIV1q */
+            pInfo->reg[LO1CQ_2] = (U8Data)(Num1 & 0x3F);            /* NUM1q */
+            pInfo->reg[LO2CQ_1] = (U8Data)(((LO2 & 0x7F) << 1)      /* DIV2q */
+                                       | (Num2 >> 12));          /* NUM2q (hi) */
+            pInfo->reg[LO2CQ_2] = (U8Data)((Num2 & 0x0FF0) >> 4);   /* NUM2q (mid) */
+            pInfo->reg[LO2CQ_3] = (U8Data)(0xE0 | (Num2 & 0x000F)); /* NUM2q (lo) */
+
+            /*
+            ** Now write out the computed register values
+            ** IMPORTANT: There is a required order for writing
+            **            (0x05 must follow all the others).
+            */
+            status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO1CQ_1, &pInfo->reg[LO1CQ_1], 5);   /* 0x01 - 0x05 */
+
+            /* The FN_CTRL register is only needed if it changes */
+            if (oFN != pInfo->reg[FN_CTRL])
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, FN_CTRL, &pInfo->reg[FN_CTRL], 1);   /* 0x34 */
+
+            if (pInfo->tuner_id == MT2063_B0)
+            {
+                /* Re-write the one-shot bits to trigger the tune operation */
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, LO2CQ_3, &pInfo->reg[LO2CQ_3], 1);   /* 0x05 */
+            }
+
+            /* Write out the FIFF offset only if it's changing */
+            if (pInfo->reg[FIFF_OFFSET] != (U8Data)fiffof)
+            {
+                pInfo->reg[FIFF_OFFSET] = (U8Data)fiffof;
+                status |= MT2063_WriteSub(pInfo->hUserData, pInfo->address, FIFF_OFFSET, &pInfo->reg[FIFF_OFFSET], 1);
+            }
+        }
+
+        /*
+        **  Check for LO's locking
+        */
+        if (MT_NO_ERROR(status))
+        {
+            status |= MT2063_GetLocked(h);
+        }
+
+        /*
+        **  If we locked OK, assign calculated data to MT2063_Info_t structure
+        */
+        if (MT_NO_ERROR(status))
+        {
+            pInfo->f_IF1_actual = pInfo->AS_Data.f_LO1 - f_in;
+        }
+    }
+
+    return (UData_t)(status);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt_spuravoid.c
+
+
+/*****************************************************************************
+**
+**  Name: mt_spuravoid.c
+**
+**  Copyright 2006-2008 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt_spuravoid.c
+**
+**  Description:    Microtune spur avoidance software module.
+**                  Supports Microtune tuner drivers.
+**
+**  CVS ID:         $Id: mt_spuravoid.c,v 1.4 2008/11/05 13:46:19 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt_spuravoid.c,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   082   03-25-2005    JWS    Original multi-tuner support - requires
+**                              MTxxxx_CNT declarations
+**   096   04-06-2005    DAD    Ver 1.11: Fix divide by 0 error if maxH==0.
+**   094   04-06-2005    JWS    Ver 1.11 Added uceil and ufloor to get rid
+**                              of compiler warnings
+**   N/A   04-07-2005    DAD    Ver 1.13: Merged single- and multi-tuner spur
+**                              avoidance into a single module.
+**   103   01-31-2005    DAD    Ver 1.14: In MT_AddExclZone(), if the range
+**                              (f_min, f_max) < 0, ignore the entry.
+**   115   03-23-2007    DAD    Fix declaration of spur due to truncation
+**                              errors.
+**   117   03-29-2007    RSK    Ver 1.15: Re-wrote to match search order from
+**                              tuner DLL.
+**   137   06-18-2007    DAD    Ver 1.16: Fix possible divide-by-0 error for
+**                              multi-tuners that have
+**                              (delta IF1) > (f_out-f_outbw/2).
+**   147   07-27-2007    RSK    Ver 1.17: Corrected calculation (-) to (+)
+**                              Added logic to force f_Center within 1/2 f_Step.
+**   177 S 02-26-2008    RSK    Ver 1.18: Corrected calculation using LO1 > MAX/2
+**                              Type casts added to preserve correct sign.
+**   195 I 06-17-2008    RSK    Ver 1.19: Refactoring avoidance of DECT
+**                              frequencies into MT_ResetExclZones().
+**   N/A I 06-20-2008    RSK    Ver 1.21: New VERSION number for ver checking.
+**   199   08-06-2008    JWS    Ver 1.22: Added 0x1x1 spur frequency calculations
+**                              and indicate success of AddExclZone operation.
+**   200   08-07-2008    JWS    Ver 1.23: Moved definition of DECT avoid constants
+**                              so users could access them more easily.
+**
+*****************************************************************************/
+//#include "mt_spuravoid.h"
+//#include <stdlib.h>
+//#include <assert.h>  /*  debug purposes  */
+
+#if !defined(MT_TUNER_CNT)
+#error MT_TUNER_CNT is not defined (see mt_userdef.h)
+#endif
+
+#if MT_TUNER_CNT == 0
+#error MT_TUNER_CNT must be updated in mt_userdef.h
+#endif
+
+/*  Version of this module                         */
+#define MT_SPURAVOID_VERSION 10203            /*  Version 01.23 */
+
+
+/*  Implement ceiling, floor functions.  */
+#define ceil(n, d) (((n) < 0) ? (-((-(n))/(d))) : (n)/(d) + ((n)%(d) != 0))
+#define uceil(n, d) ((n)/(d) + ((n)%(d) != 0))
+#define floor(n, d) (((n) < 0) ? (-((-(n))/(d))) - ((n)%(d) != 0) : (n)/(d))
+#define ufloor(n, d) ((n)/(d))
+
+/*  Macros to check for DECT exclusion options */
+#define MT_EXCLUDE_US_DECT_FREQUENCIES(s) (((s) & MT_AVOID_US_DECT) != 0)
+#define MT_EXCLUDE_EURO_DECT_FREQUENCIES(s) (((s) & MT_AVOID_EURO_DECT) != 0)
+
+
+struct MT_FIFZone_t
+{
+    SData_t         min_;
+    SData_t         max_;
+};
+
+#if MT_TUNER_CNT > 1
+static MT2063_AvoidSpursData_t* TunerList[MT_TUNER_CNT];
+static UData_t              TunerCount = 0;
+#endif
+
+UData_t MT2063_RegisterTuner(MT2063_AvoidSpursData_t* pAS_Info)
+{
+#if MT_TUNER_CNT == 1
+    pAS_Info->nAS_Algorithm = 1;
+    return MT_OK;
+#else
+    UData_t index;
+
+    pAS_Info->nAS_Algorithm = 2;
+
+    /*
+    **  Check to see if tuner is already registered
+    */
+    for (index = 0; index < TunerCount; index++)
+    {
+        if (TunerList[index] == pAS_Info)
+        {
+            return MT_OK;  /* Already here - no problem  */
+        }
+    }
+
+    /*
+    ** Add tuner to list - if there is room.
+    */
+    if (TunerCount < MT_TUNER_CNT)
+    {
+        TunerList[TunerCount] = pAS_Info;
+        TunerCount++;
+        return MT_OK;
+    }
+    else
+        return MT_TUNER_CNT_ERR;
+#endif
+}
+
+
+void MT2063_UnRegisterTuner(MT2063_AvoidSpursData_t* pAS_Info)
+{
+#if MT_TUNER_CNT == 1
+  //  pAS_Info;
+   // pAS_Info->nAS_Algorithm = 1;
+   // return MT_OK;
+#else
+
+    UData_t index;
+
+    for (index = 0; index < TunerCount; index++)
+    {
+        if (TunerList[index] == pAS_Info)
+        {
+            TunerList[index] = TunerList[--TunerCount];
+        }
+    }
+#endif
+}
+
+
+/*
+**  Reset all exclusion zones.
+**  Add zones to protect the PLL FracN regions near zero
+**
+**   195 I 06-17-2008    RSK    Ver 1.19: Refactoring avoidance of DECT
+**                              frequencies into MT_ResetExclZones().
+*/
+void MT2063_ResetExclZones(MT2063_AvoidSpursData_t* pAS_Info)
+{
+    UData_t center;
+#if MT_TUNER_CNT > 1
+    UData_t index;
+    MT2063_AvoidSpursData_t* adj;
+#endif
+
+    pAS_Info->nZones = 0;                           /*  this clears the used list  */
+    pAS_Info->usedZones = MT_NULL;                     /*  reset ptr                  */
+    pAS_Info->freeZones = MT_NULL;                     /*  reset ptr                  */
+
+    center = pAS_Info->f_ref * ((pAS_Info->f_if1_Center - pAS_Info->f_if1_bw/2 + pAS_Info->f_in) / pAS_Info->f_ref) - pAS_Info->f_in;
+    while (center < pAS_Info->f_if1_Center + pAS_Info->f_if1_bw/2 + pAS_Info->f_LO1_FracN_Avoid)
+    {
+        /*  Exclude LO1 FracN  */
+        MT2063_AddExclZone(pAS_Info, center-pAS_Info->f_LO1_FracN_Avoid, center-1);
+        MT2063_AddExclZone(pAS_Info, center+1, center+pAS_Info->f_LO1_FracN_Avoid);
+        center += pAS_Info->f_ref;
+    }
+
+    center = pAS_Info->f_ref * ((pAS_Info->f_if1_Center - pAS_Info->f_if1_bw/2 - pAS_Info->f_out) / pAS_Info->f_ref) + pAS_Info->f_out;
+    while (center < pAS_Info->f_if1_Center + pAS_Info->f_if1_bw/2 + pAS_Info->f_LO2_FracN_Avoid)
+    {
+        /*  Exclude LO2 FracN  */
+        MT2063_AddExclZone(pAS_Info, center-pAS_Info->f_LO2_FracN_Avoid, center-1);
+        MT2063_AddExclZone(pAS_Info, center+1, center+pAS_Info->f_LO2_FracN_Avoid);
+        center += pAS_Info->f_ref;
+    }
+
+    if( MT_EXCLUDE_US_DECT_FREQUENCIES(pAS_Info->avoidDECT) )
+    {
+        /*  Exclude LO1 values that conflict with DECT channels */
+        MT2063_AddExclZone(pAS_Info, 1920836000 - pAS_Info->f_in, 1922236000 - pAS_Info->f_in);  /* Ctr = 1921.536 */
+        MT2063_AddExclZone(pAS_Info, 1922564000 - pAS_Info->f_in, 1923964000 - pAS_Info->f_in);  /* Ctr = 1923.264 */
+        MT2063_AddExclZone(pAS_Info, 1924292000 - pAS_Info->f_in, 1925692000 - pAS_Info->f_in);  /* Ctr = 1924.992 */
+        MT2063_AddExclZone(pAS_Info, 1926020000 - pAS_Info->f_in, 1927420000 - pAS_Info->f_in);  /* Ctr = 1926.720 */
+        MT2063_AddExclZone(pAS_Info, 1927748000 - pAS_Info->f_in, 1929148000 - pAS_Info->f_in);  /* Ctr = 1928.448 */
+    }
+
+    if( MT_EXCLUDE_EURO_DECT_FREQUENCIES(pAS_Info->avoidDECT) )
+    {
+        MT2063_AddExclZone(pAS_Info, 1896644000 - pAS_Info->f_in, 1898044000 - pAS_Info->f_in);  /* Ctr = 1897.344 */
+        MT2063_AddExclZone(pAS_Info, 1894916000 - pAS_Info->f_in, 1896316000 - pAS_Info->f_in);  /* Ctr = 1895.616 */
+        MT2063_AddExclZone(pAS_Info, 1893188000 - pAS_Info->f_in, 1894588000 - pAS_Info->f_in);  /* Ctr = 1893.888 */
+        MT2063_AddExclZone(pAS_Info, 1891460000 - pAS_Info->f_in, 1892860000 - pAS_Info->f_in);  /* Ctr = 1892.16  */
+        MT2063_AddExclZone(pAS_Info, 1889732000 - pAS_Info->f_in, 1891132000 - pAS_Info->f_in);  /* Ctr = 1890.432 */
+        MT2063_AddExclZone(pAS_Info, 1888004000 - pAS_Info->f_in, 1889404000 - pAS_Info->f_in);  /* Ctr = 1888.704 */
+        MT2063_AddExclZone(pAS_Info, 1886276000 - pAS_Info->f_in, 1887676000 - pAS_Info->f_in);  /* Ctr = 1886.976 */
+        MT2063_AddExclZone(pAS_Info, 1884548000 - pAS_Info->f_in, 1885948000 - pAS_Info->f_in);  /* Ctr = 1885.248 */
+        MT2063_AddExclZone(pAS_Info, 1882820000 - pAS_Info->f_in, 1884220000 - pAS_Info->f_in);  /* Ctr = 1883.52  */
+        MT2063_AddExclZone(pAS_Info, 1881092000 - pAS_Info->f_in, 1882492000 - pAS_Info->f_in);  /* Ctr = 1881.792 */
+    }
+
+#if MT_TUNER_CNT > 1
+    /*
+    ** Iterate through all adjacent tuners and exclude frequencies related to them
+    */
+    for (index = 0; index < TunerCount; ++index)
+    {
+        adj = TunerList[index];
+        if (pAS_Info == adj)    /* skip over our own data, don't process it */
+            continue;
+
+        /*
+        **  Add 1st IF exclusion zone covering adjacent tuner's LO2
+        **  at "adjfLO2 + f_out" +/- m_MinLOSpacing
+        */
+        if (adj->f_LO2 != 0)
+            MT2063_AddExclZone(pAS_Info,
+                           (adj->f_LO2 + pAS_Info->f_out) - pAS_Info->f_min_LO_Separation,
+                           (adj->f_LO2 + pAS_Info->f_out) + pAS_Info->f_min_LO_Separation );
+
+        /*
+        **  Add 1st IF exclusion zone covering adjacent tuner's LO1
+        **  at "adjfLO1 - f_in" +/- m_MinLOSpacing
+        */
+        if (adj->f_LO1 != 0)
+            MT2063_AddExclZone(pAS_Info,
+                           (adj->f_LO1 - pAS_Info->f_in) - pAS_Info->f_min_LO_Separation,
+                           (adj->f_LO1 - pAS_Info->f_in) + pAS_Info->f_min_LO_Separation );
+    }
+#endif
+}
+
+
+static struct MT2063_ExclZone_t* InsertNode(MT2063_AvoidSpursData_t* pAS_Info,
+                                  struct MT2063_ExclZone_t* pPrevNode)
+{
+    struct MT2063_ExclZone_t* pNode;
+    /*  Check for a node in the free list  */
+    if (pAS_Info->freeZones != MT_NULL)
+    {
+        /*  Use one from the free list  */
+        pNode = pAS_Info->freeZones;
+        pAS_Info->freeZones = pNode->next_;
+    }
+    else
+    {
+        /*  Grab a node from the array  */
+        pNode = &pAS_Info->MT_ExclZones[pAS_Info->nZones];
+    }
+
+    if (pPrevNode != MT_NULL)
+    {
+        pNode->next_ = pPrevNode->next_;
+        pPrevNode->next_ = pNode;
+    }
+    else    /*  insert at the beginning of the list  */
+    {
+        pNode->next_ = pAS_Info->usedZones;
+        pAS_Info->usedZones = pNode;
+    }
+
+    pAS_Info->nZones++;
+    return pNode;
+}
+
+
+static struct MT2063_ExclZone_t* RemoveNode(MT2063_AvoidSpursData_t* pAS_Info,
+                                  struct MT2063_ExclZone_t* pPrevNode,
+                                  struct MT2063_ExclZone_t* pNodeToRemove)
+{
+    struct MT2063_ExclZone_t* pNext = pNodeToRemove->next_;
+
+    /*  Make previous node point to the subsequent node  */
+    if (pPrevNode != MT_NULL)
+        pPrevNode->next_ = pNext;
+
+    /*  Add pNodeToRemove to the beginning of the freeZones  */
+    pNodeToRemove->next_ = pAS_Info->freeZones;
+    pAS_Info->freeZones = pNodeToRemove;
+
+    /*  Decrement node count  */
+    pAS_Info->nZones--;
+
+    return pNext;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_AddExclZone
+**
+**  Description:    Add (and merge) an exclusion zone into the list.
+**                  If the range (f_min, f_max) is totally outside the
+**                  1st IF BW, ignore the entry.
+**                  If the range (f_min, f_max) is negative, ignore the entry.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   103   01-31-2005    DAD    Ver 1.14: In MT_AddExclZone(), if the range
+**                              (f_min, f_max) < 0, ignore the entry.
+**   199   08-06-2008    JWS    Ver 1.22: Indicate success of addition operation.
+**
+*****************************************************************************/
+UData_t MT2063_AddExclZone(MT2063_AvoidSpursData_t* pAS_Info,
+                       UData_t f_min,
+                       UData_t f_max)
+{
+    UData_t status = 1;  /* Assume addition is possible */
+
+    /*  Check to see if this overlaps the 1st IF filter  */
+    if ((f_max > (pAS_Info->f_if1_Center - (pAS_Info->f_if1_bw / 2)))
+        && (f_min < (pAS_Info->f_if1_Center + (pAS_Info->f_if1_bw / 2)))
+        && (f_min < f_max))
+    {
+        /*
+        **                1           2          3        4         5          6
+        **
+        **   New entry:  |---|    |--|        |--|       |-|      |---|         |--|
+        **                     or          or        or       or        or
+        **   Existing:  |--|          |--|      |--|    |---|      |-|      |--|
+        */
+        struct MT2063_ExclZone_t* pNode = pAS_Info->usedZones;
+        struct MT2063_ExclZone_t* pPrev = MT_NULL;
+        struct MT2063_ExclZone_t* pNext = MT_NULL;
+
+        /*  Check for our place in the list  */
+        while ((pNode != MT_NULL) && (pNode->max_ < f_min))
+        {
+            pPrev = pNode;
+            pNode = pNode->next_;
+        }
+
+        if ((pNode != MT_NULL) && (pNode->min_ < f_max))
+        {
+            /*  Combine me with pNode  */
+            if (f_min < pNode->min_)
+                pNode->min_ = f_min;
+            if (f_max > pNode->max_)
+                pNode->max_ = f_max;
+        }
+        else
+        {
+            pNode = InsertNode(pAS_Info, pPrev);
+            pNode->min_ = f_min;
+            pNode->max_ = f_max;
+        }
+
+        /*  Look for merging possibilities  */
+        pNext = pNode->next_;
+        while ((pNext != MT_NULL) && (pNext->min_ < pNode->max_))
+        {
+            if (pNext->max_ > pNode->max_)
+                pNode->max_ = pNext->max_;
+            pNext = RemoveNode(pAS_Info, pNode, pNext);  /*  Remove pNext, return ptr to pNext->next  */
+        }
+    }
+    else
+        status = 0;  /* Did not add the zone - caller determines whether this is a problem */
+
+    return status;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_ChooseFirstIF
+**
+**  Description:    Choose the best available 1st IF
+**                  If f_Desired is not excluded, choose that first.
+**                  Otherwise, return the value closest to f_Center that is
+**                  not excluded
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   117   03-29-2007    RSK    Ver 1.15: Re-wrote to match search order from
+**                              tuner DLL.
+**   147   07-27-2007    RSK    Ver 1.17: Corrected calculation (-) to (+)
+**                              Added logic to force f_Center within 1/2 f_Step.
+**
+*****************************************************************************/
+UData_t MT2063_ChooseFirstIF(MT2063_AvoidSpursData_t* pAS_Info)
+{
+    /*
+    ** Update "f_Desired" to be the nearest "combinational-multiple" of "f_LO1_Step".
+    ** The resulting number, F_LO1 must be a multiple of f_LO1_Step.  And F_LO1 is the arithmetic sum
+    ** of f_in + f_Center.  Neither f_in, nor f_Center must be a multiple of f_LO1_Step.
+    ** However, the sum must be.
+    */
+    const UData_t f_Desired = pAS_Info->f_LO1_Step * ((pAS_Info->f_if1_Request + pAS_Info->f_in + pAS_Info->f_LO1_Step/2) / pAS_Info->f_LO1_Step) - pAS_Info->f_in;
+    const UData_t f_Step = (pAS_Info->f_LO1_Step > pAS_Info->f_LO2_Step) ? pAS_Info->f_LO1_Step : pAS_Info->f_LO2_Step;
+    UData_t f_Center;
+
+    SData_t i;
+    SData_t j = 0;
+    UData_t bDesiredExcluded = 0;
+    UData_t bZeroExcluded = 0;
+    SData_t tmpMin, tmpMax;
+    SData_t bestDiff;
+    struct MT2063_ExclZone_t* pNode = pAS_Info->usedZones;
+    struct MT_FIFZone_t zones[MT2063_MAX_ZONES];
+
+    if (pAS_Info->nZones == 0)
+        return f_Desired;
+
+    /*  f_Center needs to be an integer multiple of f_Step away from f_Desired */
+    if (pAS_Info->f_if1_Center > f_Desired)
+        f_Center = f_Desired + f_Step * ((pAS_Info->f_if1_Center - f_Desired + f_Step/2) / f_Step);
+    else
+        f_Center = f_Desired - f_Step * ((f_Desired - pAS_Info->f_if1_Center + f_Step/2) / f_Step);
+
+//    assert(abs((SData_t) f_Center - (SData_t) pAS_Info->f_if1_Center) <= (SData_t) (f_Step/2));
+
+    /*  Take MT_ExclZones, center around f_Center and change the resolution to f_Step  */
+    while (pNode != MT_NULL)
+    {
+        /*  floor function  */
+        tmpMin = floor((SData_t) (pNode->min_ - f_Center), (SData_t) f_Step);
+
+        /*  ceil function  */
+        tmpMax = ceil((SData_t) (pNode->max_ - f_Center), (SData_t) f_Step);
+
+        if ((pNode->min_ < f_Desired) && (pNode->max_ > f_Desired))
+            bDesiredExcluded = 1;
+
+        if ((tmpMin < 0) && (tmpMax > 0))
+            bZeroExcluded = 1;
+
+        /*  See if this zone overlaps the previous  */
+        if ((j>0) && (tmpMin < zones[j-1].max_))
+            zones[j-1].max_ = tmpMax;
+        else
+        {
+            /*  Add new zone  */
+//            assert(j<MT2063_MAX_ZONES);
+            zones[j].min_ = tmpMin;
+            zones[j].max_ = tmpMax;
+            j++;
+        }
+        pNode = pNode->next_;
+    }
+
+    /*
+    **  If the desired is okay, return with it
+    */
+    if (bDesiredExcluded == 0)
+        return f_Desired;
+
+    /*
+    **  If the desired is excluded and the center is okay, return with it
+    */
+    if (bZeroExcluded == 0)
+        return f_Center;
+
+    /*  Find the value closest to 0 (f_Center)  */
+    bestDiff = zones[0].min_;
+    for (i=0; i<j; i++)
+    {
+        if (abs(zones[i].min_) < abs(bestDiff)) bestDiff = zones[i].min_;
+        if (abs(zones[i].max_) < abs(bestDiff)) bestDiff = zones[i].max_;
+    }
+
+
+    if (bestDiff < 0)
+        return f_Center - ((UData_t) (-bestDiff) * f_Step);
+
+    return f_Center + (bestDiff * f_Step);
+}
+
+
+/****************************************************************************
+**
+**  Name: gcd
+**
+**  Description:    Uses Euclid's algorithm
+**
+**  Parameters:     u, v     - unsigned values whose GCD is desired.
+**
+**  Global:         None
+**
+**  Returns:        greatest common divisor of u and v, if either value
+**                  is 0, the other value is returned as the result.
+**
+**  Dependencies:   None.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-01-2004    JWS    Original
+**   N/A   08-03-2004    DAD    Changed to Euclid's since it can handle
+**                              unsigned numbers.
+**
+****************************************************************************/
+static UData_t gcd(UData_t u, UData_t v)
+{
+    UData_t r;
+
+    while (v != 0)
+    {
+        r = u % v;
+        u = v;
+        v = r;
+    }
+
+    return u;
+}
+
+/****************************************************************************
+**
+**  Name: umax
+**
+**  Description:    Implements a simple maximum function for unsigned numbers.
+**                  Implemented as a function rather than a macro to avoid
+**                  multiple evaluation of the calling parameters.
+**
+**  Parameters:     a, b     - Values to be compared
+**
+**  Global:         None
+**
+**  Returns:        larger of the input values.
+**
+**  Dependencies:   None.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-02-2004    JWS    Original
+**
+****************************************************************************/
+static UData_t umax(UData_t a, UData_t b)
+{
+    return (a >= b) ? a : b;
+}
+
+#if MT_TUNER_CNT > 1
+static SData_t RoundAwayFromZero(SData_t n, SData_t d)
+{
+    return (n<0) ? floor(n, d) : ceil(n, d);
+}
+
+/****************************************************************************
+**
+**  Name: IsSpurInAdjTunerBand
+**
+**  Description:    Checks to see if a spur will be present within the IF's
+**                  bandwidth or near the zero IF.
+**                  (fIFOut +/- fIFBW/2, -fIFOut +/- fIFBW/2)
+**                                  and
+**                  (0 +/- fZIFBW/2)
+**
+**                    ma   mb               me   mf               mc   md
+**                  <--+-+-+-----------------+-+-+-----------------+-+-+-->
+**                     |   ^                   0                   ^   |
+**                     ^   b=-fIFOut+fIFBW/2      -b=+fIFOut-fIFBW/2   ^
+**                     a=-fIFOut-fIFBW/2              -a=+fIFOut+fIFBW/2
+**
+**                  Note that some equations are doubled to prevent round-off
+**                  problems when calculating fIFBW/2
+**
+**                  The spur frequencies are computed as:
+**
+**                     fSpur = n * f1 - m * f2 - fOffset
+**
+**  Parameters:     f1      - The 1st local oscillator (LO) frequency
+**                            of the tuner whose output we are examining
+**                  f2      - The 1st local oscillator (LO) frequency
+**                            of the adjacent tuner
+**                  fOffset - The 2nd local oscillator of the tuner whose
+**                            output we are examining
+**                  fIFOut  - Output IF center frequency
+**                  fIFBW   - Output IF Bandwidth
+**                  nMaxH   - max # of LO harmonics to search
+**                  fp      - If spur, positive distance to spur-free band edge (returned)
+**                  fm      - If spur, negative distance to spur-free band edge (returned)
+**
+**  Returns:        1 if an LO spur would be present, otherwise 0.
+**
+**  Dependencies:   None.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   01-21-2005    JWS    Original, adapted from MT_DoubleConversion.
+**   115   03-23-2007    DAD    Fix declaration of spur due to truncation
+**                              errors.
+**   137   06-18-2007    DAD    Ver 1.16: Fix possible divide-by-0 error for
+**                              multi-tuners that have
+**                              (delta IF1) > (f_out-f_outbw/2).
+**   177 S 02-26-2008    RSK    Ver 1.18: Corrected calculation using LO1 > MAX/2
+**                              Type casts added to preserve correct sign.
+**   199   08-06-2008    JWS    Ver 1.22: Added 0x1x1 spur frequency calculations.
+**
+****************************************************************************/
+static UData_t IsSpurInAdjTunerBand(UData_t bIsMyOutput,
+                                    UData_t f1,
+                                    UData_t f2,
+                                    UData_t fOffset,
+                                    UData_t fIFOut,
+                                    UData_t fIFBW,
+                                    UData_t fZIFBW,
+                                    UData_t nMaxH,
+                                    UData_t *fp,
+                                    UData_t *fm)
+{
+    UData_t bSpurFound = 0;
+
+    const UData_t fHalf_IFBW = fIFBW / 2;
+    const UData_t fHalf_ZIFBW = fZIFBW / 2;
+
+    /* Calculate a scale factor for all frequencies, so that our
+       calculations all stay within 31 bits */
+    const UData_t f_Scale = ((f1 + (fOffset + fIFOut + fHalf_IFBW) / nMaxH) / (MAX_UDATA/2 / nMaxH)) + 1;
+
+    /*
+    **  After this scaling, _f1, _f2, and _f3 are guaranteed to fit into
+    **  signed data types (smaller than MAX_UDATA/2)
+    */
+    const SData_t _f1 = (SData_t) (     f1 / f_Scale);
+    const SData_t _f2 = (SData_t) (     f2 / f_Scale);
+    const SData_t _f3 = (SData_t) (fOffset / f_Scale);
+
+    const SData_t c = (SData_t) (fIFOut - fHalf_IFBW) / (SData_t) f_Scale;
+    const SData_t d = (SData_t) ((fIFOut + fHalf_IFBW) / f_Scale);
+    const SData_t f = (SData_t) (fHalf_ZIFBW / f_Scale);
+
+    SData_t  ma, mb, mc, md, me, mf;
+
+    SData_t  fp_ = 0;
+    SData_t  fm_ = 0;
+    SData_t  n;
+
+
+    /*
+    **  If the other tuner does not have an LO frequency defined,
+    **  assume that we cannot interfere with it
+    */
+    if (f2 == 0)
+        return 0;
+
+
+    /* Check out all multiples of f1 from -nMaxH to +nMaxH */
+    for (n = -(SData_t)nMaxH; n <= (SData_t)nMaxH; ++n)
+    {
+        const SData_t nf1 = n*_f1;
+        md = floor(_f3 + d - nf1, _f2);
+
+        /* If # f2 harmonics > nMaxH, then no spurs present */
+        if (md <= -(SData_t) nMaxH )
+            break;
+
+        ma = floor(_f3 - d - nf1, _f2);
+        if ((ma == md) || (ma >= (SData_t) (nMaxH)))
+            continue;
+
+        mc = floor(_f3 + c - nf1, _f2);
+        if (mc != md)
+        {
+            const SData_t m = md;
+            const SData_t fspur = (nf1 + m*_f2 - _f3);
+            const SData_t den = (bIsMyOutput ? n - 1 : n);
+            if (den == 0)
+            {
+                fp_ = (d - fspur)* f_Scale;
+                fm_ = (fspur - c)* f_Scale;
+            }
+            else
+            {
+                fp_ = (SData_t) RoundAwayFromZero((d - fspur)* f_Scale, den);
+                fm_ = (SData_t) RoundAwayFromZero((fspur - c)* f_Scale, den);
+            }
+            if (((UData_t)abs(fm_) >= f_Scale) && ((UData_t)abs(fp_) >= f_Scale))
+            {
+                bSpurFound = 1;
+                break;
+            }
+        }
+
+        /* Location of Zero-IF-spur to be checked */
+        mf = floor(_f3 + f - nf1, _f2);
+        me = floor(_f3 - f - nf1, _f2);
+        if (me != mf)
+        {
+            const SData_t m = mf;
+            const SData_t fspur = (nf1 + m*_f2 - _f3);
+            const SData_t den = (bIsMyOutput ? n - 1 : n);
+            if (den == 0)
+            {
+                fp_ = (d - fspur)* f_Scale;
+                fm_ = (fspur - c)* f_Scale;
+            }
+            else
+            {
+                fp_ = (SData_t) RoundAwayFromZero((f - fspur)* f_Scale, den);
+                fm_ = (SData_t) RoundAwayFromZero((fspur + f)* f_Scale, den);
+            }
+            if (((UData_t)abs(fm_) >= f_Scale) && ((UData_t)abs(fp_) >= f_Scale))
+            {
+                bSpurFound = 1;
+                break;
+            }
+        }
+
+        mb = floor(_f3 - c - nf1, _f2);
+        if (ma != mb)
+        {
+            const SData_t m = mb;
+            const SData_t fspur = (nf1 + m*_f2 - _f3);
+            const SData_t den = (bIsMyOutput ? n - 1 : n);
+            if (den == 0)
+            {
+                fp_ = (d - fspur)* f_Scale;
+                fm_ = (fspur - c)* f_Scale;
+            }
+            else
+            {
+                fp_ = (SData_t) RoundAwayFromZero((-c - fspur)* f_Scale, den);
+                fm_ = (SData_t) RoundAwayFromZero((fspur +d)* f_Scale, den);
+            }
+            if (((UData_t)abs(fm_) >= f_Scale) && ((UData_t)abs(fp_) >= f_Scale))
+            {
+                bSpurFound = 1;
+                break;
+            }
+        }
+    }
+
+    /*
+    **  Verify that fm & fp are both positive
+    **  Add one to ensure next 1st IF choice is not right on the edge
+    */
+    if (fp_ < 0)
+    {
+        *fp = -fm_ + 1;
+        *fm = -fp_ + 1;
+    }
+    else if (fp_ > 0)
+    {
+        *fp = fp_ + 1;
+        *fm = fm_ + 1;
+    }
+    else
+    {
+        *fp = 1;
+        *fm = abs(fm_) + 1;
+    }
+
+    return bSpurFound;
+}
+#endif
+
+/****************************************************************************
+**
+**  Name: IsSpurInBand
+**
+**  Description:    Checks to see if a spur will be present within the IF's
+**                  bandwidth. (fIFOut +/- fIFBW, -fIFOut +/- fIFBW)
+**
+**                    ma   mb                                     mc   md
+**                  <--+-+-+-------------------+-------------------+-+-+-->
+**                     |   ^                   0                   ^   |
+**                     ^   b=-fIFOut+fIFBW/2      -b=+fIFOut-fIFBW/2   ^
+**                     a=-fIFOut-fIFBW/2              -a=+fIFOut+fIFBW/2
+**
+**                  Note that some equations are doubled to prevent round-off
+**                  problems when calculating fIFBW/2
+**
+**  Parameters:     pAS_Info - Avoid Spurs information block
+**                  fm       - If spur, amount f_IF1 has to move negative
+**                  fp       - If spur, amount f_IF1 has to move positive
+**
+**  Global:         None
+**
+**  Returns:        1 if an LO spur would be present, otherwise 0.
+**
+**  Dependencies:   None.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   11-28-2002    DAD    Implemented algorithm from applied patent
+**
+****************************************************************************/
+static UData_t IsSpurInBand(MT2063_AvoidSpursData_t* pAS_Info,
+                            UData_t* fm,
+                            UData_t* fp)
+{
+    /*
+    **  Calculate LO frequency settings.
+    */
+    UData_t n, n0;
+    const UData_t f_LO1 = pAS_Info->f_LO1;
+    const UData_t f_LO2 = pAS_Info->f_LO2;
+    const UData_t d = pAS_Info->f_out + pAS_Info->f_out_bw/2;
+    const UData_t c = d - pAS_Info->f_out_bw;
+    const UData_t f = pAS_Info->f_zif_bw/2;
+    const UData_t f_Scale = (f_LO1 / (MAX_UDATA/2 / pAS_Info->maxH1)) + 1;
+    SData_t f_nsLO1, f_nsLO2;
+    SData_t f_Spur;
+    UData_t ma, mb, mc, md, me, mf;
+    UData_t lo_gcd, gd_Scale, gc_Scale, gf_Scale, hgds, hgfs, hgcs;
+#if MT_TUNER_CNT > 1
+    UData_t index;
+
+    MT2063_AvoidSpursData_t *adj;
+#endif
+    *fm = 0;
+
+    /*
+    ** For each edge (d, c & f), calculate a scale, based on the gcd
+    ** of f_LO1, f_LO2 and the edge value.  Use the larger of this
+    ** gcd-based scale factor or f_Scale.
+    */
+    lo_gcd = gcd(f_LO1, f_LO2);
+    gd_Scale = umax((UData_t) gcd(lo_gcd, d), f_Scale);
+    hgds = gd_Scale/2;
+    gc_Scale = umax((UData_t) gcd(lo_gcd, c), f_Scale);
+    hgcs = gc_Scale/2;
+    gf_Scale = umax((UData_t) gcd(lo_gcd, f), f_Scale);
+    hgfs = gf_Scale/2;
+
+    n0 = uceil(f_LO2 - d, f_LO1 - f_LO2);
+
+    /*  Check out all multiples of LO1 from n0 to m_maxLOSpurHarmonic  */
+    for (n=n0; n<=pAS_Info->maxH1; ++n)
+    {
+        md = (n*((f_LO1+hgds)/gd_Scale) - ((d+hgds)/gd_Scale)) / ((f_LO2+hgds)/gd_Scale);
+
+        /*  If # fLO2 harmonics > m_maxLOSpurHarmonic, then no spurs present  */
+        if (md >= pAS_Info->maxH1)
+            break;
+
+        ma = (n*((f_LO1+hgds)/gd_Scale) + ((d+hgds)/gd_Scale)) / ((f_LO2+hgds)/gd_Scale);
+
+        /*  If no spurs between +/- (f_out + f_IFBW/2), then try next harmonic  */
+        if (md == ma)
+            continue;
+
+        mc = (n*((f_LO1+hgcs)/gc_Scale) - ((c+hgcs)/gc_Scale)) / ((f_LO2+hgcs)/gc_Scale);
+        if (mc != md)
+        {
+            f_nsLO1 = (SData_t) (n*(f_LO1/gc_Scale));
+            f_nsLO2 = (SData_t) (mc*(f_LO2/gc_Scale));
+            f_Spur = (gc_Scale * (f_nsLO1 - f_nsLO2)) + n*(f_LO1 % gc_Scale) - mc*(f_LO2 % gc_Scale);
+
+            *fp = ((f_Spur - (SData_t) c) / (mc - n)) + 1;
+            *fm = (((SData_t) d - f_Spur) / (mc - n)) + 1;
+            return 1;
+        }
+
+        /*  Location of Zero-IF-spur to be checked  */
+        me = (n*((f_LO1+hgfs)/gf_Scale) + ((f+hgfs)/gf_Scale)) / ((f_LO2+hgfs)/gf_Scale);
+        mf = (n*((f_LO1+hgfs)/gf_Scale) - ((f+hgfs)/gf_Scale)) / ((f_LO2+hgfs)/gf_Scale);
+        if (me != mf)
+        {
+            f_nsLO1 = n*(f_LO1/gf_Scale);
+            f_nsLO2 = me*(f_LO2/gf_Scale);
+            f_Spur = (gf_Scale * (f_nsLO1 - f_nsLO2)) + n*(f_LO1 % gf_Scale) - me*(f_LO2 % gf_Scale);
+
+            *fp = ((f_Spur + (SData_t) f) / (me - n)) + 1;
+            *fm = (((SData_t) f - f_Spur) / (me - n)) + 1;
+            return 1;
+        }
+
+        mb = (n*((f_LO1+hgcs)/gc_Scale) + ((c+hgcs)/gc_Scale)) / ((f_LO2+hgcs)/gc_Scale);
+        if (ma != mb)
+        {
+            f_nsLO1 = n*(f_LO1/gc_Scale);
+            f_nsLO2 = ma*(f_LO2/gc_Scale);
+            f_Spur = (gc_Scale * (f_nsLO1 - f_nsLO2)) + n*(f_LO1 % gc_Scale) - ma*(f_LO2 % gc_Scale);
+
+            *fp = (((SData_t) d + f_Spur) / (ma - n)) + 1;
+            *fm = (-(f_Spur + (SData_t) c) / (ma - n)) + 1;
+            return 1;
+        }
+    }
+
+#if MT_TUNER_CNT > 1
+    /*  If no spur found, see if there are more tuners on the same board  */
+    for (index = 0; index < TunerCount; ++index)
+    {
+        adj = TunerList[index];
+        if (pAS_Info == adj)    /* skip over our own data, don't process it */
+            continue;
+
+        /*  Look for LO-related spurs from the adjacent tuner generated into my IF output  */
+        if (IsSpurInAdjTunerBand(1,                   /*  check my IF output                     */
+                                 pAS_Info->f_LO1,     /*  my fLO1                                */
+                                 adj->f_LO1,          /*  the other tuner's fLO1                 */
+                                 pAS_Info->f_LO2,     /*  my fLO2                                */
+                                 pAS_Info->f_out,     /*  my fOut                                */
+                                 pAS_Info->f_out_bw,  /*  my output IF bandwidth                 */
+                                 pAS_Info->f_zif_bw,  /*  my Zero-IF bandwidth                   */
+                                 pAS_Info->maxH2,
+                                 fp,                  /*  minimum amount to move LO's positive   */
+                                 fm))                 /*  miminum amount to move LO's negative   */
+            return 1;
+        /*  Look for LO-related spurs from my tuner generated into the adjacent tuner's IF output  */
+        if (IsSpurInAdjTunerBand(0,                   /*  check his IF output                    */
+                                 pAS_Info->f_LO1,     /*  my fLO1                                */
+                                 adj->f_LO1,          /*  the other tuner's fLO1                 */
+                                 adj->f_LO2,          /*  the other tuner's fLO2                 */
+                                 adj->f_out,          /*  the other tuner's fOut                 */
+                                 adj->f_out_bw,       /*  the other tuner's output IF bandwidth  */
+                                 pAS_Info->f_zif_bw,  /*  the other tuner's Zero-IF bandwidth    */
+                                 adj->maxH2,
+                                 fp,                  /*  minimum amount to move LO's positive   */
+                                 fm))                 /*  miminum amount to move LO's negative   */
+            return 1;
+    }
+#endif
+    /*  No spurs found  */
+    return 0;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_AvoidSpurs
+**
+**  Description:    Main entry point to avoid spurs.
+**                  Checks for existing spurs in present LO1, LO2 freqs
+**                  and if present, chooses spur-free LO1, LO2 combination
+**                  that tunes the same input/output frequencies.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   096   04-06-2005    DAD    Ver 1.11: Fix divide by 0 error if maxH==0.
+**
+*****************************************************************************/
+UData_t MT2063_AvoidSpurs(Handle_t h,
+                      MT2063_AvoidSpursData_t* pAS_Info)
+{
+    UData_t status = MT_OK;
+    UData_t fm, fp;                     /*  restricted range on LO's        */
+    pAS_Info->bSpurAvoided = 0;
+    pAS_Info->nSpursFound = 0;
+    h;                          /*  warning expected: code has no effect    */
+
+    if (pAS_Info->maxH1 == 0)
+        return MT_OK;
+
+    /*
+    **  Avoid LO Generated Spurs
+    **
+    **  Make sure that have no LO-related spurs within the IF output
+    **  bandwidth.
+    **
+    **  If there is an LO spur in this band, start at the current IF1 frequency
+    **  and work out until we find a spur-free frequency or run up against the
+    **  1st IF SAW band edge.  Use temporary copies of fLO1 and fLO2 so that they
+    **  will be unchanged if a spur-free setting is not found.
+    */
+    pAS_Info->bSpurPresent = IsSpurInBand(pAS_Info, &fm, &fp);
+    if (pAS_Info->bSpurPresent)
+    {
+        UData_t zfIF1 = pAS_Info->f_LO1 - pAS_Info->f_in; /*  current attempt at a 1st IF  */
+        UData_t zfLO1 = pAS_Info->f_LO1;         /*  current attempt at an LO1 freq  */
+        UData_t zfLO2 = pAS_Info->f_LO2;         /*  current attempt at an LO2 freq  */
+        UData_t delta_IF1;
+        UData_t new_IF1;
+        UData_t added;                           /*  success of Excl Zone addition  */
+
+        /*
+        **  Spur was found, attempt to find a spur-free 1st IF
+        */
+        do
+        {
+            pAS_Info->nSpursFound++;
+
+            /*  Raise f_IF1_upper, if needed  */
+            added = MT2063_AddExclZone(pAS_Info, zfIF1 - fm, zfIF1 + fp);
+
+            /*
+            **  If Exclusion Zone could NOT be added, then we'll just keep picking
+            **  the same bad point, so exit this loop and report that there is a
+            **  spur present in the output
+            */
+            if (!added)
+                break;
+
+            /*  Choose next IF1 that is closest to f_IF1_CENTER              */
+            new_IF1 = MT2063_ChooseFirstIF(pAS_Info);
+
+            if (new_IF1 > zfIF1)
+            {
+                pAS_Info->f_LO1 += (new_IF1 - zfIF1);
+                pAS_Info->f_LO2 += (new_IF1 - zfIF1);
+            }
+            else
+            {
+                pAS_Info->f_LO1 -= (zfIF1 - new_IF1);
+                pAS_Info->f_LO2 -= (zfIF1 - new_IF1);
+            }
+            zfIF1 = new_IF1;
+
+            if (zfIF1 > pAS_Info->f_if1_Center)
+                delta_IF1 = zfIF1 - pAS_Info->f_if1_Center;
+            else
+                delta_IF1 = pAS_Info->f_if1_Center - zfIF1;
+        }
+        /*
+        **  Continue while the new 1st IF is still within the 1st IF bandwidth
+        **  and there is a spur in the band (again)
+        */
+        while ((2*delta_IF1 + pAS_Info->f_out_bw <= pAS_Info->f_if1_bw) &&
+              (pAS_Info->bSpurPresent = IsSpurInBand(pAS_Info, &fm, &fp)));
+
+        /*
+        ** Use the LO-spur free values found.  If the search went all the way to
+        ** the 1st IF band edge and always found spurs, just leave the original
+        ** choice.  It's as "good" as any other.
+        */
+        if (pAS_Info->bSpurPresent == 1)
+        {
+            status |= MT_SPUR_PRESENT;
+            pAS_Info->f_LO1 = zfLO1;
+            pAS_Info->f_LO2 = zfLO2;
+        }
+        else
+            pAS_Info->bSpurAvoided = 1;
+    }
+
+    status |= ((pAS_Info->nSpursFound << MT_SPUR_SHIFT) & MT_SPUR_CNT_MASK);
+
+    return (status);
+}
+
+
+UData_t MT2063_AvoidSpursVersion(void)
+{
+    return (MT_SPURAVOID_VERSION);
+}
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_mt2063.h b/drivers/media/usb/rtl2832u/tuner_mt2063.h
new file mode 100644
index 00000000..b35a285b
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mt2063.h
@@ -0,0 +1,2206 @@
+#ifndef __TUNER_MT2063_H
+#define __TUNER_MT2063_H
+
+/**
+
+@file
+
+@brief   MT2063 tuner module declaration
+
+One can manipulate MT2063 tuner through MT2063 module.
+MT2063 module is derived from tunerd module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_mt2063.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	MT2063_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long IfFreqHz;
+
+
+	...
+
+
+
+	// Build MT2063 tuner module.
+	BuildMt2063Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0								// I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get MT2063 tuner extra module.
+	pTunerExtra = &(pTuner->pExtra.Mt2063);
+
+	// Open MT2063 handle.
+	pTunerExtra->OpenHandle(pTuner);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set MT2063 IF frequency.
+	pTunerExtra->SetIfFreqHz(pTuner, IF_FREQ_36125000HZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get MT2063 IF frequency.
+	pTunerExtra->SetIfFreqHz(pTuner, &IfFreqHz);
+
+
+
+
+
+	// Close MT2063 handle.
+	pTunerExtra->CloseHandle(pTuner);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Microtune source code - mt_errordef.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt_errordef.h
+**
+**  Copyright 2004-2007 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt_errordef.h
+**
+**  Description:    Definition of bits in status/error word used by various
+**                  MicroTuner control programs.
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_errordef.h,v 1.2 2008/11/05 13:46:19 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt_errordef.h,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   09-09-2004    JWS    Original
+**   088   01-26-2005    DAD    Added MT_TUNER_INIT_ERR.
+**   N/A   12-09-2005    DAD    Added MT_TUNER_TIMEOUT (info).
+**   N/A   10-17-2006    JWS    Updated copyright notice.
+**   N/A L 02-25-2008    RSK    Correcting Comment Block to match constants.
+**
+*****************************************************************************/
+
+/*
+** Note to users:  DO NOT EDIT THIS FILE
+**
+** If you wish to rename any of the "user defined" bits,
+** it should be done in the user file that includes this
+** source file (e.g. mt_userdef.h)
+**
+*/
+
+
+
+/*
+**  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+**  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+**  M U <- Info Codes --> <# Spurs> < User> <----- Err Codes ----->
+**
+**  31 = MT_ERROR - Master Error Flag.  If set, check Err Codes for reason.
+**  30 = MT_USER_ERROR - User-declared error flag.
+**  29 = Unused
+**  28 = Unused
+**
+**  27 = MT_DNC_RANGE
+**  26 = MT_UPC_RANGE
+**  25 = MT_FOUT_RANGE
+**  24 = MT_FIN_OUT_OF_RANGE
+**
+**  23 = MT_SPUR_PRESENT - Unavoidable spur in output
+**  22 = MT_TUNER_TIMEOUT
+**  21 = Unused
+**  20 = MT_SPUR_CNT_MASK (MSB) - Count of avoided spurs
+**
+**  19 = MT_SPUR_CNT_MASK
+**  18 = MT_SPUR_CNT_MASK
+**  17 = MT_SPUR_CNT_MASK
+**  16 = MT_SPUR_CNT_MASK (LSB)
+**
+**  15 = MT_USER_DEFINED4 - User-definable bit (see MT_Userdef.h)
+**  14 = MT_USER_DEFINED3 - User-definable bit (see MT_Userdef.h)
+**  13 = MT_USER_DEFINED2 - User-definable bit (see MT_Userdef.h)
+**  12 = MT_USER_DEFINED1 - User-definable bit (see MT_Userdef.h)
+**
+**  11 = Unused
+**  10 = Unused
+**   9 = MT_TUNER_INIT_ERR - Tuner initialization error
+**   8 = MT_TUNER_ID_ERR - Tuner Part Code / Rev Code mismatches expected value
+**
+**   7 = MT_TUNER_CNT_ERR - Attempt to open more than MT_TUNER_CNT tuners
+**   6 = MT_ARG_NULL - Null pointer passed as argument
+**   5 = MT_ARG_RANGE - Argument value out of range
+**   4 = MT_INV_HANDLE - Tuner handle is invalid
+**
+**   3 = MT_COMM_ERR - Serial bus communications error
+**   2 = MT_DNC_UNLOCK - Downconverter PLL is unlocked
+**   1 = MT_UPC_UNLOCK - Upconverter PLL is unlocked
+**   0 = MT_UNKNOWN - Unknown error
+*/
+#define MT_ERROR (1 << 31)
+#define MT_USER_ERROR (1 << 30)
+
+/*  Macro to be used to check for errors  */
+#define MT_IS_ERROR(s) (((s) >> 30) != 0)
+#define MT_NO_ERROR(s) (((s) >> 30) == 0)
+
+
+#define MT_OK                           (0x00000000)
+
+/*  Unknown error  */
+#define MT_UNKNOWN                      (0x80000001)
+
+/*  Error:  Upconverter PLL is not locked  */
+#define MT_UPC_UNLOCK                   (0x80000002)
+
+/*  Error:  Downconverter PLL is not locked  */
+#define MT_DNC_UNLOCK                   (0x80000004)
+
+/*  Error:  Two-wire serial bus communications error  */
+#define MT_COMM_ERR                     (0x80000008)
+
+/*  Error:  Tuner handle passed to function was invalid  */
+#define MT_INV_HANDLE                   (0x80000010)
+
+/*  Error:  Function argument is invalid (out of range)  */
+#define MT_ARG_RANGE                    (0x80000020)
+
+/*  Error:  Function argument (ptr to return value) was NULL  */
+#define MT_ARG_NULL                     (0x80000040)
+
+/*  Error: Attempt to open more than MT_TUNER_CNT tuners  */
+#define MT_TUNER_CNT_ERR                (0x80000080)
+
+/*  Error: Tuner Part Code / Rev Code mismatches expected value  */
+#define MT_TUNER_ID_ERR                 (0x80000100)
+
+/*  Error: Tuner Initialization failure  */
+#define MT_TUNER_INIT_ERR               (0x80000200)
+
+/*  User-definable fields (see mt_userdef.h)  */
+#define MT_USER_DEFINED1                (0x00001000)
+#define MT_USER_DEFINED2                (0x00002000)
+#define MT_USER_DEFINED3                (0x00004000)
+#define MT_USER_DEFINED4                (0x00008000)
+#define MT_USER_MASK                    (0x4000f000)
+#define MT_USER_SHIFT                   (12)
+
+/*  Info: Mask of bits used for # of LO-related spurs that were avoided during tuning  */
+#define MT_SPUR_CNT_MASK                (0x001f0000)
+#define MT_SPUR_SHIFT                   (16)
+
+/*  Info: Tuner timeout waiting for condition  */
+#define MT_TUNER_TIMEOUT                (0x00400000)
+
+/*  Info: Unavoidable LO-related spur may be present in the output  */
+#define MT_SPUR_PRESENT                 (0x00800000)
+
+/*  Info: Tuner input frequency is out of range */
+#define MT_FIN_RANGE                    (0x01000000)
+
+/*  Info: Tuner output frequency is out of range */
+#define MT_FOUT_RANGE                   (0x02000000)
+
+/*  Info: Upconverter frequency is out of range (may be reason for MT_UPC_UNLOCK) */
+#define MT_UPC_RANGE                    (0x04000000)
+
+/*  Info: Downconverter frequency is out of range (may be reason for MT_DPC_UNLOCK) */
+#define MT_DNC_RANGE                    (0x08000000)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt_userdef.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt_userdef.h
+**
+**  Copyright 2006-2008 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable and the terms of the end-user software
+**  license agreement (EULA).
+**
+**  Protected by US Patent 7,035,614 and additional patents pending or filed.
+**
+**  BY INSTALLING, COPYING, OR USING THE MICROTUNE SOFTWARE, YOU AGREE TO BE
+**  BOUND BY ALL OF THE TERMS AND CONDITIONS OF THE MICROTUNE, INC. END-USER
+**  SOFTWARE LICENSE AGREEMENT (EULA), INCLUDING BUT NOT LIMITED TO, THE
+**  CONFIDENTIALITY OBLIGATIONS DESCRIBED THEREIN. IF YOU DO NOT AGREE, DO NOT
+**  INSTALL, COPY, OR USE THE MICROTUNE SOFTWARE AND IMMEDIATELY RETURN OR
+**  DESTROY ANY COPIES OF MICROTUNE SOFTWARE OR CONFIDENTIAL INFORMATION THAT
+**  YOU HAVE IN YOUR POSSESSION.
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt_userdef.h
+**
+**  Description:    User-defined data types needed by MicroTuner source code.
+**
+**                  Customers must provide the code for these functions
+**                  in the file "mt_userdef.c".
+**
+**                  Customers must verify that the typedef's in the 
+**                  "Data Types" section are correct for their platform.
+**
+**  Functions
+**  Requiring
+**  Implementation: MT_WriteSub
+**                  MT_ReadSub
+**                  MT_Sleep
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_userdef.h,v 1.2 2008/11/05 13:46:20 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt_userdef.h,v $
+**	               
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**   082   12-06-2004    JWS    Multi-tuner support - requires MTxxxx_CNT 
+**                              declarations
+**   N/A   04-13-2007    JWS    Added Signed 8-bit type - S8Data
+**   200   08-07-2008    JWS    Included definition of DECT avoid constants.
+**
+*****************************************************************************/
+#if !defined( __MT_USERDEF_H )
+#define __MT_USERDEF_H
+
+//#include "mt_errordef.h"
+
+#if defined( __cplusplus )     
+extern "C"                     /* Use "C" external linkage                  */
+{
+#endif
+
+#if !defined( __MT_DATA_DEF_H )
+#define __MT_DATA_DEF_H
+/*
+**  Data Types
+*/
+typedef unsigned char   U8Data;         /*  type corresponds to 8 bits      */
+typedef signed char     S8Data;         /*  type corresponds to 8 bits      */
+typedef unsigned int    UData_t;        /*  type must be at least 32 bits   */
+typedef int             SData_t;        /*  type must be at least 32 bits   */
+typedef void *          Handle_t;       /*  memory pointer type             */
+typedef double          FData_t;        /*  floating point data type        */
+#endif
+#define MAX_UDATA         (4294967295)  /*  max value storable in UData_t   */
+
+/*
+** Define an MTxxxx_CNT macro for each type of tuner that will be built
+** into your application (e.g., MT2121, MT2060). MT_TUNER_CNT
+** must be set to the SUM of all of the MTxxxx_CNT macros.
+**
+** #define MT2050_CNT  (1)
+** #define MT2060_CNT  (1)
+** #define MT2111_CNT  (1)
+** #define MT2121_CNT  (3)
+*/
+
+
+#if !defined( MT_TUNER_CNT )
+#define MT_TUNER_CNT               (1)  /*  total num of MicroTuner tuners  */
+#endif
+
+#ifndef _MT_DECT_Avoid_Type_DEFINE_
+#define _MT_DECT_Avoid_Type_DEFINE_
+//
+// DECT Frequency Avoidance:
+// These constants are used to avoid interference from DECT frequencies.
+//
+typedef enum
+{
+    MT_NO_DECT_AVOIDANCE = 0,              /* Do not create DECT exclusion zones.     */
+    MT_AVOID_US_DECT     = 0x00000001,     /* Avoid US DECT frequencies.              */
+    MT_AVOID_EURO_DECT   = 0x00000002,     /* Avoid European DECT frequencies.        */
+    MT_AVOID_BOTH                          /* Avoid both regions. Not typically used. */
+} MT_DECT_Avoid_Type;
+#endif
+/*
+**  Optional user-defined Error/Info Codes  (examples below)
+**
+**  This is the area where you can define user-specific error/info return
+**  codes to be returned by any of the functions you are responsible for
+**  writing such as MT_WriteSub() and MT_ReadSub.  There are four bits
+**  available in the status field for your use.  When set, these
+**  bits will be returned in the status word returned by any tuner driver
+**  call.  If you OR in the MT_ERROR bit as well, the tuner driver code
+**  will treat the code as an error.
+**
+**  The following are a few examples of errors you can provide.
+**
+**  Example 1:
+**  You might check to see the hUserData handle is correct and issue 
+**  MY_USERDATA_INVALID which would be defined like this:
+**
+**  #define MY_USERDATA_INVALID  (MT_USER_ERROR | MT_USER_DEFINED1)
+**
+**
+**  Example 2:
+**  You might be able to provide more descriptive two-wire bus errors:
+**
+**  #define NO_ACK   (MT_USER_ERROR | MT_USER_DEFINED1)
+**  #define NO_NACK  (MT_USER_ERROR | MT_USER_DEFINED2)
+**  #define BUS_BUSY (MT_USER_ERROR | MT_USER_DEFINED3)
+**
+**
+**  Example 3:
+**  You can also provide information (non-error) feedback:
+**
+**  #define MY_INFO_1   (MT_USER_DEFINED1)
+**
+**
+**  Example 4:
+**  You can combine the fields together to make a multi-bit field.
+**  This one can provide the tuner number based off of the addr
+**  passed to MT_WriteSub or MT_ReadSub.  It assumes that
+**  MT_USER_DEFINED4 through MT_USER_DEFINED1 are contiguously. If
+**  TUNER_NUM were OR'ed into the status word on an error, you could
+**  use this to identify which tuner had the problem (and whether it
+**  was during a read or write operation).
+**
+**  #define TUNER_NUM  ((addr & 0x07) >> 1) << MT_USER_SHIFT
+**
+*/
+
+/*****************************************************************************
+**
+**  Name: MT_WriteSub
+**
+**  Description:    Write values to device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to write data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2063_WriteSub(Handle_t hUserData, 
+                    UData_t addr, 
+                    U8Data subAddress, 
+                    U8Data *pData, 
+                    UData_t cnt);
+
+
+/*****************************************************************************
+**
+**  Name: MT_ReadSub
+**
+**  Description:    Read values from device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to read data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2063_ReadSub(Handle_t hUserData, 
+                   UData_t addr, 
+                   U8Data subAddress, 
+                   U8Data *pData, 
+                   UData_t cnt);
+
+
+/*****************************************************************************
+**
+**  Name: MT_Sleep
+**
+**  Description:    Delay execution for "nMinDelayTime" milliseconds
+**
+**  Parameters:     hUserData     - User-specific I/O parameter that was
+**                                  passed to tuner's Open function.
+**                  nMinDelayTime - Delay time in milliseconds
+**
+**  Returns:        None.
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code that
+**                  blocks execution for the specified period of time. 
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+void MT2063_Sleep(Handle_t hUserData,
+              UData_t nMinDelayTime);
+
+
+#if defined(MT2060_CNT)
+#if MT2060_CNT > 0
+/*****************************************************************************
+**
+**  Name: MT_TunerGain  (for MT2060 only)
+**
+**  Description:    Measure the relative tuner gain using the demodulator
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  pMeas      - Tuner gain (1/100 of dB scale).
+**                               ie. 1234 = 12.34 (dB)
+**
+**  Returns:        status:
+**                      MT_OK  - No errors
+**                      user-defined errors could be set
+**
+**  Notes:          This is a callback function that is called from the
+**                  the 1st IF location routine.  You MUST provide
+**                  code that measures the relative tuner gain in a dB
+**                  (not linear) scale.  The return value is an integer
+**                  value scaled to 1/100 of a dB.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-16-2004    DAD    Original
+**   N/A   11-30-2004    DAD    Renamed from MT_DemodInputPower.  This name
+**                              better describes what this function does.
+**
+*****************************************************************************/
+UData_t MT_TunerGain(Handle_t hUserData,
+                     SData_t* pMeas);
+#endif
+#endif
+
+#if defined( __cplusplus )     
+}
+#endif
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt2063.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt2063.h
+**
+**  Copyright 2007 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt2063.h
+**
+**  Description:    Microtune MT2063 B0/B1 Tuner software interface
+**                  Supports tuners with Part/Rev codes: 0x9B, 0x9C.
+**
+**  Functions
+**  Implemented:    UData_t  MT2063_Open
+**                  UData_t  MT2063_Close
+**                  UData_t  MT2063_GetGPIO
+**                  UData_t  MT2063_GetLocked
+**                  UData_t  MT2063_GetParam
+**                  UData_t  MT2063_GetPowerMaskBits
+**                  UData_t  MT2063_GetReg
+**                  UData_t  MT2063_GetTemp
+**                  UData_t  MT2063_GetUserData
+**                  UData_t  MT2063_ReInit
+**                  UData_t  MT2063_SetGPIO
+**                  UData_t  MT2063_SetParam
+**                  UData_t  MT2063_SetPowerMaskBits
+**                  UData_t  MT2063_ClearPowerMaskBits
+**                  UData_t  MT2063_SetReg
+**                  UData_t  MT2063_Tune
+**
+**  References:     AN-xxxxx: MT2063 Programming Procedures Application Note
+**                  MicroTune, Inc.
+**                  AN-00010: MicroTuner Serial Interface Application Note
+**                  MicroTune, Inc.
+**
+**  Enumerations
+**  Defined:        MT2063_Ext_SRO
+**                  MT2063_Param
+**                  MT2063_Mask_Bits
+**                  MT2063_GPIO_Attr;
+**                  MT2063_Temperature
+**
+**  Exports:        None
+**
+**  Dependencies:   MT_ReadSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Read byte(s) of data from the two-wire bus.
+**
+**                  MT_WriteSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Write byte(s) of data to the two-wire bus.
+**
+**                  MT_Sleep(hUserData, nMinDelayTime);
+**                  - Delay execution for nMinDelayTime milliseconds
+**
+**  CVS ID:         $Id: mt2063.h,v 1.5 2009/04/29 09:58:14 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt2063.h,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   N/A   08-01-2007    PINZ   Changed Analog & DVB-T settings and added
+**                              SAW-less receiver mode.
+**   155   10-01-2007    DAD    Ver 1.06: Add receiver mode for SECAM positive
+**                                        modulation
+**                                        (MT2063_ANALOG_TV_POS_NO_RFAGC_MODE)
+**   N/A   10-22-2007    PINZ   Ver 1.07: Changed some Registers at init to have
+**                                        the same settings as with MT Launcher
+**   N/A   10-30-2007    PINZ             Add SetParam VGAGC & VGAOI
+**                                        Add SetParam DNC_OUTPUT_ENABLE
+**                                        Removed VGAGC from receiver mode,
+**                                        default now 1
+**   N/A   10-31-2007    PINZ   Ver 1.08: Add SetParam TAGC, removed from rcvr-mode
+**                                        Add SetParam AMPGC, removed from rcvr-mode
+**                                        Corrected names of GCU values
+**                                        Actualized Receiver-Mode values
+**   N/A   04-18-2008    PINZ   Ver 1.09: Add SetParam LNA_TGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   175 I 06-06-2008    PINZ   Ver 1.10: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**   175 I 06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         07-10-2008    PINZ   Ver 1.19: Documentation Updates, Add a GetParam
+**                                        for each SetParam (LNA_RIN, TGTs)
+**         01-07-2009    PINZ   Ver 1.27: Changed value of MT2063_ALL_SD in .h
+**         02-16-2009    PINZ   Ver 1.29: Several fixes to improve compiler behavior
+**   N/A I 03-19-2009    PINZ   Ver 1.32: Add GetParam VERSION (of API)
+**                                        Add GetParam IC_REV
+*****************************************************************************/
+#if !defined( __MT2063_H )
+#define __MT2063_H
+
+//#include "mt_userdef.h"
+
+#if defined( __cplusplus )
+extern "C"                     /* Use "C" external linkage                  */
+{
+#endif
+
+
+/*
+** Chip revision
+**
+*/
+typedef enum
+{
+    MT2063_XX = 0,
+    MT2063_B0 = 206310,
+    MT2063_B1 = 206311,
+    MT2063_B3 = 206313
+} MT2063_REVCODE;
+
+
+/*
+**  Values returned by the MT2063's on-chip temperature sensor
+**  to be read/written.
+*/
+typedef enum
+{
+    MT2063_T_0C = 0,                    /*  Temperature approx 0C           */
+    MT2063_T_10C,                       /*  Temperature approx 10C          */
+    MT2063_T_20C,                       /*  Temperature approx 20C          */
+    MT2063_T_30C,                       /*  Temperature approx 30C          */
+    MT2063_T_40C,                       /*  Temperature approx 40C          */
+    MT2063_T_50C,                       /*  Temperature approx 50C          */
+    MT2063_T_60C,                       /*  Temperature approx 60C          */
+    MT2063_T_70C,                       /*  Temperature approx 70C          */
+    MT2063_T_80C,                       /*  Temperature approx 80C          */
+    MT2063_T_90C,                       /*  Temperature approx 90C          */
+    MT2063_T_100C,                      /*  Temperature approx 100C         */
+    MT2063_T_110C,                      /*  Temperature approx 110C         */
+    MT2063_T_120C,                      /*  Temperature approx 120C         */
+    MT2063_T_130C,                      /*  Temperature approx 130C         */
+    MT2063_T_140C,                      /*  Temperature approx 140C         */
+    MT2063_T_150C                       /*  Temperature approx 150C         */
+} MT2063_Temperature;
+
+
+/*
+** Parameters for selecting GPIO bits
+*/
+typedef enum
+{
+    MT2063_GPIO_IN,
+    MT2063_GPIO_DIR,
+    MT2063_GPIO_OUT
+} MT2063_GPIO_Attr;
+
+typedef enum
+{
+    MT2063_GPIO0,
+    MT2063_GPIO1,
+    MT2063_GPIO2
+} MT2063_GPIO_ID;
+
+
+/*
+**  Parameter for function MT2063_SetExtSRO that specifies the external
+**  SRO drive frequency.
+**
+**  MT2063_EXT_SRO_OFF is the power-up default value.
+*/
+typedef enum
+{
+    MT2063_EXT_SRO_OFF,                 /*  External SRO drive off          */
+    MT2063_EXT_SRO_BY_4,                /*  External SRO drive divide by 4  */
+    MT2063_EXT_SRO_BY_2,                /*  External SRO drive divide by 2  */
+    MT2063_EXT_SRO_BY_1                 /*  External SRO drive divide by 1  */
+} MT2063_Ext_SRO;
+
+
+/*
+**  Parameter for function MT2063_SetPowerMask that specifies the power down
+**  of various sections of the MT2063.
+*/
+typedef enum
+{
+    MT2063_REG_SD   = 0x0040,   /* Shutdown regulator                 */
+    MT2063_SRO_SD   = 0x0020,   /* Shutdown SRO                       */
+    MT2063_AFC_SD   = 0x0010,   /* Shutdown AFC A/D                   */
+    MT2063_PD_SD    = 0x0002,   /* Enable power detector shutdown     */
+    MT2063_PDADC_SD = 0x0001,   /* Enable power detector A/D shutdown */
+    MT2063_VCO_SD   = 0x8000,   /* Enable VCO shutdown                */
+    MT2063_LTX_SD   = 0x4000,   /* Enable LTX shutdown                */
+    MT2063_LT1_SD   = 0x2000,   /* Enable LT1 shutdown                */
+    MT2063_LNA_SD   = 0x1000,   /* Enable LNA shutdown                */
+    MT2063_UPC_SD   = 0x0800,   /* Enable upconverter shutdown        */
+    MT2063_DNC_SD   = 0x0400,   /* Enable downconverter shutdown      */
+    MT2063_VGA_SD   = 0x0200,   /* Enable VGA shutdown                */
+    MT2063_AMP_SD   = 0x0100,   /* Enable AMP shutdown                */
+    MT2063_ALL_SD   = 0xFF13,   /* All shutdown bits for this tuner   */
+    MT2063_NONE_SD  = 0x0000    /* No shutdown bits                   */
+} MT2063_Mask_Bits;
+
+
+/*
+**  Parameter for function MT2063_GetParam & MT2063_SetParam that
+**  specifies the tuning algorithm parameter to be read/written.
+*/
+typedef enum
+{
+    /*  version of the API, e.g. 10302 = 1.32                               */
+    MT2063_VERSION,
+
+    /*  tuner address                                  set by MT2063_Open() */
+    MT2063_IC_ADDR,
+
+    /*  tuner revision code  (see enum  MT2063_REVCODE for values)          */
+    MT2063_IC_REV,
+
+    /*  max number of MT2063 tuners     set by MT_TUNER_CNT in mt_userdef.h */
+    MT2063_MAX_OPEN,
+
+    /*  current number of open MT2063 tuners           set by MT2063_Open() */
+    MT2063_NUM_OPEN,
+
+    /*  crystal frequency                            (default: 16000000 Hz) */
+    MT2063_SRO_FREQ,
+
+    /*  min tuning step size                            (default: 50000 Hz) */
+    MT2063_STEPSIZE,
+
+    /*  input center frequency                         set by MT2063_Tune() */
+    MT2063_INPUT_FREQ,
+
+    /*  LO1 Frequency                                  set by MT2063_Tune() */
+    MT2063_LO1_FREQ,
+
+    /*  LO1 minimum step size                          (default: 250000 Hz) */
+    MT2063_LO1_STEPSIZE,
+
+    /*  LO1 FracN keep-out region                      (default: 999999 Hz) */
+    MT2063_LO1_FRACN_AVOID,
+
+    /*  Current 1st IF in use                          set by MT2063_Tune() */
+    MT2063_IF1_ACTUAL,
+
+    /*  Requested 1st IF                               set by MT2063_Tune() */
+    MT2063_IF1_REQUEST,
+
+    /*  Center of 1st IF SAW filter                (default: 1218000000 Hz) */
+    MT2063_IF1_CENTER,
+
+    /*  Bandwidth of 1st IF SAW filter               (default: 20000000 Hz) */
+    MT2063_IF1_BW,
+
+    /*  zero-IF bandwidth                             (default: 2000000 Hz) */
+    MT2063_ZIF_BW,
+
+    /*  LO2 Frequency                                  set by MT2063_Tune() */
+    MT2063_LO2_FREQ,
+
+    /*  LO2 minimum step size                           (default: 50000 Hz) */
+    MT2063_LO2_STEPSIZE,
+
+    /*  LO2 FracN keep-out region                      (default: 374999 Hz) */
+    MT2063_LO2_FRACN_AVOID,
+
+    /*  output center frequency                        set by MT2063_Tune() */
+    MT2063_OUTPUT_FREQ,
+
+    /*  output bandwidth                               set by MT2063_Tune() */
+    MT2063_OUTPUT_BW,
+
+    /*  min inter-tuner LO separation                 (default: 1000000 Hz) */
+    MT2063_LO_SEPARATION,
+
+    /*  ID of avoid-spurs algorithm in use            compile-time constant */
+    MT2063_AS_ALG,
+
+    /*  max # of intra-tuner harmonics                       (default: 15)  */
+    MT2063_MAX_HARM1,
+
+    /*  max # of inter-tuner harmonics                        (default: 7)  */
+    MT2063_MAX_HARM2,
+
+    /*  # of 1st IF exclusion zones used               set by MT2063_Tune() */
+    MT2063_EXCL_ZONES,
+
+    /*  # of spurs found/avoided                       set by MT2063_Tune() */
+    MT2063_NUM_SPURS,
+
+    /*  >0 spurs avoided                               set by MT2063_Tune() */
+    MT2063_SPUR_AVOIDED,
+
+    /*  >0 spurs in output (mathematically)            set by MT2063_Tune() */
+    MT2063_SPUR_PRESENT,
+
+    /* Receiver Mode for some parameters. 1 is DVB-T                        */
+    MT2063_RCVR_MODE,
+
+    /* directly set LNA attenuation, parameter is value to set              */
+    MT2063_ACLNA,
+
+    /* maximum LNA attenuation, parameter is value to set                   */
+    MT2063_ACLNA_MAX,
+
+    /* directly set ATN attenuation.  Paremeter is value to set.            */
+    MT2063_ACRF,
+
+    /* maxium ATN attenuation.  Paremeter is value to set.                  */
+    MT2063_ACRF_MAX,
+
+    /* directly set FIF attenuation.  Paremeter is value to set.            */
+    MT2063_ACFIF,
+
+    /* maxium FIF attenuation.  Paremeter is value to set.                  */
+    MT2063_ACFIF_MAX,
+
+    /*  LNA Rin                                                             */
+    MT2063_LNA_RIN,
+
+    /*  Power Detector LNA level target                                     */
+    MT2063_LNA_TGT,
+
+    /*  Power Detector 1 level                                              */
+    MT2063_PD1,
+
+    /*  Power Detector 1 level target                                       */
+    MT2063_PD1_TGT,
+
+    /*  Power Detector 2 level                                              */
+    MT2063_PD2,
+
+    /*  Power Detector 2 level target                                       */
+    MT2063_PD2_TGT,
+
+    /*  Selects, which DNC is activ                                         */
+    MT2063_DNC_OUTPUT_ENABLE,
+
+    /*  VGA gain code                                                       */
+    MT2063_VGAGC,
+
+    /*  VGA bias current                                                    */
+    MT2063_VGAOI,
+
+    /*  TAGC, determins the speed of the AGC                                */
+    MT2063_TAGC,
+
+    /*  AMP gain code                                                       */
+    MT2063_AMPGC,
+
+    /* Control setting to avoid DECT freqs         (default: MT_AVOID_BOTH) */
+    MT2063_AVOID_DECT,
+
+    /* Cleartune filter selection: 0 - by IC (default), 1 - by software     */
+    MT2063_CTFILT_SW,
+
+    MT2063_EOP                    /*  last entry in enumerated list         */
+
+} MT2063_Param;
+
+
+/*
+**  Parameter for selecting tuner mode
+*/
+typedef enum
+{
+    MT2063_CABLE_QAM = 0,            /* Digital cable              */
+    MT2063_CABLE_ANALOG,             /* Analog cable               */
+    MT2063_OFFAIR_COFDM,             /* Digital offair             */
+    MT2063_OFFAIR_COFDM_SAWLESS,     /* Digital offair without SAW */
+    MT2063_OFFAIR_ANALOG,            /* Analog offair              */
+    MT2063_OFFAIR_8VSB,              /* Analog offair              */
+    MT2063_NUM_RCVR_MODES
+} MT2063_RCVR_MODES;
+
+
+/*
+**  Possible values for MT2063_DNC_OUTPUT
+*/
+typedef enum {
+    MT2063_DNC_NONE = 0,
+    MT2063_DNC_1,
+    MT2063_DNC_2,
+    MT2063_DNC_BOTH
+} MT2063_DNC_Output_Enable;
+
+
+/* ====== Functions which are declared in MT2063.c File ======= */
+
+/******************************************************************************
+**
+**  Name: MT2063_Open
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Usage:          status = MT2063_Open(0xC0, &hMT2063, NULL);
+**                  if (MT_IS_ERROR(status))
+**                      //  Check error codes for reason
+**
+**  Parameters:     MT2063_Addr  - Serial bus address of the tuner.
+**                  hMT2063      - Tuner handle passed back.
+**                  hUserData    - User-defined data, if needed for the
+**                                 MT_ReadSub() & MT_WriteSub functions.
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**                      MT_COMM_ERR       - Serial bus communications error
+**                      MT_ARG_NULL       - Null pointer argument passed
+**                      MT_TUNER_CNT_ERR  - Too many tuners open
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_Open(UData_t MT2063_Addr,
+                    Handle_t* hMT2063,
+                    Handle_t hUserData);
+
+
+/******************************************************************************
+**
+**  Name: MT2063_Close
+**
+**  Description:    Release the handle to the tuner.
+**
+**  Parameters:     hMT2063      - Handle to the MT2063 tuner
+**
+**  Usage:          status = MT2063_Close(hMT2063);
+**
+**  Returns:        status:
+**                      MT_OK         - No errors
+**                      MT_INV_HANDLE - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_Close(Handle_t hMT2063);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_Tune
+**
+**  Description:    Change the tuner's tuned frequency to f_in.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Usage:          status = MT2063_Tune(hMT2063,
+**                                       f_in)
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_UPC_UNLOCK    - Upconverter PLL unlocked
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_SPUR_CNT_MASK - Count of avoided LO spurs
+**                      MT_SPUR_PRESENT  - LO spur possible in output
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_FOUT_RANGE    - Output freq out of range
+**                      MT_UPC_RANGE     - Upconverter freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2063_Open BEFORE MT2063_Tune!
+**
+**                  MT_ReadSub   - Read data from the two-wire serial bus
+**                  MT_WriteSub  - Write data to the two-wire serial bus
+**                  MT_Sleep     - Delay execution for x milliseconds
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_Tune(Handle_t h,
+                    UData_t f_in);    /* RF input center frequency   */
+
+
+/******************************************************************************
+**
+**  Name: MT2063_GetGPIO
+**
+**  Description:    Get the current MT2063 GPIO value.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  attr         - Selects input readback, I/O direction or
+**                                 output value
+**                  bit          - Selects GPIO0, GPIO1, or GPIO2
+**                  *value       - current setting of GPIO pin
+**
+**  Usage:          status = MT2063_GetGPIO(hMT2063, MT2063_GPIO2, &value);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the serial bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_GetGPIO(Handle_t h, MT2063_GPIO_ID gpio_id, MT2063_GPIO_Attr attr, UData_t* value);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetLocked
+**
+**  Description:    Checks to see if LO1 and LO2 are locked.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**
+**  Usage:          status = MT2063_GetLocked(hMT2063);
+**                  if (status & (MT_UPC_UNLOCK | MT_DNC_UNLOCK))
+**                      //  error!, one or more PLL's unlocked
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_UPC_UNLOCK    - Upconverter PLL unlocked
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_ReadSub    - Read byte(s) of data from the serial bus
+**                  MT_Sleep      - Delay execution for x milliseconds
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetLocked(Handle_t h);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetParam
+**
+**  Description:    Gets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm - mostly for testing purposes.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2063_Param)
+**                  pValue      - ptr to returned value
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2063_IC_ADDR          Serial Bus address of this tuner
+**                  MT2063_MAX_OPEN         Max # of MT2063's allowed open
+**                  MT2063_NUM_OPEN         # of MT2063's open
+**                  MT2063_SRO_FREQ         crystal frequency
+**                  MT2063_STEPSIZE         minimum tuning step size
+**                  MT2063_INPUT_FREQ       input center frequency
+**                  MT2063_LO1_FREQ         LO1 Frequency
+**                  MT2063_LO1_STEPSIZE     LO1 minimum step size
+**                  MT2063_LO1_FRACN_AVOID  LO1 FracN keep-out region
+**                  MT2063_IF1_ACTUAL       Current 1st IF in use
+**                  MT2063_IF1_REQUEST      Requested 1st IF
+**                  MT2063_IF1_CENTER       Center of 1st IF SAW filter
+**                  MT2063_IF1_BW           Bandwidth of 1st IF SAW filter
+**                  MT2063_ZIF_BW           zero-IF bandwidth
+**                  MT2063_LO2_FREQ         LO2 Frequency
+**                  MT2063_LO2_STEPSIZE     LO2 minimum step size
+**                  MT2063_LO2_FRACN_AVOID  LO2 FracN keep-out region
+**                  MT2063_OUTPUT_FREQ      output center frequency
+**                  MT2063_OUTPUT_BW        output bandwidth
+**                  MT2063_LO_SEPARATION    min inter-tuner LO separation
+**                  MT2063_AS_ALG           ID of avoid-spurs algorithm in use
+**                  MT2063_MAX_HARM1        max # of intra-tuner harmonics
+**                  MT2063_MAX_HARM2        max # of inter-tuner harmonics
+**                  MT2063_EXCL_ZONES       # of 1st IF exclusion zones
+**                  MT2063_NUM_SPURS        # of spurs found/avoided
+**                  MT2063_SPUR_AVOIDED     >0 spurs avoided
+**                  MT2063_SPUR_PRESENT     >0 spurs in output (mathematically)
+**                  MT2063_RCVR_MODE          Predefined modes.
+**                  MT2063_LNA_RIN            Get LNA RIN value
+**                  MT2063_LNA_TGT            Get target power level at LNA
+**                  MT2063_PD1_TGT            Get target power level at PD1
+**                  MT2063_PD2_TGT            Get target power level at PD2
+**                  MT2063_ACLNA              LNA attenuator gain code
+**                  MT2063_ACRF               RF attenuator gain code
+**                  MT2063_ACFIF              FIF attenuator gain code
+**                  MT2063_ACLNA_MAX          LNA attenuator limit
+**                  MT2063_ACRF_MAX           RF attenuator limit
+**                  MT2063_ACFIF_MAX          FIF attenuator limit
+**                  MT2063_PD1                Actual value of PD1
+**                  MT2063_PD2                Actual value of PD2
+**                  MT2063_DNC_OUTPUT_ENABLE  DNC output selection
+**                  MT2063_VGAGC              VGA gain code
+**                  MT2063_VGAOI              VGA output current
+**                  MT2063_TAGC               TAGC setting
+**                  MT2063_AMPGC              AMP gain code
+**                  MT2063_AVOID_DECT         Avoid DECT Frequencies
+**                  MT2063_CTFILT_SW          Cleartune filter selection
+**
+**  Usage:          status |= MT2063_GetParam(hMT2063,
+**                                            MT2063_IF1_ACTUAL,
+**                                            &f_IF1_Actual);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  See Also:       MT2063_SetParam, MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   154   09-13-2007    RSK    Ver 1.05: Get/SetParam changes for LOx_FREQ
+**         10-31-2007    PINZ   Ver 1.08: Get/SetParam add VGAGC, VGAOI, AMPGC, TAGC
+**   173 M 01-23-2008    RSK    Ver 1.12: Read LO1C and LO2C registers from HW
+**                                        in GetParam.
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   175 I 16-06-2008    PINZ   Ver 1.16: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**         07-10-2008    PINZ   Ver 1.19: Documentation Updates, Add a GetParam
+**                                        for each SetParam (LNA_RIN, TGTs)
+**
+****************************************************************************/
+UData_t MT2063_GetParam(Handle_t     h,
+                        MT2063_Param param,
+                        UData_t*     pValue);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetReg
+**
+**  Description:    Gets an MT2063 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  reg         - MT2063 register/subaddress location
+**                  *val        - MT2063 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  Use this function if you need to read a register from
+**                  the MT2063.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data*  val);
+
+
+/******************************************************************************
+**
+**  Name: MT2063_GetTemp
+**
+**  Description:    Get the MT2063 Temperature register.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  *value       - value read from the register
+**
+**                                    Binary
+**                  Value Returned    Value    Approx Temp
+**                  ---------------------------------------------
+**                  MT2063_T_0C       0000         0C
+**                  MT2063_T_10C      0001        10C
+**                  MT2063_T_20C      0010        20C
+**                  MT2063_T_30C      0011        30C
+**                  MT2063_T_40C      0100        40C
+**                  MT2063_T_50C      0101        50C
+**                  MT2063_T_60C      0110        60C
+**                  MT2063_T_70C      0111        70C
+**                  MT2063_T_80C      1000        80C
+**                  MT2063_T_90C      1001        90C
+**                  MT2063_T_100C     1010       100C
+**                  MT2063_T_110C     1011       110C
+**                  MT2063_T_120C     1100       120C
+**                  MT2063_T_130C     1101       130C
+**                  MT2063_T_140C     1110       140C
+**                  MT2063_T_150C     1111       150C
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_GetTemp(Handle_t h, MT2063_Temperature* value);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetUserData
+**
+**  Description:    Gets the user-defined data item.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**
+**  Usage:          status = MT2063_GetUserData(hMT2063, &hUserData);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  The hUserData parameter is a user-specific argument
+**                  that is stored internally with the other tuner-
+**                  specific information.
+**
+**                  For example, if additional arguments are needed
+**                  for the user to identify the device communicating
+**                  with the tuner, this argument can be used to supply
+**                  the necessary information.
+**
+**                  The hUserData parameter is initialized in the tuner's
+**                  Open function to NULL.
+**
+**  See Also:       MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetUserData(Handle_t h,
+                           Handle_t* hUserData);
+
+
+/******************************************************************************
+**
+**  Name: MT2063_ReInit
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_ReInit(Handle_t h);
+
+
+/******************************************************************************
+**
+**  Name: MT2063_SetGPIO
+**
+**  Description:    Modify the MT2063 GPIO value.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2063_Open).
+**                  gpio_id      - Selects GPIO0, GPIO1, or GPIO2
+**                  attr         - Selects input readback, I/O direction or
+**                                 output value
+**                  value        - value to set GPIO pin
+**
+**  Usage:          status = MT2063_SetGPIO(hMT2063, MT2063_GPIO1, MT2063_GPIO_OUT, 1);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_WriteSub - Write byte(s) of data to the two-wire-bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+******************************************************************************/
+UData_t MT2063_SetGPIO(Handle_t h, MT2063_GPIO_ID gpio_id, MT2063_GPIO_Attr attr, UData_t value);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetParam
+**
+**  Description:    Sets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm.  You can override many of the tuning
+**                  algorithm defaults using this function.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2063_Param)
+**                  nValue      - value to be set
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2063_SRO_FREQ         crystal frequency
+**                  MT2063_STEPSIZE         minimum tuning step size
+**                  MT2063_LO1_FREQ           LO1 frequency
+**                  MT2063_LO1_STEPSIZE     LO1 minimum step size
+**                  MT2063_LO1_FRACN_AVOID  LO1 FracN keep-out region
+**                  MT2063_IF1_REQUEST      Requested 1st IF
+**                  MT2063_ZIF_BW           zero-IF bandwidth
+**                  MT2063_LO2_FREQ           LO2 frequency
+**                  MT2063_LO2_STEPSIZE     LO2 minimum step size
+**                  MT2063_LO2_FRACN_AVOID  LO2 FracN keep-out region
+**                  MT2063_OUTPUT_FREQ      output center frequency
+**                  MT2063_OUTPUT_BW        output bandwidth
+**                  MT2063_LO_SEPARATION    min inter-tuner LO separation
+**                  MT2063_MAX_HARM1        max # of intra-tuner harmonics
+**                  MT2063_MAX_HARM2        max # of inter-tuner harmonics
+**                  MT2063_RCVR_MODE          Predefined modes
+**                  MT2063_LNA_RIN            Set LNA Rin (*)
+**                  MT2063_LNA_TGT            Set target power level at LNA (*)
+**                  MT2063_PD1_TGT            Set target power level at PD1 (*)
+**                  MT2063_PD2_TGT            Set target power level at PD2 (*)
+**                  MT2063_ACLNA_MAX          LNA attenuator limit (*)
+**                  MT2063_ACRF_MAX           RF attenuator limit (*)
+**                  MT2063_ACFIF_MAX          FIF attenuator limit (*)
+**                  MT2063_DNC_OUTPUT_ENABLE  DNC output selection
+**                  MT2063_VGAGC              VGA gain code
+**                  MT2063_VGAOI              VGA output current
+**                  MT2063_TAGC               TAGC setting
+**                  MT2063_AMPGC              AMP gain code
+**                  MT2063_AVOID_DECT         Avoid DECT Frequencies
+**                  MT2063_CTFILT_SW          Cleartune filter selection
+**
+**                  (*) This parameter is set by MT2063_RCVR_MODE, do not call
+**                      additionally.
+**
+**  Usage:          status |= MT2063_SetParam(hMT2063,
+**                                            MT2063_STEPSIZE,
+**                                            50000);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**                                         or set value out of range
+**                                         or non-writable parameter
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  See Also:       MT2063_GetParam, MT2063_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**   154   09-13-2007    RSK    Ver 1.05: Get/SetParam changes for LOx_FREQ
+**         10-31-2007    PINZ   Ver 1.08: Get/SetParam add VGAGC, VGAOI, AMPGC, TAGC
+**         04-18-2008    PINZ   Ver 1.15: Add SetParam LNARIN & PDxTGT
+**                                        Split SetParam up to ACLNA / ACLNA_MAX
+**                                        removed ACLNA_INRC/DECR (+RF & FIF)
+**                                        removed GCUAUTO / BYPATNDN/UP
+**   175 I 06-06-2008    PINZ   Ver 1.16: Add control to avoid US DECT freqs.
+**   175 I 06-19-2008    RSK    Ver 1.17: Refactor DECT control to SpurAvoid.
+**         06-24-2008    PINZ   Ver 1.18: Add Get/SetParam CTFILT_SW
+**
+****************************************************************************/
+UData_t MT2063_SetParam(Handle_t     h,
+                        MT2063_Param param,
+                        UData_t      nValue);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetPowerMaskBits
+**
+**  Description:    Sets the power-down mask bits for various sections of
+**                  the MT2063
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to be set.
+**
+**                    MT2063_ALL_SD   All shutdown bits for this tuner
+**
+**                    MT2063_REG_SD   Shutdown regulator
+**                    MT2063_SRO_SD   Shutdown SRO
+**                    MT2063_AFC_SD   Shutdown AFC A/D
+**                    MT2063_PD_SD    Enable power detector shutdown
+**                    MT2063_PDADC_SD Enable power detector A/D shutdown
+**                    MT2063_VCO_SD   Enable VCO shutdown VCO
+**                    MT2063_UPC_SD   Enable upconverter shutdown
+**                    MT2063_DNC_SD   Enable downconverter shutdown
+**                    MT2063_VGA_SD   Enable VGA shutdown
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SetPowerMaskBits(Handle_t h, MT2063_Mask_Bits Bits);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_ClearPowerMaskBits
+**
+**  Description:    Clears the power-down mask bits for various sections of
+**                  the MT2063
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to be cleared.
+**
+**                    MT2063_ALL_SD   All shutdown bits for this tuner
+**
+**                    MT2063_REG_SD   Shutdown regulator
+**                    MT2063_SRO_SD   Shutdown SRO
+**                    MT2063_AFC_SD   Shutdown AFC A/D
+**                    MT2063_PD_SD    Enable power detector shutdown
+**                    MT2063_PDADC_SD Enable power detector A/D shutdown
+**                    MT2063_VCO_SD   Enable VCO shutdown VCO
+**                    MT2063_UPC_SD   Enable upconverter shutdown
+**                    MT2063_DNC_SD   Enable downconverter shutdown
+**                    MT2063_VGA_SD   Enable VGA shutdown
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_ClearPowerMaskBits(Handle_t h, MT2063_Mask_Bits Bits);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_GetPowerMaskBits
+**
+**  Description:    Returns a mask of the enabled power shutdown bits
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Bits        - Mask bits to currently set.
+**
+**                    MT2063_REG_SD   Shutdown regulator
+**                    MT2063_SRO_SD   Shutdown SRO
+**                    MT2063_AFC_SD   Shutdown AFC A/D
+**                    MT2063_PD_SD    Enable power detector shutdown
+**                    MT2063_PDADC_SD Enable power detector A/D shutdown
+**                    MT2063_VCO_SD   Enable VCO shutdown VCO
+**                    MT2063_UPC_SD   Enable upconverter shutdown
+**                    MT2063_DNC_SD   Enable downconverter shutdown
+**                    MT2063_VGA_SD   Enable VGA shutdown
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Output argument is NULL
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_GetPowerMaskBits(Handle_t h, MT2063_Mask_Bits *Bits);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_EnableExternalShutdown
+**
+**  Description:    Enables or disables the operation of the external
+**                  shutdown pin
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Enabled     - 0 = disable the pin, otherwise enable it
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_EnableExternalShutdown(Handle_t h, U8Data Enabled);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SoftwareShutdown
+**
+**  Description:    Enables or disables software shutdown function.  When
+**                  Shutdown==1, any section whose power mask is set will be
+**                  shutdown.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Shutdown    - 1 = shutdown the masked sections, otherwise
+**                                power all sections on
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_COMM_ERR      - Serial bus communications error
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SoftwareShutdown(Handle_t h, U8Data Shutdown);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetExtSRO
+**
+**  Description:    Sets the external SRO driver.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  Ext_SRO_Setting - external SRO drive setting
+**
+**       (default)    MT2063_EXT_SRO_OFF  - ext driver off
+**                    MT2063_EXT_SRO_BY_1 - ext driver = SRO frequency
+**                    MT2063_EXT_SRO_BY_2 - ext driver = SRO/2 frequency
+**                    MT2063_EXT_SRO_BY_4 - ext driver = SRO/4 frequency
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  The Ext_SRO_Setting settings default to OFF
+**                  Use this function if you need to override the default
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SetExtSRO(Handle_t h, MT2063_Ext_SRO Ext_SRO_Setting);
+
+
+/****************************************************************************
+**
+**  Name: MT2063_SetReg
+**
+**  Description:    Sets an MT2063 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2063_Open)
+**                  reg         - MT2063 register/subaddress location
+**                  val         - MT2063 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2063_Open() FIRST!
+**
+**                  Use this function if you need to override a default
+**                  register value
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   138   06-19-2007    DAD    Ver 1.00: Initial, derived from mt2067_b.
+**
+****************************************************************************/
+UData_t MT2063_SetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data   val);
+
+
+#if defined( __cplusplus )
+}
+#endif
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt_spuravoid.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt_spuravoid.h
+**
+**  Copyright 2006-2008 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt_spuravoid.h
+**
+**  Description:    Implements spur avoidance for MicroTuners
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_spuravoid.h,v 1.4 2008/11/05 13:46:20 software Exp $
+**  CVS Source:     $Source: /export/vol0/cvsroot/software/tuners/MT2063/mt_spuravoid.h,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**   083   02-08-2005    JWS    Added separate version number for expected
+**                              version of MT_SpurAvoid.h
+**   083   02-08-2005    JWS    Added function to return the version of the
+**                              MT_AvoidSpurs source file.
+**   098   04-12-2005    DAD    Increased MAX_ZONES from 32 to 48.  32 is
+**                              sufficient for the default avoidance params.
+**   103   01-31-2005    DAD    In MT_AddExclZone(), if the range
+**                              (f_min, f_max) < 0, ignore the entry.
+**   195 M 06-20-2008    RSK    Ver 1.21: Refactoring to place DECT frequency
+**                              avoidance (US and Euro) in 'SpurAvoidance'.
+**   199   08-06-2008    JWS    Ver 1.22: Added 0x1x1 spur frequency calculations
+**                              and indicate success of AddExclZone operation.
+**   200   08-07-2008    JWS    Ver 1.23: Moved definition of DECT avoid constants
+**                              so users could access them more easily.
+**
+*****************************************************************************/
+#if !defined(__MT2063_SPURAVOID_H)
+#define __MT2063_SPURAVOID_H
+
+//#include "mt_userdef.h"
+
+#if defined( __cplusplus )
+extern "C"                     /* Use "C" external linkage                  */
+{
+#endif
+
+/*
+**  Constant defining the version of the following structure
+**  and therefore the API for this code.
+**
+**  When compiling the tuner driver, the preprocessor will
+**  check against this version number to make sure that
+**  it matches the version that the tuner driver knows about.
+*/
+/* Version 010201 => 1.21 */
+#define MT2063_AVOID_SPURS_INFO_VERSION 010201
+
+
+#define MT2063_MAX_ZONES 48
+
+struct MT2063_ExclZone_t;
+
+struct MT2063_ExclZone_t
+{
+    UData_t         min_;
+    UData_t         max_;
+    struct MT2063_ExclZone_t*  next_;
+};
+#ifndef _MT_DECT_Avoid_Type_DEFINE_
+#define _MT_DECT_Avoid_Type_DEFINE_
+//
+// DECT Frequency Avoidance:
+// These constants are used to avoid interference from DECT frequencies.
+//
+typedef enum
+{
+    MT_NO_DECT_AVOIDANCE = 0x00000000,     // Do not create DECT exclusion zones.     
+    MT_AVOID_US_DECT     = 0x00000001,     // Avoid US DECT frequencies.              
+    MT_AVOID_EURO_DECT   = 0x00000002,     // Avoid European DECT frequencies.        
+    MT_AVOID_BOTH                          // Avoid both regions. Not typically used. 
+} MT_DECT_Avoid_Type;
+#endif
+
+/*
+**  Structure of data needed for Spur Avoidance
+*/
+typedef struct
+{
+    UData_t nAS_Algorithm;
+    UData_t f_ref;
+    UData_t f_in;
+    UData_t f_LO1;
+    UData_t f_if1_Center;
+    UData_t f_if1_Request;
+    UData_t f_if1_bw;
+    UData_t f_LO2;
+    UData_t f_out;
+    UData_t f_out_bw;
+    UData_t f_LO1_Step;
+    UData_t f_LO2_Step;
+    UData_t f_LO1_FracN_Avoid;
+    UData_t f_LO2_FracN_Avoid;
+    UData_t f_zif_bw;
+    UData_t f_min_LO_Separation;
+    UData_t maxH1;
+    UData_t maxH2;
+    MT_DECT_Avoid_Type  avoidDECT;
+    UData_t bSpurPresent;
+    UData_t bSpurAvoided;
+    UData_t nSpursFound;
+    UData_t nZones;
+    struct MT2063_ExclZone_t* freeZones;
+    struct MT2063_ExclZone_t* usedZones;
+    struct MT2063_ExclZone_t MT_ExclZones[MT2063_MAX_ZONES];
+} MT2063_AvoidSpursData_t;
+
+UData_t MT2063_RegisterTuner(MT2063_AvoidSpursData_t* pAS_Info);
+
+void MT2063_UnRegisterTuner(MT2063_AvoidSpursData_t* pAS_Info);
+
+void MT2063_ResetExclZones(MT2063_AvoidSpursData_t* pAS_Info);
+
+UData_t MT2063_AddExclZone(MT2063_AvoidSpursData_t* pAS_Info,
+                       UData_t f_min,
+                       UData_t f_max);
+
+UData_t MT2063_ChooseFirstIF(MT2063_AvoidSpursData_t* pAS_Info);
+
+UData_t MT2063_AvoidSpurs(Handle_t h,
+                     MT2063_AvoidSpursData_t* pAS_Info);
+
+UData_t MT2063_AvoidSpursVersion(void);
+
+#if defined( __cplusplus )
+}
+#endif
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is MT2063 tuner API source code
+
+
+
+
+
+/**
+
+@file
+
+@brief   MT2063 tuner module declaration
+
+One can manipulate MT2063 tuner through MT2063 module.
+MT2063 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// Definitions
+
+// MT2063 API option
+#define MT2063_CNT		4
+
+// MT2063 macro
+//#define abs(x) ((x) < 0 ? -(x) : (x))
+
+// MT2063 bandwidth shift
+#define MT2063_BANDWIDTH_SHIFT_HZ		1000000
+
+
+
+// Bandwidth modes
+enum MT2063_BANDWIDTH_MODE
+{
+	MT2063_BANDWIDTH_6MHZ = 6000000,
+	MT2063_BANDWIDTH_7MHZ = 7000000,
+	MT2063_BANDWIDTH_8MHZ = 8000000,
+};
+
+
+// Standard modes
+enum MT2063_STANDARD_MODE
+{
+	MT2063_STANDARD_DVBT,
+	MT2063_STANDARD_QAM,
+};
+
+
+// VGAGC settings
+enum MT2063_VGAGC_SETTINGS
+{
+	MT2063_VGAGC_0X0 = 0x0,
+	MT2063_VGAGC_0X1 = 0x1,
+	MT2063_VGAGC_0X3 = 0x3,
+};
+
+
+
+
+
+// Builder
+void
+BuildMt2063Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	int StandardMode,
+	unsigned long IfVgaGainControl
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+mt2063_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+mt2063_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+mt2063_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+mt2063_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+mt2063_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+mt2063_OpenHandle(
+	TUNER_MODULE *pTuner
+	);
+
+int
+mt2063_CloseHandle(
+	TUNER_MODULE *pTuner
+	);
+
+void
+mt2063_GetHandle(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	);
+
+int
+mt2063_SetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long IfFreqHz
+	);
+
+int
+mt2063_GetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	);
+
+int
+mt2063_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+int
+mt2063_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_mt2266.c b/drivers/media/usb/rtl2832u/tuner_mt2266.c
new file mode 100644
index 00000000..b7359249
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mt2266.c
@@ -0,0 +1,3278 @@
+/**
+
+@file
+
+@brief   MT2266 tuner module definition
+
+One can manipulate MT2266 tuner through MT2266 module.
+MT2266 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_mt2266.h"
+
+
+
+
+
+/**
+
+@brief   MT2266 tuner module builder
+
+Use BuildMt2266Module() to build MT2266 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to MT2266 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   MT2266 I2C device address
+
+
+@note
+	-# One should call BuildMt2266Module() to build MT2266 module before using it.
+
+*/
+void
+BuildMt2266Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr
+	)
+{
+	TUNER_MODULE *pTuner;
+	MT2266_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_MT2266;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = mt2266_GetTunerType;
+	pTuner->GetDeviceAddr = mt2266_GetDeviceAddr;
+
+	pTuner->Initialize    = mt2266_Initialize;
+	pTuner->SetRfFreqHz   = mt2266_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = mt2266_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->IsBandwidthHzSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->OpenHandle     = mt2266_OpenHandle;
+	pExtra->CloseHandle    = mt2266_CloseHandle;
+	pExtra->GetHandle      = mt2266_GetHandle;
+	pExtra->SetBandwidthHz = mt2266_SetBandwidthHz;
+	pExtra->GetBandwidthHz = mt2266_GetBandwidthHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+mt2266_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+mt2266_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+mt2266_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Re-initialize tuner.
+	Status = MT2266_ReInit(DeviceHandle);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+mt2266_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Set tuner RF frequency in Hz.
+	Status = MT2266_ChangeFreq(DeviceHandle, RfFreqHz);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+mt2266_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Open MT2266 tuner handle.
+
+*/
+int
+mt2266_OpenHandle(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+	unsigned char DeviceAddr;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner I2C device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Open MT2266 handle.
+	// Note: 1. Must take tuner extra module DeviceHandle as handle input argument.
+	//       2. Take pTuner as user-defined data input argument.
+	Status = MT2266_Open(DeviceAddr, &pExtra->DeviceHandle, pTuner);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_open_mt2266_handle;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_open_mt2266_handle:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Close MT2266 tuner handle.
+
+*/
+int
+mt2266_CloseHandle(
+	TUNER_MODULE *pTuner
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Close MT2266 handle.
+	Status = MT2266_Close(DeviceHandle);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_open_mt2266_handle;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_open_mt2266_handle:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MT2266 tuner handle.
+
+*/
+void
+mt2266_GetHandle(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	*pDeviceHandle = pExtra->DeviceHandle;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@brief   Set MT2266 tuner bandwidth in Hz.
+
+*/
+int
+mt2266_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+	Handle_t DeviceHandle;
+	UData_t Status;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+	// Get tuner handle.
+	DeviceHandle = pExtra->DeviceHandle;
+
+
+	// Set tuner bandwidth in Hz.
+	Status = MT2266_SetParam(DeviceHandle, MT2266_OUTPUT_BW, BandwidthHz);
+
+	if(MT_IS_ERROR(Status))
+		goto error_status_set_tuner_bandwidth;
+
+
+	// Set tuner bandwidth parameter.
+	pExtra->BandwidthHz      = BandwidthHz;
+	pExtra->IsBandwidthHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MT2266 tuner bandwidth in Hz.
+
+*/
+int
+mt2266_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	)
+{
+	MT2266_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mt2266);
+
+
+	// Get tuner bandwidth in Hz from tuner module.
+	if(pExtra->IsBandwidthHzSet != YES)
+		goto error_status_get_tuner_bandwidth;
+
+	*pBandwidthHz = pExtra->BandwidthHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Microtune source code - mt_userdef.c
+
+
+/*****************************************************************************
+**
+**  Name: mt_userdef.c
+**
+**  Description:    User-defined MicroTuner software interface 
+**
+**  Functions
+**  Requiring
+**  Implementation: MT_WriteSub
+**                  MT_ReadSub
+**                  MT_Sleep
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_userdef.c,v 1.2 2006/10/26 16:39:18 software Exp $
+**  CVS Source:     $Source: /export/home/cvsroot/software/tuners/MT2266/mt_userdef.c,v $
+**	               
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+//#include "mt_userdef.h"
+
+
+/*****************************************************************************
+**
+**  Name: MT_WriteSub
+**
+**  Description:    Write values to device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to write data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2266_WriteSub(Handle_t hUserData, 
+                    UData_t addr, 
+                    U8Data subAddress, 
+                    U8Data *pData, 
+                    UData_t cnt)
+{
+//    UData_t status = MT_OK;                  /* Status to be returned        */
+    /*
+    **  ToDo:  Add code here to implement a serial-bus write
+    **         operation to the MTxxxx tuner.  If successful,
+    **         return MT_OK.
+    */
+/*  return status;  */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned int i, j;
+
+	unsigned char RegStartAddr;
+	unsigned char *pWritingBytes;
+	unsigned long ByteNum;
+
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+	unsigned long WritingByteNum, WritingByteNumMax, WritingByteNumRem;
+	unsigned char RegWritingAddr;
+
+
+
+	// Get tuner module, base interface, and I2C bridge.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+	pI2cBridge     = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Get regiser start address, writing bytes, and byte number.
+	RegStartAddr  = subAddress;
+	pWritingBytes = pData;
+	ByteNum       = (unsigned long)cnt;
+
+
+	// Calculate maximum writing byte number.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax - LEN_1_BYTE;
+
+
+	// Set tuner register bytes with writing bytes.
+	// Note: Set tuner register bytes considering maximum writing byte number.
+	for(i = 0; i < ByteNum; i += WritingByteNumMax)
+	{
+		// Set register writing address.
+		RegWritingAddr = RegStartAddr + i;
+
+		// Calculate remainder writing byte number.
+		WritingByteNumRem = ByteNum - i;
+
+		// Determine writing byte number.
+		WritingByteNum = (WritingByteNumRem > WritingByteNumMax) ? WritingByteNumMax : WritingByteNumRem;
+
+
+		// Set writing buffer.
+		// Note: The I2C format of tuner register byte setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegWritingAddr + writing_bytes (WritingByteNum bytes) +
+		//       stop_bit
+		WritingBuffer[0] = RegWritingAddr;
+
+		for(j = 0; j < WritingByteNum; j++)
+			WritingBuffer[LEN_1_BYTE + j] = pWritingBytes[i + j];
+
+
+		// Set tuner register bytes with writing buffer.
+		if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, WritingByteNum + LEN_1_BYTE) != 
+			FUNCTION_SUCCESS)
+			goto error_status_set_tuner_registers;
+	}
+
+
+	return MT_OK;
+
+
+error_status_set_tuner_registers:
+	return MT_COMM_ERR;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_ReadSub
+**
+**  Description:    Read values from device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to read data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2266_ReadSub(Handle_t hUserData, 
+                   UData_t addr, 
+                   U8Data subAddress, 
+                   U8Data *pData, 
+                   UData_t cnt)
+{
+  //  UData_t status = MT_OK;                        /* Status to be returned        */
+
+    /*
+    **  ToDo:  Add code here to implement a serial-bus read
+    **         operation to the MTxxxx tuner.  If successful,
+    **         return MT_OK.
+    */
+/*  return status;  */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned int i;
+
+	unsigned char RegStartAddr;
+	unsigned char *pReadingBytes;
+	unsigned long ByteNum;
+
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+
+	// Get tuner module, base interface, and I2C bridge.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+	pI2cBridge     = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Get regiser start address, writing bytes, and byte number.
+	RegStartAddr  = subAddress;
+	pReadingBytes = pData;
+	ByteNum       = (unsigned long)cnt;
+
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+	// Get tuner register bytes.
+	// Note: Get tuner register bytes considering maximum reading byte number.
+	for(i = 0; i < ByteNum; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = RegStartAddr + i;
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ByteNum - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set tuner register reading address.
+		// Note: The I2C format of tuner register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + RegReadingAddr + stop_bit
+		if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegReadingAddr, LEN_1_BYTE) != FUNCTION_SUCCESS)
+			goto error_status_set_tuner_register_reading_address;
+
+		// Get tuner register bytes.
+		// Note: The I2C format of tuner register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + reading_bytes (ReadingByteNum bytes) + stop_bit
+		if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, &pReadingBytes[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_tuner_registers;
+	}
+
+
+	return MT_OK;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return MT_COMM_ERR;
+}
+
+
+/*****************************************************************************
+**
+**  Name: MT_Sleep
+**
+**  Description:    Delay execution for "nMinDelayTime" milliseconds
+**
+**  Parameters:     hUserData     - User-specific I/O parameter that was
+**                                  passed to tuner's Open function.
+**                  nMinDelayTime - Delay time in milliseconds
+**
+**  Returns:        None.
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code that
+**                  blocks execution for the specified period of time. 
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+void MT2266_Sleep(Handle_t hUserData, 
+              UData_t nMinDelayTime)
+{
+    /*
+    **  ToDo:  Add code here to implement a OS blocking
+    **         for a period of "nMinDelayTime" milliseconds.
+    */
+
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get tuner module, base interface.
+	pTuner         = (TUNER_MODULE *)hUserData;
+	pBaseInterface = pTuner->pBaseInterface;
+
+
+	// Wait nMinDelayTime milliseconds.
+	pBaseInterface->WaitMs(pBaseInterface, nMinDelayTime);
+
+
+	return;
+}
+
+
+#if defined(MT2060_CNT)
+#if MT2060_CNT > 0
+/*****************************************************************************
+**
+**  Name: MT_TunerGain  (MT2060 only)
+**
+**  Description:    Measure the relative tuner gain using the demodulator
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  pMeas      - Tuner gain (1/100 of dB scale).
+**                               ie. 1234 = 12.34 (dB)
+**
+**  Returns:        status:
+**                      MT_OK  - No errors
+**                      user-defined errors could be set
+**
+**  Notes:          This is a callback function that is called from the
+**                  the 1st IF location routine.  You MUST provide
+**                  code that measures the relative tuner gain in a dB
+**                  (not linear) scale.  The return value is an integer
+**                  value scaled to 1/100 of a dB.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-16-2004    DAD    Original
+**   N/A   11-30-2004    DAD    Renamed from MT_DemodInputPower.  This name
+**                              better describes what this function does.
+**
+*****************************************************************************/
+UData_t MT_TunerGain(Handle_t hUserData,
+                     SData_t* pMeas)
+{
+    UData_t status = MT_OK;                        /* Status to be returned        */
+
+    /*
+    **  ToDo:  Add code here to return the gain / power level measured
+    **         at the input to the demodulator.
+    */
+
+
+
+    return (status);
+}
+#endif
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt2266.c
+
+
+
+/*****************************************************************************
+**
+**  Name: mt2266.c
+**
+**  Copyright 2007 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt2266.c
+**
+**  Description:    Microtune MT2266 Tuner software interface.
+**                  Supports tuners with Part/Rev code: 0x85.
+**
+**  Functions
+**  Implemented:    UData_t  MT2266_Open
+**                  UData_t  MT2266_Close
+**                  UData_t  MT2266_ChangeFreq
+**                  UData_t  MT2266_GetLocked
+**                  UData_t  MT2266_GetParam
+**                  UData_t  MT2266_GetReg
+**                  UData_t  MT2266_GetUHFXFreqs
+**                  UData_t  MT2266_GetUserData
+**                  UData_t  MT2266_ReInit
+**                  UData_t  MT2266_SetParam
+**                  UData_t  MT2266_SetPowerModes
+**                  UData_t  MT2266_SetReg
+**                  UData_t  MT2266_SetUHFXFreqs
+**
+**  References:     AN-00010: MicroTuner Serial Interface Application Note
+**                  MicroTune, Inc.
+**
+**  Exports:        None
+**
+**  Dependencies:   MT_ReadSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Read byte(s) of data from the two-wire bus.
+**
+**                  MT_WriteSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Write byte(s) of data to the two-wire bus.
+**
+**                  MT_Sleep(hUserData, nMinDelayTime);
+**                  - Delay execution for x milliseconds
+**
+**  CVS ID:         $Id: mt2266.c,v 1.5 2007/10/02 18:43:17 software Exp $
+**  CVS Source:     $Source: /export/home/cvsroot/software/tuners/MT2266/mt2266.c,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   06-08-2006    JWS    Ver 1.01: Corrected problem with tuner ID check
+**   N/A   11-01-2006    RSK    Ver 1.02: Adding multiple-filter support
+**                                        as well as Get/Set functions.
+**   N/A   11-29-2006    DAD    Ver 1.03: Parenthesis clarification for gcc
+**   N/A   12-20-2006    RSK    Ver 1.04: Adding fLO_FractionalTerm() usage.
+**   118   05-09-2007    RSK    Ver 1.05: Adding Standard MTxxxx_Tune() API.
+**
+*****************************************************************************/
+//#include "mt2266.h"
+//#include <stdlib.h>                     /* for NULL */
+#define MT_NULL			0
+
+/*  Version of this module                          */
+#define VERSION 10005             /*  Version 01.05 */
+
+
+#ifndef MT2266_CNT
+#error You must define MT2266_CNT in the "mt_userdef.h" file
+#endif
+
+/*
+**  Normally, the "reg" array in the tuner structure is used as a cache
+**  containing the current value of the tuner registers.  If the user's
+**  application MUST change tuner registers without using the MT2266_SetReg
+**  routine provided, he may compile this code with the __NO_CACHE__
+**  variable defined.
+**  The PREFETCH macro will insert code code to re-read tuner registers if
+**  __NO_CACHE__ is defined.  If it is not defined (normal) then PREFETCH
+**  does nothing.
+*/
+
+#if defined(__NO_CACHE__)
+#define PREFETCH(var, cnt) \
+    if (MT_NO_ERROR(status)) \
+    status |= MT2266_ReadSub(pInfo->hUserData, pInfo->address, (var), &pInfo->reg[(var)], (cnt));
+#else
+#define PREFETCH(var, cnt)
+#endif
+
+
+
+/*
+**  Two-wire serial bus subaddresses of the tuner registers.
+**  Also known as the tuner's register addresses.
+*/
+enum MT2266_Register_Offsets
+{
+    MT2266_PART_REV = 0,   /*  0x00 */
+    MT2266_LO_CTRL_1,      /*  0x01 */
+    MT2266_LO_CTRL_2,      /*  0x02 */
+    MT2266_LO_CTRL_3,      /*  0x03 */
+    MT2266_SMART_ANT,      /*  0x04 */
+    MT2266_BAND_CTRL,      /*  0x05 */
+    MT2266_CLEARTUNE,      /*  0x06 */
+    MT2266_IGAIN,          /*  0x07 */
+    MT2266_BBFILT_1,       /*  0x08 */
+    MT2266_BBFILT_2,       /*  0x09 */
+    MT2266_BBFILT_3,       /*  0x0A */
+    MT2266_BBFILT_4,       /*  0x0B */
+    MT2266_BBFILT_5,       /*  0x0C */
+    MT2266_BBFILT_6,       /*  0x0D */
+    MT2266_BBFILT_7,       /*  0x0E */
+    MT2266_BBFILT_8,       /*  0x0F */
+    MT2266_RCC_CTRL,       /*  0x10 */
+    MT2266_RSVD_11,        /*  0x11 */
+    MT2266_STATUS_1,       /*  0x12 */
+    MT2266_STATUS_2,       /*  0x13 */
+    MT2266_STATUS_3,       /*  0x14 */
+    MT2266_STATUS_4,       /*  0x15 */
+    MT2266_STATUS_5,       /*  0x16 */
+    MT2266_SRO_CTRL,       /*  0x17 */
+    MT2266_RSVD_18,        /*  0x18 */
+    MT2266_RSVD_19,        /*  0x19 */
+    MT2266_RSVD_1A,        /*  0x1A */
+    MT2266_RSVD_1B,        /*  0x1B */
+    MT2266_ENABLES,        /*  0x1C */
+    MT2266_RSVD_1D,        /*  0x1D */
+    MT2266_RSVD_1E,        /*  0x1E */
+    MT2266_RSVD_1F,        /*  0x1F */
+    MT2266_GPO,            /*  0x20 */
+    MT2266_RSVD_21,        /*  0x21 */
+    MT2266_RSVD_22,        /*  0x22 */
+    MT2266_RSVD_23,        /*  0x23 */
+    MT2266_RSVD_24,        /*  0x24 */
+    MT2266_RSVD_25,        /*  0x25 */
+    MT2266_RSVD_26,        /*  0x26 */
+    MT2266_RSVD_27,        /*  0x27 */
+    MT2266_RSVD_28,        /*  0x28 */
+    MT2266_RSVD_29,        /*  0x29 */
+    MT2266_RSVD_2A,        /*  0x2A */
+    MT2266_RSVD_2B,        /*  0x2B */
+    MT2266_RSVD_2C,        /*  0x2C */
+    MT2266_RSVD_2D,        /*  0x2D */
+    MT2266_RSVD_2E,        /*  0x2E */
+    MT2266_RSVD_2F,        /*  0x2F */
+    MT2266_RSVD_30,        /*  0x30 */
+    MT2266_RSVD_31,        /*  0x31 */
+    MT2266_RSVD_32,        /*  0x32 */
+    MT2266_RSVD_33,        /*  0x33 */
+    MT2266_RSVD_34,        /*  0x34 */
+    MT2266_RSVD_35,        /*  0x35 */
+    MT2266_RSVD_36,        /*  0x36 */
+    MT2266_RSVD_37,        /*  0x37 */
+    MT2266_RSVD_38,        /*  0x38 */
+    MT2266_RSVD_39,        /*  0x39 */
+    MT2266_RSVD_3A,        /*  0x3A */
+    MT2266_RSVD_3B,        /*  0x3B */
+    MT2266_RSVD_3C,        /*  0x3C */
+    END_REGS
+};
+
+/*
+** DefaultsEntry points to an array of U8Data used to initialize
+** various registers (the first byte is the starting subaddress)
+** and a count of the bytes (including subaddress) in the array.
+**
+** DefaultsList is an array of DefaultsEntry elements terminated
+** by an entry with a NULL pointer for the data array.
+*/
+typedef struct MT2266_DefaultsEntryTag
+{
+    U8Data *data;
+    UData_t cnt;
+} MT2266_DefaultsEntry;
+
+typedef MT2266_DefaultsEntry MT2266_DefaultsList[];
+
+#define DEF_LIST_ENTRY(a) {a, sizeof(a)/sizeof(U8Data) - 1}
+#define END_DEF_LIST {0,0}
+
+/*
+** Constants used by the tuning algorithm
+*/
+                                        /* REF_FREQ is now the actual crystal frequency */
+#define REF_FREQ          (30000000UL)  /* Reference oscillator Frequency (in Hz) */
+#define TUNE_STEP_SIZE          (50UL)  /* Tune in steps of 50 kHz */
+#define MIN_UHF_FREQ     (350000000UL)  /* Minimum UHF frequency (in Hz) */
+#define MAX_UHF_FREQ     (900000000UL)  /* Maximum UHF frequency (in Hz) */
+#define MIN_VHF_FREQ     (174000000UL)  /* Minimum VHF frequency (in Hz) */
+#define MAX_VHF_FREQ     (230000000UL)  /* Maximum VHF frequency (in Hz) */
+#define OUTPUT_BW          (8000000UL)  /* Output channel bandwidth (in Hz) */
+#define UHF_DEFAULT_FREQ (600000000UL)  /* Default UHF input frequency (in Hz) */
+
+
+/*
+**  The number of Tuner Registers
+*/
+static const UData_t Num_Registers = END_REGS;
+
+/*
+**  Crossover Frequency sets for 2 filters, without and with attenuation.
+*/
+typedef struct
+{
+    MT2266_XFreq_Set    xfreq[ MT2266_NUMBER_OF_XFREQ_SETS ];
+
+}  MT2266_XFreqs_t;
+
+
+MT2266_XFreqs_t MT2266_default_XFreqs =
+{
+    /*  xfreq  */
+    {
+        /*  uhf0  */
+        {                                /*          < 0 MHz: 15+1 */
+            0UL,                         /*    0 ..    0 MHz: 15 */
+            0UL,                         /*    0 ..  443 MHz: 14 */
+            443000 / TUNE_STEP_SIZE,     /*  443 ..  470 MHz: 13 */
+            470000 / TUNE_STEP_SIZE,     /*  470 ..  496 MHz: 12 */
+            496000 / TUNE_STEP_SIZE,     /*  496 ..  525 MHz: 11 */
+            525000 / TUNE_STEP_SIZE,     /*  525 ..  552 MHz: 10 */
+            552000 / TUNE_STEP_SIZE,     /*  552 ..  580 MHz:  9 */
+            580000 / TUNE_STEP_SIZE,     /*  580 ..  657 MHz:  8 */
+            657000 / TUNE_STEP_SIZE,     /*  657 ..  682 MHz:  7 */
+            682000 / TUNE_STEP_SIZE,     /*  682 ..  710 MHz:  6 */
+            710000 / TUNE_STEP_SIZE,     /*  710 ..  735 MHz:  5 */
+            735000 / TUNE_STEP_SIZE,     /*  735 ..  763 MHz:  4 */
+            763000 / TUNE_STEP_SIZE,     /*  763 ..  802 MHz:  3 */
+            802000 / TUNE_STEP_SIZE,     /*  802 ..  840 MHz:  2 */
+            840000 / TUNE_STEP_SIZE,     /*  840 ..  877 MHz:  1 */
+            877000 / TUNE_STEP_SIZE      /*  877+        MHz:  0 */
+        },
+
+        /*  uhf1  */
+        {                                /*        < 443 MHz: 15+1 */
+            443000 / TUNE_STEP_SIZE,     /*  443 ..  470 MHz: 15 */
+            470000 / TUNE_STEP_SIZE,     /*  470 ..  496 MHz: 14 */
+            496000 / TUNE_STEP_SIZE,     /*  496 ..  525 MHz: 13 */
+            525000 / TUNE_STEP_SIZE,     /*  525 ..  552 MHz: 12 */
+            552000 / TUNE_STEP_SIZE,     /*  552 ..  580 MHz: 11 */
+            580000 / TUNE_STEP_SIZE,     /*  580 ..  605 MHz: 10 */
+            605000 / TUNE_STEP_SIZE,     /*  605 ..  632 MHz:  9 */
+            632000 / TUNE_STEP_SIZE,     /*  632 ..  657 MHz:  8 */
+            657000 / TUNE_STEP_SIZE,     /*  657 ..  682 MHz:  7 */
+            682000 / TUNE_STEP_SIZE,     /*  682 ..  710 MHz:  6 */
+            710000 / TUNE_STEP_SIZE,     /*  710 ..  735 MHz:  5 */
+            735000 / TUNE_STEP_SIZE,     /*  735 ..  763 MHz:  4 */
+            763000 / TUNE_STEP_SIZE,     /*  763 ..  802 MHz:  3 */
+            802000 / TUNE_STEP_SIZE,     /*  802 ..  840 MHz:  2 */
+            840000 / TUNE_STEP_SIZE,     /*  840 ..  877 MHz:  1 */
+            877000 / TUNE_STEP_SIZE      /*  877+        MHz:  0 */
+        },
+
+        /*  uhf0_a  */
+        {                                /*        <   0 MHz: 15+1 */
+            0UL,                         /*    0 ..    0 MHz: 15 */
+            0UL,                         /*    0 ..  442 MHz: 14 */
+            442000 / TUNE_STEP_SIZE,     /*  442 ..  472 MHz: 13 */
+            472000 / TUNE_STEP_SIZE,     /*  472 ..  505 MHz: 12 */
+            505000 / TUNE_STEP_SIZE,     /*  505 ..  535 MHz: 11 */
+            535000 / TUNE_STEP_SIZE,     /*  535 ..  560 MHz: 10 */
+            560000 / TUNE_STEP_SIZE,     /*  560 ..  593 MHz:  9 */
+            593000 / TUNE_STEP_SIZE,     /*  593 ..  673 MHz:  8 */
+            673000 / TUNE_STEP_SIZE,     /*  673 ..  700 MHz:  7 */
+            700000 / TUNE_STEP_SIZE,     /*  700 ..  727 MHz:  6 */
+            727000 / TUNE_STEP_SIZE,     /*  727 ..  752 MHz:  5 */
+            752000 / TUNE_STEP_SIZE,     /*  752 ..  783 MHz:  4 */
+            783000 / TUNE_STEP_SIZE,     /*  783 ..  825 MHz:  3 */
+            825000 / TUNE_STEP_SIZE,     /*  825 ..  865 MHz:  2 */
+            865000 / TUNE_STEP_SIZE,     /*  865 ..  905 MHz:  1 */
+            905000 / TUNE_STEP_SIZE      /*  905+        MHz:  0 */
+        },
+
+        /*  uhf1_a  */
+        {                                /*        < 442 MHz: 15+1 */
+            442000 / TUNE_STEP_SIZE,     /*  442 ..  472 MHz: 15 */
+            472000 / TUNE_STEP_SIZE,     /*  472 ..  505 MHz: 14 */
+            505000 / TUNE_STEP_SIZE,     /*  505 ..  535 MHz: 13 */
+            535000 / TUNE_STEP_SIZE,     /*  535 ..  560 MHz: 12 */
+            560000 / TUNE_STEP_SIZE,     /*  560 ..  593 MHz: 11 */
+            593000 / TUNE_STEP_SIZE,     /*  593 ..  620 MHz: 10 */
+            620000 / TUNE_STEP_SIZE,     /*  620 ..  647 MHz:  9 */
+            647000 / TUNE_STEP_SIZE,     /*  647 ..  673 MHz:  8 */
+            673000 / TUNE_STEP_SIZE,     /*  673 ..  700 MHz:  7 */
+            700000 / TUNE_STEP_SIZE,     /*  700 ..  727 MHz:  6 */
+            727000 / TUNE_STEP_SIZE,     /*  727 ..  752 MHz:  5 */
+            752000 / TUNE_STEP_SIZE,     /*  752 ..  783 MHz:  4 */
+            783000 / TUNE_STEP_SIZE,     /*  783 ..  825 MHz:  3 */
+            825000 / TUNE_STEP_SIZE,     /*  825 ..  865 MHz:  2 */
+            865000 / TUNE_STEP_SIZE,     /*  865 ..  905 MHz:  1 */
+            905000 / TUNE_STEP_SIZE      /*  905+        MHz:  0 */
+        }
+    }
+};
+
+typedef struct
+{
+    Handle_t    handle;
+    Handle_t    hUserData;
+    UData_t     address;
+    UData_t     version;
+    UData_t     tuner_id;
+    UData_t     f_Ref;
+    UData_t     f_Step;
+    UData_t     f_in;
+    UData_t     f_LO;
+    UData_t     f_bw;
+    UData_t     band;
+    UData_t     num_regs;
+    U8Data      RC2_Value;
+    U8Data      RC2_Nominal;
+    U8Data      reg[END_REGS];
+
+    MT2266_XFreqs_t xfreqs;
+
+}  MT2266_Info_t;
+
+static UData_t nMaxTuners = MT2266_CNT;
+static MT2266_Info_t MT2266_Info[MT2266_CNT];
+static MT2266_Info_t *Avail[MT2266_CNT];
+static UData_t nOpenTuners = 0;
+
+/*
+**  Constants used to write a minimal set of registers when changing bands.
+**  If the user wants a total reset, they should call MT2266_Open() again.
+**  Skip 01, 02, 03, 04  (get overwritten anyways)
+**  Write 05
+**  Skip 06 - 18
+**  Write 19   (diff for L-Band)
+**  Skip 1A 1B 1C
+**  Write 1D - 2B
+**  Skip 2C - 3C
+*/
+
+static U8Data MT2266_VHF_defaults1[] =
+{
+    0x05,              /* address 0xC0, reg 0x05 */
+    0x04,              /* Reg 0x05 LBANDen = 1 (that's right)*/
+};
+static U8Data MT2266_VHF_defaults2[] =
+{
+    0x19,              /* address 0xC0, reg 0x19 */
+    0x61,              /* Reg 0x19 CAPto = 3*/
+};
+static U8Data MT2266_VHF_defaults3[] =
+{
+    0x1D,              /* address 0xC0, reg 0x1D */
+    0xFE,              /* reg 0x1D */
+    0x00,              /* reg 0x1E */
+    0x00,              /* reg 0x1F */
+    0xB4,              /* Reg 0x20 GPO = 1*/
+    0x03,              /* Reg 0x21 LBIASen = 1, UBIASen = 1*/
+    0xA5,              /* Reg 0x22 */
+    0xA5,              /* Reg 0x23 */
+    0xA5,              /* Reg 0x24 */
+    0xA5,              /* Reg 0x25 */
+    0x82,              /* Reg 0x26 CASCM = b0001 (bits reversed)*/
+    0xAA,              /* Reg 0x27 */
+    0xF1,              /* Reg 0x28 */
+    0x17,              /* Reg 0x29 */
+    0x80,              /* Reg 0x2A MIXbiasen = 1*/
+    0x1F,              /* Reg 0x2B */
+};
+
+static MT2266_DefaultsList MT2266_VHF_defaults = {
+    DEF_LIST_ENTRY(MT2266_VHF_defaults1),
+    DEF_LIST_ENTRY(MT2266_VHF_defaults2),
+    DEF_LIST_ENTRY(MT2266_VHF_defaults3),
+    END_DEF_LIST
+};
+
+static U8Data MT2266_UHF_defaults1[] =
+{
+    0x05,              /* address 0xC0, reg 0x05 */
+    0x52,              /* Reg 0x05 */
+};
+static U8Data MT2266_UHF_defaults2[] =
+{
+    0x19,              /* address 0xC0, reg 0x19 */
+    0x61,              /* Reg 0x19 CAPto = 3*/
+};
+static U8Data MT2266_UHF_defaults3[] =
+{
+    0x1D,              /* address 0xC0, reg 0x1D */
+    0xDC,              /* Reg 0x1D */
+    0x00,              /* Reg 0x1E */
+    0x0A,              /* Reg 0x1F */
+    0xD4,              /* Reg 0x20 GPO = 1*/
+    0x03,              /* Reg 0x21 LBIASen = 1, UBIASen = 1*/
+    0x64,              /* Reg 0x22 */
+    0x64,              /* Reg 0x23 */
+    0x64,              /* Reg 0x24 */
+    0x64,              /* Reg 0x25 */
+    0x22,              /* Reg 0x26 CASCM = b0100 (bits reversed)*/
+    0xAA,              /* Reg 0x27 */
+    0xF2,              /* Reg 0x28 */
+    0x1E,              /* Reg 0x29 */
+    0x80,              /* Reg 0x2A MIXbiasen = 1*/
+    0x14,              /* Reg 0x2B */
+};
+
+static MT2266_DefaultsList MT2266_UHF_defaults = {
+    DEF_LIST_ENTRY(MT2266_UHF_defaults1),
+    DEF_LIST_ENTRY(MT2266_UHF_defaults2),
+    DEF_LIST_ENTRY(MT2266_UHF_defaults3),
+    END_DEF_LIST
+};
+
+
+static UData_t UncheckedSet(MT2266_Info_t* pInfo,
+                            U8Data         reg,
+                            U8Data         val);
+
+static UData_t UncheckedGet(MT2266_Info_t* pInfo,
+                            U8Data   reg,
+                            U8Data*  val);
+
+
+/******************************************************************************
+**
+**  Name: MT2266_Open
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     MT2266_Addr  - Serial bus address of the tuner.
+**                  hMT2266      - Tuner handle passed back.
+**                  hUserData    - User-defined data, if needed for the
+**                                 MT_ReadSub() & MT_WriteSub functions.
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**                      MT_COMM_ERR       - Serial bus communications error
+**                      MT_ARG_NULL       - Null pointer argument passed
+**                      MT_TUNER_CNT_ERR  - Too many tuners open
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   11-01-2006    RSK    Ver 1.02: Initialize Crossover Tables to Default
+**
+******************************************************************************/
+UData_t MT2266_Open(UData_t MT2266_Addr,
+                    Handle_t* hMT2266,
+                    Handle_t hUserData)
+{
+    UData_t status = MT_OK;             /*  Status to be returned.  */
+    SData_t i, j;
+    MT2266_Info_t* pInfo = MT_NULL;
+ 
+
+    /*  Check the argument before using  */
+    if (hMT2266 == MT_NULL)
+        return MT_ARG_NULL;
+    *hMT2266 = MT_NULL;
+
+    /*
+    **  If this is our first tuner, initialize the address fields and
+    **  the list of available control blocks.
+    */
+    if (nOpenTuners == 0)
+    {
+        for (i=MT2266_CNT-1; i>=0; i--)
+        {
+            MT2266_Info[i].handle = MT_NULL;
+            MT2266_Info[i].address =MAX_UDATA;
+            MT2266_Info[i].hUserData = MT_NULL;
+
+            /* Reset the UHF Crossover Frequency tables on open/init. */
+            for (j=0; j< MT2266_NUM_XFREQS; j++ )
+            {
+                MT2266_Info[i].xfreqs.xfreq[MT2266_UHF0][j]       = MT2266_default_XFreqs.xfreq[MT2266_UHF0][j];
+                MT2266_Info[i].xfreqs.xfreq[MT2266_UHF1][j]       = MT2266_default_XFreqs.xfreq[MT2266_UHF1][j];
+                MT2266_Info[i].xfreqs.xfreq[MT2266_UHF0_ATTEN][j] = MT2266_default_XFreqs.xfreq[MT2266_UHF0_ATTEN][j];
+                MT2266_Info[i].xfreqs.xfreq[MT2266_UHF1_ATTEN][j] = MT2266_default_XFreqs.xfreq[MT2266_UHF1_ATTEN][j];
+            }
+
+            Avail[i] = &MT2266_Info[i];
+        }
+    }
+
+    /*
+    **  Look for an existing MT2266_State_t entry with this address.
+    */
+    for (i=MT2266_CNT-1; i>=0; i--)
+    {
+        /*
+        **  If an open'ed handle provided, we'll re-initialize that structure.
+        **
+        **  We recognize an open tuner because the address and hUserData are
+        **  the same as one that has already been opened
+        */
+        if ((MT2266_Info[i].address == MT2266_Addr) &&
+            (MT2266_Info[i].hUserData == hUserData))
+        {
+            pInfo = &MT2266_Info[i];
+            break;
+        }
+    }
+
+    /*  If not found, choose an empty spot.  */
+    if (pInfo == MT_NULL)
+    {
+        /*  Check to see that we're not over-allocating.  */
+        if (nOpenTuners == MT2266_CNT)
+            return MT_TUNER_CNT_ERR;
+
+        /* Use the next available block from the list */
+        pInfo = Avail[nOpenTuners];
+        nOpenTuners++;
+    }
+
+    pInfo->handle = (Handle_t) pInfo;
+    pInfo->hUserData = hUserData;
+    pInfo->address = MT2266_Addr;
+
+//    status |= MT2266_ReInit((Handle_t) pInfo);
+
+    if (MT_IS_ERROR(status))
+        MT2266_Close((Handle_t) pInfo);
+    else
+        *hMT2266 = pInfo->handle;
+
+    return (status);
+}
+
+
+static UData_t IsValidHandle(MT2266_Info_t* handle)
+{
+    return ((handle != MT_NULL) && (handle->handle == handle)) ? 1 : 0;
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2266_Close
+**
+**  Description:    Release the handle to the tuner.
+**
+**  Parameters:     hMT2266      - Handle to the MT2266 tuner
+**
+**  Returns:        status:
+**                      MT_OK         - No errors
+**                      MT_INV_HANDLE - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+******************************************************************************/
+UData_t MT2266_Close(Handle_t hMT2266)
+{
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) hMT2266;
+
+    if (!IsValidHandle(pInfo))
+        return MT_INV_HANDLE;
+
+    /* Remove the tuner from our list of tuners */
+    pInfo->handle = MT_NULL;
+    pInfo->address = MAX_UDATA;
+    pInfo->hUserData = MT_NULL;
+    nOpenTuners--;
+    Avail[nOpenTuners] = pInfo; /* Return control block to available list */
+
+    return MT_OK;
+}
+
+
+/******************************************************************************
+**
+**  Name: Run_BB_RC_Cal2
+**
+**  Description:    Run Base Band RC Calibration (Method 2)
+**                  MT2266 B0 only, others return MT_OK
+**
+**  Parameters:     hMT2266      - Handle to the MT2266 tuner
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+******************************************************************************/
+static UData_t Run_BB_RC_Cal2(Handle_t h)
+{
+    UData_t status = MT_OK;                  /* Status to be returned */
+    U8Data tmp_rcc;
+    U8Data dumy;
+
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    /*
+    ** Set the crystal frequency in the calibration register
+    ** and enable RC calibration #2
+    */
+    PREFETCH(MT2266_RCC_CTRL, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+    tmp_rcc = pInfo->reg[MT2266_RCC_CTRL];
+    if (pInfo->f_Ref < (36000000 /*/ TUNE_STEP_SIZE*/))
+        tmp_rcc = (tmp_rcc & 0xDF) | 0x10;
+    else
+        tmp_rcc |= 0x30;
+    status |= UncheckedSet(pInfo, MT2266_RCC_CTRL, tmp_rcc);
+
+    /*  Read RC Calibration value  */
+    status |= UncheckedGet(pInfo, MT2266_STATUS_4, &dumy);
+
+    /* Disable RC Cal 2 */
+    status |= UncheckedSet(pInfo, MT2266_RCC_CTRL, pInfo->reg[MT2266_RCC_CTRL] & 0xEF);
+
+    /* Store RC Cal 2 value */
+    pInfo->RC2_Value = pInfo->reg[MT2266_STATUS_4];
+
+    if (pInfo->f_Ref < (36000000 /*/ TUNE_STEP_SIZE*/))
+        pInfo->RC2_Nominal = (U8Data) ((pInfo->f_Ref + 77570) / 155139);
+    else
+        pInfo->RC2_Nominal = (U8Data) ((pInfo->f_Ref + 93077) / 186154);
+
+    return (status);
+}
+
+
+/******************************************************************************
+**
+**  Name: Set_BBFilt
+**
+**  Description:    Set Base Band Filter bandwidth
+**                  Based on SRO frequency & BB RC Calibration
+**                  User stores channel bw as 5-8 MHz.  This routine
+**                  calculates a 3 dB corner bw based on 1/2 the bandwidth
+**                  and a bandwidth related constant.
+**
+**  Parameters:     hMT2266      - Handle to the MT2266 tuner
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+******************************************************************************/
+static UData_t Set_BBFilt(Handle_t h)
+{
+    UData_t f_3dB_bw;
+    U8Data BBFilt = 0;
+    U8Data Sel = 0;
+    SData_t TmpFilt;
+    SData_t i;
+    UData_t status = MT_OK;                  /* Status to be returned */
+
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+	/* Check RC2_Value value */
+	if(pInfo->RC2_Value == 0)
+		return MT_UNKNOWN;
+
+    /*
+    ** Convert the channel bandwidth into a 3 dB bw by dividing it by 2
+    ** and subtracting 300, 250, 200, or 0 kHz based on 8, 7, 6, 5 MHz
+    ** channel bandwidth.
+    */
+    f_3dB_bw = (pInfo->f_bw / 2);  /* bw -> bw/2 */
+    if (pInfo->f_bw > 7500000)
+    {
+        /*  >3.75 MHz corner  */
+        f_3dB_bw -= 300000;
+        Sel = 0x00;
+        TmpFilt = ((429916107 / pInfo->RC2_Value) * pInfo->RC2_Nominal) / f_3dB_bw - 81;
+    }
+    else if (pInfo->f_bw > 6500000)
+    {
+        /*  >3.25 MHz .. 3.75 MHz corner  */
+        f_3dB_bw -= 250000;
+        Sel = 0x00;
+        TmpFilt = ((429916107 / pInfo->RC2_Value) * pInfo->RC2_Nominal) / f_3dB_bw - 81;
+    }
+    else if (pInfo->f_bw > 5500000)
+    {
+        /*  >2.75 MHz .. 3.25 MHz corner  */
+        f_3dB_bw -= 200000;
+        Sel = 0x80;
+        TmpFilt = ((429916107 / pInfo->RC2_Value) * pInfo->RC2_Nominal) / f_3dB_bw - 113;
+    }
+    else
+    {
+        /*  <= 2.75 MHz corner  */
+        Sel = 0xC0;
+        TmpFilt = ((429916107 / pInfo->RC2_Value) * pInfo->RC2_Nominal) / f_3dB_bw - 129;
+    }
+
+    if (TmpFilt > 63)
+        TmpFilt = 63;
+    else if (TmpFilt < 0)
+        TmpFilt = 0;
+    BBFilt = ((U8Data) TmpFilt) | Sel;
+
+    for ( i = MT2266_BBFILT_1; i <= MT2266_BBFILT_8; i++ )
+        pInfo->reg[i] = BBFilt;
+
+    if (MT_NO_ERROR(status))
+        status |= MT2266_WriteSub(pInfo->hUserData,
+                              pInfo->address,
+                              MT2266_BBFILT_1,
+                              &pInfo->reg[MT2266_BBFILT_1],
+                              8);
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetLocked
+**
+**  Description:    Checks to see if the PLL is locked.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_ReadSub    - Read byte(s) of data from the serial bus
+**                  MT_Sleep      - Delay execution for x milliseconds
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_GetLocked(Handle_t h)
+{
+    const UData_t nMaxWait = 200;            /*  wait a maximum of 200 msec   */
+    const UData_t nPollRate = 2;             /*  poll status bits every 2 ms */
+    const UData_t nMaxLoops = nMaxWait / nPollRate;
+    UData_t status = MT_OK;                  /* Status to be returned */
+    UData_t nDelays = 0;
+    U8Data statreg;
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    if (IsValidHandle(pInfo) == 0)
+        return MT_INV_HANDLE;
+
+    do
+    {
+        status |= UncheckedGet(pInfo, MT2266_STATUS_1, &statreg);
+
+        if ((MT_IS_ERROR(status)) || ((statreg & 0x40) == 0x40))
+            return (status);
+
+        MT2266_Sleep(pInfo->hUserData, nPollRate);       /*  Wait between retries  */
+    }
+    while (++nDelays < nMaxLoops);
+
+    if ((statreg & 0x40) != 0x40)
+        status |= MT_DNC_UNLOCK;
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetParam
+**
+**  Description:    Gets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm - mostly for testing purposes.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2266_Param)
+**                  pValue      - ptr to returned value
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2266_IC_ADDR          Serial Bus address of this tuner
+**                  MT2266_MAX_OPEN         Max number of MT2266's that can be open
+**                  MT2266_NUM_OPEN         Number of MT2266's currently open
+**                  MT2266_NUM_REGS         Number of tuner registers
+**                  MT2266_SRO_FREQ         crystal frequency
+**                  MT2266_STEPSIZE         minimum tuning step size
+**                  MT2266_INPUT_FREQ       input center frequency
+**                  MT2266_LO_FREQ          LO Frequency
+**                  MT2266_OUTPUT_BW        Output channel bandwidth
+**                  MT2266_RC2_VALUE        Base band filter cal RC code (method 2)
+**                  MT2266_RC2_NOMINAL      Base band filter nominal cal RC code
+**                  MT2266_RF_ADC           RF attenuator A/D readback
+**                  MT2266_RF_ATTN          RF attenuation (0-255)
+**                  MT2266_RF_EXT           External control of RF atten
+**                  MT2266_LNA_GAIN         LNA gain setting (0-15)
+**                  MT2266_BB_ADC           BB attenuator A/D readback
+**                  MT2266_BB_ATTN          Baseband attenuation (0-255)
+**                  MT2266_BB_EXT           External control of BB atten
+**
+**  Usage:          status |= MT2266_GetParam(hMT2266,
+**                                            MT2266_OUTPUT_BW,
+**                                            &f_bw);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetParam, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_GetParam(Handle_t     h,
+                        MT2266_Param param,
+                        UData_t*     pValue)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data tmp;
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    if (pValue == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (MT_NO_ERROR(status))
+    {
+        switch (param)
+        {
+        /*  Serial Bus address of this tuner      */
+        case MT2266_IC_ADDR:
+            *pValue = pInfo->address;
+            break;
+
+        /*  Max # of MT2266's allowed to be open  */
+        case MT2266_MAX_OPEN:
+            *pValue = nMaxTuners;
+            break;
+
+        /*  # of MT2266's open                    */
+        case MT2266_NUM_OPEN:
+            *pValue = nOpenTuners;
+            break;
+
+        /*  Number of tuner registers             */
+        case MT2266_NUM_REGS:
+            *pValue = Num_Registers;
+            break;
+
+        /*  crystal frequency                     */
+        case MT2266_SRO_FREQ:
+            *pValue = pInfo->f_Ref;
+            break;
+
+        /*  minimum tuning step size              */
+        case MT2266_STEPSIZE:
+            *pValue = pInfo->f_Step;
+            break;
+
+        /*  input center frequency                */
+        case MT2266_INPUT_FREQ:
+            *pValue = pInfo->f_in;
+            break;
+
+        /*  LO Frequency                          */
+        case MT2266_LO_FREQ:
+            *pValue = pInfo->f_LO;
+            break;
+
+        /*  Output Channel Bandwidth              */
+        case MT2266_OUTPUT_BW:
+            *pValue = pInfo->f_bw;
+            break;
+
+        /*  Base band filter cal RC code          */
+        case MT2266_RC2_VALUE:
+            *pValue = (UData_t) pInfo->RC2_Value;
+            break;
+
+        /*  Base band filter nominal cal RC code          */
+        case MT2266_RC2_NOMINAL:
+            *pValue = (UData_t) pInfo->RC2_Nominal;
+            break;
+
+        /*  RF attenuator A/D readback            */
+        case MT2266_RF_ADC:
+            status |= UncheckedGet(pInfo, MT2266_STATUS_2, &tmp);
+            if (MT_NO_ERROR(status))
+                *pValue = (UData_t) tmp;
+            break;
+
+        /*  BB attenuator A/D readback            */
+        case MT2266_BB_ADC:
+            status |= UncheckedGet(pInfo, MT2266_STATUS_3, &tmp);
+            if (MT_NO_ERROR(status))
+                *pValue = (UData_t) tmp;
+            break;
+
+        /*  RF attenuator setting                 */
+        case MT2266_RF_ATTN:
+            PREFETCH(MT2266_RSVD_1F, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+            if (MT_NO_ERROR(status))
+                *pValue = pInfo->reg[MT2266_RSVD_1F];
+            break;
+
+        /*  BB attenuator setting                 */
+        case MT2266_BB_ATTN:
+            PREFETCH(MT2266_RSVD_2C, 3);  /* Fetch register(s) if __NO_CACHE__ defined */
+            *pValue = pInfo->reg[MT2266_RSVD_2C]
+                    + pInfo->reg[MT2266_RSVD_2D]
+                    + pInfo->reg[MT2266_RSVD_2E] - 3;
+            break;
+
+        /*  RF external / internal atten control  */
+        case MT2266_RF_EXT:
+            PREFETCH(MT2266_GPO, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+            *pValue = ((pInfo->reg[MT2266_GPO] & 0x40) != 0x00);
+            break;
+
+        /*  BB external / internal atten control  */
+        case MT2266_BB_EXT:
+            PREFETCH(MT2266_RSVD_33, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+            *pValue = ((pInfo->reg[MT2266_RSVD_33] & 0x10) != 0x00);
+            break;
+
+        /*  LNA gain setting (0-15)               */
+        case MT2266_LNA_GAIN:
+            PREFETCH(MT2266_IGAIN, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+            *pValue = ((pInfo->reg[MT2266_IGAIN] & 0x3C) >> 2);
+            break;
+
+        case MT2266_EOP:
+        default:
+            status |= MT_ARG_RANGE;
+        }
+    }
+    return (status);
+}
+
+
+/****************************************************************************
+**  LOCAL FUNCTION - DO NOT USE OUTSIDE OF mt2266.c
+**
+**  Name: UncheckedGet
+**
+**  Description:    Gets an MT2266 register with minimal checking
+**
+**                  NOTE: This is a local function that performs the same
+**                  steps as the MT2266_GetReg function that is available
+**                  in the external API.  It does not do any of the standard
+**                  error checking that the API function provides and should
+**                  not be called from outside this file.
+**
+**  Parameters:     *pInfo      - Tuner control structure
+**                  reg         - MT2266 register/subaddress location
+**                  *val        - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Use this function if you need to read a register from
+**                  the MT2266.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+static UData_t UncheckedGet(MT2266_Info_t* pInfo,
+                            U8Data   reg,
+                            U8Data*  val)
+{
+    UData_t status;                  /* Status to be returned        */
+
+#if defined(_DEBUG)
+    status = MT_OK;
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (val == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_IS_ERROR(status))
+        return(status);
+#endif
+
+    status = MT2266_ReadSub(pInfo->hUserData, pInfo->address, reg, &pInfo->reg[reg], 1);
+
+    if (MT_NO_ERROR(status))
+        *val = pInfo->reg[reg];
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetReg
+**
+**  Description:    Gets an MT2266 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  reg         - MT2266 register/subaddress location
+**                  *val        - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Use this function if you need to read a register from
+**                  the MT2266.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_GetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data*  val)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (val == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+        status |= UncheckedGet(pInfo, reg, val);
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetUHFXFreqs
+**
+**  Description:    Retrieves the specified set of UHF Crossover Frequencies
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Usage:          MT2266_Freq_Set  tmpFreqs;
+**                  status = MT2266_GetUHFXFreqs(hMT2266,
+**                                               MT2266_UHF1_WITH_ATTENUATION,
+**                                               tmpFreqs );
+**                  if (status & MT_ARG_RANGE)
+**                      // error, Invalid UHF Crossover Frequency Set requested.
+**                  else
+**                      for( int i = 0;  i < MT2266_NUM_XFREQS; i++ )
+**                         . . .
+**
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_ARG_RANGE     - freq_type is out of range.
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   freqs_buffer *must* be defined of type MT2266_Freq_Set
+**                     to assure sufficient space allocation!
+**
+**                  USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetUHFXFreqs
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   10-26-2006   RSK     Original.
+**
+****************************************************************************/
+UData_t MT2266_GetUHFXFreqs(Handle_t h,
+                            MT2266_UHFXFreq_Type freq_type,
+                            MT2266_XFreq_Set     freqs_buffer)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+
+    if (freq_type >= MT2266_NUMBER_OF_XFREQ_SETS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+    {
+        int  i;
+
+        for( i = 0; i < MT2266_NUM_XFREQS; i++ )
+        {
+            freqs_buffer[i] = pInfo->xfreqs.xfreq[ freq_type ][i] * TUNE_STEP_SIZE / 1000;
+        }
+    }
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetUserData
+**
+**  Description:    Gets the user-defined data item.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  The hUserData parameter is a user-specific argument
+**                  that is stored internally with the other tuner-
+**                  specific information.
+**
+**                  For example, if additional arguments are needed
+**                  for the user to identify the device communicating
+**                  with the tuner, this argument can be used to supply
+**                  the necessary information.
+**
+**                  The hUserData parameter is initialized in the tuner's
+**                  Open function to NULL.
+**
+**  See Also:       MT2266_SetUserData, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_GetUserData(Handle_t h,
+                           Handle_t* hUserData)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+
+    if (hUserData == MT_NULL)
+        status |= MT_ARG_NULL;
+
+    if (MT_NO_ERROR(status))
+        *hUserData = pInfo->hUserData;
+
+    return (status);
+}
+
+
+/******************************************************************************
+**
+**  Name: MT2266_ReInit
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**                      MT_INV_HANDLE     - Invalid tuner handle
+**                      MT_COMM_ERR       - Serial bus communications error
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   06-08-2006    JWS    Ver 1.01: Corrected problem with tuner ID check
+**   N/A   11-01-2006    RSK    Ver 1.02: Initialize XFreq Tables to Default
+**   N/A   11-29-2006    DAD    Ver 1.03: Parenthesis clarification
+**
+******************************************************************************/
+UData_t MT2266_ReInit(Handle_t h)
+{
+    int j;
+
+    U8Data MT2266_Init_Defaults1[] =
+    {
+        0x01,            /* Start w/register 0x01 */
+        0x00,            /* Reg 0x01 */
+        0x00,            /* Reg 0x02 */
+        0x28,            /* Reg 0x03 */
+        0x00,            /* Reg 0x04 */
+        0x52,            /* Reg 0x05 */
+        0x99,            /* Reg 0x06 */
+        0x3F,            /* Reg 0x07 */
+    };
+
+    U8Data MT2266_Init_Defaults2[] =
+    {
+        0x17,            /* Start w/register 0x17 */
+        0x6D,            /* Reg 0x17 */
+        0x71,            /* Reg 0x18 */
+        0x61,            /* Reg 0x19 */
+        0xC0,            /* Reg 0x1A */
+        0xBF,            /* Reg 0x1B */
+        0xFF,            /* Reg 0x1C */
+        0xDC,            /* Reg 0x1D */
+        0x00,            /* Reg 0x1E */
+        0x0A,            /* Reg 0x1F */
+        0xD4,            /* Reg 0x20 */
+        0x03,            /* Reg 0x21 */
+        0x64,            /* Reg 0x22 */
+        0x64,            /* Reg 0x23 */
+        0x64,            /* Reg 0x24 */
+        0x64,            /* Reg 0x25 */
+        0x22,            /* Reg 0x26 */
+        0xAA,            /* Reg 0x27 */
+        0xF2,            /* Reg 0x28 */
+        0x1E,            /* Reg 0x29 */
+        0x80,            /* Reg 0x2A */
+        0x14,            /* Reg 0x2B */
+        0x01,            /* Reg 0x2C */
+        0x01,            /* Reg 0x2D */
+        0x01,            /* Reg 0x2E */
+        0x01,            /* Reg 0x2F */
+        0x01,            /* Reg 0x30 */
+        0x01,            /* Reg 0x31 */
+        0x7F,            /* Reg 0x32 */
+        0x5E,            /* Reg 0x33 */
+        0x3F,            /* Reg 0x34 */
+        0xFF,            /* Reg 0x35 */
+        0xFF,            /* Reg 0x36 */
+        0xFF,            /* Reg 0x37 */
+        0x00,            /* Reg 0x38 */
+        0x77,            /* Reg 0x39 */
+        0x0F,            /* Reg 0x3A */
+        0x2D,            /* Reg 0x3B */
+    };
+
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+    U8Data BBVref;
+    U8Data tmpreg = 0;
+    U8Data statusreg = 0;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    /*  Read the Part/Rev code from the tuner */
+    if (MT_NO_ERROR(status))
+        status |= UncheckedGet(pInfo, MT2266_PART_REV, &tmpreg);
+    if (MT_NO_ERROR(status) && (tmpreg != 0x85))  // MT226? B0
+        status |= MT_TUNER_ID_ERR;
+    else
+    {
+        /*
+        **  Read the status register 5
+        */
+        tmpreg = pInfo->reg[MT2266_RSVD_11] |= 0x03;
+        if (MT_NO_ERROR(status))
+            status |= UncheckedSet(pInfo, MT2266_RSVD_11, tmpreg);
+        tmpreg &= ~(0x02);
+        if (MT_NO_ERROR(status))
+            status |= UncheckedSet(pInfo, MT2266_RSVD_11, tmpreg);
+
+        /*  Get and store the status 5 register value  */
+        if (MT_NO_ERROR(status))
+            status |= UncheckedGet(pInfo, MT2266_STATUS_5, &statusreg);
+
+        /*  MT2266  */
+        if (MT_IS_ERROR(status) || ((statusreg & 0x30) != 0x30))
+                status |= MT_TUNER_ID_ERR;      /*  Wrong tuner Part/Rev code   */
+    }
+
+    if (MT_NO_ERROR(status))
+    {
+        /*  Initialize the tuner state.  Hold off on f_in and f_LO */
+        pInfo->version = VERSION;
+        pInfo->tuner_id = pInfo->reg[MT2266_PART_REV];
+        pInfo->f_Ref = REF_FREQ;
+        pInfo->f_Step = TUNE_STEP_SIZE * 1000;  /* kHz -> Hz */
+        pInfo->f_in = UHF_DEFAULT_FREQ;
+        pInfo->f_LO = UHF_DEFAULT_FREQ;
+        pInfo->f_bw = OUTPUT_BW;
+        pInfo->band = MT2266_UHF_BAND;
+        pInfo->num_regs = END_REGS;
+
+        /* Reset the UHF Crossover Frequency tables on open/init. */
+        for (j=0; j< MT2266_NUM_XFREQS; j++ )
+        {
+            pInfo->xfreqs.xfreq[MT2266_UHF0][j]       = MT2266_default_XFreqs.xfreq[MT2266_UHF0][j];
+            pInfo->xfreqs.xfreq[MT2266_UHF1][j]       = MT2266_default_XFreqs.xfreq[MT2266_UHF1][j];
+            pInfo->xfreqs.xfreq[MT2266_UHF0_ATTEN][j] = MT2266_default_XFreqs.xfreq[MT2266_UHF0_ATTEN][j];
+            pInfo->xfreqs.xfreq[MT2266_UHF1_ATTEN][j] = MT2266_default_XFreqs.xfreq[MT2266_UHF1_ATTEN][j];
+        }
+
+        /*  Write the default values to the tuner registers. Default mode is UHF */
+        status |= MT2266_WriteSub(pInfo->hUserData,
+                              pInfo->address,
+                              MT2266_Init_Defaults1[0],
+                              &MT2266_Init_Defaults1[1],
+                              sizeof(MT2266_Init_Defaults1)/sizeof(U8Data)-1);
+        status |= MT2266_WriteSub(pInfo->hUserData,
+                              pInfo->address,
+                              MT2266_Init_Defaults2[0],
+                              &MT2266_Init_Defaults2[1],
+                              sizeof(MT2266_Init_Defaults2)/sizeof(U8Data)-1);
+    }
+
+    /*  Read back all the registers from the tuner */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2266_ReadSub(pInfo->hUserData, pInfo->address, 0, &pInfo->reg[0], END_REGS);
+    }
+
+    /*
+    **  Set reg[0x33] based on statusreg
+    */
+    if (MT_NO_ERROR(status))
+    {
+        BBVref = (((statusreg >> 6) + 2) & 0x03);
+        tmpreg = (pInfo->reg[MT2266_RSVD_33] & ~(0x60)) | (BBVref << 5);
+        status |= UncheckedSet(pInfo, MT2266_RSVD_33, tmpreg);
+    }
+
+    /*  Run the baseband filter calibration  */
+    if (MT_NO_ERROR(status))
+        status |= Run_BB_RC_Cal2(h);
+
+    /*  Set the baseband filter bandwidth to the default  */
+    if (MT_NO_ERROR(status))
+        status |= Set_BBFilt(h);
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetParam
+**
+**  Description:    Sets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm.  You can override many of the tuning
+**                  algorithm defaults using this function.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2266_Param)
+**                  nValue      - value to be set
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2266_SRO_FREQ         crystal frequency
+**                  MT2266_STEPSIZE         minimum tuning step size
+**                  MT2266_INPUT_FREQ       Center of input channel
+**                  MT2266_OUTPUT_BW        Output channel bandwidth
+**                  MT2266_RF_ATTN          RF attenuation (0-255)
+**                  MT2266_RF_EXT           External control of RF atten
+**                  MT2266_LNA_GAIN         LNA gain setting (0-15)
+**                  MT2266_LNA_GAIN_DECR    Decrement LNA Gain (arg=min)
+**                  MT2266_LNA_GAIN_INCR    Increment LNA Gain (arg=max)
+**                  MT2266_BB_ATTN          Baseband attenuation (0-255)
+**                  MT2266_BB_EXT           External control of BB atten
+**                  MT2266_UHF_MAXSENS      Set for UHF max sensitivity mode
+**                  MT2266_UHF_NORMAL       Set for UHF normal mode
+**
+**  Usage:          status |= MT2266_SetParam(hMT2266,
+**                                            MT2266_STEPSIZE,
+**                                            50000);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**                                         or set value out of range
+**                                         or non-writable parameter
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_GetParam, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   11-29-2006    DAD    Ver 1.03: Parenthesis clarification for gcc
+**
+****************************************************************************/
+UData_t MT2266_SetParam(Handle_t     h,
+                        MT2266_Param param,
+                        UData_t      nValue)
+{
+    UData_t status = MT_OK;                  /* Status to be returned        */
+    U8Data tmpreg;
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (MT_NO_ERROR(status))
+    {
+        switch (param)
+        {
+        /*  crystal frequency                     */
+        case MT2266_SRO_FREQ:
+            pInfo->f_Ref = nValue;
+            if (pInfo->f_Ref < 22000000)
+            {
+                /*  Turn off f_SRO divide by 2  */
+                status |= UncheckedSet(pInfo,
+                                       MT2266_SRO_CTRL,
+                                       (U8Data) (pInfo->reg[MT2266_SRO_CTRL] &= 0xFE));
+            }
+            else
+            {
+                /*  Turn on f_SRO divide by 2  */
+                status |= UncheckedSet(pInfo,
+                                       MT2266_SRO_CTRL,
+                                       (U8Data) (pInfo->reg[MT2266_SRO_CTRL] |= 0x01));
+            }
+            status |= Run_BB_RC_Cal2(h);
+            if (MT_NO_ERROR(status))
+                status |= Set_BBFilt(h);
+            break;
+
+        /*  minimum tuning step size              */
+        case MT2266_STEPSIZE:
+            pInfo->f_Step = nValue;
+            break;
+
+        /*  Width of output channel               */
+        case MT2266_OUTPUT_BW:
+            pInfo->f_bw = nValue;
+            status |= Set_BBFilt(h);
+            break;
+
+        /*  BB attenuation (0-255)                */
+        case MT2266_BB_ATTN:
+            if (nValue > 255)
+                status |= MT_ARG_RANGE;
+            else
+            {
+                UData_t BBA_Stage1;
+                UData_t BBA_Stage2;
+                UData_t BBA_Stage3;
+
+                BBA_Stage3 = (nValue > 102) ? 103 : nValue + 1;
+                BBA_Stage2 = (nValue > 175) ? 75 : nValue + 2 - BBA_Stage3;
+                BBA_Stage1 = (nValue > 176) ? nValue - 175 : 1;
+                pInfo->reg[MT2266_RSVD_2C] = (U8Data) BBA_Stage1;
+                pInfo->reg[MT2266_RSVD_2D] = (U8Data) BBA_Stage2;
+                pInfo->reg[MT2266_RSVD_2E] = (U8Data) BBA_Stage3;
+                pInfo->reg[MT2266_RSVD_2F] = (U8Data) BBA_Stage1;
+                pInfo->reg[MT2266_RSVD_30] = (U8Data) BBA_Stage2;
+                pInfo->reg[MT2266_RSVD_31] = (U8Data) BBA_Stage3;
+                status |= MT2266_WriteSub(pInfo->hUserData,
+                                      pInfo->address,
+                                      MT2266_RSVD_2C,
+                                      &pInfo->reg[MT2266_RSVD_2C],
+                                      6);
+            }
+            break;
+
+        /*  RF attenuation (0-255)                */
+        case MT2266_RF_ATTN:
+            if (nValue > 255)
+                status |= MT_ARG_RANGE;
+            else
+                status |= UncheckedSet(pInfo, MT2266_RSVD_1F, (U8Data) nValue);
+            break;
+
+        /*  RF external / internal atten control  */
+        case MT2266_RF_EXT:
+            if (nValue == 0)
+                tmpreg = pInfo->reg[MT2266_GPO] &= ~0x40;
+            else
+                tmpreg = pInfo->reg[MT2266_GPO] |= 0x40;
+            status |= UncheckedSet(pInfo, MT2266_GPO, tmpreg);
+            break;
+
+        /*  LNA gain setting (0-15)               */
+        case MT2266_LNA_GAIN:
+            if (nValue > 15)
+                status |= MT_ARG_RANGE;
+            else
+            {
+                tmpreg = (pInfo->reg[MT2266_IGAIN] & 0xC3) | ((U8Data)nValue << 2);
+                status |= UncheckedSet(pInfo, MT2266_IGAIN, tmpreg);
+            }
+            break;
+
+        /*  Decrement LNA Gain setting, argument is min LNA Gain setting  */
+        case MT2266_LNA_GAIN_DECR:
+            if (nValue > 15)
+                status |= MT_ARG_RANGE;
+            else
+            {
+                PREFETCH(MT2266_IGAIN, 1);
+                if (MT_NO_ERROR(status) && ((U8Data) ((pInfo->reg[MT2266_IGAIN] & 0x3C) >> 2) > (U8Data) nValue))
+                    status |= UncheckedSet(pInfo, MT2266_IGAIN, pInfo->reg[MT2266_IGAIN] - 0x04);
+            }
+            break;
+
+        /*  Increment LNA Gain setting, argument is max LNA Gain setting  */
+        case MT2266_LNA_GAIN_INCR:
+            if (nValue > 15)
+                status |= MT_ARG_RANGE;
+            else
+            {
+                PREFETCH(MT2266_IGAIN, 1);
+                if (MT_NO_ERROR(status) && ((U8Data) ((pInfo->reg[MT2266_IGAIN] & 0x3C) >> 2) < (U8Data) nValue))
+                    status |= UncheckedSet(pInfo, MT2266_IGAIN, pInfo->reg[MT2266_IGAIN] + 0x04);
+            }
+            break;
+
+        /*  BB external / internal atten control  */
+        case MT2266_BB_EXT:
+            if (nValue == 0)
+                tmpreg = pInfo->reg[MT2266_RSVD_33] &= ~0x08;
+            else
+                tmpreg = pInfo->reg[MT2266_RSVD_33] |= 0x08;
+            status |= UncheckedSet(pInfo, MT2266_RSVD_33, tmpreg);
+            break;
+
+        /*  Set for UHF max sensitivity mode  */
+        case MT2266_UHF_MAXSENS:
+            PREFETCH(MT2266_BAND_CTRL, 1);
+            if (MT_NO_ERROR(status) && ((pInfo->reg[MT2266_BAND_CTRL] & 0x30) == 0x10))
+                status |= UncheckedSet(pInfo, MT2266_BAND_CTRL, pInfo->reg[MT2266_BAND_CTRL] ^ 0x30);
+            break;
+
+        /*  Set for UHF normal mode  */
+        case MT2266_UHF_NORMAL:
+            if (MT_NO_ERROR(status) && ((pInfo->reg[MT2266_BAND_CTRL] & 0x30) == 0x20))
+                status |= UncheckedSet(pInfo, MT2266_BAND_CTRL, pInfo->reg[MT2266_BAND_CTRL] ^ 0x30);
+            break;
+
+        /*  These parameters are read-only  */
+        case MT2266_IC_ADDR:
+        case MT2266_MAX_OPEN:
+        case MT2266_NUM_OPEN:
+        case MT2266_NUM_REGS:
+        case MT2266_INPUT_FREQ:
+        case MT2266_LO_FREQ:
+        case MT2266_RC2_VALUE:
+        case MT2266_RF_ADC:
+        case MT2266_BB_ADC:
+        case MT2266_EOP:
+        default:
+            status |= MT_ARG_RANGE;
+        }
+    }
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetPowerModes
+**
+**  Description:    Sets the bits in the MT2266_ENABLES register and the
+**                  SROsd bit in the MT2266_SROADC_CTRL register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  flags       - Bit mask of flags to indicate enabled
+**                                bits.
+**
+**  Usage:          status = MT2266_SetPowerModes(hMT2266, flags);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  The bits in the MT2266_ENABLES register and the
+**                  SROsd bit are set according to the supplied flags.
+**
+**                  The pre-defined flags are as follows:
+**                      MT2266_SROen
+**                      MT2266_LOen
+**                      MT2266_ADCen
+**                      MT2266_PDen
+**                      MT2266_DCOCen
+**                      MT2266_BBen
+**                      MT2266_MIXen
+**                      MT2266_LNAen
+**                      MT2266_ALL_ENABLES
+**                      MT2266_NO_ENABLES
+**                      MT2266_SROsd
+**                      MT2266_SRO_NOT_sd
+**
+**                  ONLY the enable bits (or SROsd bit) specified in the
+**                  flags parameter will be set.  Any flag which is not
+**                  included, will cause that bit to be disabled.
+**
+**                  The ALL_ENABLES, NO_ENABLES, and SRO_NOT_sd constants
+**                  are for convenience.  The NO_ENABLES and SRO_NOT_sd
+**                  do not actually have to be included, but are provided
+**                  for clarity.
+**
+**  See Also:       MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_SetPowerModes(Handle_t h,
+                             UData_t  flags)
+{
+    UData_t status = MT_OK;                  /* Status to be returned */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+    U8Data tmpreg;
+
+    /*  Verify that the handle passed points to a valid tuner */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    PREFETCH(MT2266_SRO_CTRL, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+    if (MT_NO_ERROR(status))
+    {
+        if (flags & MT2266_SROsd)
+            tmpreg = pInfo->reg[MT2266_SRO_CTRL] |= 0x10;  /* set the SROsd bit */
+        else
+            tmpreg = pInfo->reg[MT2266_SRO_CTRL] &= 0xEF;  /* clear the SROsd bit */
+        status |= UncheckedSet(pInfo, MT2266_SRO_CTRL, tmpreg);
+    }
+
+    PREFETCH(MT2266_ENABLES, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+
+    if (MT_NO_ERROR(status))
+    {
+        status |= UncheckedSet(pInfo, MT2266_ENABLES, (U8Data)(flags & 0xff));
+    }
+
+    return status;
+}
+
+
+/****************************************************************************
+**  LOCAL FUNCTION - DO NOT USE OUTSIDE OF mt2266.c
+**
+**  Name: UncheckedSet
+**
+**  Description:    Sets an MT2266 register.
+**
+**                  NOTE: This is a local function that performs the same
+**                  steps as the MT2266_SetReg function that is available
+**                  in the external API.  It does not do any of the standard
+**                  error checking that the API function provides and should
+**                  not be called from outside this file.
+**
+**  Parameters:     *pInfo      - Tuner control structure
+**                  reg         - MT2266 register/subaddress location
+**                  val         - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Sets a register value without any preliminary checking for
+**                  valid handles or register numbers.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+static UData_t UncheckedSet(MT2266_Info_t* pInfo,
+                            U8Data         reg,
+                            U8Data         val)
+{
+    UData_t status;                  /* Status to be returned */
+
+#if defined(_DEBUG)
+    status = MT_OK;
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_IS_ERROR(status))
+        return (status);
+#endif
+
+    status = MT2266_WriteSub(pInfo->hUserData, pInfo->address, reg, &val, 1);
+
+    if (MT_NO_ERROR(status))
+        pInfo->reg[reg] = val;
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetReg
+**
+**  Description:    Sets an MT2266 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  reg         - MT2266 register/subaddress location
+**                  val         - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Use this function if you need to override a default
+**                  register value
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+UData_t MT2266_SetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data   val)
+{
+    UData_t status = MT_OK;                  /* Status to be returned */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status |= MT_INV_HANDLE;
+
+    if (reg >= END_REGS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+        status |= UncheckedSet(pInfo, reg, val);
+
+    return (status);
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetUHFXFreqs
+**
+**  Description:    Assigns the specified set of UHF Crossover Frequencies
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Usage:          MT2266_Freq_Set  tmpFreqs;
+**                  status = MT2266_GetUHFXFreqs(hMT2266,
+**                                               MT2266_UHF1_WITH_ATTENUATION,
+**                                               tmpFreqs );
+**                   ...
+**                  tmpFreqs[i] = <desired value>
+**                   ...
+**                  status = MT2266_SetUHFXFreqs(hMT2266,
+**                                               MT2266_UHF1_WITH_ATTENUATION,
+**                                               tmpFreqs );
+**
+**                  if (status & MT_ARG_RANGE)
+**                      // error, Invalid UHF Crossover Frequency Set requested.
+**                  else
+**                      for( int i = 0;  i < MT2266_NUM_XFREQS; i++ )
+**                         . . .
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_ARG_RANGE     - freq_type is out of range.
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   freqs_buffer *must* be defined of type MT2266_Freq_Set
+**                     to assure sufficient space allocation!
+**
+**                  USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetUHFXFreqs
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   10-26-2006   RSK     Original.
+**
+****************************************************************************/
+UData_t MT2266_SetUHFXFreqs(Handle_t h,
+                            MT2266_UHFXFreq_Type freq_type,
+                            MT2266_XFreq_Set     freqs_buffer)
+{
+    UData_t status = MT_OK;                     /* Status to be returned */
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        status = MT_INV_HANDLE;
+
+    if (freq_type >= MT2266_NUMBER_OF_XFREQ_SETS)
+        status |= MT_ARG_RANGE;
+
+    if (MT_NO_ERROR(status))
+    {
+        int  i;
+
+        for( i = 0; i < MT2266_NUM_XFREQS; i++ )
+        {
+            pInfo->xfreqs.xfreq[ freq_type ][i] = freqs_buffer[i] * 1000 / TUNE_STEP_SIZE;
+        }
+    }
+
+    return (status);
+}
+
+
+/****************************************************************************
+** LOCAL FUNCTION
+**
+**  Name: RoundToStep
+**
+**  Description:    Rounds the given frequency to the closes f_Step value
+**                  given the tuner ref frequency..
+**
+**
+**  Parameters:     freq      - Frequency to be rounded (in Hz).
+**                  f_Step    - Step size for the frequency (in Hz).
+**                  f_Ref     - SRO frequency (in Hz).
+**
+**  Returns:        Rounded frequency.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**
+****************************************************************************/
+static UData_t RoundToStep(UData_t freq, UData_t f_Step, UData_t f_ref)
+{
+    return f_ref * (freq / f_ref)
+        + f_Step * (((freq % f_ref) + (f_Step / 2)) / f_Step);
+}
+
+
+/****************************************************************************
+**
+**  Name: fLO_FractionalTerm
+**
+**  Description:    Calculates the portion contributed by FracN / denom.
+**
+**                  This function preserves maximum precision without
+**                  risk of overflow.  It accurately calculates
+**                  f_ref * num / denom to within 1 HZ with fixed math.
+**
+**  Parameters:     num       - Fractional portion of the multiplier
+**                  denom     - denominator portion of the ratio
+**                              This routine successfully handles denom values
+**                              up to and including 2^18.
+**                  f_Ref     - SRO frequency.  This calculation handles
+**                              f_ref as two separate 14-bit fields.
+**                              Therefore, a maximum value of 2^28-1
+**                              may safely be used for f_ref.  This is
+**                              the genesis of the magic number "14" and the
+**                              magic mask value of 0x03FFF.
+**
+**  Returns:        f_ref * num / denom
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   12-20-2006    RSK    Ver 1.04: Adding fLO_FractionalTerm() usage.
+**
+****************************************************************************/
+static UData_t fLO_FractionalTerm( UData_t f_ref,
+                                   UData_t num,
+                                   UData_t denom )
+{
+    UData_t t1     = (f_ref >> 14) * num;
+    UData_t term1  = t1 / denom;
+    UData_t loss   = t1 % denom;
+    UData_t term2  = ( ((f_ref & 0x00003FFF) * num + (loss<<14)) + (denom/2) )  / denom;
+    return ((term1 << 14) + term2);
+}
+
+
+/****************************************************************************
+** LOCAL FUNCTION
+**
+**  Name: CalcLOMult
+**
+**  Description:    Calculates Integer divider value and the numerator
+**                  value for LO's FracN PLL.
+**
+**                  This function assumes that the f_LO and f_Ref are
+**                  evenly divisible by f_LO_Step.
+**
+**  Parameters:     Div       - OUTPUT: Whole number portion of the multiplier
+**                  FracN     - OUTPUT: Fractional portion of the multiplier
+**                  f_LO      - desired LO frequency.
+**                  denom     - LO FracN denominator value
+**                  f_Ref     - SRO frequency.
+**
+**  Returns:        Recalculated LO frequency.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   12-20-2006    RSK    Ver 1.04: Adding fLO_FractionalTerm() usage.
+**
+****************************************************************************/
+static UData_t CalcLOMult(UData_t *Div,
+                          UData_t *FracN,
+                          UData_t  f_LO,
+                          UData_t  denom,
+                          UData_t  f_Ref)
+{
+    UData_t a, b, i;
+    const SData_t TwoNShift = 13;   // bits to shift to obtain 2^n qty
+    const SData_t RoundShift = 18;  // bits to shift before rounding
+
+    /*  Calculate the whole number portion of the divider */
+    *Div = f_LO / f_Ref;
+
+    /*
+    **  Calculate the FracN numerator 1 bit at a time.  This keeps the
+    **  integer values from overflowing when large values are multiplied.
+    **  This loop calculates the fractional portion of F/20MHz accurate
+    **  to 32 bits.  The 2^n factor is represented by the placement of
+    **  the value in the 32-bit word.  Since we want as much accuracy
+    **  as possible, we'll leave it at the top of the word.
+    */
+    *FracN = 0;
+    a = f_LO;
+    for (i=32; i>0; --i)
+    {
+        b = 2*(a % f_Ref);
+        *FracN = (*FracN * 2) + (b >= f_Ref);
+        a = b;
+    }
+
+    /*
+    **  If the denominator is a 2^n - 1 value (the usual case) then the
+    **  value we really need is (F/20) * 2^n - (F/20).  Shifting the
+    **  calculated (F/20) value to the right and subtracting produces
+    **  the desired result -- still accurate to 32 bits.
+    */
+    if ((denom & 0x01) != 0)
+        *FracN -= (*FracN >> TwoNShift);
+
+    /*
+    ** Now shift the result so that it is 1 bit bigger than we need,
+    ** use the low-order bit to round the remaining bits, and shift
+    ** to make the answer the desired size.
+    */
+    *FracN >>= RoundShift;
+    *FracN = (*FracN & 0x01) + (*FracN >> 1);
+
+    /*  Check for rollover (cannot happen with 50 kHz step size) */
+    if (*FracN == (denom | 1))
+    {
+        *FracN = 0;
+        ++Div;
+    }
+
+
+    return (f_Ref * (*Div)) + fLO_FractionalTerm( f_Ref, *FracN, denom );
+}
+
+
+/****************************************************************************
+** LOCAL FUNCTION
+**
+**  Name: GetCrossover
+**
+**  Description:    Determines the appropriate value in the set of
+**                  crossover frequencies.
+**
+**                  This function assumes that the crossover frequency table
+**                  ias been properly initialized in descending order.
+**
+**  Parameters:     f_in      - The input frequency to use.
+**                  freqs     - The array of crossover frequency entries.
+**
+**  Returns:        Index of crossover frequency band to use.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   10-27-2006    RSK    Original
+**
+****************************************************************************/
+static U8Data GetCrossover( UData_t f_in,  UData_t* freqs )
+{
+    U8Data idx;
+    U8Data retVal = 0;
+
+    for (idx=0; idx< (U8Data)MT2266_NUM_XFREQS; idx++)
+    {
+        if ( freqs[idx] >= f_in)
+        {
+            retVal = (U8Data)MT2266_NUM_XFREQS - idx;
+            break;
+        }
+    }
+
+    return retVal;
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_ChangeFreq
+**
+**  Description:    Change the tuner's tuned frequency to f_in.
+**
+**  Parameters:     h           - Open handle to the tuner (from MT2266_Open).
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2266_Open BEFORE MT2266_ChangeFreq!
+**
+**                  MT_ReadSub       - Read byte(s) of data from the two-wire-bus
+**                  MT_WriteSub      - Write byte(s) of data to the two-wire-bus
+**                  MT_Sleep         - Delay execution for x milliseconds
+**                  MT2266_GetLocked - Checks to see if the PLL is locked
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   11-01-2006    RSK    Ver 1.02: Added usage of UFILT0 and UFILT1.
+**   N/A   11-29-2006    DAD    Ver 1.03: Parenthesis clarification
+**   118   05-09-2007    RSK    Ver 1.05: Refactored to call _Tune() API.
+**
+****************************************************************************/
+UData_t MT2266_ChangeFreq(Handle_t h,
+                          UData_t f_in)     /* RF input center frequency   */
+{
+    return (MT2266_Tune(h, f_in));
+}
+
+
+/****************************************************************************
+**
+**  Name: MT2266_Tune
+**
+**  Description:    Change the tuner's tuned frequency to f_in.
+**
+**  Parameters:     h           - Open handle to the tuner (from MT2266_Open).
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2266_Open BEFORE MT2266_Tune!
+**
+**                  MT_ReadSub       - Read byte(s) of data from the two-wire-bus
+**                  MT_WriteSub      - Write byte(s) of data to the two-wire-bus
+**                  MT_Sleep         - Delay execution for x milliseconds
+**                  MT2266_GetLocked - Checks to see if the PLL is locked
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   11-01-2006    RSK    Ver 1.02: Added usage of UFILT0 and UFILT1.
+**   N/A   11-29-2006    DAD    Ver 1.03: Parenthesis clarification
+**   118   05-09-2007    RSK    Ver 1.05: Adding Standard MTxxxx_Tune() API.
+**
+****************************************************************************/
+UData_t MT2266_Tune(Handle_t h,
+                    UData_t f_in)     /* RF input center frequency   */
+{
+    MT2266_Info_t* pInfo = (MT2266_Info_t*) h;
+
+    UData_t status = MT_OK;       /*  status of operation             */
+    UData_t LO;                   /*  LO register value               */
+    UData_t Num;                  /*  Numerator for LO reg. value     */
+    UData_t ofLO;                 /*  last time's LO frequency        */
+    UData_t ofin;                 /*  last time's input frequency     */
+    U8Data  LO_Band;              /*  LO Mode bits                    */
+    UData_t s_fRef;               /*  Ref Freq scaled for LO Band     */
+    UData_t this_band;            /*  Band for the requested freq     */
+    UData_t SROx2;                /*  SRO times 2                     */
+
+    /*  Verify that the handle passed points to a valid tuner         */
+    if (IsValidHandle(pInfo) == 0)
+        return MT_INV_HANDLE;
+
+    /*
+    **  Save original input and LO value
+    */
+    ofLO = pInfo->f_LO;
+    ofin = pInfo->f_in;
+
+    /*
+    **  Assign in the requested input value
+    */
+    pInfo->f_in = f_in;
+
+    /*
+    **  Get the SRO multiplier value
+    */
+    SROx2 = (2 - (pInfo->reg[MT2266_SRO_CTRL] & 0x01));
+
+	/* Check f_Step value */
+	if(pInfo->f_Step == 0)
+		return MT_UNKNOWN;
+
+	/*  Request an LO that is on a step size boundary  */
+    pInfo->f_LO = RoundToStep(f_in, pInfo->f_Step, pInfo->f_Ref);
+
+    if (pInfo->f_LO < MIN_VHF_FREQ)
+    {
+        status |= MT_FIN_RANGE | MT_ARG_RANGE | MT_DNC_RANGE;
+        return status;  /* Does not support frequencies below MIN_VHF_FREQ  */
+    }
+    else if (pInfo->f_LO <= MAX_VHF_FREQ)
+    {
+        /*  VHF Band  */
+        s_fRef = pInfo->f_Ref * SROx2 / 4;
+        LO_Band = 0;
+        this_band = MT2266_VHF_BAND;
+    }
+    else if (pInfo->f_LO < MIN_UHF_FREQ)
+    {
+        status |= MT_FIN_RANGE | MT_ARG_RANGE | MT_DNC_RANGE;
+        return status;  /* Does not support frequencies between MAX_VHF_FREQ & MIN_UHF_FREQ */
+    }
+    else if (pInfo->f_LO <= MAX_UHF_FREQ)
+    {
+        /*  UHF Band  */
+        s_fRef = pInfo->f_Ref * SROx2 / 2;
+        LO_Band = 1;
+        this_band = MT2266_UHF_BAND;
+    }
+    else
+    {
+        status |= MT_FIN_RANGE | MT_ARG_RANGE | MT_DNC_RANGE;
+        return status;  /* Does not support frequencies above MAX_UHF_FREQ */
+    }
+
+    /*
+    ** Calculate the LO frequencies and the values to be placed
+    ** in the tuning registers.
+    */
+    pInfo->f_LO = CalcLOMult(&LO, &Num, pInfo->f_LO, 8191, s_fRef);
+
+    /*
+    **  If we have the same LO frequencies and we're already locked,
+    **  then just return without writing any registers.
+    */
+    if ((ofLO == pInfo->f_LO)
+        && ((pInfo->reg[MT2266_STATUS_1] & 0x40) == 0x40))
+    {
+        return (status);
+    }
+
+    /*
+    ** Reset defaults here if we're tuning into a new band
+    */
+    if (MT_NO_ERROR(status))
+    {
+        if (this_band != pInfo->band)
+        {
+            MT2266_DefaultsEntry *defaults = MT_NULL;
+            switch (this_band)
+            {
+                case MT2266_VHF_BAND:
+                    defaults = &MT2266_VHF_defaults[0];
+                    break;
+                case MT2266_UHF_BAND:
+                    defaults = &MT2266_UHF_defaults[0];
+                    break;
+                default:
+                    status |= MT_ARG_RANGE;
+            }
+            if ( MT_NO_ERROR(status))
+            {
+                while (defaults->data && MT_NO_ERROR(status))
+                {
+                    status |= MT2266_WriteSub(pInfo->hUserData, pInfo->address, defaults->data[0], &defaults->data[1], defaults->cnt);
+                    defaults++;
+                }
+                /* re-read the new registers into the cached values */
+                status |= MT2266_ReadSub(pInfo->hUserData, pInfo->address, 0, &pInfo->reg[0], END_REGS);
+                pInfo->band = this_band;
+            }
+        }
+    }
+
+    /*
+    **  Place all of the calculated values into the local tuner
+    **  register fields.
+    */
+    if (MT_NO_ERROR(status))
+    {
+        pInfo->reg[MT2266_LO_CTRL_1] = (U8Data)(Num >> 8);
+        pInfo->reg[MT2266_LO_CTRL_2] = (U8Data)(Num & 0xFF);
+        pInfo->reg[MT2266_LO_CTRL_3] = (U8Data)(LO & 0xFF);
+
+        /*
+        ** Now write out the computed register values
+        */
+        status |= MT2266_WriteSub(pInfo->hUserData, pInfo->address, MT2266_LO_CTRL_1, &pInfo->reg[MT2266_LO_CTRL_1], 3);
+
+        if (pInfo->band == MT2266_UHF_BAND)
+        {
+            U8Data UFilt0 = 0;                        /*  def when f_in > all    */
+            U8Data UFilt1 = 0;                        /*  def when f_in > all    */
+            UData_t* XFreq0;
+            UData_t* XFreq1;
+            SData_t ClearTune_Fuse;
+            SData_t f_offset;
+            UData_t f_in_;
+
+            PREFETCH(MT2266_BAND_CTRL, 2);  /* Fetch register(s) if __NO_CACHE__ defined */
+            PREFETCH(MT2266_STATUS_5, 1);  /* Fetch register(s) if __NO_CACHE__ defined */
+
+            XFreq0 = (pInfo->reg[MT2266_BAND_CTRL] & 0x10) ? pInfo->xfreqs.xfreq[ MT2266_UHF0_ATTEN ] : pInfo->xfreqs.xfreq[ MT2266_UHF0 ];
+            XFreq1 = (pInfo->reg[MT2266_BAND_CTRL] & 0x10) ? pInfo->xfreqs.xfreq[ MT2266_UHF1_ATTEN ] : pInfo->xfreqs.xfreq[ MT2266_UHF1 ];
+
+            ClearTune_Fuse = pInfo->reg[MT2266_STATUS_5] & 0x07;
+            f_offset = (10000000) * ((ClearTune_Fuse > 3) ? (ClearTune_Fuse - 8) : ClearTune_Fuse);
+            f_in_ = (f_in - f_offset) / 1000 / TUNE_STEP_SIZE;
+
+            UFilt0 = GetCrossover( f_in_, XFreq0 );
+            UFilt1 = GetCrossover( f_in_, XFreq1 );
+
+            /*  If UFilt == 16, set UBANDen and set UFilt = 15  */
+            if ( (UFilt0 == 16) || (UFilt1 == 16) )
+            {
+                pInfo->reg[MT2266_BAND_CTRL] |= 0x01;
+                if( UFilt0 > 0 ) UFilt0--;
+                if( UFilt1 > 0 ) UFilt1--;
+            }
+            else
+                pInfo->reg[MT2266_BAND_CTRL] &= ~(0x01);
+
+            pInfo->reg[MT2266_BAND_CTRL] =
+                    (pInfo->reg[MT2266_BAND_CTRL] & 0x3F) | (LO_Band << 6);
+
+            pInfo->reg[MT2266_CLEARTUNE] = (UFilt1 << 4) | UFilt0;
+            /*  Write UBANDsel  [05] & ClearTune [06]  */
+            status |= MT2266_WriteSub(pInfo->hUserData, pInfo->address, MT2266_BAND_CTRL, &pInfo->reg[MT2266_BAND_CTRL], 2);
+        }
+    }
+
+    /*
+    **  Check for LO lock
+    */
+    if (MT_NO_ERROR(status))
+    {
+        status |= MT2266_GetLocked(h);
+    }
+
+    return (status);
+}
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_mt2266.h b/drivers/media/usb/rtl2832u/tuner_mt2266.h
new file mode 100644
index 00000000..84730763
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mt2266.h
@@ -0,0 +1,1534 @@
+#ifndef __TUNER_MT2266_H
+#define __TUNER_MT2266_H
+
+/**
+
+@file
+
+@brief   MT2266 tuner module declaration
+
+One can manipulate MT2266 tuner through MT2266 module.
+MT2266 module is derived from tunerd module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_mt2266.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	MT2266_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthHz;
+
+
+	...
+
+
+
+	// Build MT2266 tuner module.
+	BuildMt2266Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0								// I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get MT2266 tuner extra module.
+	pTunerExtra = &(pTuner->Extra.Mt2266);
+
+	// Open MT2266 handle.
+	pTunerExtra->OpenHandle(pTuner);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set MT2266 bandwidth.
+	pTunerExtra->SetBandwidthHz(pTuner, MT2266_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get MT2266 bandwidth.
+	pTunerExtra->GetBandwidthHz(pTuner, &BandwidthHz);
+
+
+
+
+
+	// Close MT2266 handle.
+	pTunerExtra->CloseHandle(pTuner);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+// The following context is source code provided by Microtune.
+
+
+
+
+
+// Microtune source code - mt_errordef.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt_errordef.h
+**
+**  Description:    Definition of bits in status/error word used by various
+**                  MicroTuner control programs.
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_errordef.h,v 1.1 2006/06/22 20:18:12 software Exp $
+**  CVS Source:     $Source: /export/home/cvsroot/software/tuners/MT2266/mt_errordef.h,v $
+**	               
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   09-09-2004    JWS    Original
+**   088   01-26-2005    DAD    Added MT_TUNER_INIT_ERR.
+**   N/A   12-09-2005    DAD    Added MT_TUNER_TIMEOUT (info).
+**
+*****************************************************************************/
+
+/*
+** Note to users:  DO NOT EDIT THIS FILE  
+**
+** If you wish to rename any of the "user defined" bits,
+** it should be done in the user file that includes this
+** source file (e.g. mt_userdef.h)
+**
+*/
+
+
+
+/*
+**  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 
+**  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+**  M U <- Info Codes --> <# Spurs> < User> <----- Err Codes ----->
+**
+**  31 = MT_ERROR - Master Error Flag.  If set, check Err Codes for reason.
+**  30 = MT_USER_ERROR - User-declared error flag.
+**  29 = Unused
+**  28 = Unused
+**  27 = MT_DNC_RANGE
+**  26 = MT_UPC_RANGE
+**  25 = MT_FOUT_RANGE
+**  24 = MT_FIN_OUT_OF_RANGE
+**  23 = MT_SPUR_PRESENT - Unavoidable spur in output
+**  22 = MT_TUNER_TIMEOUT
+**  21 = Unused
+**  20 = Unused
+**  19 = MT_SPUR_CNT_MASK (MSB) - Count of avoided spurs
+**  18 = MT_SPUR_CNT_MASK
+**  17 = MT_SPUR_CNT_MASK
+**  16 = MT_SPUR_CNT_MASK
+**  15 = MT_SPUR_CNT_MASK (LSB)
+**  14 = MT_USER_DEFINED4 - User-definable bit (see MT_Userdef.h)
+**  13 = MT_USER_DEFINED3 - User-definable bit (see MT_Userdef.h)
+**  12 = MT_USER_DEFINED2 - User-definable bit (see MT_Userdef.h)
+**  11 = MT_USER_DEFINED1 - User-definable bit (see MT_Userdef.h)
+**  10 = Unused
+**   9 = MT_TUNER_INIT_ERR - Tuner initialization error
+**   8 = MT_TUNER_ID_ERR - Tuner Part Code / Rev Code mismatches expected value
+**   7 = MT_TUNER_CNT_ERR - Attempt to open more than MT_TUNER_CNT tuners
+**   6 = MT_ARG_NULL - Null pointer passed as argument
+**   5 = MT_ARG_RANGE - Argument value out of range
+**   4 = MT_INV_HANDLE - Tuner handle is invalid
+**   3 = MT_COMM_ERR - Serial bus communications error
+**   2 = MT_DNC_UNLOCK - Downconverter PLL is unlocked
+**   1 = MT_UPC_UNLOCK - Upconverter PLL is unlocked
+**   0 = MT_UNKNOWN - Unknown error
+*/
+#define MT_ERROR (1 << 31)
+#define MT_USER_ERROR (1 << 30)
+
+/*  Macro to be used to check for errors  */
+#define MT_IS_ERROR(s) (((s) >> 30) != 0)
+#define MT_NO_ERROR(s) (((s) >> 30) == 0)
+
+
+#define MT_OK                           (0x00000000)
+
+/*  Unknown error  */
+#define MT_UNKNOWN                      (0x80000001)
+
+/*  Error:  Upconverter PLL is not locked  */
+#define MT_UPC_UNLOCK                   (0x80000002)
+
+/*  Error:  Downconverter PLL is not locked  */
+#define MT_DNC_UNLOCK                   (0x80000004)
+
+/*  Error:  Two-wire serial bus communications error  */
+#define MT_COMM_ERR                     (0x80000008)
+
+/*  Error:  Tuner handle passed to function was invalid  */
+#define MT_INV_HANDLE                   (0x80000010)
+
+/*  Error:  Function argument is invalid (out of range)  */
+#define MT_ARG_RANGE                    (0x80000020)
+
+/*  Error:  Function argument (ptr to return value) was NULL  */
+#define MT_ARG_NULL                     (0x80000040)
+
+/*  Error: Attempt to open more than MT_TUNER_CNT tuners  */
+#define MT_TUNER_CNT_ERR                (0x80000080)
+
+/*  Error: Tuner Part Code / Rev Code mismatches expected value  */
+#define MT_TUNER_ID_ERR                 (0x80000100)
+
+/*  Error: Tuner Initialization failure  */
+#define MT_TUNER_INIT_ERR               (0x80000200)
+
+/*  User-definable fields (see mt_userdef.h)  */
+#define MT_USER_DEFINED1                (0x00001000)
+#define MT_USER_DEFINED2                (0x00002000)
+#define MT_USER_DEFINED3                (0x00004000)
+#define MT_USER_DEFINED4                (0x00008000)
+#define MT_USER_MASK                    (0x4000f000)
+#define MT_USER_SHIFT                   (12)
+
+/*  Info: Mask of bits used for # of LO-related spurs that were avoided during tuning  */
+#define MT_SPUR_CNT_MASK                (0x001f0000)
+#define MT_SPUR_SHIFT                   (16)
+
+/*  Info: Tuner timeout waiting for condition  */
+#define MT_TUNER_TIMEOUT                (0x00400000)
+
+/*  Info: Unavoidable LO-related spur may be present in the output  */
+#define MT_SPUR_PRESENT                 (0x00800000)
+
+/*  Info: Tuner input frequency is out of range */
+#define MT_FIN_RANGE                    (0x01000000)
+
+/*  Info: Tuner output frequency is out of range */
+#define MT_FOUT_RANGE                   (0x02000000)
+
+/*  Info: Upconverter frequency is out of range (may be reason for MT_UPC_UNLOCK) */
+#define MT_UPC_RANGE                    (0x04000000)
+
+/*  Info: Downconverter frequency is out of range (may be reason for MT_DPC_UNLOCK) */
+#define MT_DNC_RANGE                    (0x08000000)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt_userdef.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt_userdef.h
+**
+**  Description:    User-defined data types needed by MicroTuner source code.
+**
+**                  Customers must provide the code for these functions
+**                  in the file "mt_userdef.c".
+**
+**                  Customers must verify that the typedef's in the 
+**                  "Data Types" section are correct for their platform.
+**
+**  Functions
+**  Requiring
+**  Implementation: MT_WriteSub
+**                  MT_ReadSub
+**                  MT_Sleep
+**
+**  References:     None
+**
+**  Exports:        None
+**
+**  CVS ID:         $Id: mt_userdef.h,v 1.1 2006/06/22 20:18:12 software Exp $
+**  CVS Source:     $Source: /export/home/cvsroot/software/tuners/MT2266/mt_userdef.h,v $
+**	               
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**   082   12-06-2004    JWS    Multi-tuner support - requires MTxxxx_CNT 
+**                              declarations
+**
+*****************************************************************************/
+#if !defined( __MT_USERDEF_H )
+#define __MT_USERDEF_H
+
+//#include "mt_errordef.h"
+
+#if defined( __cplusplus )     
+extern "C"                     /* Use "C" external linkage                  */
+{
+#endif
+
+/*
+**  Data Types
+*/
+typedef unsigned char   U8Data;         /*  type corresponds to 8 bits      */
+typedef unsigned int    UData_t;        /*  type must be at least 32 bits   */
+typedef int             SData_t;        /*  type must be at least 32 bits   */
+typedef void *          Handle_t;       /*  memory pointer type             */
+typedef double          FData_t;        /*  floating point data type        */
+
+#define MAX_UDATA         (4294967295U)  /*  max value storable in UData_t   */
+	
+
+/*
+** Define an MTxxxx_CNT macro for each type of tuner that will be built
+** into your application (e.g., MT2121, MT2060). MT_TUNER_CNT
+** must be set to the SUM of all of the MTxxxx_CNT macros.
+**
+** #define MT2050_CNT  (1)
+** #define MT2060_CNT  (1)
+** #define MT2111_CNT  (1)
+** #define MT2121_CNT  (3)
+*/
+
+
+#if !defined( MT_TUNER_CNT )
+#define MT_TUNER_CNT               (1)  /*  total num of MicroTuner tuners  */
+#endif
+
+/*
+**  Optional user-defined Error/Info Codes  (examples below)
+**
+**  This is the area where you can define user-specific error/info return
+**  codes to be returned by any of the functions you are responsible for
+**  writing such as MT_WriteSub() and MT_ReadSub.  There are four bits
+**  available in the status field for your use.  When set, these
+**  bits will be returned in the status word returned by any tuner driver
+**  call.  If you OR in the MT_ERROR bit as well, the tuner driver code
+**  will treat the code as an error.
+**
+**  The following are a few examples of errors you can provide.
+**
+**  Example 1:
+**  You might check to see the hUserData handle is correct and issue 
+**  MY_USERDATA_INVALID which would be defined like this:
+**
+**  #define MY_USERDATA_INVALID  (MT_USER_ERROR | MT_USER_DEFINED1)
+**
+**
+**  Example 2:
+**  You might be able to provide more descriptive two-wire bus errors:
+**
+**  #define NO_ACK   (MT_USER_ERROR | MT_USER_DEFINED1)
+**  #define NO_NACK  (MT_USER_ERROR | MT_USER_DEFINED2)
+**  #define BUS_BUSY (MT_USER_ERROR | MT_USER_DEFINED3)
+**
+**
+**  Example 3:
+**  You can also provide information (non-error) feedback:
+**
+**  #define MY_INFO_1   (MT_USER_DEFINED1)
+**
+**
+**  Example 4:
+**  You can combine the fields together to make a multi-bit field.
+**  This one can provide the tuner number based off of the addr
+**  passed to MT_WriteSub or MT_ReadSub.  It assumes that
+**  MT_USER_DEFINED4 through MT_USER_DEFINED1 are contiguously. If
+**  TUNER_NUM were OR'ed into the status word on an error, you could
+**  use this to identify which tuner had the problem (and whether it
+**  was during a read or write operation).
+**
+**  #define TUNER_NUM  ((addr & 0x07) >> 1) << MT_USER_SHIFT
+**
+*/
+
+/*****************************************************************************
+**
+**  Name: MT_WriteSub
+**
+**  Description:    Write values to device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to write data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2266_WriteSub(Handle_t hUserData, 
+                    UData_t addr, 
+                    U8Data subAddress, 
+                    U8Data *pData, 
+                    UData_t cnt);
+
+
+/*****************************************************************************
+**
+**  Name: MT_ReadSub
+**
+**  Description:    Read values from device using a two-wire serial bus.
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  addr       - device serial bus address  (value passed
+**                               as parameter to MTxxxx_Open)
+**                  subAddress - serial bus sub-address (Register Address)
+**                  pData      - pointer to the Data to be written to the 
+**                               device 
+**                  cnt        - number of bytes/registers to be written
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      user-defined
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code for this
+**                  function to read data using the tuner's 2-wire serial 
+**                  bus.
+**
+**                  The hUserData parameter is a user-specific argument.
+**                  If additional arguments are needed for the user's
+**                  serial bus read/write functions, this argument can be
+**                  used to supply the necessary information.
+**                  The hUserData parameter is initialized in the tuner's Open
+**                  function.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+UData_t MT2266_ReadSub(Handle_t hUserData, 
+                   UData_t addr, 
+                   U8Data subAddress, 
+                   U8Data *pData, 
+                   UData_t cnt);
+
+
+/*****************************************************************************
+**
+**  Name: MT_Sleep
+**
+**  Description:    Delay execution for "nMinDelayTime" milliseconds
+**
+**  Parameters:     hUserData     - User-specific I/O parameter that was
+**                                  passed to tuner's Open function.
+**                  nMinDelayTime - Delay time in milliseconds
+**
+**  Returns:        None.
+**
+**  Notes:          This is a callback function that is called from the
+**                  the tuning algorithm.  You MUST provide code that
+**                  blocks execution for the specified period of time. 
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   03-25-2004    DAD    Original
+**
+*****************************************************************************/
+void MT2266_Sleep(Handle_t hUserData,
+              UData_t nMinDelayTime);
+
+
+#if defined(MT2060_CNT)
+#if MT2060_CNT > 0
+/*****************************************************************************
+**
+**  Name: MT_TunerGain  (for MT2060 only)
+**
+**  Description:    Measure the relative tuner gain using the demodulator
+**
+**  Parameters:     hUserData  - User-specific I/O parameter that was
+**                               passed to tuner's Open function.
+**                  pMeas      - Tuner gain (1/100 of dB scale).
+**                               ie. 1234 = 12.34 (dB)
+**
+**  Returns:        status:
+**                      MT_OK  - No errors
+**                      user-defined errors could be set
+**
+**  Notes:          This is a callback function that is called from the
+**                  the 1st IF location routine.  You MUST provide
+**                  code that measures the relative tuner gain in a dB
+**                  (not linear) scale.  The return value is an integer
+**                  value scaled to 1/100 of a dB.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   06-16-2004    DAD    Original
+**   N/A   11-30-2004    DAD    Renamed from MT_DemodInputPower.  This name
+**                              better describes what this function does.
+**
+*****************************************************************************/
+UData_t MT_TunerGain(Handle_t hUserData,
+                     SData_t* pMeas);
+#endif
+#endif
+
+#if defined( __cplusplus )     
+}
+#endif
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Microtune source code - mt2266.h
+
+
+
+/*****************************************************************************
+**
+**  Name: mt2266.h
+**
+**  Copyright 2007 Microtune, Inc. All Rights Reserved
+**
+**  This source code file contains confidential information and/or trade
+**  secrets of Microtune, Inc. or its affiliates and is subject to the
+**  terms of your confidentiality agreement with Microtune, Inc. or one of
+**  its affiliates, as applicable.
+**
+*****************************************************************************/
+
+/*****************************************************************************
+**
+**  Name: mt2266.h
+**
+**  Description:    Microtune MT2266 Tuner software interface.
+**                  Supports tuners with Part/Rev code: 0x85.
+**
+**  Functions
+**  Implemented:    UData_t  MT2266_Open
+**                  UData_t  MT2266_Close
+**                  UData_t  MT2266_ChangeFreq
+**                  UData_t  MT2266_GetLocked
+**                  UData_t  MT2266_GetParam
+**                  UData_t  MT2266_GetReg
+**                  UData_t  MT2266_GetUHFXFreqs
+**                  UData_t  MT2266_GetUserData
+**                  UData_t  MT2266_ReInit
+**                  UData_t  MT2266_SetParam
+**                  UData_t  MT2266_SetPowerModes
+**                  UData_t  MT2266_SetReg
+**                  UData_t  MT2266_SetUHFXFreqs
+**                  UData_t  MT2266_Tune
+**
+**  References:     AN-00010: MicroTuner Serial Interface Application Note
+**                  MicroTune, Inc.
+**
+**  Exports:        None
+**
+**  Dependencies:   MT_ReadSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Read byte(s) of data from the two-wire bus.
+**
+**                  MT_WriteSub(hUserData, IC_Addr, subAddress, *pData, cnt);
+**                  - Write byte(s) of data to the two-wire bus.
+**
+**                  MT_Sleep(hUserData, nMinDelayTime);
+**                  - Delay execution for x milliseconds
+**
+**  CVS ID:         $Id: mt2266.h,v 1.3 2007/10/02 18:43:17 software Exp $
+**  CVS Source:     $Source: /export/home/cvsroot/software/tuners/MT2266/mt2266.h,v $
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   05-30-2006    DAD    Ver 1.0: Modified version of mt2260.c (Ver 1.01).
+**   N/A   11-01-2006    RSK    Ver 1.02: Adding Get/Set UHFXFreq access functions.
+**   118   05-09-2007    RSK    Ver 1.05: Adding Standard MTxxxx_Tune() API.
+**
+*****************************************************************************/
+#if !defined( __MT2266_H )
+#define __MT2266_H
+
+//#include "mt_userdef.h"
+
+#if defined( __cplusplus )
+extern "C"                     /* Use "C" external linkage                  */
+{
+#endif
+
+/*
+**  Parameter for function MT2266_GetParam & MT2266_SetParam that
+**  specifies the tuning algorithm parameter to be read/written.
+*/
+typedef enum
+{
+    /*  tuner address                                  set by MT2266_Open() */
+    MT2266_IC_ADDR,
+
+    /*  max number of MT2266 tuners       set by MT2266_CNT in mt_userdef.h */
+    MT2266_MAX_OPEN,
+
+    /*  current number of open MT2266 tuners           set by MT2266_Open() */
+    MT2266_NUM_OPEN,
+
+    /*  Number of tuner registers                                           */
+    MT2266_NUM_REGS,
+
+    /*  crystal frequency                            (default: 18000000 Hz) */
+    MT2266_SRO_FREQ,
+
+    /*  min tuning step size                            (default: 50000 Hz) */
+    MT2266_STEPSIZE,
+
+    /*  input center frequency                   set by MT2266_ChangeFreq() */
+    MT2266_INPUT_FREQ,
+
+    /*  LO Frequency                             set by MT2266_ChangeFreq() */
+    MT2266_LO_FREQ,
+
+    /*  output channel bandwidth                      (default: 8000000 Hz) */
+    MT2266_OUTPUT_BW,
+
+    /*  Base band filter calibration RC code                 (default: N/A) */
+    MT2266_RC2_VALUE,
+
+    /*  Base band filter nominal cal RC code                 (default: N/A) */
+    MT2266_RC2_NOMINAL,
+
+    /*  RF attenuator A/D readback                              (read-only) */
+    MT2266_RF_ADC,
+
+    /*  BB attenuator A/D readback                              (read-only) */
+    MT2266_BB_ADC,
+
+    /*  RF attenuator setting                             (default: varies) */
+    MT2266_RF_ATTN,
+
+    /*  BB attenuator setting                             (default: varies) */
+    MT2266_BB_ATTN,
+
+    /*  RF external / internal atten control              (default: varies) */
+    MT2266_RF_EXT,
+
+    /*  BB external / internal atten control                   (default: 1) */
+    MT2266_BB_EXT,
+
+    /*  LNA gain setting (0-15)                           (default: varies) */
+    MT2266_LNA_GAIN,
+
+    /*  Decrement LNA Gain (where arg=min LNA Gain value)                   */
+    MT2266_LNA_GAIN_DECR,
+
+    /*  Increment LNA Gain (where arg=max LNA Gain value)                   */
+    MT2266_LNA_GAIN_INCR,
+
+    /*  Set for UHF max sensitivity mode                                    */
+    MT2266_UHF_MAXSENS,
+
+    /*  Set for UHF normal mode                                             */
+    MT2266_UHF_NORMAL,
+
+    MT2266_EOP                    /*  last entry in enumerated list         */
+} MT2266_Param;
+
+
+/*
+**  Parameter for function MT2266_GetUHFXFreqs & MT2266_SetUHFXFreqs that
+**  specifies the particular frequency crossover table to be read/written.
+*/
+typedef enum
+{
+    /*  Reference the UHF 0 filter, without any attenuation                 */
+    MT2266_UHF0,
+
+    /*  Reference the UHF 1 filter, without any attenuation                 */
+    MT2266_UHF1,
+
+    /*  Reference the UHF 0 filter, with attenuation                        */
+    MT2266_UHF0_ATTEN,
+
+    /*  Reference the UHF 1 filter, with attenuation                        */
+    MT2266_UHF1_ATTEN,
+
+    MT2266_NUMBER_OF_XFREQ_SETS    /*  last entry in enumerated list        */
+
+} MT2266_UHFXFreq_Type;
+
+
+#define  MT2266_NUM_XFREQS  (16)
+
+typedef  UData_t MT2266_XFreq_Set[ MT2266_NUM_XFREQS ];
+
+/*
+**  Constants for Specifying Operating Band of the Tuner
+*/
+#define MT2266_VHF_BAND (0)
+#define MT2266_UHF_BAND (1)
+#define MT2266_L_BAND   (2)
+
+/*
+**  Constants for specifying power modes these values
+**  are bit-mapped and can be added/OR'ed to indicate
+**  multiple settings.  Examples:
+**     MT2266_SetPowerModes(h, MT2266_NO_ENABLES + MT22266_SROsd);
+**     MT2266_SetPowerModes(h, MT2266_ALL_ENABLES | MT22266_SRO_NOT_sd);
+**     MT2266_SetPowerModes(h, MT2266_NO_ENABLES + MT22266_SROsd);
+**     MT2266_SetPowerModes(h, MT2266_SROen + MT22266_LOen + MT2266_ADCen);
+*/
+#define MT2266_SROen       (0x01)
+#define MT2266_LOen        (0x02)
+#define MT2266_ADCen       (0x04)
+#define MT2266_PDen        (0x08)
+#define MT2266_DCOCen      (0x10)
+#define MT2266_BBen        (0x20)
+#define MT2266_MIXen       (0x40)
+#define MT2266_LNAen       (0x80)
+#define MT2266_ALL_ENABLES (0xFF)
+#define MT2266_NO_ENABLES  (0x00)
+#define MT2266_SROsd       (0x100)
+#define MT2266_SRO_NOT_sd  (0x000)
+
+/* ====== Functions which are declared in mt2266.c File ======= */
+
+/******************************************************************************
+**
+**  Name: MT2266_Open
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Usage:          status = MT2266_Open(0xC0, &hMT2266, NULL);
+**                  if (MT_IS_ERROR(status))
+**                      //  Check error codes for reason
+**
+**  Parameters:     MT2266_Addr  - Serial bus address of the tuner.
+**                  hMT2266      - Tuner handle passed back.
+**                  hUserData    - User-defined data, if needed for the
+**                                 MT_ReadSub() & MT_WriteSub functions.
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**                      MT_COMM_ERR       - Serial bus communications error
+**                      MT_ARG_NULL       - Null pointer argument passed
+**                      MT_TUNER_CNT_ERR  - Too many tuners open
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+******************************************************************************/
+UData_t MT2266_Open(UData_t MT2266_Addr,
+                    Handle_t* hMT2266,
+                    Handle_t hUserData);
+
+
+/******************************************************************************
+**
+**  Name: MT2266_Close
+**
+**  Description:    Release the handle to the tuner.
+**
+**  Parameters:     hMT2266      - Handle to the MT2266 tuner
+**
+**  Usage:          status = MT2266_Close(hMT2266);
+**
+**  Returns:        status:
+**                      MT_OK         - No errors
+**                      MT_INV_HANDLE - Invalid tuner handle
+**
+**  Dependencies:   mt_errordef.h - definition of error codes
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+******************************************************************************/
+UData_t MT2266_Close(Handle_t hMT2266);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_ChangeFreq
+**
+**  Description:    Change the tuner's tuned frequency to f_in.
+**
+**  Parameters:     h           - Open handle to the tuner (from MT2266_Open).
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Usage:          status = MT2266_ChangeFreq(hMT2266, f_in);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2266_Open BEFORE MT2266_ChangeFreq!
+**
+**                  MT_ReadSub       - Read byte(s) of data from the two-wire-bus
+**                  MT_WriteSub      - Write byte(s) of data to the two-wire-bus
+**                  MT_Sleep         - Delay execution for x milliseconds
+**                  MT2266_GetLocked - Checks to see if the PLL is locked
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+******************************************************************************/
+UData_t MT2266_ChangeFreq(Handle_t h,
+                          UData_t f_in);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetLocked
+**
+**  Description:    Checks to see if the PLL is locked.
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Usage:          status = MT2266_GetLocked(hMT2266);
+**                  if (status & MT_DNC_UNLOCK)
+**                      //  error!, PLL is unlocked
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   MT_ReadSub    - Read byte(s) of data from the serial bus
+**                  MT_Sleep      - Delay execution for x milliseconds
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_GetLocked(Handle_t h);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetParam
+**
+**  Description:    Gets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm - mostly for testing purposes.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2266_Param)
+**                  pValue      - ptr to returned value
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2266_IC_ADDR          Serial Bus address of this tuner
+**                  MT2266_MAX_OPEN         Max number of MT2266's that can be open
+**                  MT2266_NUM_OPEN         Number of MT2266's currently open
+**                  MT2266_NUM_REGS         Number of tuner registers
+**                  MT2266_SRO_FREQ         crystal frequency
+**                  MT2266_STEPSIZE         minimum tuning step size
+**                  MT2266_INPUT_FREQ       input center frequency
+**                  MT2266_LO_FREQ          LO Frequency
+**                  MT2266_OUTPUT_BW        Output channel bandwidth
+**                  MT2266_RC2_VALUE        Base band filter cal RC code (method 2)
+**                  MT2266_RF_ADC           RF attenuator A/D readback
+**                  MT2266_RF_ATTN          RF attenuation (0-255)
+**                  MT2266_RF_EXT           External control of RF atten
+**                  MT2266_LNA_GAIN         LNA gain setting (0-15)
+**                  MT2266_BB_ADC           BB attenuator A/D readback
+**                  MT2266_BB_ATTN          Baseband attenuation (0-255)
+**                  MT2266_BB_EXT           External control of BB atten
+**
+**  Usage:          status |= MT2266_GetParam(hMT2266,
+**                                            MT2266_OUTPUT_BW,
+**                                            &f_bw);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetParam, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_GetParam(Handle_t     h,
+                        MT2266_Param param,
+                        UData_t*     pValue);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetReg
+**
+**  Description:    Gets an MT2266 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  reg         - MT2266 register/subaddress location
+**                  *val        - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Use this function if you need to read a register from
+**                  the MT2266.
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_GetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data*  val);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetUHFXFreqs
+**
+**  Description:    Retrieves the specified set of UHF Crossover Frequencies
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Usage:          MT2266_Freq_Set  tmpFreqs;
+**                  status = MT2266_GetUHFXFreqs(hMT2266,
+**                                               MT2266_UHF1_WITH_ATTENUATION,
+**                                               tmpFreqs );
+**                  if (status & MT_ARG_RANGE)
+**                      // error, Invalid UHF Crossover Frequency Set requested.
+**                  else
+**                      for( int i = 0;  i < MT2266_NUM_XFREQS; i++ )
+**                         . . .
+**
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_ARG_RANGE     - freq_type is out of range.
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   freqs_buffer *must* be defined of type MT2266_Freq_Set
+**                     to assure sufficient space allocation!
+**
+**                  USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetUHFXFreqs
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   11-01-2006   RSK     Original.
+**
+****************************************************************************/
+UData_t MT2266_GetUHFXFreqs(Handle_t             h,
+                            MT2266_UHFXFreq_Type freq_type,
+                            MT2266_XFreq_Set     freqs_buffer);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_GetUserData
+**
+**  Description:    Gets the user-defined data item.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**
+**  Usage:          status = MT2266_GetUserData(hMT2266, &hUserData);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  The hUserData parameter is a user-specific argument
+**                  that is stored internally with the other tuner-
+**                  specific information.
+**
+**                  For example, if additional arguments are needed
+**                  for the user to identify the device communicating
+**                  with the tuner, this argument can be used to supply
+**                  the necessary information.
+**
+**                  The hUserData parameter is initialized in the tuner's
+**                  Open function to NULL.
+**
+**  See Also:       MT2266_SetUserData, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_GetUserData(Handle_t  h,
+                           Handle_t* hUserData);
+
+
+/******************************************************************************
+**
+**  Name: MT2266_ReInit
+**
+**  Description:    Initialize the tuner's register values.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**
+**  Returns:        status:
+**                      MT_OK             - No errors
+**                      MT_TUNER_ID_ERR   - Tuner Part/Rev code mismatch
+**                      MT_TUNER_INIT_ERR - Tuner initialization failed
+**                      MT_INV_HANDLE     - Invalid tuner handle
+**                      MT_COMM_ERR       - Serial bus communications error
+**
+**  Dependencies:   MT_ReadSub  - Read byte(s) of data from the two-wire bus
+**                  MT_WriteSub - Write byte(s) of data to the two-wire bus
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+******************************************************************************/
+UData_t MT2266_ReInit(Handle_t h);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetParam
+**
+**  Description:    Sets a tuning algorithm parameter.
+**
+**                  This function provides access to the internals of the
+**                  tuning algorithm.  You can override many of the tuning
+**                  algorithm defaults using this function.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  param       - Tuning algorithm parameter
+**                                (see enum MT2266_Param)
+**                  nValue      - value to be set
+**
+**                  param                   Description
+**                  ----------------------  --------------------------------
+**                  MT2266_SRO_FREQ         crystal frequency
+**                  MT2266_STEPSIZE         minimum tuning step size
+**                  MT2266_INPUT_FREQ       Center of input channel
+**                  MT2266_OUTPUT_BW        Output channel bandwidth
+**                  MT2266_RF_ATTN          RF attenuation (0-255)
+**                  MT2266_RF_EXT           External control of RF atten
+**                  MT2266_LNA_GAIN         LNA gain setting (0-15)
+**                  MT2266_LNA_GAIN_DECR    Decrement LNA Gain (arg=min)
+**                  MT2266_LNA_GAIN_INCR    Increment LNA Gain (arg=max)
+**                  MT2266_BB_ATTN          Baseband attenuation (0-255)
+**                  MT2266_BB_EXT           External control of BB atten
+**                  MT2266_UHF_MAXSENS      Set for UHF max sensitivity mode
+**                  MT2266_UHF_NORMAL       Set for UHF normal mode
+**
+**  Usage:          status |= MT2266_SetParam(hMT2266,
+**                                            MT2266_STEPSIZE,
+**                                            50000);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_NULL      - Null pointer argument passed
+**                      MT_ARG_RANGE     - Invalid parameter requested
+**                                         or set value out of range
+**                                         or non-writable parameter
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_GetParam, MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_SetParam(Handle_t     h,
+                        MT2266_Param param,
+                        UData_t      nValue);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetPowerModes
+**
+**  Description:    Sets the bits in the MT2266_ENABLES register and the
+**                  SROsd bit in the MT2266_SROADC_CTRL register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  flags       - Bit mask of flags to indicate enabled
+**                                bits.
+**
+**  Usage:          status = MT2266_SetPowerModes(hMT2266, flags);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  The bits in the MT2266_ENABLES register and the
+**                  SROsd bit are set according to the supplied flags.
+**
+**                  The pre-defined flags are as follows:
+**                      MT2266_SROen
+**                      MT2266_LOen
+**                      MT2266_ADCen
+**                      MT2266_PDen
+**                      MT2266_DCOCen
+**                      MT2266_BBen
+**                      MT2266_MIXen
+**                      MT2266_LNAen
+**                      MT2266_ALL_ENABLES
+**                      MT2266_NO_ENABLES
+**                      MT2266_SROsd
+**                      MT2266_SRO_NOT_sd
+**
+**                  ONLY the enable bits (or SROsd bit) specified in the
+**                  flags parameter will be set.  Any flag which is not
+**                  included, will cause that bit to be disabled.
+**
+**                  The ALL_ENABLES, NO_ENABLES, and SRO_NOT_sd constants
+**                  are for convenience.  The NO_ENABLES and SRO_NOT_sd
+**                  do not actually have to be included, but are provided
+**                  for clarity.
+**
+**  See Also:       MT2266_Open
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_SetPowerModes(Handle_t h,
+                             UData_t  flags);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetReg
+**
+**  Description:    Sets an MT2266 register.
+**
+**  Parameters:     h           - Tuner handle (returned by MT2266_Open)
+**                  reg         - MT2266 register/subaddress location
+**                  val         - MT2266 register/subaddress value
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_ARG_RANGE     - Argument out of range
+**
+**  Dependencies:   USERS MUST CALL MT2266_Open() FIRST!
+**
+**                  Use this function if you need to override a default
+**                  register value
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   02-03-2006   DAD/JWS Original.
+**
+****************************************************************************/
+UData_t MT2266_SetReg(Handle_t h,
+                      U8Data   reg,
+                      U8Data   val);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_SetUHFXFreqs
+**
+**  Description:    Retrieves the specified set of UHF Crossover Frequencies
+**
+**  Parameters:     h            - Open handle to the tuner (from MT2266_Open).
+**
+**  Usage:          MT2266_Freq_Set  tmpFreqs;
+**                  status = MT2266_SetUHFXFreqs(hMT2266,
+**                                               MT2266_UHF1_WITH_ATTENUATION,
+**                                               tmpFreqs );
+**                  if (status & MT_ARG_RANGE)
+**                      // error, Invalid UHF Crossover Frequency Set requested.
+**                  else
+**                      for( int i = 0;  i < MT2266_NUM_XFREQS; i++ )
+**                         . . .
+**
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_ARG_RANGE     - freq_type is out of range.
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**
+**  Dependencies:   freqs_buffer *must* be defined of type MT2266_Freq_Set
+**                     to assure sufficient space allocation!
+**
+**                  USERS MUST CALL MT2266_Open() FIRST!
+**
+**  See Also:       MT2266_SetUHFXFreqs
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   11_01-2006   RSK     Original.
+**
+****************************************************************************/
+UData_t MT2266_SetUHFXFreqs(Handle_t             h,
+                            MT2266_UHFXFreq_Type freq_type,
+                            MT2266_XFreq_Set     freqs_buffer);
+
+
+/****************************************************************************
+**
+**  Name: MT2266_Tune
+**
+**  Description:    Change the tuner's tuned frequency to f_in.
+**
+**  Parameters:     h           - Open handle to the tuner (from MT2266_Open).
+**                  f_in        - RF input center frequency (in Hz).
+**
+**  Usage:          status = MT2266_Tune(hMT2266, f_in);
+**
+**  Returns:        status:
+**                      MT_OK            - No errors
+**                      MT_INV_HANDLE    - Invalid tuner handle
+**                      MT_DNC_UNLOCK    - Downconverter PLL unlocked
+**                      MT_COMM_ERR      - Serial bus communications error
+**                      MT_FIN_RANGE     - Input freq out of range
+**                      MT_DNC_RANGE     - Downconverter freq out of range
+**
+**  Dependencies:   MUST CALL MT2266_Open BEFORE MT2266_Tune!
+**
+**                  MT_ReadSub       - Read byte(s) of data from the two-wire-bus
+**                  MT_WriteSub      - Write byte(s) of data to the two-wire-bus
+**                  MT_Sleep         - Delay execution for x milliseconds
+**                  MT2266_GetLocked - Checks to see if the PLL is locked
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   118   05-09-2007   RSK     Original API Introduction (was ChangeFreq).
+**
+******************************************************************************/
+UData_t MT2266_Tune(Handle_t h,
+                    UData_t f_in);
+
+
+#if defined( __cplusplus )
+}
+#endif
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is MT2266 tuner API source code
+
+
+
+
+
+/**
+
+@file
+
+@brief   MT2266 tuner module declaration
+
+One can manipulate MT2266 tuner through MT2266 module.
+MT2266 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// Definitions
+
+// MT2266 API option
+#define __NO_CACHE__
+#define MT2266_CNT		4
+
+
+// Bandwidth modes
+enum MT2266_BANDWIDTH_HZ
+{
+	MT2266_BANDWIDTH_5MHZ = 5000000,
+	MT2266_BANDWIDTH_6MHZ = 6000000,
+	MT2266_BANDWIDTH_7MHZ = 7000000,
+	MT2266_BANDWIDTH_8MHZ = 8000000,
+};
+
+
+
+
+
+// Builder
+void
+BuildMt2266Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+mt2266_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+mt2266_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+mt2266_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+mt2266_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+mt2266_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+mt2266_OpenHandle(
+	TUNER_MODULE *pTuner
+	);
+
+int
+mt2266_CloseHandle(
+	TUNER_MODULE *pTuner
+	);
+
+void
+mt2266_GetHandle(
+	TUNER_MODULE *pTuner,
+	void **pDeviceHandle
+	);
+
+int
+mt2266_SetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long BandwidthHz
+	);
+
+int
+mt2266_GetBandwidthHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pBandwidthHz
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_mxl5007t.c b/drivers/media/usb/rtl2832u/tuner_mxl5007t.c
new file mode 100644
index 00000000..9a238b27
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mxl5007t.c
@@ -0,0 +1,1267 @@
+/**
+
+@file
+
+@brief   MxL5007T tuner module definition
+
+One can manipulate MxL5007T tuner through MxL5007T module.
+MxL5007T module is derived from tuner module.
+
+*/
+
+
+#include "tuner_mxl5007t.h"
+
+
+
+
+
+/**
+
+@brief   MxL5007T tuner module builder
+
+Use BuildMxl5007tModule() to build MxL5007T module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to MxL5007T tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   MxL5007T I2C device address
+@param [in]   CrystalFreqHz                MxL5007T crystal frequency in Hz
+@param [in]   StandardMode                 MxL5007T standard mode
+@param [in]   IfFreqHz                     MxL5007T IF frequency in Hz
+@param [in]   LoopThroughMode              MxL5007T loop-through mode
+@param [in]   ClkOutMode                   MxL5007T clock output mode
+@param [in]   ClkOutAmpMode                MxL5007T clock output amplitude mode
+@param [in]   QamIfDiffOutLevel            MxL5007T QAM IF differential output level for QAM standard only
+
+
+@note
+	-# One should call BuildMxl5007tModule() to build MxL5007T module before using it.
+
+*/
+void
+BuildMxl5007tModule(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int StandardMode,
+	unsigned long IfFreqHz,
+	int SpectrumMode,
+	int LoopThroughMode,
+	int ClkOutMode,
+	int ClkOutAmpMode,
+	long QamIfDiffOutLevel
+	)
+{
+	TUNER_MODULE *pTuner;
+	MXL5007T_EXTRA_MODULE *pExtra;
+	MxL5007_TunerConfigS *pTunerConfigS;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mxl5007t);
+
+	// Set and get MaxLinear-defined MxL5007T structure pointer.
+	pExtra->pTunerConfigS = &(pExtra->TunerConfigSMemory);
+	pTunerConfigS = pExtra->pTunerConfigS;
+
+	// Set additional definition tuner module pointer.
+	pTunerConfigS->pTuner = pTuner;
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_MXL5007T;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = mxl5007t_GetTunerType;
+	pTuner->GetDeviceAddr = mxl5007t_GetDeviceAddr;
+
+	pTuner->Initialize    = mxl5007t_Initialize;
+	pTuner->SetRfFreqHz   = mxl5007t_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = mxl5007t_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->LoopThroughMode    = LoopThroughMode;
+	pExtra->IsBandwidthModeSet = NO;
+
+
+	// Initialize MaxLinear-defined MxL5007T structure variables.
+	// Note: The API doesn't use I2C device address of MaxLinear-defined MxL5007T structure.
+	switch(StandardMode)
+	{
+		default:
+		case MXL5007T_STANDARD_DVBT:	pTunerConfigS->Mode = MxL_MODE_DVBT;		break;
+		case MXL5007T_STANDARD_ATSC:	pTunerConfigS->Mode = MxL_MODE_ATSC;		break;
+		case MXL5007T_STANDARD_QAM:		pTunerConfigS->Mode = MxL_MODE_CABLE;		break;
+		case MXL5007T_STANDARD_ISDBT:	pTunerConfigS->Mode = MxL_MODE_ISDBT;		break;
+	}
+
+	pTunerConfigS->IF_Diff_Out_Level = (SINT32)QamIfDiffOutLevel;
+
+	switch(CrystalFreqHz)
+	{
+		default:
+		case CRYSTAL_FREQ_16000000HZ:	pTunerConfigS->Xtal_Freq = MxL_XTAL_16_MHZ;			break;
+		case CRYSTAL_FREQ_24000000HZ:	pTunerConfigS->Xtal_Freq = MxL_XTAL_24_MHZ;			break;
+		case CRYSTAL_FREQ_25000000HZ:	pTunerConfigS->Xtal_Freq = MxL_XTAL_25_MHZ;			break;
+		case CRYSTAL_FREQ_27000000HZ:	pTunerConfigS->Xtal_Freq = MxL_XTAL_27_MHZ;			break;
+		case CRYSTAL_FREQ_28800000HZ:	pTunerConfigS->Xtal_Freq = MxL_XTAL_28_8_MHZ;		break;
+	}
+
+	switch(IfFreqHz)
+	{
+		default:
+		case IF_FREQ_4570000HZ:		pTunerConfigS->IF_Freq = MxL_IF_4_57_MHZ;		break;
+		case IF_FREQ_36150000HZ:	pTunerConfigS->IF_Freq = MxL_IF_36_15_MHZ;		break;
+		case IF_FREQ_44000000HZ:	pTunerConfigS->IF_Freq = MxL_IF_44_MHZ;			break;
+	}
+
+	switch(SpectrumMode)
+	{
+		default:
+		case SPECTRUM_NORMAL:		pTunerConfigS->IF_Spectrum = MxL_NORMAL_IF;			break;
+		case SPECTRUM_INVERSE:		pTunerConfigS->IF_Spectrum = MxL_INVERT_IF;			break;
+	}
+
+	switch(ClkOutMode)
+	{
+		default:
+		case MXL5007T_CLK_OUT_DISABLE:		pTunerConfigS->ClkOut_Setting = MxL_CLKOUT_DISABLE;			break;
+		case MXL5007T_CLK_OUT_ENABLE:		pTunerConfigS->ClkOut_Setting = MxL_CLKOUT_ENABLE;			break;
+	}
+
+	switch(ClkOutAmpMode)
+	{
+		default:
+		case MXL5007T_CLK_OUT_AMP_0:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_0;		break;
+		case MXL5007T_CLK_OUT_AMP_1:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_1;		break;
+		case MXL5007T_CLK_OUT_AMP_2:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_2;		break;
+		case MXL5007T_CLK_OUT_AMP_3:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_3;		break;
+		case MXL5007T_CLK_OUT_AMP_4:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_4;		break;
+		case MXL5007T_CLK_OUT_AMP_5:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_5;		break;
+		case MXL5007T_CLK_OUT_AMP_6:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_6;		break;
+		case MXL5007T_CLK_OUT_AMP_7:		pTunerConfigS->ClkOut_Amp = MxL_CLKOUT_AMP_7;		break;
+	}
+
+	pTunerConfigS->BW_MHz = MXL5007T_BANDWIDTH_MODE_DEFAULT;
+	pTunerConfigS->RF_Freq_Hz = MXL5007T_RF_FREQ_HZ_DEFAULT;
+
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode = mxl5007t_SetBandwidthMode;
+	pExtra->GetBandwidthMode = mxl5007t_GetBandwidthMode;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+mxl5007t_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+mxl5007t_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+mxl5007t_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	MXL5007T_EXTRA_MODULE *pExtra;
+	MxL5007_TunerConfigS *pTunerConfigS;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mxl5007t);
+
+	// Get MaxLinear-defined MxL5007T structure.
+	pTunerConfigS = pExtra->pTunerConfigS;
+
+
+	// Initialize tuner.
+	if(MxL_Tuner_Init(pTunerConfigS) != MxL_OK)
+		goto error_status_initialize_tuner;
+
+	// Set tuner loop-through mode.
+	if(MxL_Loop_Through_On(pTunerConfigS, pExtra->LoopThroughMode) != MxL_OK)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+mxl5007t_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	MXL5007T_EXTRA_MODULE *pExtra;
+	MxL5007_TunerConfigS *pTunerConfigS;
+
+	UINT32 Mxl5007tRfFreqHz;
+	MxL5007_BW_MHz Mxl5007tBandwidthMhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mxl5007t);
+
+	// Get MaxLinear-defined MxL5007T structure.
+	pTunerConfigS = pExtra->pTunerConfigS;
+
+
+	// Get bandwidth.
+	Mxl5007tBandwidthMhz = pTunerConfigS->BW_MHz;
+
+	// Set RF frequency.
+	Mxl5007tRfFreqHz = (UINT32)RfFreqHz;
+
+	// Set MxL5007T RF frequency and bandwidth.
+	if(MxL_Tuner_RFTune(pTunerConfigS, Mxl5007tRfFreqHz, Mxl5007tBandwidthMhz) != MxL_OK)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+mxl5007t_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set MxL5007T tuner bandwidth mode.
+
+*/
+int
+mxl5007t_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	MXL5007T_EXTRA_MODULE *pExtra;
+	MxL5007_TunerConfigS *pTunerConfigS;
+
+	UINT32 Mxl5007tRfFreqHz;
+	MxL5007_BW_MHz Mxl5007tBandwidthMhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mxl5007t);
+
+	// Get MaxLinear-defined MxL5007T structure.
+	pTunerConfigS = pExtra->pTunerConfigS;
+
+
+	// Get RF frequency.
+	Mxl5007tRfFreqHz = pTunerConfigS->RF_Freq_Hz;
+
+	// Set bandwidth.
+	switch(BandwidthMode)
+	{
+		case MXL5007T_BANDWIDTH_6000000HZ:		Mxl5007tBandwidthMhz = MxL_BW_6MHz;		break;
+		case MXL5007T_BANDWIDTH_7000000HZ:		Mxl5007tBandwidthMhz = MxL_BW_7MHz;		break;
+		case MXL5007T_BANDWIDTH_8000000HZ:		Mxl5007tBandwidthMhz = MxL_BW_8MHz;		break;
+
+		default:	goto error_status_get_undefined_value;
+	}
+
+	// Set MxL5007T RF frequency and bandwidth.
+	if(MxL_Tuner_RFTune(pTunerConfigS, Mxl5007tRfFreqHz, Mxl5007tBandwidthMhz) != MxL_OK)
+		goto error_status_set_tuner_bandwidth;
+
+
+	// Set tuner bandwidth parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth:
+error_status_get_undefined_value:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get MxL5007T tuner bandwidth mode.
+
+*/
+int
+mxl5007t_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	MXL5007T_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Mxl5007t);
+
+
+	// Get tuner bandwidth mode from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth_mode;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by MaxLinear.
+
+
+
+
+
+// MaxLinear source code - MxL_User_Define.c
+
+
+/*
+ 
+ Driver APIs for MxL5007 Tuner
+ 
+ Copyright, Maxlinear, Inc.
+ All Rights Reserved
+ 
+ File Name:      MxL_User_Define.c
+
+ */
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//																		   //
+//					I2C Functions (implement by customer)				   //
+//																		   //
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+
+/******************************************************************************
+**
+**  Name: MxL_I2C_Write
+**
+**  Description:    I2C write operations
+**
+**  Parameters:    	
+**					DeviceAddr	- MxL5007 Device address
+**					pArray		- Write data array pointer
+**					count		- total number of array
+**
+**  Returns:        0 if success
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   12-16-2007   khuang initial release.
+**
+******************************************************************************/
+//UINT32 MxL_I2C_Write(UINT8 DeviceAddr, UINT8* pArray, UINT32 count)
+UINT32 MxL_I2C_Write(MxL5007_TunerConfigS* myTuner, UINT8* pArray, UINT32 count)
+{
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned long WritingByteNumMax;
+
+	unsigned long i;
+	unsigned char Buffer[I2C_BUFFER_LEN];
+	unsigned long WritingIndex;
+
+	unsigned char *pData;
+	unsigned long DataLen;
+
+
+
+	// Get tuner module, base interface, and I2C bridge.
+	pTuner = myTuner->pTuner;
+	pBaseInterface = pTuner->pBaseInterface;
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+	// Get writing byte and byte number.
+	pData = (unsigned char *)pArray;
+	DataLen = (unsigned long)count;
+
+	// Calculate MxL5007T maximum writing byte number.
+	// Note: MxL5007T maximum writing byte number must be a multiple of 2.
+	WritingByteNumMax = pBaseInterface->I2cWritingByteNumMax;
+	WritingByteNumMax = ((WritingByteNumMax % 2) == 0) ? WritingByteNumMax : (WritingByteNumMax - 1);
+
+
+	// Set register bytes.
+	// Note: The 2 kind of I2C formats of MxL5007T is described as follows:
+	//       1. start_bit + (device_addr | writing_bit) + (register_addr + writing_byte) * n + stop_bit
+	//          ...
+	//          start_bit + (device_addr | writing_bit) + (register_addr + writing_byte) * m + stop_bit
+	//       2. start_bit + (device_addr | writing_bit) + 0xff + stop_bit
+	for(i = 0, WritingIndex = 0; i < DataLen; i++, WritingIndex++)
+	{
+		// Put data into buffer.
+		Buffer[WritingIndex] = pData[i];
+
+		// If writing buffer is full or put data into buffer completely, send the I2C writing command with buffer.
+		if( (WritingIndex == (WritingByteNumMax - 1)) || (i == (DataLen - 1)) )
+		{
+			if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, Buffer, (WritingIndex + LEN_1_BYTE)) != FUNCTION_SUCCESS)
+				goto error_status_set_tuner_registers;
+
+			WritingIndex = -1;
+		}
+	}
+
+
+	return MxL_OK;
+
+
+error_status_set_tuner_registers:
+	return MxL_ERR_OTHERS;
+}
+
+/******************************************************************************
+**
+**  Name: MxL_I2C_Read
+**
+**  Description:    I2C read operations
+**
+**  Parameters:    	
+**					DeviceAddr	- MxL5007 Device address
+**					Addr		- register address for read
+**					*Data		- data return
+**
+**  Returns:        0 if success
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   12-16-2007   khuang initial release.
+**
+******************************************************************************/
+//UINT32 MxL_I2C_Read(UINT8 DeviceAddr, UINT8 Addr, UINT8* mData)
+UINT32 MxL_I2C_Read(MxL5007_TunerConfigS* myTuner, UINT8 Addr, UINT8* mData)
+{
+	TUNER_MODULE *pTuner;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	unsigned char Buffer[LEN_2_BYTE];
+
+
+
+	// Get tuner module and I2C bridge.
+	pTuner = myTuner->pTuner;
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+	// Set tuner register reading address.
+	// Note: The I2C format of tuner register reading address setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + 0xfb + RegReadingAddr + stop_bit
+	Buffer[0] = (unsigned char)MXL5007T_I2C_READING_CONST;
+	Buffer[1] = (unsigned char)Addr;
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, Buffer, LEN_2_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_register_reading_address;
+
+	// Get tuner register bytes.
+	// Note: The I2C format of tuner register byte getting is as follows:
+	//       start_bit + (DeviceAddr | reading_bit) + reading_byte + stop_bit
+	if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, Buffer, LEN_1_BYTE) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+	*mData = (UINT8)Buffer[0];
+
+
+	return MxL_OK;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+	return MxL_ERR_OTHERS;
+}
+
+/******************************************************************************
+**
+**  Name: MxL_Delay
+**
+**  Description:    Delay function in milli-second
+**
+**  Parameters:    	
+**					mSec		- milli-second to delay
+**
+**  Returns:        0
+**
+**  Revision History:
+**
+**   SCR      Date      Author  Description
+**  -------------------------------------------------------------------------
+**   N/A   12-16-2007   khuang initial release.
+**
+******************************************************************************/
+//void MxL_Delay(UINT32 mSec)
+void MxL_Delay(MxL5007_TunerConfigS* myTuner, UINT32 mSec)
+{
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+
+	// Get tuner module and base interface.
+	pTuner = myTuner->pTuner;
+	pBaseInterface = pTuner->pBaseInterface;
+
+	// Wait in ms.
+	pBaseInterface->WaitMs(pBaseInterface, mSec);
+
+
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// MaxLinear source code - MxL5007.c
+
+
+/*
+ MxL5007 Source Code : V4.1.3
+ 
+ Copyright, Maxlinear, Inc.
+ All Rights Reserved
+ 
+ File Name:      MxL5007.c
+
+ Description: The source code is for MxL5007 user to quickly integrate MxL5007 into their software.
+	There are two functions the user can call to generate a array of I2C command that's require to
+	program the MxL5007 tuner. The user should pass an array pointer and an integer pointer in to the 
+	function. The funciton will fill up the array with format like follow:
+	
+		addr1
+		data1
+		addr2
+		data2
+		...
+	
+	The user can then pass this array to their I2C function to perform progromming the tuner. 
+*/
+//#include "StdAfx.h"
+//#include "MxL5007_Common.h"
+//#include "MxL5007.h"
+
+
+
+UINT32 MxL5007_Init(UINT8* pArray,				// a array pointer that store the addr and data pairs for I2C write
+					UINT32* Array_Size,			// a integer pointer that store the number of element in above array
+					UINT8 Mode,				
+					SINT32 IF_Diff_Out_Level,		 
+					UINT32 Xtal_Freq_Hz,			
+					UINT32 IF_Freq_Hz,				
+					UINT8 Invert_IF,											
+					UINT8 Clk_Out_Enable,    
+					UINT8 Clk_Out_Amp													
+					)
+{
+	
+	UINT32 Reg_Index=0;
+	UINT32 Array_Index=0;
+
+	IRVType IRV_Init[]=
+	{
+		//{ Addr, Data}	
+		{ 0x02, 0x06}, 
+		{ 0x03, 0x48},
+		{ 0x05, 0x04},  
+		{ 0x06, 0x10}, 
+		{ 0x2E, 0x15},  //Override
+		{ 0x30, 0x10},  //Override
+		{ 0x45, 0x58},  //Override
+		{ 0x48, 0x19},  //Override
+		{ 0x52, 0x03},  //Override
+		{ 0x53, 0x44},  //Override
+		{ 0x6A, 0x4B},  //Override
+		{ 0x76, 0x00},  //Override
+		{ 0x78, 0x18},  //Override
+		{ 0x7A, 0x17},  //Override
+		{ 0x85, 0x06},  //Override		
+		{ 0x01, 0x01}, //TOP_MASTER_ENABLE=1
+		{ 0, 0}
+	};
+
+
+	IRVType IRV_Init_Cable[]=
+	{
+		//{ Addr, Data}	
+		{ 0x02, 0x06}, 
+		{ 0x03, 0x48},
+		{ 0x05, 0x04},  
+		{ 0x06, 0x10},  
+		{ 0x09, 0x3F},  
+		{ 0x0A, 0x3F},  
+		{ 0x0B, 0x3F},  
+		{ 0x2E, 0x15},  //Override
+		{ 0x30, 0x10},  //Override
+		{ 0x45, 0x58},  //Override
+		{ 0x48, 0x19},  //Override
+		{ 0x52, 0x03},  //Override
+		{ 0x53, 0x44},  //Override
+		{ 0x6A, 0x4B},  //Override
+		{ 0x76, 0x00},  //Override
+		{ 0x78, 0x18},  //Override
+		{ 0x7A, 0x17},  //Override
+		{ 0x85, 0x06},  //Override	
+		{ 0x01, 0x01}, //TOP_MASTER_ENABLE=1
+		{ 0, 0}
+	};
+	//edit Init setting here
+
+	PIRVType myIRV=IRV_Init;
+
+	switch(Mode)
+	{
+	case MxL_MODE_ISDBT: //ISDB-T Mode	
+		myIRV = IRV_Init;
+		SetIRVBit(myIRV, 0x06, 0x1F, 0x10);  
+		break;
+	case MxL_MODE_DVBT: //DVBT Mode			
+		myIRV = IRV_Init;
+		SetIRVBit(myIRV, 0x06, 0x1F, 0x11);  
+		break;
+	case MxL_MODE_ATSC: //ATSC Mode			
+		myIRV = IRV_Init;
+		SetIRVBit(myIRV, 0x06, 0x1F, 0x12);  
+		break;	
+	case MxL_MODE_CABLE:						
+		myIRV = IRV_Init_Cable;
+		SetIRVBit(myIRV, 0x09, 0xFF, 0xC1);	
+		SetIRVBit(myIRV, 0x0A, 0xFF, 8-IF_Diff_Out_Level);	
+		SetIRVBit(myIRV, 0x0B, 0xFF, 0x17);							
+		break;
+	
+
+	}
+
+	switch(IF_Freq_Hz)
+	{
+	case MxL_IF_4_MHZ:
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x00); 		
+		break;
+	case MxL_IF_4_5_MHZ: //4.5MHz
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x02); 		
+		break;
+	case MxL_IF_4_57_MHZ: //4.57MHz
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x03); 
+		break;
+	case MxL_IF_5_MHZ:
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x04); 
+		break;
+	case MxL_IF_5_38_MHZ: //5.38MHz
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x05); 
+		break;
+	case MxL_IF_6_MHZ: 
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x06); 
+		break;
+	case MxL_IF_6_28_MHZ: //6.28MHz
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x07); 
+		break;
+	case MxL_IF_9_1915_MHZ: //9.1915MHz
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x08); 
+		break;
+	case MxL_IF_35_25_MHZ:
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x09); 
+		break;
+	case MxL_IF_36_15_MHZ:
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x0a); 
+		break;
+	case MxL_IF_44_MHZ:
+		SetIRVBit(myIRV, 0x02, 0x0F, 0x0B); 
+		break;
+	}
+
+	if(Invert_IF) 
+		SetIRVBit(myIRV, 0x02, 0x10, 0x10);   //Invert IF
+	else
+		SetIRVBit(myIRV, 0x02, 0x10, 0x00);   //Normal IF
+
+
+	switch(Xtal_Freq_Hz)
+	{
+	case MxL_XTAL_16_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x00);  //select xtal freq & Ref Freq
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x00);
+		break;
+	case MxL_XTAL_20_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x10);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x01);
+		break;
+	case MxL_XTAL_20_25_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x20);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x02);
+		break;
+	case MxL_XTAL_20_48_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x30);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x03);
+		break;
+	case MxL_XTAL_24_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x40);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x04);
+		break;
+	case MxL_XTAL_25_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x50);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x05);
+		break;
+	case MxL_XTAL_25_14_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x60);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x06);
+		break;
+	case MxL_XTAL_27_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x70);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x07);
+		break;
+	case MxL_XTAL_28_8_MHZ: 
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x80);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x08);
+		break;
+	case MxL_XTAL_32_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0x90);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x09);
+		break;
+	case MxL_XTAL_40_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0xA0);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x0A);
+		break;
+	case MxL_XTAL_44_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0xB0);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x0B);
+		break;
+	case MxL_XTAL_48_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0xC0);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x0C);
+		break;
+	case MxL_XTAL_49_3811_MHZ:
+		SetIRVBit(myIRV, 0x03, 0xF0, 0xD0);
+		SetIRVBit(myIRV, 0x05, 0x0F, 0x0D);
+		break;	
+	}
+
+	if(!Clk_Out_Enable) //default is enable 
+		SetIRVBit(myIRV, 0x03, 0x08, 0x00);   
+
+	//Clk_Out_Amp
+	SetIRVBit(myIRV, 0x03, 0x07, Clk_Out_Amp);   
+
+	//Generate one Array that Contain Data, Address
+	while (myIRV[Reg_Index].Num || myIRV[Reg_Index].Val)
+	{
+		pArray[Array_Index++] = myIRV[Reg_Index].Num;
+		pArray[Array_Index++] = myIRV[Reg_Index].Val;
+		Reg_Index++;
+	}
+	    
+	*Array_Size=Array_Index;
+	return 0;
+}
+
+
+UINT32 MxL5007_RFTune(UINT8* pArray, UINT32* Array_Size, UINT32 RF_Freq, UINT8 BWMHz)
+{
+	IRVType IRV_RFTune[]=
+	{
+	//{ Addr, Data}
+		{ 0x0F, 0x00},  //abort tune
+		{ 0x0C, 0x15},
+		{ 0x0D, 0x40},
+		{ 0x0E, 0x0E},	
+		{ 0x1F, 0x87},  //Override
+		{ 0x20, 0x1F},  //Override
+		{ 0x21, 0x87},  //Override
+		{ 0x22, 0x1F},  //Override		
+		{ 0x80, 0x01},  //Freq Dependent Setting
+		{ 0x0F, 0x01},	//start tune
+		{ 0, 0}
+	};
+
+	UINT32 dig_rf_freq=0;
+	UINT32 temp;
+	UINT32 Reg_Index=0;
+	UINT32 Array_Index=0;
+	UINT32 i;
+	UINT32 frac_divider = 1000000;
+
+	switch(BWMHz)
+	{
+	case MxL_BW_6MHz: //6MHz
+			SetIRVBit(IRV_RFTune, 0x0C, 0x3F, 0x15);  //set DIG_MODEINDEX, DIG_MODEINDEX_A, and DIG_MODEINDEX_CSF
+		break;
+	case MxL_BW_7MHz: //7MHz
+			SetIRVBit(IRV_RFTune, 0x0C, 0x3F, 0x2A);
+		break;
+	case MxL_BW_8MHz: //8MHz
+			SetIRVBit(IRV_RFTune, 0x0C, 0x3F, 0x3F);
+		break;
+	}
+
+
+	//Convert RF frequency into 16 bits => 10 bit integer (MHz) + 6 bit fraction
+	dig_rf_freq = RF_Freq / MHz;
+	temp = RF_Freq % MHz;
+	for(i=0; i<6; i++)
+	{
+		dig_rf_freq <<= 1;
+		frac_divider /=2;
+		if(temp > frac_divider)
+		{
+			temp -= frac_divider;
+			dig_rf_freq++;
+		}
+	}
+
+	//add to have shift center point by 7.8124 kHz
+	if(temp > 7812)
+		dig_rf_freq ++;
+    	
+	SetIRVBit(IRV_RFTune, 0x0D, 0xFF, (UINT8)dig_rf_freq);
+	SetIRVBit(IRV_RFTune, 0x0E, 0xFF, (UINT8)(dig_rf_freq>>8));
+
+	if (RF_Freq >=333*MHz)
+		SetIRVBit(IRV_RFTune, 0x80, 0x40, 0x40);
+
+	//Generate one Array that Contain Data, Address 
+	while (IRV_RFTune[Reg_Index].Num || IRV_RFTune[Reg_Index].Val)
+	{
+		pArray[Array_Index++] = IRV_RFTune[Reg_Index].Num;
+		pArray[Array_Index++] = IRV_RFTune[Reg_Index].Val;
+		Reg_Index++;
+	}
+    
+	*Array_Size=Array_Index;
+	
+	return 0;
+}
+
+//local functions called by Init and RFTune
+UINT32 SetIRVBit(PIRVType pIRV, UINT8 Num, UINT8 Mask, UINT8 Val)
+{
+	while (pIRV->Num || pIRV->Val)
+	{
+		if (pIRV->Num==Num)
+		{
+			pIRV->Val&=~Mask;
+			pIRV->Val|=Val;
+		}
+		pIRV++;
+
+	}	
+	return 0;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// MaxLinear source code - MxL5007_API.h
+
+
+/*
+
+ Driver APIs for MxL5007 Tuner
+ 
+ Copyright, Maxlinear, Inc.
+ All Rights Reserved
+ 
+ File Name:      MxL5007_API.c
+ 
+ Version:    4.1.3
+*/
+
+
+//#include "StdAfx.h"
+//#include "MxL5007_API.h"
+//#include "MxL_User_Define.c"
+//#include "MxL5007.c"
+
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//																		   //
+//							Tuner Functions								   //
+//																		   //
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
+MxL_ERR_MSG MxL_Set_Register(MxL5007_TunerConfigS* myTuner, UINT8 RegAddr, UINT8 RegData)
+{
+	UINT32 Status=0;
+	UINT8 pArray[2];
+	pArray[0] = RegAddr;
+	pArray[1] = RegData;
+//	Status = MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, 2);
+	Status = MxL_I2C_Write(myTuner, pArray, 2);
+	if(Status) return MxL_ERR_SET_REG;
+
+	return MxL_OK;
+
+}
+
+MxL_ERR_MSG MxL_Get_Register(MxL5007_TunerConfigS* myTuner, UINT8 RegAddr, UINT8 *RegData)
+{
+//	if(MxL_I2C_Read((UINT8)myTuner->I2C_Addr, RegAddr, RegData))
+	if(MxL_I2C_Read(myTuner, RegAddr, RegData))
+		return MxL_ERR_GET_REG;
+	return MxL_OK;
+
+}
+
+MxL_ERR_MSG MxL_Soft_Reset(MxL5007_TunerConfigS* myTuner)
+{
+/*	UINT32 Status=0;	*/
+	UINT8 reg_reset=0;
+	reg_reset = 0xFF;
+/*	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, &reg_reset, 1))*/
+	if(MxL_I2C_Write(myTuner, &reg_reset, 1))
+		return MxL_ERR_OTHERS;
+
+	return MxL_OK;
+}
+
+MxL_ERR_MSG MxL_Loop_Through_On(MxL5007_TunerConfigS* myTuner, MxL5007_LoopThru isOn)
+{	
+	UINT8 pArray[2];	// a array pointer that store the addr and data pairs for I2C write	
+	
+	pArray[0]=0x04;
+	if(isOn)
+	 pArray[1]= 0x01;
+	else
+	 pArray[1]= 0x0;
+
+//	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, 2))
+	if(MxL_I2C_Write(myTuner, pArray, 2))
+		return MxL_ERR_OTHERS;
+
+	return MxL_OK;
+}
+
+MxL_ERR_MSG MxL_Stand_By(MxL5007_TunerConfigS* myTuner)
+{
+	UINT8 pArray[4];	// a array pointer that store the addr and data pairs for I2C write	
+	
+	pArray[0] = 0x01;
+	pArray[1] = 0x0;
+	pArray[2] = 0x0F;
+	pArray[3] = 0x0;
+
+//	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, 4))
+	if(MxL_I2C_Write(myTuner, pArray, 4))
+		return MxL_ERR_OTHERS;
+
+	return MxL_OK;
+}
+
+MxL_ERR_MSG MxL_Wake_Up(MxL5007_TunerConfigS* myTuner)
+{
+	UINT8 pArray[2];	// a array pointer that store the addr and data pairs for I2C write	
+	
+	pArray[0] = 0x01;
+	pArray[1] = 0x01;
+
+//	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, 2))
+	if(MxL_I2C_Write(myTuner, pArray, 2))
+		return MxL_ERR_OTHERS;
+
+	if(MxL_Tuner_RFTune(myTuner, myTuner->RF_Freq_Hz, myTuner->BW_MHz))
+		return MxL_ERR_RFTUNE;
+
+	return MxL_OK;
+}
+
+MxL_ERR_MSG MxL_Tuner_Init(MxL5007_TunerConfigS* myTuner)
+{	
+	UINT8 pArray[MAX_ARRAY_SIZE];	// a array pointer that store the addr and data pairs for I2C write
+	UINT32 Array_Size;							// a integer pointer that store the number of element in above array
+
+	//Soft reset tuner
+	if(MxL_Soft_Reset(myTuner))
+		return MxL_ERR_INIT;
+
+	//perform initialization calculation
+	MxL5007_Init(pArray, &Array_Size, (UINT8)myTuner->Mode, myTuner->IF_Diff_Out_Level, (UINT32)myTuner->Xtal_Freq, 
+				(UINT32)myTuner->IF_Freq, (UINT8)myTuner->IF_Spectrum, (UINT8)myTuner->ClkOut_Setting, (UINT8)myTuner->ClkOut_Amp);
+
+	//perform I2C write here
+//	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, Array_Size))
+	if(MxL_I2C_Write(myTuner, pArray, Array_Size))
+		return MxL_ERR_INIT;
+
+	return MxL_OK;
+}
+
+
+MxL_ERR_MSG MxL_Tuner_RFTune(MxL5007_TunerConfigS* myTuner, UINT32 RF_Freq_Hz, MxL5007_BW_MHz BWMHz)
+{
+	//UINT32 Status=0;
+	UINT8 pArray[MAX_ARRAY_SIZE];	// a array pointer that store the addr and data pairs for I2C write
+	UINT32 Array_Size;							// a integer pointer that store the number of element in above array
+
+	//Store information into struc
+	myTuner->RF_Freq_Hz = RF_Freq_Hz;
+	myTuner->BW_MHz = BWMHz;
+
+	//perform Channel Change calculation
+	MxL5007_RFTune(pArray,&Array_Size,RF_Freq_Hz,BWMHz);
+
+	//perform I2C write here
+//	if(MxL_I2C_Write((UINT8)myTuner->I2C_Addr, pArray, Array_Size))
+	if(MxL_I2C_Write(myTuner, pArray, Array_Size))
+		return MxL_ERR_RFTUNE;
+
+	//wait for 3ms
+//	MxL_Delay(3); 
+	MxL_Delay(myTuner, 3); 
+
+	return MxL_OK;
+}
+
+MxL5007_ChipVersion MxL_Check_ChipVersion(MxL5007_TunerConfigS* myTuner)
+{	
+	UINT8 Data;
+//	if(MxL_I2C_Read((UINT8)myTuner->I2C_Addr, 0xD9, &Data))
+	if(MxL_I2C_Read(myTuner, 0xD9, &Data))
+		return MxL_GET_ID_FAIL;
+		
+	switch(Data)
+	{
+	case 0x14: return MxL_5007T_V4; break;
+	default: return MxL_UNKNOWN_ID;
+	}	
+}
+
+MxL_ERR_MSG MxL_RFSynth_Lock_Status(MxL5007_TunerConfigS* myTuner, BOOL* isLock)
+{	
+	UINT8 Data;
+	*isLock = MxL_FALSE; 
+//	if(MxL_I2C_Read((UINT8)myTuner->I2C_Addr, 0xD8, &Data))
+	if(MxL_I2C_Read(myTuner, 0xD8, &Data))
+		return MxL_ERR_OTHERS;
+	Data &= 0x0C;
+	if (Data == 0x0C)
+		*isLock = MxL_TRUE;  //RF Synthesizer is Lock	
+	return MxL_OK;
+}
+
+MxL_ERR_MSG MxL_REFSynth_Lock_Status(MxL5007_TunerConfigS* myTuner, BOOL* isLock)
+{
+	UINT8 Data;
+	*isLock = MxL_FALSE; 
+//	if(MxL_I2C_Read((UINT8)myTuner->I2C_Addr, 0xD8, &Data))
+	if(MxL_I2C_Read(myTuner, 0xD8, &Data))
+		return MxL_ERR_OTHERS;
+	Data &= 0x03;
+	if (Data == 0x03)
+		*isLock = MxL_TRUE;   //REF Synthesizer is Lock
+	return MxL_OK;
+}
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_mxl5007t.h b/drivers/media/usb/rtl2832u/tuner_mxl5007t.h
new file mode 100644
index 00000000..18eac8a4
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_mxl5007t.h
@@ -0,0 +1,784 @@
+#ifndef __TUNER_MXL5007T_H
+#define __TUNER_MXL5007T_H
+
+/**
+
+@file
+
+@brief   MxL5007T tuner module declaration
+
+One can manipulate MxL5007T tuner through MxL5007T module.
+MxL5007T module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_mxl5007t.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE        *pTuner;
+	MXL5007T_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	unsigned long BandwidthMode;
+
+
+	...
+
+
+
+	// Build MxL5007T tuner module.
+	BuildMxl5007tModule(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0,								// I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,			// Crystal frequency is 16.0 MHz.
+		MXL5007T_STANDARD_DVBT,				// The MxL5007T standard mode is DVB-T.
+		IF_FREQ_4570000HZ,					// The MxL5007T IF frequency is 4.57 MHz.
+		SPECTRUM_NORMAL,					// The MxL5007T spectrum mode is normal.
+		MXL5007T_LOOP_THROUGH_DISABLE,		// The MxL5007T loop-through mode is disabled.
+		MXL5007T_CLK_OUT_DISABLE,			// The MxL5007T clock output mode is disabled.
+		MXL5007T_CLK_OUT_AMP_0,				// The MxL5007T clock output amplitude is 0.
+		0									// The MxL5007T QAM IF differential output level is 0 for cable only.
+		);
+
+
+
+
+
+	// Get MxL5007T tuner extra module.
+	pTunerExtra = (T2266_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set MXL5007T bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, MXL5007T_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get MXL5007T bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// The following context is source code provided by MaxLinear.
+
+
+
+
+
+// MaxLinear source code - MxL5007_Common.h
+
+
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL_Common.h
+ * 
+ * AUTHOR             : Kyle Huang
+ * DATE CREATED       : May 05, 2008
+ *
+ * DESCRIPTION        : 
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+ 
+//#ifndef __MXL5007_COMMON_H
+//#define __MXL5007_COMMON_H
+
+
+
+/******************************************************************************
+*						User-Defined Types (Typedefs)
+******************************************************************************/
+
+
+/****************************************************************************
+*       Imports and definitions for WIN32                             
+****************************************************************************/
+//#include <windows.h>
+typedef unsigned char  UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int   UINT32;
+typedef char           SINT8;
+typedef short          SINT16;
+typedef int            SINT32;
+//typedef float          REAL32;
+
+// Additional definition
+#define BOOL		int
+#define MxL_FALSE	0
+#define MxL_TRUE	1
+
+/****************************************************************************\
+*      Imports and definitions for non WIN32 platforms                   *
+\****************************************************************************/
+/*
+typedef unsigned char  UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int   UINT32;
+typedef char           SINT8;
+typedef short          SINT16;
+typedef int            SINT32;
+typedef float          REAL32;
+
+// create a boolean 
+#ifndef __boolean__
+#define __boolean__
+typedef enum {FALSE=0,TRUE} BOOL;
+#endif //boolean
+*/
+
+
+/****************************************************************************\
+*          Definitions for all platforms					                 *
+\****************************************************************************/
+#ifndef NULL
+#define NULL (void*)0
+#endif
+
+
+
+/******************************/
+/*	MxL5007 Err message  	  */
+/******************************/
+typedef enum{
+	MxL_OK				=   0,
+	MxL_ERR_INIT		=   1,
+	MxL_ERR_RFTUNE		=   2,
+	MxL_ERR_SET_REG		=   3,
+	MxL_ERR_GET_REG		=	4,
+	MxL_ERR_OTHERS		=   10
+}MxL_ERR_MSG;
+
+/******************************/
+/*	MxL5007 Chip verstion     */
+/******************************/
+typedef enum{
+	MxL_UNKNOWN_ID		= 0x00,
+	MxL_5007T_V4		= 0x14,
+	MxL_GET_ID_FAIL		= 0xFF
+}MxL5007_ChipVersion;
+
+
+/******************************************************************************
+    CONSTANTS
+******************************************************************************/
+
+#ifndef MHz
+	#define MHz 1000000
+#endif
+
+#define MAX_ARRAY_SIZE 100
+
+
+// Enumeration of Mode
+// Enumeration of Mode
+typedef enum 
+{
+	MxL_MODE_ISDBT = 0,
+	MxL_MODE_DVBT = 1,
+	MxL_MODE_ATSC = 2,	
+	MxL_MODE_CABLE = 0x10
+} MxL5007_Mode ;
+
+typedef enum
+{
+	MxL_IF_4_MHZ	  = 4000000,
+	MxL_IF_4_5_MHZ	  = 4500000,
+	MxL_IF_4_57_MHZ	  =	4570000,
+	MxL_IF_5_MHZ	  =	5000000,
+	MxL_IF_5_38_MHZ	  =	5380000,
+	MxL_IF_6_MHZ	  =	6000000,
+	MxL_IF_6_28_MHZ	  =	6280000,
+	MxL_IF_9_1915_MHZ =	9191500,
+	MxL_IF_35_25_MHZ  = 35250000,
+	MxL_IF_36_15_MHZ  = 36150000,
+	MxL_IF_44_MHZ	  = 44000000
+} MxL5007_IF_Freq ;
+
+typedef enum
+{
+	MxL_XTAL_16_MHZ		= 16000000,
+	MxL_XTAL_20_MHZ		= 20000000,
+	MxL_XTAL_20_25_MHZ	= 20250000,
+	MxL_XTAL_20_48_MHZ	= 20480000,
+	MxL_XTAL_24_MHZ		= 24000000,
+	MxL_XTAL_25_MHZ		= 25000000,
+	MxL_XTAL_25_14_MHZ	= 25140000,
+	MxL_XTAL_27_MHZ		= 27000000,
+	MxL_XTAL_28_8_MHZ	= 28800000,
+	MxL_XTAL_32_MHZ		= 32000000,
+	MxL_XTAL_40_MHZ		= 40000000,
+	MxL_XTAL_44_MHZ		= 44000000,
+	MxL_XTAL_48_MHZ		= 48000000,
+	MxL_XTAL_49_3811_MHZ = 49381100	
+} MxL5007_Xtal_Freq ;
+
+typedef enum
+{
+	MxL_BW_6MHz = 6,
+	MxL_BW_7MHz = 7,
+	MxL_BW_8MHz = 8
+} MxL5007_BW_MHz;
+
+typedef enum
+{
+	MxL_NORMAL_IF = 0 ,
+	MxL_INVERT_IF
+
+} MxL5007_IF_Spectrum ;
+
+typedef enum
+{
+	MxL_LT_DISABLE = 0 ,
+	MxL_LT_ENABLE
+
+} MxL5007_LoopThru ;
+
+typedef enum
+{
+	MxL_CLKOUT_DISABLE = 0 ,
+	MxL_CLKOUT_ENABLE
+
+} MxL5007_ClkOut;
+
+typedef enum
+{
+	MxL_CLKOUT_AMP_0 = 0 ,
+	MxL_CLKOUT_AMP_1,
+	MxL_CLKOUT_AMP_2,
+	MxL_CLKOUT_AMP_3,
+	MxL_CLKOUT_AMP_4,
+	MxL_CLKOUT_AMP_5,
+	MxL_CLKOUT_AMP_6,
+	MxL_CLKOUT_AMP_7
+} MxL5007_ClkOut_Amp;
+
+typedef enum
+{
+	MxL_I2C_ADDR_96 = 96 ,
+	MxL_I2C_ADDR_97 = 97 ,
+	MxL_I2C_ADDR_98 = 98 ,
+	MxL_I2C_ADDR_99 = 99 	
+} MxL5007_I2CAddr ;
+/*
+//
+// MxL5007 TunerConfig Struct
+//
+typedef struct _MxL5007_TunerConfigS
+{
+	MxL5007_I2CAddr		I2C_Addr;
+	MxL5007_Mode		Mode;
+	SINT32				IF_Diff_Out_Level;
+	MxL5007_Xtal_Freq	Xtal_Freq;
+	MxL5007_IF_Freq	    IF_Freq;
+	MxL5007_IF_Spectrum IF_Spectrum;
+	MxL5007_ClkOut		ClkOut_Setting;
+    MxL5007_ClkOut_Amp	ClkOut_Amp;
+	MxL5007_BW_MHz		BW_MHz;
+	UINT32				RF_Freq_Hz;
+
+	// Additional definition
+	TUNER_MODULE *pTuner;
+
+} MxL5007_TunerConfigS;
+*/
+
+
+
+//#endif /* __MXL5007_COMMON_H__*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// MaxLinear source code - MxL5007.h
+
+
+
+/*
+ 
+ Driver APIs for MxL5007 Tuner
+ 
+ Copyright, Maxlinear, Inc.
+ All Rights Reserved
+ 
+ File Name:      MxL5007.h
+
+ */
+
+
+//#include "MxL5007_Common.h"
+
+
+typedef struct
+{
+	UINT8 Num;	//Register number
+	UINT8 Val;	//Register value
+} IRVType, *PIRVType;
+
+
+UINT32 MxL5007_Init(UINT8* pArray,				// a array pointer that store the addr and data pairs for I2C write
+					UINT32* Array_Size,			// a integer pointer that store the number of element in above array
+					UINT8 Mode,				
+					SINT32 IF_Diff_Out_Level,
+					UINT32 Xtal_Freq_Hz,		
+					UINT32 IF_Freq_Hz,		
+					UINT8 Invert_IF,			
+					UINT8 Clk_Out_Enable,    
+					UINT8 Clk_Out_Amp		
+					);
+UINT32 MxL5007_RFTune(UINT8* pArray, UINT32* Array_Size, 
+					 UINT32 RF_Freq,			// RF Frequency in Hz
+					 UINT8 BWMHz		// Bandwidth in MHz
+					 );
+UINT32 SetIRVBit(PIRVType pIRV, UINT8 Num, UINT8 Mask, UINT8 Val);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// MaxLinear source code - MxL5007.h
+
+
+
+/*
+ 
+ Driver APIs for MxL5007 Tuner
+ 
+ Copyright, Maxlinear, Inc.
+ All Rights Reserved
+ 
+ File Name:      MxL5007_API.h
+ 
+ */
+//#ifndef __MxL5007_API_H
+//#define __MxL5007_API_H
+
+//#include "MxL5007_Common.h"
+
+/******************************************************************************
+**
+**  Name: MxL_Set_Register
+**
+**  Description:    Write one register to MxL5007
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					RegAddr				- Register address to be written
+**					RegData				- Data to be written
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_SET_REG if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Set_Register(MxL5007_TunerConfigS* myTuner, UINT8 RegAddr, UINT8 RegData);
+
+/******************************************************************************
+**
+**  Name: MxL_Get_Register
+**
+**  Description:    Read one register from MxL5007
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					RegAddr				- Register address to be read
+**					RegData				- Pointer to register read
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_GET_REG if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Get_Register(MxL5007_TunerConfigS* myTuner, UINT8 RegAddr, UINT8 *RegData);
+
+/******************************************************************************
+**
+**  Name: MxL_Tuner_Init
+**
+**  Description:    MxL5007 Initialization
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_INIT if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Tuner_Init(MxL5007_TunerConfigS* );
+
+/******************************************************************************
+**
+**  Name: MxL_Tuner_RFTune
+**
+**  Description:    Frequency tunning for channel
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					RF_Freq_Hz			- RF Frequency in Hz
+**					BWMHz				- Bandwidth 6, 7 or 8 MHz
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_RFTUNE if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Tuner_RFTune(MxL5007_TunerConfigS*, UINT32 RF_Freq_Hz, MxL5007_BW_MHz BWMHz);		
+
+/******************************************************************************
+**
+**  Name: MxL_Soft_Reset
+**
+**  Description:    Software Reset the MxL5007 Tuner
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Soft_Reset(MxL5007_TunerConfigS*);
+
+/******************************************************************************
+**
+**  Name: MxL_Loop_Through_On
+**
+**  Description:    Turn On/Off on-chip Loop-through
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					isOn				- True to turn On Loop Through
+**										- False to turn off Loop Through
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Loop_Through_On(MxL5007_TunerConfigS*, MxL5007_LoopThru);
+
+/******************************************************************************
+**
+**  Name: MxL_Standby
+**
+**  Description:    Enter Standby Mode
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Stand_By(MxL5007_TunerConfigS*);
+
+/******************************************************************************
+**
+**  Name: MxL_Wakeup
+**
+**  Description:    Wakeup from Standby Mode (Note: after wake up, please call RF_Tune again)
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_Wake_Up(MxL5007_TunerConfigS*);
+
+/******************************************************************************
+**
+**  Name: MxL_Check_ChipVersion
+**
+**  Description:    Return the MxL5007 Chip ID
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**			
+**  Returns:        MxL_ChipVersion			
+**
+******************************************************************************/
+MxL5007_ChipVersion MxL_Check_ChipVersion(MxL5007_TunerConfigS*);
+
+/******************************************************************************
+**
+**  Name: MxL_RFSynth_Lock_Status
+**
+**  Description:    RF synthesizer lock status of MxL5007
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					isLock				- Pointer to Lock Status
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_RFSynth_Lock_Status(MxL5007_TunerConfigS* , BOOL* isLock);
+
+/******************************************************************************
+**
+**  Name: MxL_REFSynth_Lock_Status
+**
+**  Description:    REF synthesizer lock status of MxL5007
+**
+**  Parameters:    	myTuner				- Pointer to MxL5007_TunerConfigS
+**					isLock				- Pointer to Lock Status
+**
+**  Returns:        MxL_ERR_MSG			- MxL_OK if success	
+**										- MxL_ERR_OTHERS if fail	
+**
+******************************************************************************/
+MxL_ERR_MSG MxL_REFSynth_Lock_Status(MxL5007_TunerConfigS* , BOOL* isLock);
+
+//#endif //__MxL5007_API_H
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is MxL5007T tuner API source code
+
+
+
+
+
+// Definitions
+
+// Standard mode
+enum MXL5007T_STANDARD_MODE
+{
+	MXL5007T_STANDARD_DVBT,
+	MXL5007T_STANDARD_ATSC,
+	MXL5007T_STANDARD_QAM,
+	MXL5007T_STANDARD_ISDBT,
+};
+
+
+// Loop-through mode
+enum MXL5007T_LOOP_THROUGH_MODE
+{
+	MXL5007T_LOOP_THROUGH_DISABLE = MxL_LT_DISABLE,
+	MXL5007T_LOOP_THROUGH_ENABLE  = MxL_LT_ENABLE,
+};
+
+
+// Clock output mode
+enum MXL5007T_CLK_OUT_MODE
+{
+	MXL5007T_CLK_OUT_DISABLE,
+	MXL5007T_CLK_OUT_ENABLE,
+};
+
+
+// Clock output amplitude mode
+enum MXL5007T_CLK_OUT_AMP_MODE
+{
+	MXL5007T_CLK_OUT_AMP_0,
+	MXL5007T_CLK_OUT_AMP_1,
+	MXL5007T_CLK_OUT_AMP_2,
+	MXL5007T_CLK_OUT_AMP_3,
+	MXL5007T_CLK_OUT_AMP_4,
+	MXL5007T_CLK_OUT_AMP_5,
+	MXL5007T_CLK_OUT_AMP_6,
+	MXL5007T_CLK_OUT_AMP_7,
+};
+
+
+// Bandwidth mode
+enum MXL5007T_BANDWIDTH_MODE
+{
+	MXL5007T_BANDWIDTH_6000000HZ,
+	MXL5007T_BANDWIDTH_7000000HZ,
+	MXL5007T_BANDWIDTH_8000000HZ,
+};
+
+
+
+// Constant
+#define MXL5007T_I2C_READING_CONST		0xfb
+
+// Default value
+#define MXL5007T_RF_FREQ_HZ_DEFAULT			44000000;
+#define MXL5007T_BANDWIDTH_MODE_DEFAULT		MxL_BW_6MHz;
+
+
+
+
+
+// Builder
+void
+BuildMxl5007tModule(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int StandardMode,
+	unsigned long IfFreqHz,
+	int SpectrumMode,
+	int LoopThroughMode,
+	int ClkOutMode,
+	int ClkOutAmpMode,
+	long QamIfDiffOutLevel
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+mxl5007t_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+mxl5007t_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+mxl5007t_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+mxl5007t_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+mxl5007t_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+mxl5007t_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+mxl5007t_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_tda18272.c b/drivers/media/usb/rtl2832u/tuner_tda18272.c
new file mode 100644
index 00000000..0f71f35e
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_tda18272.c
@@ -0,0 +1,21631 @@
+/**
+
+@file
+
+@brief   TDA18272 tuner module definition
+
+One can manipulate TDA18272 tuner through TDA18272 module.
+TDA18272 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_tda18272.h"
+
+
+
+
+
+/**
+
+@brief   TDA18272 tuner module builder
+
+Use BuildTda18272Module() to build TDA18272 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to TDA18272 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   TDA18272 I2C device address
+@param [in]   CrystalFreqHz                TDA18272 crystal frequency in Hz
+@param [in]   UnitNo                       TDA18272 unit number
+@param [in]   IfOutputVppMode              TDA18272 IF output Vp-p mode
+
+
+@note
+	-# One should call BuildTda18272Module() to build TDA18272 module before using it.
+
+*/
+void
+BuildTda18272Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int UnitNo,
+	int IfOutputVppMode
+	)
+{
+	TUNER_MODULE *pTuner;
+	TDA18272_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_TDA18272;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = tda18272_GetTunerType;
+	pTuner->GetDeviceAddr = tda18272_GetDeviceAddr;
+
+	pTuner->Initialize  = tda18272_Initialize;
+	pTuner->SetRfFreqHz = tda18272_SetRfFreqHz;
+	pTuner->GetRfFreqHz = tda18272_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	pExtra->CrystalFreqHz              = CrystalFreqHz;
+	pExtra->UnitNo                     = UnitNo;
+	pExtra->IfOutputVppMode            = IfOutputVppMode;
+	pExtra->IsStandardBandwidthModeSet = NO;
+	pExtra->IsPowerModeSet             = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->SetStandardBandwidthMode = tda18272_SetStandardBandwidthMode;
+	pExtra->GetStandardBandwidthMode = tda18272_GetStandardBandwidthMode;
+	pExtra->SetPowerMode             = tda18272_SetPowerMode;
+	pExtra->GetPowerMode             = tda18272_GetPowerMode;
+	pExtra->GetIfFreqHz              = tda18272_GetIfFreqHz;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+tda18272_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+tda18272_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+tda18272_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+
+	int UnitNo;
+	tmbslFrontEndDependency_t  sSrvTunerFunc;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+	// Get unit number.
+	UnitNo = pExtra->UnitNo;
+
+
+	// Set user-defined function to tuner structure.
+	sSrvTunerFunc.sIo.Write             = tda18272_Write;
+	sSrvTunerFunc.sIo.Read              = tda18272_Read;
+	sSrvTunerFunc.sTime.Get             = Null;
+	sSrvTunerFunc.sTime.Wait            = tda18272_Wait;
+	sSrvTunerFunc.sDebug.Print          = Null;
+	sSrvTunerFunc.sMutex.Init           = Null;
+	sSrvTunerFunc.sMutex.DeInit         = Null;
+	sSrvTunerFunc.sMutex.Acquire        = Null;
+	sSrvTunerFunc.sMutex.Release        = Null;
+	sSrvTunerFunc.dwAdditionalDataSize  = 0;
+	sSrvTunerFunc.pAdditionalData       = Null;
+
+	// De-initialize tuner.
+	// Note: 1. tmbslTDA182I2DeInit() doesn't access hardware.
+	//       2. Doesn't need to check tmbslTDA182I2DeInit() return, because we will get error return when the module is
+	//          un-initialized.
+	tmbslTDA182I2DeInit(UnitNo);
+
+	// Initialize tuner.
+	// Note: tmbslTDA182I2Init() doesn't access hardware.
+	if(tmbslTDA182I2Init(UnitNo, &sSrvTunerFunc, pTuner) != TM_OK)
+		goto error_status_initialize_tuner;
+
+	// Reset tuner.
+	if(tmbslTDA182I2Reset(UnitNo) != TM_OK)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+tda18272_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	TDA18272_EXTRA_MODULE     *pExtra;
+	tmUnitSelect_t            UnitNo;
+	tmTDA182I2IF_AGC_Gain_t   IfOutputVppMode;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+	// Get unit number.
+	UnitNo = (tmUnitSelect_t)pExtra->UnitNo;
+
+	// Get IF output Vp-p mode.
+	IfOutputVppMode = (tmTDA182I2IF_AGC_Gain_t)pExtra->IfOutputVppMode;
+
+
+	// Set tuner RF frequency.
+	if(tmbslTDA182I2SetRf(UnitNo, RfFreqHz, IfOutputVppMode) != TM_OK)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = RfFreqHz;
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+tda18272_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set TDA18272 tuner standard and bandwidth mode.
+
+*/
+int
+tda18272_SetStandardBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int StandardBandwidthMode
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+	int UnitNo;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+	// Get unit number.
+	UnitNo = pExtra->UnitNo;
+
+
+	// Set tuner standard and bandwidth mode.
+	if(tmbslTDA182I2SetStandardMode(UnitNo, StandardBandwidthMode) != TM_OK)
+		goto error_status_set_tuner_standard_bandwidth_mode;
+
+
+	// Set tuner bandwidth mode parameter.
+	pExtra->StandardBandwidthMode      = StandardBandwidthMode;
+	pExtra->IsStandardBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_standard_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get TDA18272 tuner standard and bandwidth mode.
+
+*/
+int
+tda18272_GetStandardBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pStandardBandwidthMode
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+
+	// Get tuner bandwidth mode from tuner module.
+	if(pExtra->IsStandardBandwidthModeSet != YES)
+		goto error_status_get_tuner_standard_bandwidth_mode;
+
+	*pStandardBandwidthMode = pExtra->StandardBandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_standard_bandwidth_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set TDA18272 tuner power mode.
+
+*/
+int
+tda18272_SetPowerMode(
+	TUNER_MODULE *pTuner,
+	int PowerMode
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+	int UnitNo;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+	// Get unit number.
+	UnitNo = pExtra->UnitNo;
+
+
+	// Set tuner power mode.
+	if(tmbslTDA182I2SetPowerState(UnitNo, PowerMode) != TM_OK)
+		goto error_status_set_tuner_power_mode;
+
+
+	// Set tuner power mode parameter.
+	pExtra->PowerMode      = PowerMode;
+	pExtra->IsPowerModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_power_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get TDA18272 tuner power mode.
+
+*/
+int
+tda18272_GetPowerMode(
+	TUNER_MODULE *pTuner,
+	int *pPowerMode
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+
+	// Get tuner power mode from tuner module.
+	if(pExtra->IsPowerModeSet != YES)
+		goto error_status_get_tuner_power_mode;
+
+	*pPowerMode = pExtra->PowerMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_power_mode:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get TDA18272 tuner IF frequency in Hz.
+
+*/
+int
+tda18272_GetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	)
+{
+	TDA18272_EXTRA_MODULE *pExtra;
+	int UnitNo;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tda18272);
+
+	// Get unit number.
+	UnitNo = pExtra->UnitNo;
+
+
+	// Get tuner IF frequency in Hz.
+	if(tmbslTDA182I2GetIF(UnitNo, pIfFreqHz) != TM_OK)
+		goto error_status_get_tuner_if_frequency;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_if_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is implemented for TDA18272 source code.
+
+
+// Read TDA18272 registers.
+tmErrorCode_t
+tda18272_Read(
+	tmUnitSelect_t tUnit,
+	UInt32 AddrSize,
+	UInt8* pAddr,
+	UInt32 ReadLen,
+	UInt8* pData
+	)
+{
+	ptmTDA182I2Object_t pObj;
+
+	TUNER_MODULE *pTuner;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	unsigned long i;
+	unsigned long ReadingByteNum, ReadingByteNumMax, ReadingByteNumRem;
+	unsigned char RegReadingAddr;
+
+
+	// Get NXP object.
+	pObj = Null;
+	if(TDA182I2GetInstance(tUnit, &pObj) != TM_OK)
+		goto error_status_get_nxp_object;
+
+
+	// Get tuner.
+	pTuner = pObj->pTuner;
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+	// Get base interface.
+	pBaseInterface = pTuner->pBaseInterface;
+
+	// Calculate maximum reading byte number.
+	ReadingByteNumMax = pBaseInterface->I2cReadingByteNumMax;
+
+
+
+	// Get tuner register bytes.
+	// Note: Get tuner register bytes considering maximum reading byte number.
+	for(i = 0; i < ReadLen; i += ReadingByteNumMax)
+	{
+		// Set register reading address.
+		RegReadingAddr = (unsigned char)(*pAddr + i);
+
+		// Calculate remainder reading byte number.
+		ReadingByteNumRem = ReadLen - i;
+
+		// Determine reading byte number.
+		ReadingByteNum = (ReadingByteNumRem > ReadingByteNumMax) ? ReadingByteNumMax : ReadingByteNumRem;
+
+
+		// Set tuner register reading address.
+		// Note: The I2C format of tuner register reading address setting is as follows:
+		//       start_bit + (DeviceAddr | writing_bit) + addr * N + stop_bit
+
+		if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, &RegReadingAddr, (unsigned long)AddrSize) != FUNCTION_SUCCESS)
+			goto error_status_set_tuner_register_reading_address;
+
+		// Get tuner register byte.
+		// Note: The I2C format of tuner register byte getting is as follows:
+		//       start_bit + (DeviceAddr | reading_bit) + read_data * N + stop_bit
+		if(pI2cBridge->ForwardI2cReadingCmd(pI2cBridge, DeviceAddr, &pData[i], ReadingByteNum) != FUNCTION_SUCCESS)
+			goto error_status_get_tuner_registers;
+
+	}
+
+
+	return TM_OK;
+
+
+error_status_get_tuner_registers:
+error_status_set_tuner_register_reading_address:
+error_status_get_nxp_object:
+	return TM_ERR_READ;
+}
+
+
+
+
+
+// Write TDA18272 registers.
+tmErrorCode_t
+tda18272_Write(
+	tmUnitSelect_t tUnit,
+	UInt32 AddrSize,
+	UInt8* pAddr,
+	UInt32 WriteLen,
+	UInt8* pData
+	)
+{
+	ptmTDA182I2Object_t pObj;
+
+	TUNER_MODULE *pTuner;
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	unsigned char DeviceAddr;
+	unsigned char WritingBuffer[I2C_BUFFER_LEN];
+
+	unsigned long i;
+	unsigned long WritingByteNum;
+
+
+	// Get NXP object.
+	pObj = Null;
+	if(TDA182I2GetInstance(tUnit, &pObj) != TM_OK)
+		goto error_status_get_nxp_object;
+
+
+	// Get tuner.
+	pTuner = pObj->pTuner;
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+	// Calculate writing byte number.
+	WritingByteNum = (unsigned char)(AddrSize + WriteLen);
+
+
+	// Set writing bytes.
+	// Note: The I2C format of tuner register byte setting is as follows:
+	//       start_bit + (DeviceAddr | writing_bit) + addr * N + data * N + stop_bit
+	for(i = 0; i < AddrSize; i++)
+		WritingBuffer[i] = pAddr[i];
+
+	for(i = 0; i < WriteLen; i++)
+		WritingBuffer[AddrSize + i] = pData[i];
+
+	// Set tuner register bytes with writing buffer.
+	if(pI2cBridge->ForwardI2cWritingCmd(pI2cBridge, DeviceAddr, WritingBuffer, WritingByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return TM_OK;
+
+
+error_status_set_tuner_registers:
+error_status_get_nxp_object:
+	return TM_ERR_WRITE;
+}
+
+
+
+
+
+// Wait a time.
+tmErrorCode_t
+tda18272_Wait(
+	tmUnitSelect_t tUnit,
+	UInt32 tms
+	)
+{
+	ptmTDA182I2Object_t pObj;
+
+	TUNER_MODULE *pTuner;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+
+	// Get NXP object.
+	pObj = Null;
+	if(TDA182I2GetInstance(tUnit, &pObj) != TM_OK)
+		goto error_status_get_nxp_object;
+
+
+	// Get tuner.
+	pTuner = pObj->pTuner;
+
+	// Get I2C bridge.
+	pBaseInterface = pTuner->pBaseInterface;
+
+	// Wait a time.
+	pBaseInterface->WaitMs(pBaseInterface, tms);
+
+
+	return TM_OK;
+
+
+error_status_get_nxp_object:
+	return TM_ERR_BAD_UNIT_NUMBER;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by NXP.
+
+
+
+
+
+// NXP source code - .\tmbslTDA182I2\src\tmbslTDA182I2.c
+
+
+//-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2001 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmbslTDA182I2.c
+//
+// %version: 33 %
+//
+// DESCRIPTION:  Function for the Hybrid silicon tuner TDA182I2
+//
+// DOCUMENT REF: 
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+//#include "tmNxTypes.h"
+//#include "tmCompId.h"
+//#include "tmFrontEnd.h"
+//#include "tmbslFrontEndTypes.h"
+
+//#include "tmddTDA182I2.h"
+
+//#ifdef TMBSL_TDA18272
+// #include "tmbslTDA18272.h"
+//#else /* TMBSL_TDA18272 */
+// #include "tmbslTDA18212.h"
+//#endif /* TMBSL_TDA18272 */
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+//#include "tmbslTDA182I2local.h"
+//#include "tmbslTDA182I2Instance.h"
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA18211Init:
+//
+// DESCRIPTION: create an instance of a TDA182I2 Tuner
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TM_OK
+//  
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2Init
+(
+    tmUnitSelect_t              tUnit,      /* I: Unit number */
+    tmbslFrontEndDependency_t*  psSrvFunc,   /*  I: setup parameters */
+    TUNER_MODULE                *pTuner	    // Added by Realtek
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    if (psSrvFunc == Null)
+    {
+        err = TDA182I2_ERR_BAD_PARAMETER;
+    }
+
+    if(err == TM_OK)
+    {
+        //----------------------
+        // initialize the Object
+        //----------------------
+        // pObj initialization
+        err = TDA182I2GetInstance(tUnit, &pObj);
+    }
+
+    /* check driver state */
+    if (err == TM_OK || err == TDA182I2_ERR_NOT_INITIALIZED)
+    {
+        if (pObj != Null && pObj->init == True)
+        {
+            err = TDA182I2_ERR_NOT_INITIALIZED;
+        }
+        else 
+        {
+            /* initialize the Object */
+            if (pObj == Null)
+            {
+                err = TDA182I2AllocInstance(tUnit, &pObj);
+                if (err != TM_OK || pObj == Null)
+                {
+                    err = TDA182I2_ERR_NOT_INITIALIZED;        
+                }
+            }
+
+            if (err == TM_OK)
+            {
+                // initialize the Object by default values
+                pObj->sRWFunc = psSrvFunc->sIo;
+                pObj->sTime = psSrvFunc->sTime;
+                pObj->sDebug = psSrvFunc->sDebug;
+
+                if(  psSrvFunc->sMutex.Init != Null
+                    && psSrvFunc->sMutex.DeInit != Null
+                    && psSrvFunc->sMutex.Acquire != Null
+                    && psSrvFunc->sMutex.Release != Null)
+                {
+                    pObj->sMutex = psSrvFunc->sMutex;
+
+                    err = pObj->sMutex.Init(&pObj->pMutex);
+                }
+
+                pObj->init = True;
+                err = TM_OK;
+
+                err = tmddTDA182I2Init(tUnit, psSrvFunc);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Init(0x%08X) failed.", pObj->tUnit));
+            }
+        }
+    }
+
+    // Added by Realtek
+    pObj->pTuner = pTuner;
+
+    return err;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2DeInit:
+//
+// DESCRIPTION: destroy an instance of a TDA182I2 Tuner
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t 
+tmbslTDA182I2DeInit
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    /* check input parameters */
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2DeInit(tUnit);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2DeInit(0x%08X) failed.", pObj->tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+
+        if(pObj->sMutex.DeInit != Null)
+        {
+            if(pObj->pMutex != Null)
+            {
+                err = pObj->sMutex.DeInit(pObj->pMutex);
+            }
+
+            pObj->sMutex.Init = Null;
+            pObj->sMutex.DeInit = Null;
+            pObj->sMutex.Acquire = Null;
+            pObj->sMutex.Release = Null;
+
+            pObj->pMutex = Null;
+        }
+    }
+
+    err = TDA182I2DeAllocInstance(tUnit);
+
+    return err;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2GetSWVersion:
+//
+// DESCRIPTION: Return the version of this device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       Values defined in the tmTDA182I2local.h file
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2GetSWVersion
+(
+    ptmSWVersion_t  pSWVersion  /* I: Receives SW Version */
+)
+{
+    tmErrorCode_t   err = TDA182I2_ERR_NOT_INITIALIZED;
+    
+    err = tmddTDA182I2GetSWVersion(pSWVersion);
+    
+    return err;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2CheckHWVersion:
+//
+// DESCRIPTION: Check HW version
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       Values defined in the tmTDA182I2local.h file
+//-----------------------------------------------------------------------------
+tmErrorCode_t
+tmbslTDA182I2CheckHWVersion
+(
+    tmUnitSelect_t tUnit    /* I: Unit number */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TDA182I2_ERR_NOT_INITIALIZED;
+    UInt16              uIdentity = 0;
+    UInt8               majorRevision = 0;
+
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2GetIdentity(tUnit, &uIdentity);
+
+        if(err == TM_OK)
+        {
+            if(uIdentity == 18272 || uIdentity == 18212)
+            {
+                /* TDA18272/12 found. Check Major Revision*/
+                err = tmddTDA182I2GetMajorRevision(tUnit, &majorRevision);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetMajorRevision(0x%08X) failed.", tUnit));
+
+                if(err == TM_OK && majorRevision != 1)
+                {
+                    /* Only TDA18272/12 ES2 are supported */
+                    err = TDA182I2_ERR_BAD_VERSION;
+                }
+            }
+            else
+            {
+                err = TDA182I2_ERR_BAD_VERSION;
+            }
+        }
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2SetPowerState:
+//
+// DESCRIPTION: Set the power state of this device.
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2SetPowerState
+(
+    tmUnitSelect_t          tUnit,      /* I: Unit number */
+    tmTDA182I2PowerState_t  powerState  /* I: Power state of this device */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        if(powerState > pObj->minPowerState)
+        {
+            powerState = pObj->minPowerState;
+        }
+        
+        // Call tmddTDA182I2SetPowerState
+        err = tmddTDA182I2SetPowerState(tUnit, powerState);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPowerState(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // set power state
+            pObj->curPowerState = powerState;
+        }
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2GetPowerState:
+//
+// DESCRIPTION: Get the power state of this device.
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2GetPowerState
+(
+    tmUnitSelect_t          tUnit,          /* I: Unit number */
+    tmTDA182I2PowerState_t  *pPowerState    /* O: Power state of this device */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    if(pPowerState == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        // pObj initialization
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // get power state
+        *pPowerState = pObj->curPowerState;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2SetStandardMode:
+//
+// DESCRIPTION: Set the standard mode of this device.
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2SetStandardMode
+(
+    tmUnitSelect_t              tUnit,          /* I: Unit number */
+    tmTDA182I2StandardMode_t    StandardMode    /* I: Standard mode of this device */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // store standard mode 
+        pObj->StandardMode = StandardMode;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2GetStandardMode:
+//
+// DESCRIPTION: Get the standard mode of this device.
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2GetStandardMode
+(
+    tmUnitSelect_t              tUnit,          /* I: Unit number */
+    tmTDA182I2StandardMode_t    *pStandardMode  /* O: Standard mode of this device */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    if(pStandardMode == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        // pObj initialization
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Get standard mode */
+        *pStandardMode = pObj->StandardMode;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2SetRf:
+//
+// DESCRIPTION: Calculate i2c I2CMap & write in TDA182I2
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TDA182I2_ERR_BAD_PARAMETER
+//              TMBSL_ERR_IIC_ERR
+//              TM_OK
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2SetRf
+(
+    tmUnitSelect_t            tUnit,  /* I: Unit number */
+    UInt32                    uRF,    /* I: RF frequency in hertz */
+    tmTDA182I2IF_AGC_Gain_t   IF_Gain     // Added by realtek
+)
+{    
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+    Bool                bIRQWait = True;
+    UInt8   ratioL, ratioH;
+    UInt32  DeltaL, DeltaH;
+	UInt8 uAGC1_loop_off;
+	UInt8 uRF_Filter_Gv = 0;
+
+    //------------------------------
+    // test input parameters
+    //------------------------------
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+	{
+		err = tmddTDA182I2GetIRQWait(tUnit, &bIRQWait);
+		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetIRQWait(0x%08X) failed.", tUnit));
+
+		pObj->uRF = uRF;
+
+        if(err == TM_OK)
+        {
+            /* Set LPF */
+            err = tmddTDA182I2SetLP_FC(tUnit, pObj->Std_Array[pObj->StandardMode].LPF);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetLP_FC(0x%08X) failed.", tUnit));
+        }
+ 
+        if(err == TM_OK)
+        {
+            /* Set LPF Offset */
+            err = tmddTDA182I2SetLP_FC_Offset(tUnit, pObj->Std_Array[pObj->StandardMode].LPF_Offset);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetLP_FC_Offset(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set IF Gain */
+//            err = tmddTDA182I2SetIF_Level(tUnit, pObj->Std_Array[pObj->StandardMode].IF_Gain);
+            err = tmddTDA182I2SetIF_Level(tUnit, IF_Gain);		// Modified by Realtek
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIF_Level(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set IF Notch */
+            err = tmddTDA182I2SetIF_ATSC_Notch(tUnit, pObj->Std_Array[pObj->StandardMode].IF_Notch);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIF_ATSC_Notch(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Enable/disable HPF */
+            if ( pObj->Std_Array[pObj->StandardMode].IF_HPF == tmTDA182I2_IF_HPF_Disabled )
+            {
+                err = tmddTDA182I2SetHi_Pass(tUnit, 0);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetHi_Pass(0x%08X, 0) failed.", tUnit));
+            }
+            else
+            {
+                err = tmddTDA182I2SetHi_Pass(tUnit, 1);     
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetHi_Pass(0x%08X, 1) failed.", tUnit));
+
+                if(err == TM_OK)
+                {
+                    /* Set IF HPF */
+                    err = tmddTDA182I2SetIF_HP_Fc(tUnit, (UInt8)(pObj->Std_Array[pObj->StandardMode].IF_HPF - 1));
+                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIF_HP_Fc(0x%08X) failed.", tUnit));
+                }
+            }
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set DC Notch */
+            err = tmddTDA182I2SetIF_Notch(tUnit, pObj->Std_Array[pObj->StandardMode].DC_Notch);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIF_Notch(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC1 LNA Top */
+            err = tmddTDA182I2SetAGC1_TOP(tUnit, pObj->Std_Array[pObj->StandardMode].AGC1_LNA_TOP);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC1_TOP(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC2 RF Top */
+            err = tmddTDA182I2SetAGC2_TOP(tUnit, pObj->Std_Array[pObj->StandardMode].AGC2_RF_Attenuator_TOP);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC2_TOP(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC3 RF AGC Top */
+            if (pObj->uRF < tmTDA182I2_AGC3_RF_AGC_TOP_FREQ_LIM)
+            {
+                err = tmddTDA182I2SetRFAGC_Top(tUnit, pObj->Std_Array[pObj->StandardMode].AGC3_RF_AGC_TOP_Low_band);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRFAGC_Top(0x%08X) failed.", tUnit));
+            }
+            else
+            {
+                err = tmddTDA182I2SetRFAGC_Top(tUnit, pObj->Std_Array[pObj->StandardMode].AGC3_RF_AGC_TOP_High_band);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRFAGC_Top(0x%08X) failed.", tUnit));
+            }
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC4 IR Mixer Top */
+            err = tmddTDA182I2SetIR_Mixer_Top(tUnit, pObj->Std_Array[pObj->StandardMode].AGC4_IR_Mixer_TOP);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIR_Mixer_Top(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC5 IF AGC Top */
+            err = tmddTDA182I2SetAGC5_TOP(tUnit, pObj->Std_Array[pObj->StandardMode].AGC5_IF_AGC_TOP);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC5_TOP(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC3 Adapt */
+            err = tmddTDA182I2SetPD_RFAGC_Adapt(tUnit, pObj->Std_Array[pObj->StandardMode].AGC3_Adapt);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPD_RFAGC_Adapt(0x%08X) failed.", tUnit));
+        }
+    
+        if(err == TM_OK)
+        {
+            /* Set AGC3 Adapt TOP */
+            err = tmddTDA182I2SetRFAGC_Adapt_TOP(tUnit, pObj->Std_Array[pObj->StandardMode].AGC3_Adapt_TOP);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRFAGC_Adapt_TOP(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC5 Atten 3dB */
+            err = tmddTDA182I2SetRF_Atten_3dB(tUnit, pObj->Std_Array[pObj->StandardMode].AGC5_Atten_3dB);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRF_Atten_3dB(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGC5 Detector HPF */
+            err = tmddTDA182I2SetAGC5_Ana(tUnit, pObj->Std_Array[pObj->StandardMode].AGC5_Detector_HPF);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC5_Ana(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set AGCK Mode */
+            err = tmddTDA182I2SetAGCK_Mode(tUnit, pObj->Std_Array[pObj->StandardMode].GSK&0x03);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGCK_Mode(0x%08X) failed.", tUnit));
+
+            err = tmddTDA182I2SetAGCK_Step(tUnit, (pObj->Std_Array[pObj->StandardMode].GSK&0x0C)>>2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGCK_Step(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set H3H5 VHF Filter 6 */
+            err = tmddTDA182I2SetPSM_StoB(tUnit, pObj->Std_Array[pObj->StandardMode].H3H5_VHF_Filter6);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPSM_StoB(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set IF */
+            err = tmddTDA182I2SetIF_Freq(tUnit, pObj->Std_Array[pObj->StandardMode].IF - pObj->Std_Array[pObj->StandardMode].CF_Offset);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIF_Freq(0x%08X) failed.", tUnit));
+        }
+		if (pObj->Std_Array[pObj->StandardMode].LTO_STO_immune && pObj->Master )
+		{
+			/* save RF_Filter_Gv current value */
+			if(err == TM_OK)
+			{
+				err = tmddTDA182I2GetAGC2_Gain_Read (tUnit, &uRF_Filter_Gv);
+				tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetRF_Filter_Gv(0x%08X) failed.", tUnit));
+			}
+			if(err == TM_OK)
+			{	     
+				err = tmddTDA182I2SetRF_Filter_Gv(tUnit, uRF_Filter_Gv );
+			}
+			if(err == TM_OK)
+			{
+				err = tmddTDA182I2SetForce_AGC2_gain(tUnit, 0x1);
+			}
+			/* smooth RF_Filter_Gv to min value */
+			if((err == TM_OK)&&(uRF_Filter_Gv != 0))
+			{
+				do
+				{
+					err = tmddTDA182I2SetRF_Filter_Gv(tUnit, uRF_Filter_Gv -1 );
+					tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetRF_Filter_Gv(0x%08X) failed.", tUnit));
+					if(err == TM_OK)
+					{
+						err = TDA182I2Wait(pObj, 10);
+						tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRF_Filter_Cap(0x%08X) failed.", tUnit));
+					}
+					uRF_Filter_Gv = uRF_Filter_Gv -1 ;
+				}
+				while ( uRF_Filter_Gv > 0);
+			}
+			if(err == TM_OK)
+			{
+				err = tmddTDA182I2SetRF_Atten_3dB (tUnit, 0x01);
+				tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetRF_Filter_Gv(0x%08X) failed.", tUnit));
+			}
+		}
+        if(err == TM_OK)
+        {
+            /* Set RF */
+            err = tmddTDA182I2SetRF_Freq(tUnit, uRF + pObj->Std_Array[pObj->StandardMode].CF_Offset);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRF_Freq(0x%08X) failed.", tUnit));
+            
+        }
+
+		if (pObj->Std_Array[pObj->StandardMode].LTO_STO_immune && pObj->Master )
+		{
+
+			if(err == TM_OK)
+			{
+				err = tmddTDA182I2SetRF_Atten_3dB (tUnit, 0x00);
+				tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetRF_Filter_Gv(0x%08X) failed.", tUnit));
+			}
+			err = TDA182I2Wait(pObj, 50);
+			if(err == TM_OK)
+			{
+				tmddTDA182I2SetForce_AGC2_gain(tUnit, 0x0);
+			}
+		}
+
+        if(err == TM_OK)
+        {
+            /*  Spurious reduction begin */
+            ratioL = (UInt8)(uRF / 16000000);
+            ratioH = (UInt8)(uRF / 16000000) + 1;
+            DeltaL = (uRF - (ratioL * 16000000));
+            DeltaH = ((ratioH * 16000000) - uRF);
+
+            if (uRF < 72000000 )
+            {
+                /* Set sigma delta clock*/
+                err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 1);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, sigma delta clock) failed.", tUnit));                    
+            }
+            else if (uRF < 104000000 )
+            {
+                /* Set 16 Mhz Xtal clock */
+                err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 0);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, 16 Mhz xtal clock) failed.", tUnit));
+            }
+            else if (uRF <= 120000000 )
+            {
+                /* Set sigma delta clock*/
+                err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 1);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, sigma delta clock) failed.", tUnit));                    
+            }
+            else  /* RF above 120 MHz */
+            {
+                if  (DeltaL <= DeltaH )  
+                {
+                    if (ratioL & 0x000001 )  /* ratioL odd */
+                    {
+                        /* Set 16 Mhz Xtal clock */
+                        err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 0);
+                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, 16 Mhz xtal clock) failed.", tUnit));
+                    }
+                    else /* ratioL even */
+                    {
+                        /* Set sigma delta clock*/
+                        err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 1);
+                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, sigma delta clock) failed.", tUnit));
+                    }
+                    
+                }
+                else  /* (DeltaL > DeltaH ) */
+                {
+                    if (ratioL & 0x000001 )  /*(ratioL odd)*/
+                    {
+                        /* Set sigma delta clock*/
+                        err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 1);
+                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, sigma delta clock) failed.", tUnit));
+                    }
+                    else
+                    {
+                        /* Set 16 Mhz Xtal clock */
+                        err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 0);
+                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, 16 Mhz xtal clock) failed.", tUnit));
+                    }
+                }
+            }
+		}
+        /*  Spurious reduction end */
+
+		if(err == TM_OK)
+		{
+			if ( pObj->Std_Array[pObj->StandardMode].AGC1_Freeze == True )
+			{
+				err  =  tmddTDA182I2GetAGC1_loop_off(tUnit, &uAGC1_loop_off) ;
+
+				if (uAGC1_loop_off == 0) // first AGC1 freeze
+				{
+					err  =  tmddTDA182I2SetAGC1_loop_off(tUnit, 0x1 ) ;
+					if(err == TM_OK)
+					{
+						err = tmddTDA182I2SetForce_AGC1_gain(tUnit, 0x1);
+					}
+				}
+				if(err == TM_OK)
+				{				
+					err = tmddTDA182I2AGC1_Adapt (tUnit); /* Adapt AGC1gain from Last SetRF */
+				}
+			}
+			else
+			{
+				err = tmddTDA182I2SetForce_AGC1_gain(tUnit, 0x0);
+				if(err == TM_OK)
+				{
+					err  =  tmddTDA182I2SetAGC1_loop_off(tUnit, 0x0 ) ;
+				}
+			}	
+		}
+
+        (void)TDA182I2MutexRelease(pObj);
+	}
+
+    return err;
+}
+
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmbslTDA182I2GetRf:
+//
+// DESCRIPTION: Get the frequency programmed in the tuner
+//
+// RETURN:      TMBSL_ERR_TUNER_BAD_UNIT_NUMBER
+//              TDA182I2_ERR_NOT_INITIALIZED
+//              TM_OK
+//
+// NOTES:       The value returned is the one stored in the Object
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslTDA182I2GetRf
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*         puRF    /* O: RF frequency in hertz */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    if(puRF == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    //------------------------------
+    // test input parameters
+    //------------------------------
+    // pObj initialization
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Get RF */
+        *puRF = pObj->uRF/* - pObj->Std_Array[pObj->StandardMode].CF_Offset*/;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2Reset                                                         */
+/*============================================================================*/
+tmErrorCode_t
+tmbslTDA182I2Reset
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+    Bool                bIRQWait = True;
+
+    //------------------------------
+    // test input parameters
+    //------------------------------
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+    
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2GetIRQWait(tUnit, &bIRQWait);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetIRQWait(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            err = TDA182I2Init(tUnit);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2Init(0x%08X) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            //  Wait for  XtalCal End ( Master only )
+            if (pObj->Master)
+            {
+                err = TDA182I2WaitXtalCal_End ( pObj, 100, 5);
+            }
+            else
+            {
+                /* Initialize Fmax_LO and N_CP_Current */
+                err = tmddTDA182I2SetFmax_Lo(tUnit, 0x00);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetFmax_Lo(0x%08X, 0x0A) failed.", tUnit));
+
+                if(err == TM_OK)
+                {
+                    err = tmddTDA182I2SetN_CP_Current(tUnit, 0x68);
+                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetN_CP_Current(0x%08X, 0x68) failed.", tUnit));
+                }
+            }
+        }
+        if(err == TM_OK)
+        {
+            // initialize tuner
+            err =  tmddTDA182I2Reset(tUnit);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Reset(0x%08X) failed.", tUnit));
+        }
+        if (err == TM_OK)
+        {
+            /* Initialize Fmax_LO and N_CP_Current */
+            err = tmddTDA182I2SetFmax_Lo(tUnit, 0x0A);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetFmax_Lo(0x%08X, 0x0A) failed.", tUnit));
+        }
+        if (err == TM_OK)
+        {
+            err = tmddTDA182I2SetLT_Enable(tUnit, pObj->LT_Enable );
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetLT_Enable(0x%08X, 0) failed.", tUnit));
+        }
+        if (err == TM_OK)
+        {
+            err = tmddTDA182I2SetPSM_AGC1(tUnit, pObj->PSM_AGC1 );
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPSM_AGC1(0x%08X, 1) failed.", tUnit));
+        }
+        if (err == TM_OK)
+        {
+            err = tmddTDA182I2SetAGC1_6_15dB(tUnit, pObj->AGC1_6_15dB );
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC1_6_15dB(0x%08X, 0) failed.", tUnit));
+        }
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetIF                                                         */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetIF
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*         puIF    /* O: IF Frequency in hertz */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(puIF == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+    
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *puIF = pObj->Std_Array[pObj->StandardMode].IF - pObj->Std_Array[pObj->StandardMode].CF_Offset;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetCF_Offset                                                  */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetCF_Offset(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32*         puOffset    /* O: Center frequency offset in hertz */
+    )
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(puOffset == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+    
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *puOffset = pObj->Std_Array[pObj->StandardMode].CF_Offset;
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetLockStatus                                                 */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetLockStatus
+(
+    tmUnitSelect_t          tUnit,      /* I: Unit number */
+    tmbslFrontEndState_t*   pLockStatus /* O: PLL Lock status */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+    UInt8 uValue, uValueLO;
+
+    if( pLockStatus == Null )
+    {
+        err = TDA182I2_ERR_BAD_PARAMETER;
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+        
+        if(err == TM_OK)
+        {
+            err =  tmddTDA182I2GetLO_Lock(tUnit, &uValueLO);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetLO_Lock(0x%08X) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            err =  tmddTDA182I2GetIRQ_status(tUnit, &uValue);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetIRQ_status(0x%08X) failed.", tUnit));
+    
+            uValue = uValue & uValueLO;
+        }
+        if(err == TM_OK)
+        {
+            *pLockStatus =  (uValue)? tmbslFrontEndStateLocked : tmbslFrontEndStateNotLocked;
+        }
+        else
+        {
+            *pLockStatus = tmbslFrontEndStateUnknown;  
+        }
+    
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetPowerLevel                                                 */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetPowerLevel
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32*         pPowerLevel /* O: Power Level in dBV */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(pPowerLevel == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *pPowerLevel = 0;
+
+        err = tmddTDA182I2GetPower_Level(tUnit, (UInt8 *)pPowerLevel);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetPower_Level(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2SetIRQWait                                                  */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2SetIRQWait
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool            bWait   /* I: Determine if we need to wait IRQ in driver functions */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2SetIRQWait(tUnit, bWait);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIRQWait(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetIRQWait                                                  */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetIRQWait
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool*           pbWait  /* O: Determine if we need to wait IRQ in driver functions */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(pbWait == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2GetIRQWait(tUnit, pbWait);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetIRQWait(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetIRQ                                                        */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetIRQ
+(
+    tmUnitSelect_t  tUnit  /* I: Unit number */,
+    Bool*           pbIRQ  /* O: IRQ triggered */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(pbIRQ == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *pbIRQ = 0;
+
+        err = tmddTDA182I2GetIRQ_status(tUnit, (UInt8 *)pbIRQ);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetIRQ_status(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2WaitIRQ                                                       */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2WaitIRQ
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          timeOut,    /* I: timeOut for IRQ wait */
+    UInt32          waitStep,   /* I: wait step */
+    UInt8           irqStatus   /* I: IRQs to wait */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2WaitIRQ(tUnit, timeOut, waitStep, irqStatus);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2GetXtalCal_End                                                */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2GetXtalCal_End
+(
+    tmUnitSelect_t  tUnit  /* I: Unit number */,
+    Bool*           pbXtalCal_End  /* O: XtalCal_End triggered */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(pbXtalCal_End == Null)
+        err = TDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *pbXtalCal_End = 0;
+
+        err = tmddTDA182I2GetMSM_XtalCal_End(tUnit, (UInt8 *)pbXtalCal_End);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetMSM_XtalCal_End(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* tmbslTDA182I2WaitXtalCal_End                                               */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2WaitXtalCal_End
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          timeOut,    /* I: timeOut for IRQ wait */
+    UInt32          waitStep   /* I: wait step */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = tmddTDA182I2WaitXtalCal_End(tUnit, timeOut, waitStep);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2WaitXtalCal_End(0x%08X) failed.", tUnit));
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+/*============================================================================*/
+/* tmbslTDA182I2CheckRFFilterRobustness                                       */
+/*============================================================================*/
+/*
+tmErrorCode_t
+tmbslTDA182I2CheckRFFilterRobustness 
+(
+ tmUnitSelect_t                         tUnit,      // I: Unit number
+ ptmTDA182I2RFFilterRating              rating      // O: RF Filter rating
+ )
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err = TM_OK;
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        UInt8  rfcal_log_0 = 0;
+        UInt8  rfcal_log_2 = 0;
+        UInt8  rfcal_log_3 = 0;
+        UInt8  rfcal_log_5 = 0;
+        UInt8  rfcal_log_6 = 0;
+        UInt8  rfcal_log_8 = 0;
+        UInt8  rfcal_log_9 = 0;
+        UInt8  rfcal_log_11 = 0;
+
+        double   VHFLow_0 = 0.0;
+        double   VHFLow_1 = 0.0;
+        double   VHFHigh_0 = 0.0;
+        double   VHFHigh_1 = 0.0;
+        double   UHFLow_0 = 0.0;
+        double   UHFLow_1 = 0.0;
+        double   UHFHigh_0 = 0.0;
+        double   UHFHigh_1 = 0.0;
+
+        err = tmddTDA182I2Getrfcal_log_0(tUnit, &rfcal_log_0);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_0(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_2(tUnit, &rfcal_log_2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_2(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_3(tUnit, &rfcal_log_3);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_3(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_5(tUnit, &rfcal_log_5);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_5(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_6(tUnit, &rfcal_log_6);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_6(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_8(tUnit, &rfcal_log_8);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_8(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_9(tUnit, &rfcal_log_9);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_9(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2Getrfcal_log_11(tUnit, &rfcal_log_11);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Getrfcal_log_11(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        { 
+            if (rfcal_log_0 & 0x80)
+            {
+                rating->VHFLow_0_Margin = 0;    
+                rating->VHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // VHFLow_0
+                VHFLow_0 = 100 * (45 - 39.8225 * (1 + (0.31 * (rfcal_log_0 < 64 ? rfcal_log_0 : rfcal_log_0 - 128)) / 1.0 / 100.0)) / 45.0;
+                rating->VHFLow_0_Margin = 0.0024 * VHFLow_0 * VHFLow_0 * VHFLow_0 - 0.101 * VHFLow_0 * VHFLow_0 + 1.629 * VHFLow_0 + 1.8266;
+                if (rating->VHFLow_0_Margin >= 0) 
+                {
+                    rating->VHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->VHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_2 & 0x80)
+            {
+                rating->VHFLow_1_Margin = 0;    
+                rating->VHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // VHFLow_1
+                VHFLow_1 = 100 * (152.1828 * (1 + (1.53 * (rfcal_log_2 < 64 ? rfcal_log_2 : rfcal_log_2 - 128)) / 1.0 / 100.0) - (144.896 - 6)) / (144.896 - 6); 
+                rating->VHFLow_1_Margin = 0.0024 * VHFLow_1 * VHFLow_1 * VHFLow_1 - 0.101 * VHFLow_1 * VHFLow_1 + 1.629 * VHFLow_1 + 1.8266;
+                if (rating->VHFLow_1_Margin >= 0)
+                {
+                    rating->VHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->VHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_3 & 0x80)
+            {
+                rating->VHFHigh_0_Margin = 0;    
+                rating->VHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // VHFHigh_0    
+                VHFHigh_0 = 100 * ((144.896 + 6) - 135.4063 * (1 + (0.27 * (rfcal_log_3 < 64 ? rfcal_log_3 : rfcal_log_3 - 128)) / 1.0 / 100.0)) / (144.896 + 6);
+                rating->VHFHigh_0_Margin = 0.0024 * VHFHigh_0 * VHFHigh_0 * VHFHigh_0 - 0.101 * VHFHigh_0 * VHFHigh_0 + 1.629 * VHFHigh_0 + 1.8266;
+                if (rating->VHFHigh_0_Margin >= 0)
+                {
+                    rating->VHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->VHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_5 & 0x80)
+            {
+                rating->VHFHigh_1_Margin = 0;    
+                rating->VHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // VHFHigh_1
+                VHFHigh_1 = 100 * (383.1455 * (1 + (0.91 * (rfcal_log_5 < 64 ? rfcal_log_5 : rfcal_log_5 - 128)) / 1.0 / 100.0) - (367.104 - 8)) / (367.104 - 8);
+                rating->VHFHigh_1_Margin = 0.0024 * VHFHigh_1 * VHFHigh_1 * VHFHigh_1 - 0.101 * VHFHigh_1 * VHFHigh_1 + 1.629 * VHFHigh_1 + 1.8266;
+                if (rating->VHFHigh_1_Margin >= 0)
+                {
+                    rating->VHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->VHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_6 & 0x80)
+            {
+                rating->UHFLow_0_Margin = 0;    
+                rating->UHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // UHFLow_0
+                UHFLow_0 = 100 * ((367.104 + 8) - 342.6224 * (1 + (0.21 * (rfcal_log_6 < 64 ? rfcal_log_6 : rfcal_log_6 - 128)) / 1.0 / 100.0)) / (367.104 + 8);
+                rating->UHFLow_0_Margin = 0.0024 * UHFLow_0 * UHFLow_0 * UHFLow_0 - 0.101 * UHFLow_0 * UHFLow_0 + 1.629 * UHFLow_0 + 1.8266;
+                if (rating->UHFLow_0_Margin >= 0)
+                {
+                    rating->UHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->UHFLow_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_8 & 0x80)
+            {
+                rating->UHFLow_1_Margin = 0;    
+                rating->UHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // UHFLow_1
+                UHFLow_1 = 100 * (662.5595 * (1 + (0.33 * (rfcal_log_8 < 64 ? rfcal_log_8 : rfcal_log_8 - 128)) / 1.0 / 100.0) - (624.128 - 2)) / (624.128 - 2);
+                rating->UHFLow_1_Margin = 0.0024 * UHFLow_1 * UHFLow_1 * UHFLow_1 - 0.101 * UHFLow_1 * UHFLow_1 + 1.629 * UHFLow_1 + 1.8266;
+                if (rating->UHFLow_1_Margin >= 0)
+                {
+                    rating->UHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->UHFLow_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_9 & 0x80)
+            {
+                rating->UHFHigh_0_Margin = 0;    
+                rating->UHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // UHFHigh_0
+                UHFHigh_0 = 100 * ((624.128 + 2) - 508.2747 * (1 + (0.23 * (rfcal_log_9 < 64 ? rfcal_log_9 : rfcal_log_9 - 128)) / 1.0 / 100.0)) / (624.128 + 2);
+                rating->UHFHigh_0_Margin = 0.0024 * UHFHigh_0 * UHFHigh_0 * UHFHigh_0 - 0.101 * UHFHigh_0 * UHFHigh_0 + 1.629 * UHFHigh_0 + 1.8266;
+                if (rating->UHFHigh_0_Margin >= 0)
+                {
+                    rating->UHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->UHFHigh_0_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+
+            if (rfcal_log_11 & 0x80)
+            {
+                rating->UHFHigh_1_Margin = 0;    
+                rating->UHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Error;
+            }
+            else
+            {
+                // UHFHigh_1
+                UHFHigh_1 = 100 * (947.8913 * (1 + (0.3 * (rfcal_log_11 < 64 ? rfcal_log_11 : rfcal_log_11 - 128)) / 1.0 / 100.0) - (866 - 14)) / (866 - 14);
+                rating->UHFHigh_1_Margin = 0.0024 * UHFHigh_1 * UHFHigh_1 * UHFHigh_1 - 0.101 * UHFHigh_1 * UHFHigh_1 + 1.629 * UHFHigh_1 + 1.8266;            
+                if (rating->UHFHigh_1_Margin >= 0)
+                {
+                    rating->UHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_High;
+                }
+                else
+                {
+                    rating->UHFHigh_1_RFFilterRobustness =  tmTDA182I2RFFilterRobustness_Low;
+                }
+            }
+        }
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+*/
+
+/*============================================================================*/
+/* tmbslTDA182I2Write                                                         */
+/*============================================================================*/
+
+tmErrorCode_t
+tmbslTDA182I2Write
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          uIndex,     /* I: Start index to write */
+    UInt32          WriteLen,   /* I: Number of bytes to write */
+    UInt8*          pData       /* I: Data to write */
+)
+{
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = TDA182I2MutexAcquire(pObj, TDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // Call tmddTDA182I2Write
+
+        (void)TDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+//-----------------------------------------------------------------------------
+// Internal functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    TDA182I2Init:
+//
+// DESCRIPTION: initialization of the Tuner
+//
+// RETURN:      always True
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+TDA182I2Init
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{     
+    ptmTDA182I2Object_t pObj = Null;
+    tmErrorCode_t       err  = TM_OK;
+
+    //------------------------------
+    // test input parameters
+    //------------------------------
+    // pObj initialization
+    err = TDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        //err = tmddTDA182I2SetIRQWait(tUnit, True);
+
+        //if(pObj->bIRQWait)
+        //{
+        //    err = TDA182I2WaitIRQ(pObj);
+        //}
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    TDA182I2Wait
+//
+// DESCRIPTION: This function waits for requested time
+//
+// RETURN:      True or False
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+static tmErrorCode_t 
+TDA182I2Wait
+(
+    ptmTDA182I2Object_t pObj,   /* I: Driver object */
+    UInt32              Time   /*  I: Time to wait for */
+)
+{
+    tmErrorCode_t   err  = TM_OK;
+
+    // wait Time ms
+    err = POBJ_SRVFUNC_STIME.Wait(pObj->tUnit, Time);
+
+    // Return value
+    return err;
+}
+
+/*============================================================================*/
+/* TDA182I2MutexAcquire                                                       */
+/*============================================================================*/
+extern tmErrorCode_t
+TDA182I2MutexAcquire
+(
+ ptmTDA182I2Object_t    pObj,
+ UInt32                 timeOut
+ )
+{
+    tmErrorCode_t       err = TM_OK;
+
+    if(pObj->sMutex.Acquire != Null && pObj->pMutex != Null)
+    {
+        err = pObj->sMutex.Acquire(pObj->pMutex, timeOut);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* TDA182I2MutexRelease                                                       */
+/*============================================================================*/
+extern tmErrorCode_t
+TDA182I2MutexRelease
+(
+ ptmTDA182I2Object_t    pObj
+ )
+{
+    tmErrorCode_t       err = TM_OK;
+
+    if(pObj->sMutex.Release != Null && pObj->pMutex != Null)
+    {
+        err = pObj->sMutex.Release(pObj->pMutex);
+    }
+
+    return err;
+}
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2WaitXtalCal_End                                     */
+/*                                                                            */
+/* DESCRIPTION: Wait for MSM_XtalCal_End to trigger                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+static tmErrorCode_t
+TDA182I2WaitXtalCal_End
+(
+    ptmTDA182I2Object_t   pObj,       /* I: Instance object */
+    UInt32                  timeOut,    /* I: timeout */
+    UInt32                  waitStep    /* I: wait step */
+)
+{     
+    tmErrorCode_t   err  = TM_OK;
+    UInt32          counter = timeOut/waitStep; /* Wait max timeOut/waitStepms */
+    UInt8           uMSM_XtalCal_End = 0;
+
+    while(err == TM_OK && (--counter)>0)
+    {
+        err = tmddTDA182I2GetMSM_XtalCal_End(pObj->tUnit, &uMSM_XtalCal_End);
+
+        if(uMSM_XtalCal_End == 1)
+        {
+            /* MSM_XtalCal_End triggered => Exit */
+            break;
+        }
+
+        TDA182I2Wait(pObj, waitStep);
+    }
+
+    if(counter == 0)
+    {
+        err = ddTDA182I2_ERR_NOT_READY;
+    }
+
+    return err;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmbslTDA182I2\src\tmbslTDA182I2Instance.c
+
+
+//-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2001 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmbslTDA182I2Instance.c
+//
+// DESCRIPTION:  define the static Objects
+//
+// DOCUMENT REF: DVP Software Coding Guidelines v1.14
+//               DVP Board Support Library Architecture Specification v0.5
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+//
+
+//#include "tmNxTypes.h"
+//#include "tmCompId.h"
+//#include "tmFrontEnd.h"
+//#include "tmUnitParams.h"
+//#include "tmbslFrontEndTypes.h"
+
+//#ifdef TMBSL_TDA18272
+// #include "tmbslTDA18272.h"
+//#else /* TMBSL_TDA18272 */
+// #include "tmbslTDA18212.h"
+//#endif /* TMBSL_TDA18272 */
+
+//#include "tmbslTDA182I2local.h"
+//#include "tmbslTDA182I2Instance.h"
+//#include <tmbslTDA182I2_InstanceCustom.h>
+
+//-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+//
+//
+// default instance
+tmTDA182I2Object_t gTDA182I2Instance[] = 
+{
+    {
+        (tmUnitSelect_t)(-1),                                   /* tUnit */
+        (tmUnitSelect_t)(-1),                                   /* tUnit temporary */
+        Null,                                                   /* pMutex */
+        False,                                                  /* init (instance initialization default) */
+        {                                                       /* sRWFunc */
+            Null,
+            Null
+        },
+        {                                                       /* sTime */
+            Null,
+            Null
+        },
+        {                                                       /* sDebug */
+            Null
+        },
+        {                                                       /* sMutex */
+            Null,
+            Null,
+            Null,
+            Null
+        },
+#ifdef TMBSL_TDA18272
+TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH0
+            {
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH0
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG_SELECTION_PATH0
+            }
+#else
+TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH0
+            {
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH0
+            }
+#endif
+    },
+    {
+        (tmUnitSelect_t)(-1),                                   /* tUnit */
+        (tmUnitSelect_t)(-1),                                   /* tUnit temporary */
+        Null,                                                   /* pMutex */
+        False,                                                  /* init (instance initialization default) */
+        {                                                       /* sRWFunc */
+            Null,
+            Null
+        },
+        {                                                       /* sTime */
+            Null,
+            Null
+        },
+        {                                                       /* sDebug */
+            Null
+        },
+        {                                                       /* sMutex */
+            Null,
+            Null,
+            Null,
+            Null
+        },
+#ifdef TMBSL_TDA18272
+TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH1
+        {
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH1
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG_SELECTION_PATH1
+        }
+#else
+TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH1
+        {
+TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH1
+        }
+#endif
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    TDA182I2AllocInstance:
+//
+// DESCRIPTION: allocate new instance
+//
+// RETURN:      
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+TDA182I2AllocInstance
+(
+    tmUnitSelect_t          tUnit,      /* I: Unit number */
+    pptmTDA182I2Object_t    ppDrvObject /* I: Device Object */
+)
+{ 
+    tmErrorCode_t       err = TDA182I2_ERR_BAD_UNIT_NUMBER;
+    ptmTDA182I2Object_t pObj = Null;
+    UInt32              uLoopCounter = 0;    
+
+    /* Find a free instance */
+    for(uLoopCounter = 0; uLoopCounter<TDA182I2_MAX_UNITS; uLoopCounter++)
+    {
+        pObj = &gTDA182I2Instance[uLoopCounter];
+        if(pObj->init == False)
+        {
+            pObj->tUnit = tUnit;
+            pObj->tUnitW = tUnit;
+
+			// Added by Realtek.
+			// Set master bit manually according to tUnit.
+			pObj->Master = (tUnit == 0) ? True : False;
+
+            *ppDrvObject = pObj;
+            err = TM_OK;
+            break;
+        }
+    }
+
+    /* return value */
+    return err;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    TDA182I2DeAllocInstance:
+//
+// DESCRIPTION: deallocate instance
+//
+// RETURN:      always TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+TDA182I2DeAllocInstance
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{     
+    tmErrorCode_t       err = TDA182I2_ERR_BAD_UNIT_NUMBER;
+    ptmTDA182I2Object_t pObj = Null;
+
+    /* check input parameters */
+    err = TDA182I2GetInstance(tUnit, &pObj);
+
+    /* check driver state */
+    if (err == TM_OK)
+    {
+        if (pObj == Null || pObj->init == False)
+        {
+            err = TDA182I2_ERR_NOT_INITIALIZED;
+        }
+    }
+
+    if ((err == TM_OK) && (pObj != Null)) 
+    {
+        pObj->init = False;
+    }
+
+    /* return value */
+    return err;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    TDA182I2GetInstance:
+//
+// DESCRIPTION: get the instance
+//
+// RETURN:      always True
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+TDA182I2GetInstance
+(
+    tmUnitSelect_t          tUnit,      /* I: Unit number */
+    pptmTDA182I2Object_t    ppDrvObject /* I: Device Object */
+)
+{     
+    tmErrorCode_t       err = TDA182I2_ERR_NOT_INITIALIZED;
+    ptmTDA182I2Object_t pObj = Null;
+    UInt32              uLoopCounter = 0;    
+
+    /* get instance */
+    for(uLoopCounter = 0; uLoopCounter<TDA182I2_MAX_UNITS; uLoopCounter++)
+    {
+        pObj = &gTDA182I2Instance[uLoopCounter];
+        if(pObj->init == True && pObj->tUnit == GET_INDEX_TYPE_TUNIT(tUnit))
+        {
+            pObj->tUnitW = tUnit;
+            
+            *ppDrvObject = pObj;
+            err = TM_OK;
+            break;
+        }
+    }
+
+    /* return value */
+    return err;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\src\tmddTDA182I2.c
+
+
+/*
+  Copyright (C) 2006-2009 NXP B.V., All Rights Reserved.
+  This source code and any compilation or derivative thereof is the proprietary
+  information of NXP B.V. and is confidential in nature. Under no circumstances
+  is this software to be  exposed to or placed under an Open Source License of
+  any type without the expressed written permission of NXP B.V.
+ *
+ * \file          tmddTDA182I2.c
+ *
+ *                3
+ *
+ * \date          %modify_time%
+ *
+ * \brief         Describe briefly the purpose of this file.
+ *
+ * REFERENCE DOCUMENTS :
+ *                TDA18254_Driver_User_Guide.pdf
+ *
+ * Detailed description may be added here.
+ *
+ * \section info Change Information
+ *
+*/
+
+/*============================================================================*/
+/* Standard include files:                                                    */
+/*============================================================================*/
+//#include "tmNxTypes.h"
+//#include "tmCompId.h"
+//#include "tmFrontEnd.h"
+//#include "tmbslFrontEndTypes.h"
+//#include "tmUnitParams.h"
+
+/*============================================================================*/
+/* Project include files:                                                     */
+/*============================================================================*/
+//#include "tmddTDA182I2.h"
+//#include <tmddTDA182I2local.h>
+
+//#include "tmddTDA182I2Instance.h"
+
+/*============================================================================*/
+/* Types and defines:                                                         */
+/*============================================================================*/
+
+/*============================================================================*/
+/* Global data:                                                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/* Internal Prototypes:                                                       */
+/*============================================================================*/
+
+/*============================================================================*/
+/* Exported functions:                                                        */
+/*============================================================================*/
+
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2Init                                              */
+/*                                                                            */
+/* DESCRIPTION: Create an instance of a TDA182I2 Tuner                        */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2Init
+(
+    tmUnitSelect_t              tUnit,      /* I: Unit number */
+    tmbslFrontEndDependency_t*  psSrvFunc   /* I: setup parameters */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    if (psSrvFunc == Null)
+    {
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+    }
+
+    /* Get Instance Object */
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+    }
+
+    /* Check driver state */
+    if (err == TM_OK || err == ddTDA182I2_ERR_NOT_INITIALIZED)
+    {
+        if (pObj != Null && pObj->init == True)
+        {
+            err = ddTDA182I2_ERR_NOT_INITIALIZED;
+        }
+        else 
+        {
+            /* Allocate the Instance Object */
+            if (pObj == Null)
+            {
+                err = ddTDA182I2AllocInstance(tUnit, &pObj);
+                if (err != TM_OK || pObj == Null)
+                {
+                    err = ddTDA182I2_ERR_NOT_INITIALIZED;        
+                }
+            }
+
+            if(err == TM_OK)
+            {
+                /* initialize the Instance Object */
+                pObj->sRWFunc = psSrvFunc->sIo;
+                pObj->sTime = psSrvFunc->sTime;
+                pObj->sDebug = psSrvFunc->sDebug;
+
+                if(  psSrvFunc->sMutex.Init != Null
+                    && psSrvFunc->sMutex.DeInit != Null
+                    && psSrvFunc->sMutex.Acquire != Null
+                    && psSrvFunc->sMutex.Release != Null)
+                {
+                    pObj->sMutex = psSrvFunc->sMutex;
+
+                    err = pObj->sMutex.Init(&pObj->pMutex);
+                }
+
+                pObj->init = True;
+                err = TM_OK;
+            }
+        }
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2DeInit                                            */
+/*                                                                            */
+/* DESCRIPTION: Destroy an instance of a TDA182I2 Tuner                       */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t 
+tmddTDA182I2DeInit
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{
+    tmErrorCode_t           err = TM_OK;
+    ptmddTDA182I2Object_t   pObj = Null;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+
+//    tmDBGPRINTEx(DEBUGLVL_VERBOSE, "tmddTDA182I2DeInit(0x%08X)", tUnit);
+
+    if(err == TM_OK)
+    {
+        if(pObj->sMutex.DeInit != Null)
+        {
+            if(pObj->pMutex != Null)
+            {
+                err = pObj->sMutex.DeInit(pObj->pMutex);
+            }
+
+            pObj->sMutex.Init = Null;
+            pObj->sMutex.DeInit = Null;
+            pObj->sMutex.Acquire = Null;
+            pObj->sMutex.Release = Null;
+
+            pObj->pMutex = Null;
+        }
+    }
+
+    err = ddTDA182I2DeAllocInstance(tUnit);
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetSWVersion                                      */
+/*                                                                            */
+/* DESCRIPTION: Return the version of this device                             */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:       Values defined in the tmddTDA182I2local.h file                */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetSWVersion
+(
+    ptmSWVersion_t  pSWVersion  /* I: Receives SW Version */
+)
+{
+    pSWVersion->compatibilityNr = TDA182I2_DD_COMP_NUM;
+    pSWVersion->majorVersionNr  = TDA182I2_DD_MAJOR_VER;
+    pSWVersion->minorVersionNr  = TDA182I2_DD_MINOR_VER;
+
+    return TM_OK;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2Reset                                             */
+/*                                                                            */
+/* DESCRIPTION: Initialize TDA182I2 Hardware                                  */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2Reset
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{   
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /****** I2C map initialization : begin *********/
+        if(err == TM_OK)
+        {
+            /* read all bytes */
+            err = ddTDA182I2Read(pObj, 0x00, TDA182I2_I2C_MAP_NB_BYTES);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            /* RSSI_Ck_Speed    31,25 kHz   0 */
+            err = tmddTDA182I2SetRSSI_Ck_Speed(tUnit, 0);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetRSSI_Ck_Speed(0x%08X, 0) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            /* AGC1_Do_step    8,176 ms   2 */
+            err = tmddTDA182I2SetAGC1_Do_step(tUnit, 2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC1_Do_step(0x%08X, 2) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            /* AGC2_Do_step    8,176 ms   1 */
+            err = tmddTDA182I2SetAGC2_Do_step(tUnit, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC2_Do_step(0x%08X, 1) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            /* AGCs_Up_Step_assym       UP 12 Asym / 4 Asym  / 5 Asym   3 */
+            err = tmddTDA182I2SetAGCs_Up_Step_assym(tUnit, 3);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGCs_Up_Step_assym(0x%08X, 3) failed.", tUnit));
+        }
+        if(err == TM_OK)
+        {
+            /* AGCs_Do_Step_assym       DO 12 Asym / 45 Sym   2 */
+            err = tmddTDA182I2SetAGCs_Do_Step_assym(tUnit, 2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGCs_Do_Step_assym(0x%08X, 2) failed.", tUnit));
+        }
+        /****** I2C map initialization : end *********/
+
+        /*****************************************/
+        /* Launch tuner calibration */
+        /* State reached after 1.5 s max */
+        if(err == TM_OK)
+        {
+            /* set IRQ_clear */
+            err = tmddTDA182I2SetIRQ_Clear(tUnit, 0x1F);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIRQ_clear(0x%08X, 0x1F) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* set power state on */
+            err = tmddTDA182I2SetPowerState(tUnit, tmddTDA182I2_PowerNormalMode);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPowerState(0x%08X, PowerNormalMode) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* set & trigger MSM */
+            pObj->I2CMap.uBx19.MSM_byte_1 = 0x3B;
+            pObj->I2CMap.uBx1A.MSM_byte_2 = 0x01;
+
+            /* write bytes 0x19 to 0x1A */
+            err = ddTDA182I2Write(pObj, 0x19, 2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+            pObj->I2CMap.uBx1A.MSM_byte_2 = 0x00;
+
+        }
+
+        if(pObj->bIRQWait)
+        {
+            if(err == TM_OK)
+            {
+                err = ddTDA182I2WaitIRQ(pObj, 1500, 50, 0x1F);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+            }
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetLPF_Gain_Mode                                  */
+/*                                                                            */
+/* DESCRIPTION: Free/Freeze LPF Gain                                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetLPF_Gain_Mode
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uMode   /* I: Unknown/Free/Frozen */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        switch(uMode)
+        {
+        case tmddTDA182I2_LPF_Gain_Unknown:
+        default:
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetLPF_Gain_Free(0x%08X, tmddTDA182I2_LPF_Gain_Unknown).", tUnit));
+            break;
+
+        case tmddTDA182I2_LPF_Gain_Free:
+            err = tmddTDA182I2SetAGC5_loop_off(tUnit, False); /* Disable AGC5 loop off */
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC5_loop_off(0x%08X) failed.", tUnit));
+
+            if(err == TM_OK)
+            {
+                err = tmddTDA182I2SetForce_AGC5_gain(tUnit, False); /* Do not force AGC5 gain */
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetForce_AGC5_gain(0x%08X) failed.", tUnit));
+            }
+            break;
+
+        case tmddTDA182I2_LPF_Gain_Frozen:
+            err = tmddTDA182I2SetAGC5_loop_off(tUnit, True); /* Enable AGC5 loop off */
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC5_loop_off(0x%08X) failed.", tUnit));
+
+            if(err == TM_OK)
+            {
+                err = tmddTDA182I2SetForce_AGC5_gain(tUnit, True); /* Force AGC5 gain */
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetForce_AGC5_gain(0x%08X) failed.", tUnit));
+            }
+
+            if(err == TM_OK)
+            {
+                err = tmddTDA182I2SetAGC5_Gain(tUnit, 0);  /* Force gain to 0dB */
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetAGC5_Gain(0x%08X) failed.", tUnit));
+            }
+            break;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetLPF_Gain_Mode                                  */
+/*                                                                            */
+/* DESCRIPTION: Free/Freeze LPF Gain                                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetLPF_Gain_Mode
+(
+ tmUnitSelect_t  tUnit,  /* I: Unit number */
+ UInt8           *puMode /* I/O: Unknown/Free/Frozen */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+    UInt8                   AGC5_loop_off = 0;
+    UInt8                   Force_AGC5_gain = 0;
+    UInt8                   AGC5_Gain = 0;
+
+    /* Test the parameter */
+    if (puMode == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *puMode = tmddTDA182I2_LPF_Gain_Unknown;
+
+        err = tmddTDA182I2GetAGC5_loop_off(tUnit, &AGC5_loop_off);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetAGC5_loop_off(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2GetForce_AGC5_gain(tUnit, &Force_AGC5_gain);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetForce_AGC5_gain(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            err = tmddTDA182I2GetAGC5_Gain(tUnit, &AGC5_Gain);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2GetAGC5_Gain(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            if(AGC5_loop_off==False && Force_AGC5_gain==False)
+            {
+                *puMode = tmddTDA182I2_LPF_Gain_Free;
+            }
+            else if(AGC5_loop_off==True && Force_AGC5_gain==True && AGC5_Gain==0)
+            {
+                *puMode = tmddTDA182I2_LPF_Gain_Frozen;
+            }
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2Write                                             */
+/*                                                                            */
+/* DESCRIPTION: Write in TDA182I2 hardware                                    */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2Write
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          uIndex,     /* I: Start index to write */
+    UInt32          uNbBytes,   /* I: Number of bytes to write */
+    UInt8*          puBytes     /* I: Pointer on an array of bytes */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err = TM_OK;
+    UInt32                  uCounter;
+    UInt8*                  pI2CMap = Null;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* pI2CMap initialization */
+        pI2CMap = &(pObj->I2CMap.uBx00.ID_byte_1) + uIndex;
+
+        /* Save the values written in the Tuner */
+        for (uCounter = 0; uCounter < uNbBytes; uCounter++)
+        {
+            *pI2CMap = puBytes[uCounter];
+            pI2CMap ++;
+        }
+
+        /* Write in the Tuner */
+        err = ddTDA182I2Write(pObj,(UInt8)(uIndex),(UInt8)(uNbBytes));
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2Read                                              */
+/*                                                                            */
+/* DESCRIPTION: Read in TDA182I2 hardware                                     */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2Read
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          uIndex,     /* I: Start index to read */
+    UInt32          uNbBytes,   /* I: Number of bytes to read */
+    UInt8*          puBytes     /* I: Pointer on an array of bytes */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err = TM_OK;
+    UInt32                  uCounter = 0;
+    UInt8*                  pI2CMap = Null;
+
+    /* Test the parameters */
+    if (uNbBytes > TDA182I2_I2C_MAP_NB_BYTES)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* pI2CMap initialization */
+        pI2CMap = &(pObj->I2CMap.uBx00.ID_byte_1) + uIndex;
+
+        /* Read from the Tuner */
+        err = ddTDA182I2Read(pObj,(UInt8)(uIndex),(UInt8)(uNbBytes));
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Copy read values to puBytes */
+            for (uCounter = 0; uCounter < uNbBytes; uCounter++)
+            {
+                *puBytes = (*pI2CMap);
+                pI2CMap ++;
+                puBytes ++;
+            }
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetMS                                             */
+/*                                                                            */
+/* DESCRIPTION: Get the MS bit(s) status                                      */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetMS
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x00 */
+        err = ddTDA182I2Read(pObj, 0x00, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        /* Get value */
+        *puValue = pObj->I2CMap.uBx00.bF.MS ;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIdentity                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the Identity bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIdentity
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt16*         puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x00-0x01 */
+        err = ddTDA182I2Read(pObj, 0x00, 2);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx00.bF.Ident_1 << 8 |  pObj->I2CMap.uBx01.bF.Ident_2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetMinorRevision                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the Revision bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetMinorRevision
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x02 */
+        err = ddTDA182I2Read(pObj, 0x02, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx02.bF.Minor_rev;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetMajorRevision                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the Revision bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetMajorRevision
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x02 */
+        err = ddTDA182I2Read(pObj, 0x02, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx02.bF.Major_rev;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetLO_Lock                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the LO_Lock bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetLO_Lock
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x05 */
+        err = ddTDA182I2Read(pObj, 0x05, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx05.bF.LO_Lock ;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetPowerState                                     */
+/*                                                                            */
+/* DESCRIPTION: Set the power state of the TDA182I2                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetPowerState
+(
+    tmUnitSelect_t              tUnit,      /* I: Unit number */
+    tmddTDA182I2PowerState_t    powerState  /* I: Power state of this device */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read bytes 0x06-0x14 */
+        err = ddTDA182I2Read(pObj, 0x06, 15);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        /* Set digital clock mode*/
+        if(err == TM_OK)
+        {
+            switch (powerState)
+            {
+            case tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndWithSyntheOn:
+            case tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn:
+            case tmddTDA182I2_PowerStandbyWithXtalOn:
+            case tmddTDA182I2_PowerStandby:
+                /* Set 16 Mhz Xtal clock */
+                err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 0);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, 16 Mhz xtal clock) failed.", tUnit));
+                break;
+
+            default:
+                break;
+            }
+        }
+
+        /* Set power state */
+        if(err == TM_OK)
+        {
+            switch (powerState)
+            {
+            case tmddTDA182I2_PowerNormalMode:          
+                pObj->I2CMap.uBx06.bF.SM = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_Synthe = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_LT = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_XT = 0x00;
+                break;
+
+            case tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndWithSyntheOn:
+                pObj->I2CMap.uBx06.bF.SM = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_Synthe = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_LT = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_XT = 0x00;
+                break;
+
+            case tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn:
+                pObj->I2CMap.uBx06.bF.SM = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_Synthe = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_LT = 0x00;
+                pObj->I2CMap.uBx06.bF.SM_XT = 0x00;
+                break;
+
+            case tmddTDA182I2_PowerStandbyWithXtalOn:
+                pObj->I2CMap.uBx06.bF.SM = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_Synthe = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_LT = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_XT = 0x00;
+                break;
+
+            case tmddTDA182I2_PowerStandby:
+                pObj->I2CMap.uBx06.bF.SM = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_Synthe = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_LT = 0x01;
+                pObj->I2CMap.uBx06.bF.SM_XT = 0x01;
+                break;
+
+            default:
+                /* Power state not supported*/
+                return ddTDA182I2_ERR_NOT_SUPPORTED;
+            }
+
+            /* Write byte 0x06 */
+            err = ddTDA182I2Write(pObj, 0x06, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+        }
+
+        /* Set digital clock mode*/
+        if(err == TM_OK)
+        {
+            switch (powerState)
+            {
+            case tmddTDA182I2_PowerNormalMode:            
+                /* Set sigma delta clock*/
+                err = tmddTDA182I2SetDigital_Clock_Mode(tUnit, 1);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetDigital_Clock_Mode(0x%08X, sigma delta clock) failed.", tUnit));
+                break;
+
+            default:
+                break;
+            }
+        }
+
+        if(err == TM_OK)
+        {
+            /* Store powerstate */
+            pObj->curPowerState = powerState;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetPowerState                                     */
+/*                                                                            */
+/* DESCRIPTION: Get the power state of the TDA182I2                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetPowerState
+(
+    tmUnitSelect_t              tUnit,      /* I: Unit number */
+    ptmddTDA182I2PowerState_t   pPowerState /* O: Power state of this device */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Get power state */
+        if ((pObj->I2CMap.uBx06.bF.SM == 0x00) && (pObj->I2CMap.uBx06.bF.SM_Synthe == 0x00) && (pObj->I2CMap.uBx06.bF.SM_LT == 0x00) && (pObj->I2CMap.uBx06.bF.SM_XT == 0x00))
+        {
+            *pPowerState = tmddTDA182I2_PowerNormalMode;
+        }
+        else if ((pObj->I2CMap.uBx06.bF.SM == 0x01) && (pObj->I2CMap.uBx06.bF.SM_Synthe == 0x00) && (pObj->I2CMap.uBx06.bF.SM_LT == 0x00) && (pObj->I2CMap.uBx06.bF.SM_XT == 0x00))
+        {
+            *pPowerState = tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndWithSyntheOn;
+        }
+        else if ((pObj->I2CMap.uBx06.bF.SM == 0x01) && (pObj->I2CMap.uBx06.bF.SM_Synthe == 0x01) && (pObj->I2CMap.uBx06.bF.SM_LT == 0x00) && (pObj->I2CMap.uBx06.bF.SM_XT == 0x00))
+        {
+            *pPowerState = tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn;
+        }
+        else if ((pObj->I2CMap.uBx06.bF.SM == 0x01) && (pObj->I2CMap.uBx06.bF.SM_Synthe == 0x01) && (pObj->I2CMap.uBx06.bF.SM_LT == 0x01) && (pObj->I2CMap.uBx06.bF.SM_XT == 0x00))
+        {
+            *pPowerState = tmddTDA182I2_PowerStandbyWithXtalOn;
+        }
+        else if ((pObj->I2CMap.uBx06.bF.SM == 0x01) && (pObj->I2CMap.uBx06.bF.SM_Synthe == 0x01) && (pObj->I2CMap.uBx06.bF.SM_LT == 0x01) && (pObj->I2CMap.uBx06.bF.SM_XT == 0x01))
+        {  
+            *pPowerState = tmddTDA182I2_PowerStandby;
+        }
+        else
+        {
+            *pPowerState = tmddTDA182I2_PowerMax;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetPower_Level                                    */
+/*                                                                            */
+/* DESCRIPTION: Get the Power_Level bit(s) status                             */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetPower_Level
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+    UInt8                   uValue = 0;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+    if(err == TM_OK)
+    {
+        /* Set IRQ_clear*/
+        err = tmddTDA182I2SetIRQ_Clear(tUnit, 0x10);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIRQ_clear(0x%08X, 0x10) failed.", tUnit));
+    }
+    if(err == TM_OK)
+    {
+        /* Trigger RSSI_Meas */
+        pObj->I2CMap.uBx19.MSM_byte_1 = 0x80;
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /*Trigger MSM_Launch */
+            pObj->I2CMap.uBx1A.bF.MSM_Launch = 1;
+
+            /* Write byte 0x1A */
+            err = ddTDA182I2Write(pObj, 0x1A, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+            pObj->I2CMap.uBx1A.bF.MSM_Launch = 0;
+            if(pObj->bIRQWait)
+            {
+                if(err == TM_OK)
+                {
+                    err = ddTDA182I2WaitIRQ(pObj, 700, 1, 0x10);
+                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+                }
+            }
+        }
+
+        if(err == TM_OK)
+        {
+            /* Read byte 0x07 */
+            err = ddTDA182I2Read(pObj, 0x07, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Get value (limit range) */
+            uValue = pObj->I2CMap.uBx07.bF.Power_Level;
+            if (uValue < TDA182I2_POWER_LEVEL_MIN)
+            {
+                *puValue = 0x00;
+            }
+            else if (uValue > TDA182I2_POWER_LEVEL_MAX)
+            {
+                *puValue = 0xFF;
+            }
+            else
+            {
+                *puValue = uValue;
+            }
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIRQ_status                                     */
+/*                                                                            */
+/* DESCRIPTION: Get the IRQ_status bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIRQ_status
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x08 */
+        err = ddTDA182I2GetIRQ_status(pObj, puValue);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetIRQ_status(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetMSM_XtalCal_End                                */
+/*                                                                            */
+/* DESCRIPTION: Get the MSM_XtalCal_End bit(s) status                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetMSM_XtalCal_End
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x08 */
+        err = ddTDA182I2GetMSM_XtalCal_End(pObj, puValue);
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIRQ_Clear                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the IRQ_Clear bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIRQ_Clear
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt8           irqStatus   /* I: IRQs to clear */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set IRQ_Clear */
+        /*pObj->I2CMap.uBx0A.bF.IRQ_Clear = 1; */
+        pObj->I2CMap.uBx0A.IRQ_clear |= (0x80|(irqStatus&0x1F));
+
+        /* Write byte 0x0A */
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        /* Reset IRQ_Clear (buffer only, no write) */
+        /*pObj->I2CMap.uBx0A.bF.IRQ_Clear = 0;*/
+        pObj->I2CMap.uBx0A.IRQ_clear &= (~(0x80|(irqStatus&0x1F)));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC1_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC1_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC1_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0C.bF.AGC1_TOP = uValue;
+
+        /* write byte 0x0C */
+        err = ddTDA182I2Write(pObj, 0x0C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC1_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC1_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC1_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if ( puValue == Null )
+    {
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+    }       
+
+    /* Get Instance Object */
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+    
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+        
+        if(err == TM_OK)
+        {
+            /* Read byte 0x0C */
+            err = ddTDA182I2Read(pObj, 0x0C, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+    
+            if(err == TM_OK)
+            {
+                /* Get value */
+                *puValue = pObj->I2CMap.uBx0C.bF.AGC1_TOP;
+            }
+    
+            (void)ddTDA182I2MutexRelease(pObj);
+        }
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC2_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC2_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC2_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* set value */
+        pObj->I2CMap.uBx0D.bF.AGC2_TOP = uValue;
+
+        /* Write byte 0x0D */
+        err = ddTDA182I2Write(pObj, 0x0D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC2_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC2_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC2_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0D */
+        err = ddTDA182I2Read(pObj, 0x0D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0D.bF.AGC2_TOP;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGCs_Up_Step                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the AGCs_Up_Step bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGCs_Up_Step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0E.bF.AGCs_Up_Step = uValue;
+
+        /* Write byte 0x0E */
+        err = ddTDA182I2Write(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGCs_Up_Step                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the AGCs_Up_Step bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGCs_Up_Step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0E */
+        err = ddTDA182I2Read(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0E.bF.AGCs_Up_Step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGCK_Step                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the AGCK_Step bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGCK_Step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0E.bF.AGCK_Step = uValue;
+
+        /* Write byte 0x0E */
+        err = ddTDA182I2Write(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGCK_Step                                      */
+/*                                                                            */
+/* DESCRIPTION: Get the AGCK_Step bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGCK_Step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0E */
+        err = ddTDA182I2Read(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0E.bF.AGCK_Step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGCK_Mode                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the AGCK_Mode bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGCK_Mode
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0E.bF.AGCK_Mode = uValue;
+
+        /* Write byte 0x0E */
+        err = ddTDA182I2Write(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGCK_Mode                                      */
+/*                                                                            */
+/* DESCRIPTION: Get the AGCK_Mode bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGCK_Mode
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0E */
+        err = ddTDA182I2Read(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0E.bF.AGCK_Mode;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetPD_RFAGC_Adapt                                 */
+/*                                                                            */
+/* DESCRIPTION: Set the PD_RFAGC_Adapt bit(s) status                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetPD_RFAGC_Adapt
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0F.bF.PD_RFAGC_Adapt = uValue;
+
+        /* Write byte 0x0F */
+        err = ddTDA182I2Write(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetPD_RFAGC_Adapt                                 */
+/*                                                                            */
+/* DESCRIPTION: Get the PD_RFAGC_Adapt bit(s) status                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetPD_RFAGC_Adapt
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0F */
+        err = ddTDA182I2Read(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0F.bF.PD_RFAGC_Adapt;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRFAGC_Adapt_TOP                                */
+/*                                                                            */
+/* DESCRIPTION: Set the RFAGC_Adapt_TOP bit(s) status                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRFAGC_Adapt_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0F.bF.RFAGC_Adapt_TOP = uValue;
+
+        /* Write byte 0x0F */
+        err = ddTDA182I2Write(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRFAGC_Adapt_TOP                                */
+/*                                                                            */
+/* DESCRIPTION: Get the RFAGC_Adapt_TOP bit(s) status                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRFAGC_Adapt_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0F */
+        err = ddTDA182I2Read(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0F.bF.RFAGC_Adapt_TOP;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRF_Atten_3dB                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the RF_Atten_3dB bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRF_Atten_3dB
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0F.bF.RF_Atten_3dB = uValue;
+
+        /* Write byte 0x0F */
+        err = ddTDA182I2Write(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRF_Atten_3dB                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the RF_Atten_3dB bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRF_Atten_3dB
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0F */
+        err = ddTDA182I2Read(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0F.bF.RF_Atten_3dB;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRFAGC_Top                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the RFAGC_Top bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRFAGC_Top
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx0F.bF.RFAGC_Top = uValue;
+
+        /* Write byte 0x0F */
+        err = ddTDA182I2Write(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRFAGC_Top                                      */
+/*                                                                            */
+/* DESCRIPTION: Get the RFAGC_Top bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRFAGC_Top
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x0F */
+        err = ddTDA182I2Read(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx0F.bF.RFAGC_Top;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIR_Mixer_Top                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the IR_Mixer_Top bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIR_Mixer_Top
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx10.bF.IR_Mixer_Top = uValue;
+
+        /* Write byte 0x10 */
+        err = ddTDA182I2Write(pObj, 0x10, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIR_Mixer_Top                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the IR_Mixer_Top bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIR_Mixer_Top
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x10 */
+        err = ddTDA182I2Read(pObj, 0x10, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx10.bF.IR_Mixer_Top;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC5_Ana                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC5_Ana bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC5_Ana
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx11.bF.AGC5_Ana = uValue;
+
+        /* Write byte 0x11 */
+        err = ddTDA182I2Write(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC5_Ana                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC5_Ana bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC5_Ana
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x11 */
+        err = ddTDA182I2Read(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx11.bF.AGC5_Ana;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC5_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC5_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC5_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx11.bF.AGC5_TOP = uValue;
+
+        /* Write byte 0x11 */
+        err = ddTDA182I2Write(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC5_TOP                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC5_TOP bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC5_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x11 */
+        err = ddTDA182I2Read(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx11.bF.AGC5_TOP;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIF_Level                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the IF_level bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIF_Level
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx12.bF.IF_level = uValue;
+
+        /* Write byte 0x12 */
+        err = ddTDA182I2Write(pObj, 0x12, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIF_Level                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the IF_level bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIF_Level
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x12 */
+        err = ddTDA182I2Read(pObj, 0x12, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx12.bF.IF_level;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIF_HP_Fc                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the IF_HP_Fc bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIF_HP_Fc
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx13.bF.IF_HP_Fc = uValue;
+
+        /* Write byte 0x13 */
+        err = ddTDA182I2Write(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIF_HP_Fc                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the IF_HP_Fc bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIF_HP_Fc
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x13 */
+        err = ddTDA182I2Read(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx13.bF.IF_HP_Fc;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIF_ATSC_Notch                                  */
+/*                                                                            */
+/* DESCRIPTION: Set the IF_ATSC_Notch bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIF_ATSC_Notch
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx13.bF.IF_ATSC_Notch = uValue;
+
+        /* Write byte 0x13 */
+        err = ddTDA182I2Write(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIF_ATSC_Notch                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the IF_ATSC_Notch bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIF_ATSC_Notch
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x13 */
+        err = ddTDA182I2Read(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx13.bF.IF_ATSC_Notch;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetLP_FC_Offset                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the LP_FC_Offset bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetLP_FC_Offset
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx13.bF.LP_FC_Offset = uValue;
+
+        /* Write byte 0x13 */
+        err = ddTDA182I2Write(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetLP_FC_Offset                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the LP_FC_Offset bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetLP_FC_Offset
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x13 */
+        err = ddTDA182I2Read(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx13.bF.LP_FC_Offset;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetLP_FC                                          */
+/*                                                                            */
+/* DESCRIPTION: Set the LP_Fc bit(s) status                                   */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetLP_FC
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx13.bF.LP_Fc = uValue;
+
+        /* Write byte 0x13 */
+        err = ddTDA182I2Write(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetLP_FC                                          */
+/*                                                                            */
+/* DESCRIPTION: Get the LP_Fc bit(s) status                                   */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetLP_FC
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x13 */
+        err = ddTDA182I2Read(pObj, 0x13, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx13.bF.LP_Fc;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetDigital_Clock_Mode                             */
+/*                                                                            */
+/* DESCRIPTION: Set the Digital_Clock_Mode bit(s) status                      */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetDigital_Clock_Mode
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx14.bF.Digital_Clock_Mode = uValue;
+
+        /* Write byte 0x14 */
+        err = ddTDA182I2Write(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetDigital_Clock_Mode                             */
+/*                                                                            */
+/* DESCRIPTION: Get the Digital_Clock_Mode bit(s) status                      */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetDigital_Clock_Mode
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x14 */
+        err = ddTDA182I2Read(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx14.bF.Digital_Clock_Mode;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIF_Freq                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the IF_Freq bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIF_Freq
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32          uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx15.bF.IF_Freq = (UInt8)(uValue / 50000);
+
+        /* Write byte 0x15 */
+        err = ddTDA182I2Write(pObj, 0x15, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIF_Freq                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the IF_Freq bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIF_Freq
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*         puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x15 */
+        err = ddTDA182I2Read(pObj, 0x15, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx15.bF.IF_Freq * 50000;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRF_Freq                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the RF_Freq bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRF_Freq
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32          uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+    UInt32                  uRF = 0;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /*****************************************/
+        /* Tune the settings that depend on the RF input frequency, expressed in kHz.*/
+        /* RF filters tuning, PLL locking*/
+        /* State reached after 5ms*/
+
+        if(err == TM_OK)
+        {
+            /* Set IRQ_clear */
+            err = tmddTDA182I2SetIRQ_Clear(tUnit, 0x0C);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetIRQ_clear(0x%08X, 0x0C) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set power state ON */
+            err = tmddTDA182I2SetPowerState(tUnit, tmddTDA182I2_PowerNormalMode);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "tmddTDA182I2SetPowerState(0x%08X, PowerNormalMode) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set RF frequency expressed in kHz */
+            uRF = uValue / 1000;
+            pObj->I2CMap.uBx16.bF.RF_Freq_1 = (UInt8)((uRF & 0x00FF0000) >> 16);
+            pObj->I2CMap.uBx17.bF.RF_Freq_2 = (UInt8)((uRF & 0x0000FF00) >> 8);
+            pObj->I2CMap.uBx18.bF.RF_Freq_3 = (UInt8)(uRF & 0x000000FF);
+
+            /* write bytes 0x16 to 0x18*/
+            err = ddTDA182I2Write(pObj, 0x16, 3);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            /* Set & trigger MSM */
+            pObj->I2CMap.uBx19.MSM_byte_1 = 0x41;
+            pObj->I2CMap.uBx1A.MSM_byte_2 = 0x01;
+
+            /* Write bytes 0x19 to 0x1A */
+            err = ddTDA182I2Write(pObj, 0x19, 2);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+            pObj->I2CMap.uBx1A.MSM_byte_2 = 0x00;
+        }
+        if(pObj->bIRQWait)
+        {
+            if(err == TM_OK)
+            {
+                err = ddTDA182I2WaitIRQ(pObj, 50, 5, 0x0C);
+                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+            }
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRF_Freq                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the RF_Freq bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRF_Freq
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*         puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read bytes 0x16 to 0x18 */
+        err = ddTDA182I2Read(pObj, 0x16, 3);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = (pObj->I2CMap.uBx16.bF.RF_Freq_1 << 16) | (pObj->I2CMap.uBx17.bF.RF_Freq_2 << 8) | pObj->I2CMap.uBx18.bF.RF_Freq_3;
+            *puValue = *puValue * 1000;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetMSM_Launch                                     */
+/*                                                                            */
+/* DESCRIPTION: Set the MSM_Launch bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetMSM_Launch
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1A.bF.MSM_Launch = 1;
+
+        /* Write byte 0x1A */
+        err = ddTDA182I2Write(pObj, 0x1A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        /* reset MSM_Launch (buffer only, no write) */
+        pObj->I2CMap.uBx1A.bF.MSM_Launch = 0x00;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetMSM_Launch                                     */
+/*                                                                            */
+/* DESCRIPTION: Get the MSM_Launch bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetMSM_Launch
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1A */
+        err = ddTDA182I2Read(pObj, 0x1A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1A.bF.MSM_Launch;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetPSM_StoB                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the PSM_StoB bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetPSM_StoB
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1B.bF.PSM_StoB = uValue;
+
+        /* Read byte 0x1B */
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetPSM_StoB                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the PSM_StoB bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetPSM_StoB
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1B */
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1B.bF.PSM_StoB;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetFmax_Lo                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the Fmax_Lo bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetFmax_Lo
+(
+    tmUnitSelect_t  tUnit,  //  I: Unit number
+    UInt8           uValue  //  I: Item value
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1D.bF.Fmax_Lo = uValue;
+
+        // read byte 0x1D
+        err = ddTDA182I2Write(pObj, 0x1D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetFmax_Lo                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the Fmax_Lo bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetFmax_Lo
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1D
+        err = ddTDA182I2Read(pObj, 0x1D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1D.bF.Fmax_Lo;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIR_Loop                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the IR_Loop bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIR_Loop
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1E.bF.IR_Loop = uValue - 4;
+
+        /* Read byte 0x1E */
+        err = ddTDA182I2Write(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIR_Loop                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the IR_Loop bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIR_Loop
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1E */
+        err = ddTDA182I2Read(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1E.bF.IR_Loop + 4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIR_Target                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the IR_Target bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIR_Target
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1E.bF.IR_Target = uValue;
+
+        /* Read byte 0x1E */
+        err = ddTDA182I2Write(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIR_Target                                      */
+/*                                                                            */
+/* DESCRIPTION: Get the IR_Target bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIR_Target
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1E */
+        err = ddTDA182I2Read(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1E.bF.IR_Target;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIR_Corr_Boost                                  */
+/*                                                                            */
+/* DESCRIPTION: Set the IR_Corr_Boost bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIR_Corr_Boost
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1F.bF.IR_Corr_Boost = uValue;
+
+        /* Read byte 0x1F */
+        err = ddTDA182I2Write(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIR_Corr_Boost                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the IR_Corr_Boost bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIR_Corr_Boost
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1F */
+        err = ddTDA182I2Read(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1F.bF.IR_Corr_Boost;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIR_mode_ram_store                              */
+/*                                                                            */
+/* DESCRIPTION: Set the IR_mode_ram_store bit(s) status                       */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIR_mode_ram_store
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx1F.bF.IR_mode_ram_store = uValue;
+
+        /* Write byte 0x1F */
+        err = ddTDA182I2Write(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIR_mode_ram_store                              */
+/*                                                                            */
+/* DESCRIPTION: Get the IR_mode_ram_store bit(s) status                       */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIR_mode_ram_store
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x1F */
+        err = ddTDA182I2Read(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx1F.bF.IR_mode_ram_store;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetPD_Udld                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the PD_Udld bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetPD_Udld
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx22.bF.PD_Udld = uValue;
+
+        /* Write byte 0x22 */
+        err = ddTDA182I2Write(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetPD_Udld                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the PD_Udld bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetPD_Udld
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x22 */
+        err = ddTDA182I2Read(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx22.bF.PD_Udld;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC_Ovld_TOP                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC_Ovld_TOP bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC_Ovld_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx22.bF.AGC_Ovld_TOP = uValue;
+
+        /* Write byte 0x22 */
+        err = ddTDA182I2Write(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC_Ovld_TOP                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC_Ovld_TOP bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC_Ovld_TOP
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x22 */
+        err = ddTDA182I2Read(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx22.bF.AGC_Ovld_TOP;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetHi_Pass                                        */
+/*                                                                            */
+/* DESCRIPTION: Set the Hi_Pass bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetHi_Pass
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx23.bF.Hi_Pass = uValue;
+
+        /* Read byte 0x23 */
+        err = ddTDA182I2Write(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetHi_Pass                                        */
+/*                                                                            */
+/* DESCRIPTION: Get the Hi_Pass bit(s) status                                 */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetHi_Pass
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x23 */
+        err = ddTDA182I2Read(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx23.bF.Hi_Pass;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIF_Notch                                       */
+/*                                                                            */
+/* DESCRIPTION: Set the IF_Notch bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIF_Notch
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx23.bF.IF_Notch = uValue;
+
+        /* Read byte 0x23 */
+        err = ddTDA182I2Write(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIF_Notch                                       */
+/*                                                                            */
+/* DESCRIPTION: Get the IF_Notch bit(s) status                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIF_Notch
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x23 */
+        err = ddTDA182I2Read(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx23.bF.IF_Notch;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC5_loop_off                                  */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC5_loop_off bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC5_loop_off
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx25.bF.AGC5_loop_off = uValue;
+
+        /* Read byte 0x25 */
+        err = ddTDA182I2Write(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC5_loop_off                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC5_loop_off bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC5_loop_off
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x25 */
+        err = ddTDA182I2Read(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx25.bF.AGC5_loop_off;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC5_Do_step                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC5_Do_step bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC5_Do_step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx25.bF.AGC5_Do_step = uValue;
+
+        /* Read byte 0x25 */
+        err = ddTDA182I2Write(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC5_Do_step                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC5_Do_step bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC5_Do_step
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x25 */
+        err = ddTDA182I2Read(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx25.bF.AGC5_Do_step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetForce_AGC5_gain                                */
+/*                                                                            */
+/* DESCRIPTION: Set the Force_AGC5_gain bit(s) status                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetForce_AGC5_gain
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx25.bF.Force_AGC5_gain = uValue;
+
+        /* Read byte 0x25 */
+        err = ddTDA182I2Write(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetForce_AGC5_gain                                */
+/*                                                                            */
+/* DESCRIPTION: Get the Force_AGC5_gain bit(s) status                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetForce_AGC5_gain
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x25 */
+        err = ddTDA182I2Read(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx25.bF.Force_AGC5_gain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetAGC5_Gain                                      */
+/*                                                                            */
+/* DESCRIPTION: Set the AGC5_Gain bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetAGC5_Gain
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx25.bF.AGC5_Gain = uValue;
+
+        /* Read byte 0x25 */
+        err = ddTDA182I2Write(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetAGC5_Gain                                      */
+/*                                                                            */
+/* DESCRIPTION: Get the AGC5_Gain bit(s) status                               */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetAGC5_Gain
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x25 */
+        err = ddTDA182I2Read(pObj, 0x25, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx25.bF.AGC5_Gain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRF_Filter_Bypass                               */
+/*                                                                            */
+/* DESCRIPTION: Set the RF_Filter_Bypass bit(s) status                        */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRF_Filter_Bypass
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx2C.bF.RF_Filter_Bypass = uValue;
+
+        /* Read byte 0x2C */
+        err = ddTDA182I2Write(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRF_Filter_Bypass                               */
+/*                                                                            */
+/* DESCRIPTION: Get the RF_Filter_Bypass bit(s) status                        */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRF_Filter_Bypass
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x2C */
+        err = ddTDA182I2Read(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx2C.bF.RF_Filter_Bypass;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRF_Filter_Band                                 */
+/*                                                                            */
+/* DESCRIPTION: Set the RF_Filter_Band bit(s) status                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRF_Filter_Band
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx2C.bF.RF_Filter_Band = uValue;
+
+        /* Read byte 0x2C */
+        err = ddTDA182I2Write(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRF_Filter_Band                                 */
+/*                                                                            */
+/* DESCRIPTION: Get the RF_Filter_Band bit(s) status                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRF_Filter_Band
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x2C */
+        err = ddTDA182I2Read(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx2C.bF.RF_Filter_Band;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRF_Filter_Cap                                  */
+/*                                                                            */
+/* DESCRIPTION: Set the RF_Filter_Cap bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRF_Filter_Cap
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx2D.bF.RF_Filter_Cap = uValue;
+
+        /* Read byte 0x2D */
+        err = ddTDA182I2Write(pObj, 0x2D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRF_Filter_Cap                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the RF_Filter_Cap bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRF_Filter_Cap
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x2D */
+        err = ddTDA182I2Read(pObj, 0x2D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx2D.bF.RF_Filter_Cap;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetGain_Taper                                     */
+/*                                                                            */
+/* DESCRIPTION: Set the Gain_Taper bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetGain_Taper
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx2E.bF.Gain_Taper = uValue;
+
+        /* Read byte 0x2E */
+        err = ddTDA182I2Write(pObj, 0x2E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetGain_Taper                                     */
+/*                                                                            */
+/* DESCRIPTION: Get the Gain_Taper bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetGain_Taper
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if( puValue == Null )
+    {
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+    }
+
+    /* Get Instance Object */
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+
+        if(err == TM_OK)
+        {
+            /* Read byte 0x2E */
+            err = ddTDA182I2Read(pObj, 0x2E, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+    
+            if(err == TM_OK)
+            {
+                /* Get value */
+                *puValue = pObj->I2CMap.uBx2E.bF.Gain_Taper;
+            }
+    
+            (void)ddTDA182I2MutexRelease(pObj);
+        }
+    }
+    
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetN_CP_Current                                   */
+/*                                                                            */
+/* DESCRIPTION: Set the N_CP_Current bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetN_CP_Current
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx30.bF.N_CP_Current = uValue;
+
+        /* Read byte 0x30 */
+        err = ddTDA182I2Write(pObj, 0x30, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetN_CP_Current                                   */
+/*                                                                            */
+/* DESCRIPTION: Get the N_CP_Current bit(s) status                            */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetN_CP_Current
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x30 */
+        err = ddTDA182I2Read(pObj, 0x30, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx30.bF.N_CP_Current;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRSSI_Ck_Speed                                  */
+/*                                                                            */
+/* DESCRIPTION: Set the RSSI_Ck_Speed bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRSSI_Ck_Speed
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx36.bF.RSSI_Ck_Speed = uValue;
+
+        /* Write byte 0x36 */
+        err = ddTDA182I2Write(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRSSI_Ck_Speed                                  */
+/*                                                                            */
+/* DESCRIPTION: Get the RSSI_Ck_Speed bit(s) status                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRSSI_Ck_Speed
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x36 */
+        err = ddTDA182I2Read(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx36.bF.RSSI_Ck_Speed;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetRFCAL_Phi2                                     */
+/*                                                                            */
+/* DESCRIPTION: Set the RFCAL_Phi2 bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Phi2
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  /* I: Item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Set value */
+        pObj->I2CMap.uBx37.bF.RFCAL_Phi2 = uValue;
+
+        /* Write byte 0x37 */
+        err = ddTDA182I2Write(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetRFCAL_Phi2                                     */
+/*                                                                            */
+/* DESCRIPTION: Get the RFCAL_Phi2 bit(s) status                              */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Phi2
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x37 */
+        err = ddTDA182I2Read(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx37.bF.RFCAL_Phi2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2WaitIRQ                                           */
+/*                                                                            */
+/* DESCRIPTION: Wait the IRQ to trigger                                       */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2WaitIRQ
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          timeOut,    /* I: timeout */
+    UInt32          waitStep,   /* I: wait step */
+    UInt8           irqStatus   /* I: IRQs to wait */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2WaitIRQ(pObj, timeOut, waitStep, irqStatus);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2WaitXtalCal_End                                   */
+/*                                                                            */
+/* DESCRIPTION: Wait the MSM_XtalCal_End to trigger                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2WaitXtalCal_End
+(
+    tmUnitSelect_t  tUnit,      /* I: Unit number */
+    UInt32          timeOut,    /* I: timeout */
+    UInt32          waitStep    /* I: wait step */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2WaitXtalCal_End(pObj, timeOut, waitStep);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitXtalCal_End(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2SetIRQWait                                        */
+/*                                                                            */
+/* DESCRIPTION: Set whether wait IRQ in driver or not                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2SetIRQWait
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool            bWait   /* I: Determine if we need to wait IRQ in driver functions */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        pObj->bIRQWait = bWait;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    tmddTDA182I2GetIRQWait                                        */
+/*                                                                            */
+/* DESCRIPTION: Get whether wait IRQ in driver or not                         */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2GetIRQWait
+(
+    tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool*           pbWait  /* O: Determine if we need to wait IRQ in driver functions */
+)
+{     
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (pbWait == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        *pbWait = pObj->bIRQWait;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2GetIRQ_status                                       */
+/*                                                                            */
+/* DESCRIPTION: Get IRQ status                                                */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2GetIRQ_status
+(
+    ptmddTDA182I2Object_t   pObj,   /* I: Instance object */
+    UInt8*                  puValue /* I: Address of the variable to output item value */
+)
+{     
+    tmErrorCode_t   err  = TM_OK;
+
+    /* Read byte 0x08 */
+    err = ddTDA182I2Read(pObj, 0x08, 1);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", pObj->tUnit));
+
+    if(err == TM_OK)
+    {
+        /* Get value */
+        *puValue = pObj->I2CMap.uBx08.bF.IRQ_status;
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2GetMSM_XtalCal_End                                  */
+/*                                                                            */
+/* DESCRIPTION: Get MSM_XtalCal_End bit(s) status                             */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2GetMSM_XtalCal_End
+(
+    ptmddTDA182I2Object_t   pObj,   /* I: Instance object */
+    UInt8*                  puValue /* I: Address of the variable to output item value */
+)
+{
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Test the parameters */
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Read byte 0x08 */
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", pObj->tUnit));
+
+        if(err == TM_OK)
+        {
+            /* Get value */
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_XtalCal_End;
+        }
+    }
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2WaitIRQ                                             */
+/*                                                                            */
+/* DESCRIPTION: Wait for IRQ to trigger                                       */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2WaitIRQ
+(
+    ptmddTDA182I2Object_t   pObj,       /* I: Instance object */
+    UInt32                  timeOut,    /* I: timeout */
+    UInt32                  waitStep,   /* I: wait step */
+    UInt8                   irqStatus   /* I: IRQs to wait */
+)
+{     
+    tmErrorCode_t   err  = TM_OK;
+    UInt32          counter = timeOut/waitStep; /* Wait max timeOut/waitStep ms */
+    UInt8           uIRQ = 0;
+    UInt8           uIRQStatus = 0;
+    Bool            bIRQTriggered = False;
+
+    while(err == TM_OK && (--counter)>0)
+    {
+        err = ddTDA182I2GetIRQ_status(pObj, &uIRQ);
+
+        if(err == TM_OK && uIRQ == 1)
+        {
+            bIRQTriggered = True;
+        }
+
+        if(bIRQTriggered)
+        {
+            /* IRQ triggered => Exit */
+            break;
+        }
+
+        if(err == TM_OK && irqStatus != 0x00)
+        {
+            uIRQStatus = ((pObj->I2CMap.uBx08.IRQ_status)&0x1F);
+
+            if(irqStatus == uIRQStatus)
+            {
+                bIRQTriggered = True;
+            }
+        }
+
+        err = ddTDA182I2Wait(pObj, waitStep);
+    }
+
+    if(counter == 0)
+    {
+        err = ddTDA182I2_ERR_NOT_READY;
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2WaitXtalCal_End                                     */
+/*                                                                            */
+/* DESCRIPTION: Wait for MSM_XtalCal_End to trigger                           */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2WaitXtalCal_End
+(
+    ptmddTDA182I2Object_t   pObj,       /* I: Instance object */
+    UInt32                  timeOut,    /* I: timeout */
+    UInt32                  waitStep    /* I: wait step */
+)
+{     
+    tmErrorCode_t   err  = TM_OK;
+    UInt32          counter = timeOut/waitStep; /* Wait max timeOut/waitStepms */
+    UInt8           uMSM_XtalCal_End = 0;
+
+    while(err == TM_OK && (--counter)>0)
+    {
+        err = ddTDA182I2GetMSM_XtalCal_End(pObj, &uMSM_XtalCal_End);
+
+        if(uMSM_XtalCal_End == 1)
+        {
+            /* MSM_XtalCal_End triggered => Exit */
+            break;
+        }
+
+        ddTDA182I2Wait(pObj, waitStep);
+    }
+
+    if(counter == 0)
+    {
+        err = ddTDA182I2_ERR_NOT_READY;
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2Write                                               */
+/*                                                                            */
+/* DESCRIPTION: Write in TDA182I2 hardware                                    */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t 
+ddTDA182I2Write
+(
+    ptmddTDA182I2Object_t   pObj,           /* I: Driver object */
+    UInt8                   uSubAddress,    /* I: sub address */
+    UInt8                   uNbData         /* I: nb of data */
+)
+{
+    tmErrorCode_t   err = TM_OK;
+    UInt8*          pI2CMap = Null;
+
+    /* pI2CMap initialization */
+    pI2CMap = &(pObj->I2CMap.uBx00.ID_byte_1);
+
+    err = POBJ_SRVFUNC_SIO.Write (pObj->tUnitW, 1, &uSubAddress, uNbData, &(pI2CMap[uSubAddress]));
+
+    /* return value */
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2Read                                                */
+/*                                                                            */
+/* DESCRIPTION: Read in TDA182I2 hardware                                     */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t 
+ddTDA182I2Read
+(
+    ptmddTDA182I2Object_t   pObj,           /* I: Driver object */
+    UInt8                   uSubAddress,    /* I: sub address */
+    UInt8                   uNbData         /* I: nb of data */
+)
+{
+    tmErrorCode_t   err = TM_OK;
+    UInt8*          pI2CMap = Null;
+
+    /* pRegister initialization */
+    pI2CMap = &(pObj->I2CMap.uBx00.ID_byte_1) + uSubAddress;
+
+    /* Read data from the Tuner */
+    err = POBJ_SRVFUNC_SIO.Read(pObj->tUnitW, 1, &uSubAddress, uNbData, pI2CMap);
+
+    /* return value */
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2Wait                                                */
+/*                                                                            */
+/* DESCRIPTION: Wait for the requested time                                   */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t 
+ddTDA182I2Wait
+(
+    ptmddTDA182I2Object_t   pObj,   /* I: Driver object */
+    UInt32                  Time    /*  I: time to wait for */
+)
+{
+    tmErrorCode_t   err  = TM_OK;
+
+    /* wait Time ms */
+    err = POBJ_SRVFUNC_STIME.Wait (pObj->tUnit, Time);
+
+    /* Return value */
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2MutexAcquire                                        */
+/*                                                                            */
+/* DESCRIPTION: Acquire driver mutex                                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2MutexAcquire
+(
+    ptmddTDA182I2Object_t   pObj,
+    UInt32                  timeOut
+)
+{
+    tmErrorCode_t   err = TM_OK;
+
+    if(pObj->sMutex.Acquire != Null && pObj->pMutex != Null)
+    {
+        err = pObj->sMutex.Acquire(pObj->pMutex, timeOut);
+    }
+
+    return err;
+}
+
+/*============================================================================*/
+/* FUNCTION:    ddTDA182I2MutexRelease                                        */
+/*                                                                            */
+/* DESCRIPTION: Release driver mutex                                          */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+ddTDA182I2MutexRelease
+(
+    ptmddTDA182I2Object_t   pObj
+)
+{
+    tmErrorCode_t   err = TM_OK;
+
+    if(pObj->sMutex.Release != Null && pObj->pMutex != Null)
+    {
+        err = pObj->sMutex.Release(pObj->pMutex);
+    }
+
+    return err;
+}
+/*============================================================================*/
+/* FUNCTION:    tmTDA182I2AGC1_change                                           */
+/*                                                                            */
+/* DESCRIPTION: adapt AGC1_gain from latest call  ( simulate AGC1 gain free ) */
+/*                                                                            */
+/* RETURN:      TM_OK if no error                                             */
+/*                                                                            */
+/* NOTES:                                                                     */
+/*                                                                            */
+/*============================================================================*/
+tmErrorCode_t
+tmddTDA182I2AGC1_Adapt
+(
+    tmUnitSelect_t  tUnit   /* I: Unit number */
+)
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+	tmErrorCode_t   err  = TM_OK;
+    UInt8 counter, vAGC1min, vAGC1_max_step;
+	Int16 TotUp , TotDo ;
+	UInt8 NbStepsDone = 0;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+	if (pObj->I2CMap.uBx0C.bF.AGC1_6_15dB == 0)
+	{
+		vAGC1min = 0; // -12 dB
+		vAGC1_max_step = 10;  // -12 +15 dB
+	}
+	else
+	{
+		vAGC1min = 6; // 6 dB
+		vAGC1_max_step = 4;  // 6 -> 15 dB
+	}
+
+	while(err == TM_OK && NbStepsDone < vAGC1_max_step)  // limit to min - max steps 10
+	{
+		counter = 0; TotUp = 0; TotDo = 0; NbStepsDone = NbStepsDone + 1;
+		while(err == TM_OK && (counter++)<40)
+		{
+			err = ddTDA182I2Read(pObj, 0x31, 1);  /* read UP , DO AGC1 */
+			tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+			TotDo = TotDo + ( pObj->I2CMap.uBx31.bF.Do_AGC1 ? 14 : -1 );
+			TotUp = TotUp + ( pObj->I2CMap.uBx31.bF.Up_AGC1 ? 1 : -4 );
+			err = ddTDA182I2Wait(pObj, 1);
+		}
+		if ( TotUp >= 15 && pObj->I2CMap.uBx24.bF.AGC1_Gain != 9 ) 
+		{
+			pObj->I2CMap.uBx24.bF.AGC1_Gain = pObj->I2CMap.uBx24.bF.AGC1_Gain + 1;
+   		    err = ddTDA182I2Write(pObj, 0x24, 1);
+			tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+		}
+		else if ( TotDo >= 10 && pObj->I2CMap.uBx24.bF.AGC1_Gain != vAGC1min  ) 
+		{
+			pObj->I2CMap.uBx24.bF.AGC1_Gain = pObj->I2CMap.uBx24.bF.AGC1_Gain - 1;
+   		    err = ddTDA182I2Write(pObj, 0x24, 1);
+			tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+		}
+		else
+		{
+			NbStepsDone = vAGC1_max_step;
+		}
+	}
+    return err;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\src\tmddTDA182I2Instance.c
+
+
+/*-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2008 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmddTDA182I2Instance.c
+//
+// DESCRIPTION:  define the static Objects
+//
+// DOCUMENT REF: DVP Software Coding Guidelines v1.14
+//               DVP Board Support Library Architecture Specification v0.5
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+*/
+
+//#include "tmNxTypes.h"
+//#include "tmCompId.h"
+//#include "tmFrontEnd.h"
+//#include "tmUnitParams.h"
+//#include "tmbslFrontEndTypes.h"
+
+//#include "tmddTDA182I2.h"
+//#include "tmddTDA182I2local.h"
+
+//#include "tmddTDA182I2Instance.h"
+
+/*-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+//
+*/
+
+
+/* default instance */
+tmddTDA182I2Object_t gddTDA182I2Instance[] = 
+{
+    {
+        (tmUnitSelect_t)(-1),           /* Unit not set */
+        (tmUnitSelect_t)(-1),           /* UnitW not set */
+        Null,                           /* pMutex */
+        False,                          /* init (instance initialization default) */
+        {                               /* sRWFunc */
+            Null,
+            Null
+        },
+        {                               /* sTime */
+            Null,
+            Null
+        },
+        {                               /* sDebug */
+            Null
+        },
+        {                               /* sMutex */
+            Null,
+            Null,
+            Null,
+            Null
+        },
+        tmddTDA182I2_PowerStandbyWithXtalOn,    /* curPowerState */
+        True,                                   /* bIRQWait */
+        {
+            0  // I2CMap;
+        }
+    },
+    {
+        (tmUnitSelect_t)(-1),           /* Unit not set */
+        (tmUnitSelect_t)(-1),           /* UnitW not set */
+        Null,                           /* pMutex */
+        False,                          /* init (instance initialization default) */
+        {                               /* sRWFunc */
+            Null,
+            Null
+        },
+        {                               /* sTime */
+            Null,
+            Null
+        },
+        {                               /* sDebug */
+            Null
+        },
+        {                               /* sMutex */
+            Null,
+            Null,
+            Null,
+            Null
+        },
+        tmddTDA182I2_PowerStandbyWithXtalOn,    /* curPowerState */
+        True,                                   /* bIRQWait */
+        {
+            0  // I2CMap;
+        }
+    }
+};
+
+/*-----------------------------------------------------------------------------
+// FUNCTION:    ddTDA182I2AllocInstance:
+//
+// DESCRIPTION: allocate new instance
+//
+// RETURN:      
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+ddTDA182I2AllocInstance
+(
+ tmUnitSelect_t          tUnit,      /* I: Unit number */
+ pptmddTDA182I2Object_t    ppDrvObject /* I: Device Object */
+ )
+{ 
+    tmErrorCode_t       err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+    ptmddTDA182I2Object_t pObj = Null;
+    UInt32              uLoopCounter = 0;    
+
+    /* Find a free instance */
+    for(uLoopCounter = 0; uLoopCounter<TDA182I2_MAX_UNITS; uLoopCounter++)
+    {
+        pObj = &gddTDA182I2Instance[uLoopCounter];
+        if(pObj->init == False)
+        {
+            pObj->tUnit = tUnit;
+            pObj->tUnitW = tUnit;
+
+            *ppDrvObject = pObj;
+            err = TM_OK;
+            break;
+        }
+    }
+
+    /* return value */
+    return err;
+}
+
+/*-----------------------------------------------------------------------------
+// FUNCTION:    ddTDA182I2DeAllocInstance:
+//
+// DESCRIPTION: deallocate instance
+//
+// RETURN:      always TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+ddTDA182I2DeAllocInstance
+(
+ tmUnitSelect_t  tUnit   /* I: Unit number */
+ )
+{     
+    tmErrorCode_t       err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+    ptmddTDA182I2Object_t pObj = Null;
+
+    /* check input parameters */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+
+    /* check driver state */
+    if (err == TM_OK)
+    {
+        if (pObj == Null || pObj->init == False)
+        {
+            err = ddTDA182I2_ERR_NOT_INITIALIZED;
+        }
+    }
+
+    if ((err == TM_OK) && (pObj != Null)) 
+    {
+        pObj->init = False;
+    }
+
+    /* return value */
+    return err;
+}
+
+/*-----------------------------------------------------------------------------
+// FUNCTION:    ddTDA182I2GetInstance:
+//
+// DESCRIPTION: get the instance
+//
+// RETURN:      always True
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+ddTDA182I2GetInstance
+(
+ tmUnitSelect_t          tUnit,      /* I: Unit number */
+ pptmddTDA182I2Object_t    ppDrvObject /* I: Device Object */
+ )
+{     
+    tmErrorCode_t           err = ddTDA182I2_ERR_NOT_INITIALIZED;
+    ptmddTDA182I2Object_t     pObj = Null;
+    UInt32                  uLoopCounter = 0;    
+
+    /* get instance */
+    for(uLoopCounter = 0; uLoopCounter<TDA182I2_MAX_UNITS; uLoopCounter++)
+    {
+        pObj = &gddTDA182I2Instance[uLoopCounter];
+        if(pObj->init == True && pObj->tUnit == GET_INDEX_TYPE_TUNIT(tUnit))
+        {
+            pObj->tUnitW = tUnit;
+
+            *ppDrvObject = pObj;
+            err = TM_OK;
+            break;
+        }
+    }
+
+    /* return value */
+    return err;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\src\tmddTDA182I2_Advanced.c
+
+
+/*-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2008 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of Philips Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of Philips
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than Philips Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmddTDA182I2_Alt.c
+//
+// DESCRIPTION:  TDA182I2 standard APIs
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+*/
+
+//#include "tmNxTypes.h"
+//#include "tmCompId.h"
+//#include "tmFrontEnd.h"
+//#include "tmbslFrontEndTypes.h"
+
+//#include "tmddTDA182I2.h"
+//#include "tmddTDA182I2local.h"
+
+//#include "tmddTDA182I2Instance.h"
+
+/*-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+*/
+
+/*-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+*/
+
+/*-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+*/
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetTM_D:
+//
+// DESCRIPTION: Get the TM_D bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetTM_D
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // switch thermometer on
+        pObj->I2CMap.uBx04.bF.TM_ON = 1;
+
+        // write byte 0x04
+        err = ddTDA182I2Write(pObj, 0x04, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // read byte 0x03
+            err = ddTDA182I2Read(pObj, 0x03, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+        }
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx03.bF.TM_D;
+
+            // switch thermometer off
+            pObj->I2CMap.uBx04.bF.TM_ON = 0;
+
+            // write byte 0x04
+            err = ddTDA182I2Write(pObj, 0x04, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetTM_ON:
+//
+// DESCRIPTION: Set the TM_ON bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetTM_ON
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx04.bF.TM_ON = uValue;
+
+        // write byte 0x04
+        err = ddTDA182I2Write(pObj, 0x04, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetTM_ON:
+//
+// DESCRIPTION: Get the TM_ON bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetTM_ON
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x04
+        err = ddTDA182I2Read(pObj, 0x04, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx04.bF.TM_ON;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPOR:
+//
+// DESCRIPTION: Get the POR bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPOR
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x05
+        err = ddTDA182I2Read(pObj, 0x05, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx05.bF.POR ;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RSSI_End:
+//
+// DESCRIPTION: Get the MSM_RSSI_End bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RSSI_End
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue   //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x08
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_RSSI_End;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_LOCalc_End:
+//
+// DESCRIPTION: Get the MSM_LOCalc_End bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_LOCalc_End
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x08
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_LOCalc_End;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RFCal_End:
+//
+// DESCRIPTION: Get the MSM_RFCal_End bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RFCal_End
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x08
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_RFCal_End;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_IRCAL_End:
+//
+// DESCRIPTION: Get the MSM_IRCAL_End bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_IRCAL_End
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x08
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_IRCAL_End;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RCCal_End:
+//
+// DESCRIPTION: Get the MSM_RCCal_End bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RCCal_End
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x08
+        err = ddTDA182I2Read(pObj, 0x08, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx08.bF.MSM_RCCal_End;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIRQ_Enable:
+//
+// DESCRIPTION: Set the IRQ_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIRQ_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.IRQ_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIRQ_Enable:
+//
+// DESCRIPTION: Get the IRQ_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIRQ_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.IRQ_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXtalCal_Enable:
+//
+// DESCRIPTION: Set the XtalCal_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXtalCal_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.XtalCal_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXtalCal_Enable:
+//
+// DESCRIPTION: Get the XtalCal_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXtalCal_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.XtalCal_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RSSI_Enable:
+//
+// DESCRIPTION: Set the MSM_RSSI_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RSSI_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.MSM_RSSI_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RSSI_Enable:
+//
+// DESCRIPTION: Get the MSM_RSSI_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RSSI_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.MSM_RSSI_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_LOCalc_Enable:
+//
+// DESCRIPTION: Set the MSM_LOCalc_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_LOCalc_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8          uValue      //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.MSM_LOCalc_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_LOCalc_Enable:
+//
+// DESCRIPTION: Get the MSM_LOCalc_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_LOCalc_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.MSM_LOCalc_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RFCAL_Enable:
+//
+// DESCRIPTION: Set the MSM_RFCAL_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RFCAL_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.MSM_RFCAL_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RFCAL_Enable:
+//
+// DESCRIPTION: Get the MSM_RFCAL_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RFCAL_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.MSM_RFCAL_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_IRCAL_Enable:
+//
+// DESCRIPTION: Set the MSM_IRCAL_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_IRCAL_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.MSM_IRCAL_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_IRCAL_Enable:
+//
+// DESCRIPTION: Get the MSM_IRCAL_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_IRCAL_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.MSM_IRCAL_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RCCal_Enable:
+//
+// DESCRIPTION: Set the MSM_RCCal_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RCCal_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx09.bF.MSM_RCCal_Enable = uValue;
+
+        // write byte 0x09
+        err = ddTDA182I2Write(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RCCal_Enable:
+//
+// DESCRIPTION: Get the MSM_RCCal_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RCCal_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x09
+        err = ddTDA182I2Read(pObj, 0x09, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx09.bF.MSM_RCCal_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXtalCal_Clear:
+//
+// DESCRIPTION: Set the XtalCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXtalCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8          uValue      //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.XtalCal_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXtalCal_Clear:
+//
+// DESCRIPTION: Get the XtalCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXtalCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.XtalCal_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RSSI_Clear:
+//
+// DESCRIPTION: Set the MSM_RSSI_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RSSI_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8          uValue      //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.MSM_RSSI_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RSSI_Clear:
+//
+// DESCRIPTION: Get the MSM_RSSI_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RSSI_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.MSM_RSSI_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_LOCalc_Clear:
+//
+// DESCRIPTION: Set the MSM_LOCalc_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_LOCalc_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.MSM_LOCalc_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_LOCalc_Clear:
+//
+// DESCRIPTION: Get the MSM_LOCalc_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_LOCalc_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.MSM_LOCalc_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RFCal_Clear:
+//
+// DESCRIPTION: Set the MSM_RFCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RFCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.MSM_RFCal_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RFCal_Clear:
+//
+// DESCRIPTION: Get the MSM_RFCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RFCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.MSM_RFCal_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_IRCAL_Clear:
+//
+// DESCRIPTION: Set the MSM_IRCAL_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_IRCAL_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8          uValue      //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.MSM_IRCAL_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_IRCAL_Clear:
+//
+// DESCRIPTION: Get the MSM_IRCAL_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_IRCAL_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.MSM_IRCAL_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RCCal_Clear:
+//
+// DESCRIPTION: Set the MSM_RCCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RCCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0A.bF.MSM_RCCal_Clear = uValue;
+
+        // write byte 0x0A
+        err = ddTDA182I2Write(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RCCal_Clear:
+//
+// DESCRIPTION: Get the MSM_RCCal_Clear bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RCCal_Clear
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0A
+        err = ddTDA182I2Read(pObj, 0x0A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0A.bF.MSM_RCCal_Clear;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIRQ_Set:
+//
+// DESCRIPTION: Set the IRQ_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIRQ_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.IRQ_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIRQ_Set:
+//
+// DESCRIPTION: Get the IRQ_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIRQ_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.IRQ_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXtalCal_Set:
+//
+// DESCRIPTION: Set the XtalCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXtalCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.XtalCal_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXtalCal_Set:
+//
+// DESCRIPTION: Get the XtalCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXtalCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.XtalCal_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RSSI_Set:
+//
+// DESCRIPTION: Set the MSM_RSSI_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RSSI_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.MSM_RSSI_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RSSI_Set:
+//
+// DESCRIPTION: Get the MSM_RSSI_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RSSI_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.MSM_RSSI_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_LOCalc_Set:
+//
+// DESCRIPTION: Set the MSM_LOCalc_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_LOCalc_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.MSM_LOCalc_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_LOCalc_Set:
+//
+// DESCRIPTION: Get the MSM_LOCalc_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_LOCalc_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        // get value
+        *puValue = pObj->I2CMap.uBx0B.bF.MSM_LOCalc_Set;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RFCal_Set:
+//
+// DESCRIPTION: Set the MSM_RFCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RFCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.MSM_RFCal_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RFCal_Set:
+//
+// DESCRIPTION: Get the MSM_RFCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RFCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.MSM_RFCal_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_IRCAL_Set:
+//
+// DESCRIPTION: Set the MSM_IRCAL_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_IRCAL_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.MSM_IRCAL_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_IRCAL_Set:
+//
+// DESCRIPTION: Get the MSM_IRCAL_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_IRCAL_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.MSM_IRCAL_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetMSM_RCCal_Set:
+//
+// DESCRIPTION: Set the MSM_RCCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetMSM_RCCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8            uValue //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0B.bF.MSM_RCCal_Set = uValue;
+
+        // write byte 0x0B
+        err = ddTDA182I2Write(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetMSM_RCCal_Set:
+//
+// DESCRIPTION: Get the MSM_RCCal_Set bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetMSM_RCCal_Set
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0B
+        err = ddTDA182I2Read(pObj, 0x0B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0B.bF.MSM_RCCal_Set;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetLT_Enable:
+//
+// DESCRIPTION: Set the LT_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetLT_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0C.bF.LT_Enable = uValue;
+
+        // write byte 0x0C
+        err = ddTDA182I2Write(pObj, 0x0C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetLT_Enable:
+//
+// DESCRIPTION: Get the LT_Enable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetLT_Enable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0C
+        err = ddTDA182I2Read(pObj, 0x0C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0C.bF.LT_Enable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC1_6_15dB:
+//
+// DESCRIPTION: Set the AGC1_6_15dB bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC1_6_15dB
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0C.bF.AGC1_6_15dB = uValue;
+
+        // write byte 0x0C
+        err = ddTDA182I2Write(pObj, 0x0C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC1_6_15dB:
+//
+// DESCRIPTION: Get the AGC1_6_15dB bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC1_6_15dB
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0C
+        err = ddTDA182I2Read(pObj, 0x0C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0C.bF.AGC1_6_15dB;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGCs_Up_Step_assym:
+//
+// DESCRIPTION: Set the AGCs_Up_Step_assym bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGCs_Up_Step_assym
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0E.bF.AGCs_Up_Step_assym = uValue;
+
+        // write byte 0x0E
+        err = ddTDA182I2Write(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGCs_Up_Step_assym:
+//
+// DESCRIPTION: Get the AGCs_Up_Step_assym bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGCs_Up_Step_assym
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0E
+        err = ddTDA182I2Read(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0E.bF.AGCs_Up_Step_assym;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPulse_Shaper_Disable:
+//
+// DESCRIPTION: Set the Pulse_Shaper_Disable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPulse_Shaper_Disable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0E.bF.Pulse_Shaper_Disable = uValue;
+
+        // write byte 0x0E
+        err = ddTDA182I2Write(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPulse_Shaper_Disable:
+//
+// DESCRIPTION: Get the Pulse_Shaper_Disable bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPulse_Shaper_Disable
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*        puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0E
+        err = ddTDA182I2Read(pObj, 0x0E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0E.bF.Pulse_Shaper_Disable;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFAGC_Low_BW:
+//
+// DESCRIPTION: Set the RFAGC_Low_BW bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFAGC_Low_BW
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx0F.bF.RFAGC_Low_BW = uValue;
+
+        // write byte 0x0F
+        err = ddTDA182I2Write(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFAGC_Low_BW:
+//
+// DESCRIPTION: Get the RFAGC_Low_BW bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFAGC_Low_BW
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x0F
+        err = ddTDA182I2Read(pObj, 0x0F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx0F.bF.RFAGC_Low_BW;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGCs_Do_Step_assym:
+//
+// DESCRIPTION: Set the AGCs_Do_Step_assym bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGCs_Do_Step_assym
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx11.bF.AGCs_Do_Step_assym = uValue;
+
+        // write byte 0x11
+        err = ddTDA182I2Write(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGCs_Do_Step_assym:
+//
+// DESCRIPTION: Get the AGCs_Do_Step_assym bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGCs_Do_Step_assym
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x11
+        err = ddTDA182I2Read(pObj, 0x11, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx11.bF.AGCs_Do_Step_assym;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetI2C_Clock_Mode:
+//
+// DESCRIPTION: Set the I2C_Clock_Mode bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetI2C_Clock_Mode
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx14.bF.I2C_Clock_Mode = uValue;
+
+        // write byte 0x14
+        err = ddTDA182I2Write(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetI2C_Clock_Mode:
+//
+// DESCRIPTION: Get the I2C_Clock_Mode bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetI2C_Clock_Mode
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x14
+        err = ddTDA182I2Read(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx14.bF.I2C_Clock_Mode;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXtalOsc_AnaReg_En:
+//
+// DESCRIPTION: Set the XtalOsc_AnaReg_En bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXtalOsc_AnaReg_En
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx14.bF.XtalOsc_AnaReg_En = uValue;
+
+        // write byte 0x14
+        err = ddTDA182I2Write(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXtalOsc_AnaReg_En:
+//
+// DESCRIPTION: Get the XtalOsc_AnaReg_En bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXtalOsc_AnaReg_En
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x14
+        err = ddTDA182I2Read(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx14.bF.XtalOsc_AnaReg_En;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXTout:
+//
+// DESCRIPTION: Set the XTout bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXTout
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx14.bF.XTout = uValue;
+
+        // write byte 0x14
+        err = ddTDA182I2Write(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXTout:
+//
+// DESCRIPTION: Get the XTout bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXTout
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x14
+        err = ddTDA182I2Read(pObj, 0x14, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx14.bF.XTout;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI_Meas:
+//
+// DESCRIPTION: Set the RSSI_Meas bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI_Meas
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.RSSI_Meas = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI_Meas:
+//
+// DESCRIPTION: Get the RSSI_Meas bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI_Meas
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.RSSI_Meas;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRF_CAL_AV:
+//
+// DESCRIPTION: Set the RF_CAL_AV bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRF_CAL_AV
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.RF_CAL_AV = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRF_CAL_AV:
+//
+// DESCRIPTION: Get the RF_CAL_AV bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRF_CAL_AV
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.RF_CAL_AV;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRF_CAL:
+//
+// DESCRIPTION: Set the RF_CAL bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRF_CAL
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.RF_CAL = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRF_CAL:
+//
+// DESCRIPTION: Get the RF_CAL bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRF_CAL
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue      //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.RF_CAL;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_CAL_Loop:
+//
+// DESCRIPTION: Set the IR_CAL_Loop bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_CAL_Loop
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.IR_CAL_Loop = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_CAL_Loop:
+//
+// DESCRIPTION: Get the IR_CAL_Loop bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_CAL_Loop
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.IR_CAL_Loop;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_Cal_Image:
+//
+// DESCRIPTION: Set the IR_Cal_Image bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_Cal_Image
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.IR_Cal_Image = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_Cal_Image:
+//
+// DESCRIPTION: Get the IR_Cal_Image bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_Cal_Image
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.IR_Cal_Image;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_CAL_Wanted:
+//
+// DESCRIPTION: Set the IR_CAL_Wanted bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_CAL_Wanted
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.IR_CAL_Wanted = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_CAL_Wanted:
+//
+// DESCRIPTION: Get the IR_CAL_Wanted bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_CAL_Wanted
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.IR_CAL_Wanted;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRC_Cal:
+//
+// DESCRIPTION: Set the RC_Cal bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRC_Cal
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.RC_Cal = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRC_Cal:
+//
+// DESCRIPTION: Get the RC_Cal bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRC_Cal
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.RC_Cal;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetCalc_PLL:
+//
+// DESCRIPTION: Set the Calc_PLL bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetCalc_PLL
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx19.bF.Calc_PLL = uValue;
+
+        // read byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetCalc_PLL:
+//
+// DESCRIPTION: Get the Calc_PLL bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetCalc_PLL
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x19
+        err = ddTDA182I2Read(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx19.bF.Calc_PLL;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetXtalCal_Launch:
+//
+// DESCRIPTION: Set the XtalCal_Launch bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetXtalCal_Launch
+(
+ tmUnitSelect_t      tUnit    //  I: Unit number
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1A.bF.XtalCal_Launch = 1;
+
+        // write byte 0x1A
+        err = ddTDA182I2Write(pObj, 0x1A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        // reset XtalCal_Launch (buffer only, no write)
+        pObj->I2CMap.uBx1A.bF.XtalCal_Launch = 0;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetXtalCal_Launch:
+//
+// DESCRIPTION: Get the XtalCal_Launch bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetXtalCal_Launch
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1A
+        err = ddTDA182I2Read(pObj, 0x1A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1A.bF.XtalCal_Launch;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPSM_AGC1:
+//
+// DESCRIPTION: Set the PSM_AGC1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPSM_AGC1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1B.bF.PSM_AGC1 = uValue;
+
+        // read byte 0x1B
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPSM_AGC1:
+//
+// DESCRIPTION: Get the PSM_AGC1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPSM_AGC1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1B
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1B.bF.PSM_AGC1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPSMRFpoly:
+//
+// DESCRIPTION: Set the PSMRFpoly bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPSMRFpoly
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1B.bF.PSMRFpoly = uValue;
+
+        // read byte 0x1B
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPSMRFpoly:
+//
+// DESCRIPTION: Get the PSMRFpoly bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPSMRFpoly
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1B
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        // get value
+        *puValue = pObj->I2CMap.uBx1B.bF.PSMRFpoly;
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPSM_Mixer:
+//
+// DESCRIPTION: Set the PSM_Mixer bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPSM_Mixer
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1B.bF.PSM_Mixer = uValue;
+
+        // read byte 0x1B
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPSM_Mixer:
+//
+// DESCRIPTION: Get the PSM_Mixer bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPSM_Mixer
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1B
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1B.bF.PSM_Mixer;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPSM_Ifpoly:
+//
+// DESCRIPTION: Set the PSM_Ifpoly bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPSM_Ifpoly
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1B.bF.PSM_Ifpoly = uValue;
+
+        // read byte 0x1B
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPSM_Ifpoly:
+//
+// DESCRIPTION: Get the PSM_Ifpoly bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPSM_Ifpoly
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1B
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1B.bF.PSM_Ifpoly;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPSM_Lodriver:
+//
+// DESCRIPTION: Set the PSM_Lodriver bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPSM_Lodriver
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1B.bF.PSM_Lodriver = uValue;
+
+        // read byte 0x1B
+        err = ddTDA182I2Write(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPSM_Lodriver:
+//
+// DESCRIPTION: Get the PSM_Lodriver bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPSM_Lodriver
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1B
+        err = ddTDA182I2Read(pObj, 0x1B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1B.bF.PSM_Lodriver;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetDCC_Bypass:
+//
+// DESCRIPTION: Set the DCC_Bypass bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetDCC_Bypass
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1C.bF.DCC_Bypass = uValue;
+
+        // read byte 0x1C
+        err = ddTDA182I2Write(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDCC_Bypass:
+//
+// DESCRIPTION: Get the DCC_Bypass bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDCC_Bypass
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1C
+        err = ddTDA182I2Read(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1C.bF.DCC_Bypass;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetDCC_Slow:
+//
+// DESCRIPTION: Set the DCC_Slow bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetDCC_Slow
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1C.bF.DCC_Slow = uValue;
+
+        // read byte 0x1C
+        err = ddTDA182I2Write(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDCC_Slow:
+//
+// DESCRIPTION: Get the DCC_Slow bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDCC_Slow
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1C
+        err = ddTDA182I2Read(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1C.bF.DCC_Slow;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetDCC_psm:
+//
+// DESCRIPTION: Set the DCC_psm bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetDCC_psm
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1C.bF.DCC_psm = uValue;
+
+        // read byte 0x1C
+        err = ddTDA182I2Write(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDCC_psm:
+//
+// DESCRIPTION: Get the DCC_psm bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDCC_psm
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1C
+        err = ddTDA182I2Read(pObj, 0x1C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1C.bF.DCC_psm;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_GStep:
+//
+// DESCRIPTION: Set the IR_GStep bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_GStep
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1E.bF.IR_GStep = uValue - 40;
+
+        // read byte 0x1E
+        err = ddTDA182I2Write(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_GStep:
+//
+// DESCRIPTION: Get the IR_GStep bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_GStep
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1E
+        err = ddTDA182I2Read(pObj, 0x1E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1E.bF.IR_GStep + 40;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_FreqLow_Sel:
+//
+// DESCRIPTION: Set the IR_FreqLow_Sel bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_FreqLow_Sel
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1F.bF.IR_FreqLow_Sel = uValue;
+
+        // read byte 0x1F
+        err = ddTDA182I2Write(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_FreqLow_Sel:
+//
+// DESCRIPTION: Get the IR_FreqLow_Sel bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_FreqLow_Sel
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1F
+        err = ddTDA182I2Read(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1F.bF.IR_FreqLow_Sel;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_FreqLow:
+//
+// DESCRIPTION: Set the IR_FreqLow bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_FreqLow
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx1F.bF.IR_FreqLow = uValue;
+
+        // read byte 0x1F
+        err = ddTDA182I2Write(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_FreqLow:
+//
+// DESCRIPTION: Get the IR_FreqLow bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_FreqLow
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x1F
+        err = ddTDA182I2Read(pObj, 0x1F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx1F.bF.IR_FreqLow;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_FreqMid:
+//
+// DESCRIPTION: Set the IR_FreqMid bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_FreqMid
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx20.bF.IR_FreqMid = uValue;
+
+        // read byte 0x20
+        err = ddTDA182I2Write(pObj, 0x20, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_FreqMid:
+//
+// DESCRIPTION: Get the IR_FreqMid bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_FreqMid
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x20
+        err = ddTDA182I2Read(pObj, 0x20, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx20.bF.IR_FreqMid;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetCoarse_IR_FreqHigh:
+//
+// DESCRIPTION: Set the Coarse_IR_FreqHigh bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetCoarse_IR_FreqHigh
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx21.bF.Coarse_IR_FreqHigh = uValue;
+
+        // write byte 0x21
+        err = ddTDA182I2Write(pObj, 0x21, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetCoarse_IR_FreqHigh:
+//
+// DESCRIPTION: Get the Coarse_IR_FreqHigh bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetCoarse_IR_FreqHigh
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x21
+        err = ddTDA182I2Read(pObj, 0x21, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx21.bF.Coarse_IR_FreqHigh;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_FreqHigh:
+//
+// DESCRIPTION: Set the IR_FreqHigh bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_FreqHigh
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx21.bF.IR_FreqHigh = uValue;
+
+        // read byte 0x21
+        err = ddTDA182I2Write(pObj, 0x21, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_FreqHigh:
+//
+// DESCRIPTION: Get the IR_FreqHigh bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_FreqHigh
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x21
+        err = ddTDA182I2Read(pObj, 0x21, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx21.bF.IR_FreqHigh;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPD_Vsync_Mgt:
+//
+// DESCRIPTION: Set the PD_Vsync_Mgt bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPD_Vsync_Mgt
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx22.bF.PD_Vsync_Mgt = uValue;
+
+        // write byte 0x22
+        err = ddTDA182I2Write(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPD_Vsync_Mgt:
+//
+// DESCRIPTION: Get the PD_Vsync_Mgt bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPD_Vsync_Mgt
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x22
+        err = ddTDA182I2Read(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx22.bF.PD_Vsync_Mgt;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetPD_Ovld:
+//
+// DESCRIPTION: Set the PD_Ovld bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetPD_Ovld
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx22.bF.PD_Ovld = uValue;
+
+        // write byte 0x22
+        err = ddTDA182I2Write(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetPD_Ovld:
+//
+// DESCRIPTION: Get the PD_Ovld bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetPD_Ovld
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x22
+        err = ddTDA182I2Read(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx22.bF.PD_Ovld;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC_Ovld_Timer:
+//
+// DESCRIPTION: Set the AGC_Ovld_Timer bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC_Ovld_Timer
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx22.bF.AGC_Ovld_Timer = uValue;
+
+        // write byte 0x22
+        err = ddTDA182I2Write(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC_Ovld_Timer:
+//
+// DESCRIPTION: Get the AGC_Ovld_Timer bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC_Ovld_Timer
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x22
+        err = ddTDA182I2Read(pObj, 0x22, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx22.bF.AGC_Ovld_Timer;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_Mixer_loop_off:
+//
+// DESCRIPTION: Set the IR_Mixer_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_Mixer_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx23.bF.IR_Mixer_loop_off = uValue;
+
+        // read byte 0x23
+        err = ddTDA182I2Write(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_Mixer_loop_off:
+//
+// DESCRIPTION: Get the IR_Mixer_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_Mixer_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x23
+        err = ddTDA182I2Read(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx23.bF.IR_Mixer_loop_off;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIR_Mixer_Do_step:
+//
+// DESCRIPTION: Set the IR_Mixer_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIR_Mixer_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx23.bF.IR_Mixer_Do_step = uValue;
+
+        // read byte 0x23
+        err = ddTDA182I2Write(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIR_Mixer_Do_step:
+//
+// DESCRIPTION: Get the IR_Mixer_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIR_Mixer_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x23
+        err = ddTDA182I2Read(pObj, 0x23, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx23.bF.IR_Mixer_Do_step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC1_loop_off:
+//
+// DESCRIPTION: Set the AGC1_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC1_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx24.bF.AGC1_loop_off = uValue;
+
+        // read byte 0x24
+        err = ddTDA182I2Write(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC1_loop_off:
+//
+// DESCRIPTION: Get the AGC1_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC1_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x24
+        err = ddTDA182I2Read(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx24.bF.AGC1_loop_off;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC1_Do_step:
+//
+// DESCRIPTION: Set the AGC1_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC1_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx24.bF.AGC1_Do_step = uValue;
+
+        // read byte 0x24
+        err = ddTDA182I2Write(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC1_Do_step:
+//
+// DESCRIPTION: Get the AGC1_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC1_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x24
+        err = ddTDA182I2Read(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx24.bF.AGC1_Do_step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetForce_AGC1_gain:
+//
+// DESCRIPTION: Set the Force_AGC1_gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetForce_AGC1_gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx24.bF.Force_AGC1_gain = uValue;
+
+        // read byte 0x24
+        err = ddTDA182I2Write(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetForce_AGC1_gain:
+//
+// DESCRIPTION: Get the Force_AGC1_gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetForce_AGC1_gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x24
+        err = ddTDA182I2Read(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx24.bF.Force_AGC1_gain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC1_Gain:
+//
+// DESCRIPTION: Set the AGC1_Gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC1_Gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx24.bF.AGC1_Gain = uValue;
+
+        // read byte 0x24
+        err = ddTDA182I2Write(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC1_Gain:
+//
+// DESCRIPTION: Get the AGC1_Gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC1_Gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x24
+        err = ddTDA182I2Read(pObj, 0x24, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx24.bF.AGC1_Gain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq0:
+//
+// DESCRIPTION: Set the RFCAL_Freq0 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq0
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx26.bF.RFCAL_Freq0 = uValue;
+
+        // read byte 0x26
+        err = ddTDA182I2Write(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq0:
+//
+// DESCRIPTION: Get the RFCAL_Freq0 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq0
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x26
+        err = ddTDA182I2Read(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx26.bF.RFCAL_Freq0;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq1:
+//
+// DESCRIPTION: Set the RFCAL_Freq1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx26.bF.RFCAL_Freq1 = uValue;
+
+        // read byte 0x26
+        err = ddTDA182I2Write(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq1:
+//
+// DESCRIPTION: Get the RFCAL_Freq1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x26
+        err = ddTDA182I2Read(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx26.bF.RFCAL_Freq1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq2:
+//
+// DESCRIPTION: Set the RFCAL_Freq2 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx27.bF.RFCAL_Freq2 = uValue;
+
+        // read byte 0x27
+        err = ddTDA182I2Write(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq2:
+//
+// DESCRIPTION: Get the RFCAL_Freq2 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x27
+        err = ddTDA182I2Read(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx27.bF.RFCAL_Freq2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq3:
+//
+// DESCRIPTION: Set the RFCAL_Freq3 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq3
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx27.bF.RFCAL_Freq3 = uValue;
+
+        // read byte 0x27
+        err = ddTDA182I2Write(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq3:
+//
+// DESCRIPTION: Get the RFCAL_Freq3 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq3
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x27
+        err = ddTDA182I2Read(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx27.bF.RFCAL_Freq3;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq4:
+//
+// DESCRIPTION: Set the RFCAL_Freq4 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx28.bF.RFCAL_Freq4 = uValue;
+
+        // read byte 0x28
+        err = ddTDA182I2Write(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq4:
+//
+// DESCRIPTION: Get the RFCAL_Freq4 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x28
+        err = ddTDA182I2Read(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx28.bF.RFCAL_Freq4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq5:
+//
+// DESCRIPTION: Set the RFCAL_Freq5 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue   //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx28.bF.RFCAL_Freq5 = uValue;
+
+        // read byte 0x28
+        err = ddTDA182I2Write(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq5:
+//
+// DESCRIPTION: Get the RFCAL_Freq5 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x28
+        err = ddTDA182I2Read(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx28.bF.RFCAL_Freq5;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq6:
+//
+// DESCRIPTION: Set the RFCAL_Freq6 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq6
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx29.bF.RFCAL_Freq6 = uValue;
+
+        // read byte 0x29
+        err = ddTDA182I2Write(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq6:
+//
+// DESCRIPTION: Get the RFCAL_Freq6 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq6
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x29
+        err = ddTDA182I2Read(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx29.bF.RFCAL_Freq6;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq7:
+//
+// DESCRIPTION: Set the RFCAL_Freq7 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq7
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx29.bF.RFCAL_Freq7 = uValue;
+
+        // read byte 0x29
+        err = ddTDA182I2Write(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq7:
+//
+// DESCRIPTION: Get the RFCAL_Freq7 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq7
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x29
+        err = ddTDA182I2Read(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx29.bF.RFCAL_Freq7;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq8:
+//
+// DESCRIPTION: Set the RFCAL_Freq8 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq8
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2A.bF.RFCAL_Freq8 = uValue;
+
+        // read byte 0x2A
+        err = ddTDA182I2Write(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq8:
+//
+// DESCRIPTION: Get the RFCAL_Freq8 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq8
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2A
+        err = ddTDA182I2Read(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2A.bF.RFCAL_Freq8;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq9:
+//
+// DESCRIPTION: Set the RFCAL_Freq9 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq9
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2A.bF.RFCAL_Freq9 = uValue;
+
+        // read byte 0x2A
+        err = ddTDA182I2Write(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq9:
+//
+// DESCRIPTION: Get the RFCAL_Freq9 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq9
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2A
+        err = ddTDA182I2Read(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2A.bF.RFCAL_Freq9;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq10:
+//
+// DESCRIPTION: Set the RFCAL_Freq10 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq10
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2B.bF.RFCAL_Freq10 = uValue;
+
+        // read byte 0x2B
+        err = ddTDA182I2Write(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq10:
+//
+// DESCRIPTION: Get the ? bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq10
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2B
+        err = ddTDA182I2Read(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2B.bF.RFCAL_Freq10;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Freq11:
+//
+// DESCRIPTION: Set the RFCAL_Freq11 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Freq11
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2B.bF.RFCAL_Freq11 = uValue;
+
+        // read byte 0x2B
+        err = ddTDA182I2Write(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Freq11:
+//
+// DESCRIPTION: Get the RFCAL_Freq11 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Freq11
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2B
+        err = ddTDA182I2Read(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2B.bF.RFCAL_Freq11;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset0:
+//
+// DESCRIPTION: Set the RFCAL_Offset0 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset0
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx26.bF.RFCAL_Offset_Cprog0 = uValue;
+
+        // read byte 0x26
+        err = ddTDA182I2Write(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset0:
+//
+// DESCRIPTION: Get the RFCAL_Offset0 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset0
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x26
+        err = ddTDA182I2Read(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx26.bF.RFCAL_Offset_Cprog0;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset1:
+//
+// DESCRIPTION: Set the RFCAL_Offset1 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx26.bF.RFCAL_Offset_Cprog1 = uValue;
+
+        // read byte 0x26
+        err = ddTDA182I2Write(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset1:
+//
+// DESCRIPTION: Get the RFCAL_Offset1 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+
+        // read byte 0x26
+        err = ddTDA182I2Read(pObj, 0x26, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx26.bF.RFCAL_Offset_Cprog1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset2:
+//
+// DESCRIPTION: Set the RFCAL_Offset2 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx27.bF.RFCAL_Offset_Cprog2 = uValue;
+
+        // read byte 0x27
+        err = ddTDA182I2Write(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset2:
+//
+// DESCRIPTION: Get the RFCAL_Offset2 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x27
+        err = ddTDA182I2Read(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx27.bF.RFCAL_Offset_Cprog2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset3:
+//
+// DESCRIPTION: Set the RFCAL_Offset3 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset3
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx27.bF.RFCAL_Offset_Cprog3 = uValue;
+
+        // read byte 0x27
+        err = ddTDA182I2Write(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset3:
+//
+// DESCRIPTION: Get the RFCAL_Offset3 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset3
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x27
+        err = ddTDA182I2Read(pObj, 0x27, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx27.bF.RFCAL_Offset_Cprog3;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset4:
+//
+// DESCRIPTION: Set the RFCAL_Offset4 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx28.bF.RFCAL_Offset_Cprog4 = uValue;
+
+        // read byte 0x28
+        err = ddTDA182I2Write(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset4:
+//
+// DESCRIPTION: Get the RFCAL_Offset4 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x28
+        err = ddTDA182I2Read(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx28.bF.RFCAL_Offset_Cprog4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset5:
+//
+// DESCRIPTION: Set the RFCAL_Offset5 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue   //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx28.bF.RFCAL_Offset_Cprog5 = uValue;
+
+        // read byte 0x28
+        err = ddTDA182I2Write(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset5:
+//
+// DESCRIPTION: Get the RFCAL_Offset5 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x28
+        err = ddTDA182I2Read(pObj, 0x28, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx28.bF.RFCAL_Offset_Cprog5;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset6:
+//
+// DESCRIPTION: Set the RFCAL_Offset6 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset6
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx29.bF.RFCAL_Offset_Cprog6 = uValue;
+
+        // read byte 0x29
+        err = ddTDA182I2Write(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset6:
+//
+// DESCRIPTION: Get the RFCAL_Offset6 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset6
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x29
+        err = ddTDA182I2Read(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx29.bF.RFCAL_Offset_Cprog6;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset7:
+//
+// DESCRIPTION: Set the RFCAL_Offset7 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset7
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx29.bF.RFCAL_Offset_Cprog7 = uValue;
+
+        // read byte 0x29
+        err = ddTDA182I2Write(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset7:
+//
+// DESCRIPTION: Get the RFCAL_Offset7 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset7
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x29
+        err = ddTDA182I2Read(pObj, 0x29, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx29.bF.RFCAL_Offset_Cprog7;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset8:
+//
+// DESCRIPTION: Set the RFCAL_Offset8 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset8
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2A.bF.RFCAL_Offset_Cprog8 = uValue;
+
+        // read byte 0x2A
+        err = ddTDA182I2Write(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset8:
+//
+// DESCRIPTION: Get the RFCAL_Offset8 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset8
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2A
+        err = ddTDA182I2Read(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2A.bF.RFCAL_Offset_Cprog8;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset9:
+//
+// DESCRIPTION: Set the RFCAL_Offset9 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset9
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2A.bF.RFCAL_Offset_Cprog9 = uValue;
+
+        // read byte 0x2A
+        err = ddTDA182I2Write(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset9:
+//
+// DESCRIPTION: Get the RFCAL_Offset9 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset9
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2A
+        err = ddTDA182I2Read(pObj, 0x2A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2A.bF.RFCAL_Offset_Cprog9;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset10:
+//
+// DESCRIPTION: Set the RFCAL_Offset10 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset10
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2B.bF.RFCAL_Offset_Cprog10 = uValue;
+
+        // read byte 0x2B
+        err = ddTDA182I2Write(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset10:
+//
+// DESCRIPTION: Get the ? bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset10
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2B
+        err = ddTDA182I2Read(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2B.bF.RFCAL_Offset_Cprog10;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_Offset11:
+//
+// DESCRIPTION: Set the RFCAL_Offset11 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_Offset11
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2B.bF.RFCAL_Offset_Cprog11 = uValue;
+
+        // read byte 0x2B
+        err = ddTDA182I2Write(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_Offset11:
+//
+// DESCRIPTION: Get the RFCAL_Offset11 bit(s) status
+//
+// RETURN:      TM_OK if no error
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_Offset11
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2B
+        err = ddTDA182I2Read(pObj, 0x2B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2B.bF.RFCAL_Offset_Cprog11;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC2_loop_off:
+//
+// DESCRIPTION: Set the AGC2_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC2_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2C.bF.AGC2_loop_off = uValue;
+
+        // read byte 0x2C
+        err = ddTDA182I2Write(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC2_loop_off:
+//
+// DESCRIPTION: Get the AGC2_loop_off bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC2_loop_off
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2C
+        err = ddTDA182I2Read(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2C.bF.AGC2_loop_off;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetForce_AGC2_gain:
+//
+// DESCRIPTION: Set the Force_AGC2_gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetForce_AGC2_gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2C.bF.Force_AGC2_gain = uValue;
+
+        // write byte 0x2C
+        err = ddTDA182I2Write(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetForce_AGC2_gain:
+//
+// DESCRIPTION: Get the Force_AGC2_gain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetForce_AGC2_gain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2C
+        err = ddTDA182I2Read(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2C.bF.Force_AGC2_gain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRF_Filter_Gv:
+//
+// DESCRIPTION: Set the RF_Filter_Gv bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRF_Filter_Gv
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2C.bF.RF_Filter_Gv = uValue;
+
+        // read byte 0x2C
+        err = ddTDA182I2Write(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRF_Filter_Gv:
+//
+// DESCRIPTION: Get the RF_Filter_Gv bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRF_Filter_Gv
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2C
+        err = ddTDA182I2Read(pObj, 0x2C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2C.bF.RF_Filter_Gv;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetAGC2_Do_step:
+//
+// DESCRIPTION: Set the AGC2_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetAGC2_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2E.bF.AGC2_Do_step = uValue;
+
+        // read byte 0x2E
+        err = ddTDA182I2Write(pObj, 0x2E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC2_Do_step:
+//
+// DESCRIPTION: Get the AGC2_Do_step bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC2_Do_step
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2E
+        err = ddTDA182I2Read(pObj, 0x2E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2E.bF.AGC2_Do_step;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRF_BPF_Bypass:
+//
+// DESCRIPTION: Set the RF_BPF_Bypass bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRF_BPF_Bypass
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2F.bF.RF_BPF_Bypass = uValue;
+
+        // read byte 0x2F
+        err = ddTDA182I2Write(pObj, 0x2F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRF_BPF_Bypass:
+//
+// DESCRIPTION: Get the RF_BPF_Bypass bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRF_BPF_Bypass
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2F
+        err = ddTDA182I2Read(pObj, 0x2F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2F.bF.RF_BPF_Bypass;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRF_BPF:
+//
+// DESCRIPTION: Set the RF_BPF bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRF_BPF
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx2F.bF.RF_BPF = uValue;
+
+        // read byte 0x2F
+        err = ddTDA182I2Write(pObj, 0x2F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRF_BPF:
+//
+// DESCRIPTION: Get the RF_BPF bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRF_BPF
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x2F
+        err = ddTDA182I2Read(pObj, 0x2F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx2F.bF.RF_BPF;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetUp_AGC5:
+//
+// DESCRIPTION: Get the Up_AGC5 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetUp_AGC5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Up_AGC5;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDo_AGC5:
+//
+// DESCRIPTION: Get the Do_AGC5 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDo_AGC5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Do_AGC5;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetUp_AGC4:
+//
+// DESCRIPTION: Get the Up_AGC4 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetUp_AGC4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Up_AGC4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDo_AGC4:
+//
+// DESCRIPTION: Get the Do_AGC4 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDo_AGC4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Do_AGC4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetUp_AGC2:
+//
+// DESCRIPTION: Get the Up_AGC2 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetUp_AGC2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Up_AGC2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDo_AGC2:
+//
+// DESCRIPTION: Get the Do_AGC2 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDo_AGC2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Do_AGC2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetUp_AGC1:
+//
+// DESCRIPTION: Get the Up_AGC1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetUp_AGC1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Up_AGC1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDo_AGC1:
+//
+// DESCRIPTION: Get the Do_AGC1 bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDo_AGC1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x31
+        err = ddTDA182I2Read(pObj, 0x31, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx31.bF.Do_AGC1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC2_Gain_Read:
+//
+// DESCRIPTION: Get the AGC2_Gain_Read bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC2_Gain_Read
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x32
+        err = ddTDA182I2Read(pObj, 0x32, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx32.bF.AGC2_Gain_Read;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC1_Gain_Read:
+//
+// DESCRIPTION: Get the AGC1_Gain_Read bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC1_Gain_Read
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x32
+        err = ddTDA182I2Read(pObj, 0x32, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx32.bF.AGC1_Gain_Read;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetTOP_AGC3_Read:
+//
+// DESCRIPTION: Get the TOP_AGC3_Read bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetTOP_AGC3_Read
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x33
+        err = ddTDA182I2Read(pObj, 0x33, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx33.bF.TOP_AGC3_Read;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC5_Gain_Read:
+//
+// DESCRIPTION: Get the AGC5_Gain_Read bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC5_Gain_Read
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x34
+        err = ddTDA182I2Read(pObj, 0x34, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx34.bF.AGC5_Gain_Read;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetAGC4_Gain_Read:
+//
+// DESCRIPTION: Get the AGC4_Gain_Read bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetAGC4_Gain_Read
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x34
+        err = ddTDA182I2Read(pObj, 0x34, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx34.bF.AGC4_Gain_Read;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI:
+//
+// DESCRIPTION: Set the RSSI bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx35.RSSI = uValue;
+
+        // write byte 0x35
+        err = ddTDA182I2Write(pObj, 0x35, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI:
+//
+// DESCRIPTION: Get the RSSI bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+       // tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x35
+        err = ddTDA182I2Read(pObj, 0x35, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx35.RSSI;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI_AV:
+//
+// DESCRIPTION: Set the RSSI_AV bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI_AV
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx36.bF.RSSI_AV = uValue;
+
+        // write byte 0x36
+        err = ddTDA182I2Write(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI_AV:
+//
+// DESCRIPTION: Get the RSSI_AV bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI_AV
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x36
+        err = ddTDA182I2Read(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx36.bF.RSSI_AV;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI_Cap_Reset_En:
+//
+// DESCRIPTION: Set the RSSI_Cap_Reset_En bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI_Cap_Reset_En
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx36.bF.RSSI_Cap_Reset_En = uValue;
+
+        // write byte 0x36
+        err = ddTDA182I2Write(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI_Cap_Reset_En:
+//
+// DESCRIPTION: Get the RSSI_Cap_Reset_En bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI_Cap_Reset_En
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x36
+        err = ddTDA182I2Read(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx36.bF.RSSI_Cap_Reset_En;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI_Cap_Val:
+//
+// DESCRIPTION: Set the RSSI_Cap_Val bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI_Cap_Val
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx36.bF.RSSI_Cap_Val = uValue;
+
+        // write byte 0x36
+        err = ddTDA182I2Write(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI_Cap_Val:
+//
+// DESCRIPTION: Get the RSSI_Cap_Val bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI_Cap_Val
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x36
+        err = ddTDA182I2Read(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx36.bF.RSSI_Cap_Val;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRSSI_Dicho_not:
+//
+// DESCRIPTION: Set the RSSI_Dicho_not bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRSSI_Dicho_not
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx36.bF.RSSI_Dicho_not = uValue;
+
+        // write byte 0x36
+        err = ddTDA182I2Write(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRSSI_Dicho_not:
+//
+// DESCRIPTION: Get the RSSI_Dicho_not bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRSSI_Dicho_not
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x36
+        err = ddTDA182I2Read(pObj, 0x36, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx36.bF.RSSI_Dicho_not;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetDDS_Polarity:
+//
+// DESCRIPTION: Set the DDS_Polarity bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetDDS_Polarity
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx37.bF.DDS_Polarity = uValue;
+
+        // write byte 0x37
+        err = ddTDA182I2Write(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetDDS_Polarity:
+//
+// DESCRIPTION: Get the DDS_Polarity bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetDDS_Polarity
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x37
+        err = ddTDA182I2Read(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx37.bF.DDS_Polarity;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetRFCAL_DeltaGain:
+//
+// DESCRIPTION: Set the RFCAL_DeltaGain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetRFCAL_DeltaGain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx37.bF.RFCAL_DeltaGain = uValue;
+
+        // read byte 0x37
+        err = ddTDA182I2Write(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetRFCAL_DeltaGain:
+//
+// DESCRIPTION: Get the RFCAL_DeltaGain bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetRFCAL_DeltaGain
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x37
+        err = ddTDA182I2Read(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx37.bF.RFCAL_DeltaGain;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2SetIRQ_Polarity:
+//
+// DESCRIPTION: Set the IRQ_Polarity bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2SetIRQ_Polarity
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8           uValue  //  I: Item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set value
+        pObj->I2CMap.uBx37.bF.IRQ_Polarity = uValue;
+
+        // read byte 0x37
+        err = ddTDA182I2Write(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2GetIRQ_Polarity:
+//
+// DESCRIPTION: Get the IRQ_Polarity bit(s) status
+//
+// RETURN:      tmdd_ERR_TUNER_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_PARAMETER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2GetIRQ_Polarity
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_PARAMETER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x37
+        err = ddTDA182I2Read(pObj, 0x37, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx37.bF.IRQ_Polarity;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_0
+//
+// DESCRIPTION: Get the rfcal_log_0 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_0
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x38
+        err = ddTDA182I2Read(pObj, 0x38, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx38.bF.rfcal_log_0;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_1
+//
+// DESCRIPTION: Get the rfcal_log_1 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_1
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x39
+        err = ddTDA182I2Read(pObj, 0x39, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx39.bF.rfcal_log_1;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_2
+//
+// DESCRIPTION: Get the rfcal_log_2 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_2
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3A
+        err = ddTDA182I2Read(pObj, 0x3A, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3A.bF.rfcal_log_2;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_3
+//
+// DESCRIPTION: Get the rfcal_log_3 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_3
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3B
+        err = ddTDA182I2Read(pObj, 0x3B, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3B.bF.rfcal_log_3;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_4
+//
+// DESCRIPTION: Get the rfcal_log_4 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_4
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3C
+        err = ddTDA182I2Read(pObj, 0x3C, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3C.bF.rfcal_log_4;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_5
+//
+// DESCRIPTION: Get the rfcal_log_5 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_5
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3D
+        err = ddTDA182I2Read(pObj, 0x3D, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3D.bF.rfcal_log_5;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_6
+//
+// DESCRIPTION: Get the rfcal_log_6 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_6
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3E
+        err = ddTDA182I2Read(pObj, 0x3E, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3E.bF.rfcal_log_6;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_7
+//
+// DESCRIPTION: Get the rfcal_log_7 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_7
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x3F
+        err = ddTDA182I2Read(pObj, 0x3F, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx3F.bF.rfcal_log_7;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_8
+//
+// DESCRIPTION: Get the rfcal_log_8 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_8
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x40
+        err = ddTDA182I2Read(pObj, 0x40, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx40.bF.rfcal_log_8;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_9
+//
+// DESCRIPTION: Get the rfcal_log_9 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_9
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x41
+        err = ddTDA182I2Read(pObj, 0x41, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx41.bF.rfcal_log_9;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_10
+//
+// DESCRIPTION: Get the rfcal_log_10 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_10
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x42
+        err = ddTDA182I2Read(pObj, 0x42, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx42.bF.rfcal_log_10;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2Getrfcal_log_11
+//
+// DESCRIPTION: Get the rfcal_log_11 bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2Getrfcal_log_11
+(
+ tmUnitSelect_t  tUnit,  //  I: Unit number
+ UInt8*          puValue //  I: Address of the variable to output item value
+ )
+{
+    ptmddTDA182I2Object_t    pObj = Null;
+    tmErrorCode_t                   err  = TM_OK;
+
+    // test the parameter
+    if (puValue == Null)
+        err = ddTDA182I2_ERR_BAD_UNIT_NUMBER;
+
+    if(err == TM_OK)
+    {
+        /* Get Instance Object */
+        err = ddTDA182I2GetInstance(tUnit, &pObj);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+    }
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // read byte 0x43
+        err = ddTDA182I2Read(pObj, 0x43, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Read(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // get value
+            *puValue = pObj->I2CMap.uBx43.bF.rfcal_log_11;
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+//-------------------------------------------------------------------------------------
+// FUNCTION:    tmddTDA182I2LaunchRF_CAL
+//
+// DESCRIPTION: Launch the RF_CAL bit(s) status
+//
+// RETURN:      ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//        ddTDA182I2_ERR_BAD_UNIT_NUMBER
+//         ddTDA182I2_ERR_NOT_INITIALIZED
+//        tmdd_ERR_IIC_ERR
+//         TM_OK 
+//
+// NOTES:       
+//-------------------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmddTDA182I2LaunchRF_CAL
+(
+ tmUnitSelect_t  tUnit   //  I: Unit number
+ )
+{
+    ptmddTDA182I2Object_t   pObj = Null;
+    tmErrorCode_t           err  = TM_OK;
+
+    /* Get Instance Object */
+    err = ddTDA182I2GetInstance(tUnit, &pObj);
+    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2GetInstance(0x%08X) failed.", tUnit));
+
+    if(err == TM_OK)
+    {
+        err = ddTDA182I2MutexAcquire(pObj, ddTDA182I2_MUTEX_TIMEOUT);
+    }
+
+    if(err == TM_OK)
+    {
+        // set Calc_PLL & RF_CAL
+        pObj->I2CMap.uBx19.MSM_byte_1 = 0x21;
+
+        // write byte 0x19
+        err = ddTDA182I2Write(pObj, 0x19, 1);
+        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+        if(err == TM_OK)
+        {
+            // trigger MSM_Launch
+            pObj->I2CMap.uBx1A.bF.MSM_Launch = 1;
+
+            // write byte 0x1A
+            err = ddTDA182I2Write(pObj, 0x1A, 1);
+            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2Write(0x%08X) failed.", tUnit));
+
+            // reset MSM_Launch (buffer only, no write)
+            pObj->I2CMap.uBx1A.bF.MSM_Launch = 0;
+
+            if(pObj->bIRQWait)
+            {
+                if(err == TM_OK)
+                {
+                    err = ddTDA182I2WaitIRQ(pObj, 1700, 50, 0x0C);
+                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "ddTDA182I2WaitIRQ(0x%08X) failed.", tUnit));
+                }
+
+            }            
+        }
+
+        (void)ddTDA182I2MutexRelease(pObj);
+    }
+
+    return err;
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_tda18272.h b/drivers/media/usb/rtl2832u/tuner_tda18272.h
new file mode 100644
index 00000000..b36c1650
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_tda18272.h
@@ -0,0 +1,7358 @@
+#ifndef __TUNER_TDA18272_H
+#define __TUNER_TDA18272_H
+
+/**
+
+@file
+
+@brief   TDA18272 tuner module declaration
+
+One can manipulate TDA18272 tuner through TDA18272 module.
+TDA18272 module is derived from tuner module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_tda18272.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE          *pTuner;
+	TDA18272_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	int StandardBandwidthMode;
+
+
+	...
+
+
+
+	// Build TDA18272 tuner module.
+	BuildTda18272Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0,								// I2C device address is 0xc0 in 8-bit format.
+		CRYSTAL_FREQ_16000000HZ,			// Crystal frequency is 16.0 MHz.
+		TDA18272_UNIT_0,					// Unit number is 0.
+		TDA18272_IF_OUTPUT_VPP_0P7V			// IF output Vp-p is 0.7 V.
+		);
+
+
+
+
+
+	// Get TDA18272 tuner extra module.
+	pTunerExtra = (TDA18272_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set TDA18272 standard and bandwidth mode.
+	pTunerExtra->SetStandardBandwidthMode(pTuner, TDA18272_STANDARD_BANDWIDTH_DVBT_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get TDA18272 bandwidth.
+	pTunerExtra->GetStandardBandwidthMode(pTuner, &StandardBandwidthMode);
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+
+
+
+#include "tuner_base.h"
+
+
+
+
+
+// Defined by Realtek for tuner TDA18272.
+#define TMBSL_TDA18272
+
+
+
+
+
+// The following context is source code provided by NXP.
+
+
+
+
+
+// NXP source code - .\cfg\tmbslTDA182I2_InstanceCustom.h
+
+
+ /*
+  Copyright (C) 2006-2009 NXP B.V., All Rights Reserved.
+  This source code and any compilation or derivative thereof is the proprietary
+  information of NXP B.V. and is confidential in nature. Under no circumstances
+  is this software to be  exposed to or placed under an Open Source License of
+  any type without the expressed written permission of NXP B.V.
+ *
+ * \file          tmbslTDA182I2_InstanceCustom.h
+ *
+ *                1
+ *
+ * \date          %modify_time%
+ *
+ * \brief         Describe briefly the purpose of this file.
+ *
+ * REFERENCE DOCUMENTS :
+ *                
+ *
+ * Detailed description may be added here.
+ *
+ * \section info Change Information
+ *
+*/
+
+#ifndef _TMBSL_TDA182I2_INSTANCE_CUSTOM_H
+#define _TMBSL_TDA182I2_INSTANCE_CUSTOM_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*============================================================================*/
+/* Types and defines:                                                         */
+/*============================================================================*/
+
+/* Driver settings version definition */
+#define TMBSL_TDA182I2_SETTINGS_CUSTOMER_NUM    0  /* SW Settings Customer Number */
+#define TMBSL_TDA182I2_SETTINGS_PROJECT_NUM     0  /* SW Settings Project Number  */
+#define TMBSL_TDA182I2_SETTINGS_MAJOR_VER       0  /* SW Settings Major Version   */
+#define TMBSL_TDA182I2_SETTINGS_MINOR_VER       0  /* SW Settings Minor Version   */
+
+/* Custom Driver Instance Parameters: (Path 0) */
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MASTER                                                 \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Current Power state */               \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Minimum Power state */               \
+        0,                                                      /* RF */               \
+        tmTDA182I2_DVBT_8MHz,                                   /* Standard mode */               \
+        True,                                                   /* Master */   \
+        0,                                                      /* LT_Enable */    \
+        1,                                                      /* PSM_AGC1 */        \
+        0,                                                      /* AGC1_6_15dB */            \
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MASTER_DIGITAL                                           \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Current Power state */               \
+        tmTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndSynthe, /* Minimum Power state */               \
+        0,                                                      /* RF */               \
+        tmTDA182I2_DVBT_8MHz,                                   /* Standard mode */               \
+        True,                                                   /* Master */   \
+        1,                                                      /* LT_Enable */    \
+        0,                                                      /* PSM_AGC1 */        \
+        1,                                                      /* AGC1_6_15dB */            \
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_SLAVE                                                                 \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Current Power state */               \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Minimum Power state */               \
+        0,                                                      /* RF */               \
+        tmTDA182I2_DVBT_8MHz,                                   /* Standard mode */               \
+        False,                                                  /* Master */   \
+        0,                                                      /* LT_Enable */    \
+        1,                                                      /* PSM_AGC1 */        \
+        0,                                                      /* AGC1_6_15dB */            \
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_SLAVE_DIGITAL                                                                 \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Current Power state */               \
+        tmTDA182I2_PowerStandbyWithXtalOn,                      /* Minimum Power state */               \
+        0,                                                      /* RF */               \
+        tmTDA182I2_DVBT_8MHz,                                   /* Standard mode */               \
+        False,                                                  /* Master */   \
+        0,                                                      /* LT_Enable */    \
+        1,                                                      /* PSM_AGC1 */        \
+        0,                                                      /* AGC1_6_15dB */            \
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL                                                                 \
+            {   /* Std_Array */                                 /* DVB-T 6MHz */               \
+                3250000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_6MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_0_4MHz,                       /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,               /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* DVB-T 7MHz */               \
+                3500000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_7MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_min_8pc,                   /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,               /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* DVB-T 8MHz */               \
+                4000000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,               /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* QAM 6MHz */               \
+                3600000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_6MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_min_8pc,                   /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,               /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				True,											/* AGC1_freeze */ \
+				True											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* QAM 8MHz */               \
+                5000000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_9MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_min_8pc,                   /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_0_85MHz,                      /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,               /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				True,											/* AGC1_freeze */ \
+				True											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* ISDBT 6MHz */               \
+                3250000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_6MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_6Vpp_min_10_3_19_7dB,  /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_0_4MHz,                       /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* ATSC 6MHz */               \
+                3250000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_6MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_6Vpp_min_10_3_19_7dB,  /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_0_4MHz,                       /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d100_u94dBuV,           /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_104dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_104dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d112_u107dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d112_u107dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_3_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* DMB-T 8MHz */               \
+                4000000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+
+#define  TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG                                          \
+            {                                                   /* Analog M/N */               \
+                5400000,                                        /* IF */               \
+                1750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_6MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog B */               \
+                6400000,                                        /* IF */               \
+                2250000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_7MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band*/               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog G/H */               \
+                6750000,                                        /* IF */               \
+                2750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog I */               \
+                7250000,                                        /* IF */               \
+                2750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog D/K */               \
+                6850000,                                        /* IF */               \
+                2750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog L */               \
+                6750000,                                        /* IF */               \
+                2750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog L' */               \
+                1250000,                                        /* IF */               \
+                -2750000,                                       /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Analog FM Radio */               \
+                1250000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_1_5MHz,                          /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_0_85MHz,                      /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x02,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* Blind Scanning copy of PAL-I */               \
+                7250000,                                        /* IF */               \
+                2750000,                                        /* CF_Offset */               \
+                tmTDA182I2_LPF_8MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Disabled,                   /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Disabled,                   /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,              /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Enabled,           /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Disabled,                 /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_0_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Disabled,             /* AGC5_Atten_3dB */               \
+                0x01,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Disabled,           /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Frozen,                     /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            },               \
+            {                                                   /* ScanXpress */               \
+                5000000,                                        /* IF */               \
+                0,                                              /* CF_Offset */               \
+                tmTDA182I2_LPF_9MHz,                            /* LPF */               \
+                tmTDA182I2_LPFOffset_0pc,                       /* LPF_Offset */               \
+                tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* IF_Gain */               \
+                tmTDA182I2_IF_Notch_Enabled,                    /* IF_Notch */               \
+                tmTDA182I2_IF_HPF_Disabled,                     /* IF_HPF */               \
+                tmTDA182I2_DC_Notch_Enabled,                    /* DC_Notch */               \
+                tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV,            /* AGC1_LNA_TOP */               \
+                tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,  /* AGC2_RF_Attenuator_TOP */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,             /* AGC3_RF_AGC_TOP_Low_band */               \
+                tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,             /* AGC3_RF_AGC_TOP_High_band */               \
+                tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,     /* AGC4_IR_Mixer_TOP */               \
+                tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,       /* AGC5_IF_AGC_TOP */               \
+                tmTDA182I2_AGC5_Detector_HPF_Disabled,          /* AGC5_Detector_HPF */               \
+                tmTDA182I2_AGC3_Adapt_Enabled,                  /* AGC3_Adapt */               \
+                tmTDA182I2_AGC3_Adapt_TOP_2_Step,        /* AGC3_Adapt_TOP */               \
+                tmTDA182I2_AGC5_Atten_3dB_Enabled,              /* AGC5_Atten_3dB */               \
+                0x0e,                                           /* GSK : settings V2.0.0  */               \
+                tmTDA182I2_H3H5_VHF_Filter6_Enabled,            /* H3H5_VHF_Filter6 */               \
+                tmTDA182I2_LPF_Gain_Free,                       /* LPF_Gain */               \
+				False,											/* AGC1_freeze */ \
+				False											/* LTO_STO_immune */ \
+            }
+/* Custom Driver Instance Parameters: (Path 1) */
+
+/******************************************************************/
+/* Mode selection for PATH0                                       */
+/******************************************************************/
+
+#ifdef TMBSL_TDA18272
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH0 TMBSL_TDA182I2_INSTANCE_CUSTOM_MASTER
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH0 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG_SELECTION_PATH0 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG
+
+#else
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH0 TMBSL_TDA182I2_INSTANCE_CUSTOM_MASTER_DIGITAL
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH0 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL
+
+#endif
+
+/******************************************************************/
+/* Mode selection for PATH1                                       */
+/******************************************************************/
+
+#ifdef TMBSL_TDA18272
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH1 TMBSL_TDA182I2_INSTANCE_CUSTOM_SLAVE
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH1 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG_SELECTION_PATH1 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_ANALOG
+
+#else
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_MODE_PATH1 TMBSL_TDA182I2_INSTANCE_CUSTOM_SLAVE_DIGITAL
+
+#define TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL_SELECTION_PATH1 TMBSL_TDA182I2_INSTANCE_CUSTOM_STD_DIGITAL
+
+#endif
+
+/******************************************************************/
+/* End of Mode selection                                          */
+/******************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TMBSL_TDA182I2_INSTANCE_CUSTOM_H */
+
+
+//#endif               \
+//*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmFlags.h
+
+
+ /*                                        */                                                                         
+ /*                                                                     */            
+ /* -- DO NOT EDIT --  file built by                                    */            
+ /*                                        */
+ /*-------------------------------------------------------------------------    */
+ /* (C) Copyright 2000 Koninklijke Philips Electronics N.V., All Rights Reserved*/
+ /*                                                                              */    
+ /* This source code and any compilation or derivative thereof is the sole       */
+ /* property of Philips Corporation and is provided pursuant to a Software       */
+ /* License Agreement.  This code is the proprietary information of              */
+ /* Philips Corporation and is confidential in nature.  Its use and              */
+ /* dissemination by any party other than Philips Corporation is strictly        */
+ /* limited by the confidential information provisions of the Agreement          */
+ /* referenced above.                                                            */
+ /*-------------------------------------------------------------------------     */
+ /*                                        */
+
+ /*                                        */                                                                         
+ /* DOCUMENT REF: DVP Build Process Specification                               */
+ /*                                                                             */
+ /* NOTES:        This file defines the TMFL_xxx build flags.                   */
+ /*                                                                             */
+ #if         !defined(_TMFLAGS_H_SEEN_)                                     
+ #define _TMFLAGS_H_SEEN_                                                   
+ /* configuration                                                            */
+ /*      */
+ /* FILENAME:     tmFlags.h                   */
+ /*                                           */
+ /* DESCRIPTION:  Generated by  */
+ #define TMFL_BUILD_VERSION            00.00.00
+ #define TMFL_CPU                      0x00020011
+ #define TMFL_ENDIAN                   1
+ #define TMFL_OS                       0x03020500
+ #define TMFL_CPU_IS_X86               1
+ #define TMFL_CPU_IS_MIPS              0
+ #define TMFL_CPU_IS_HP                0
+ #define TMFL_CPU_IS_TM                0
+ #define TMFL_CPU_IS_ARM               0
+ #define TMFL_CPU_IS_REAL              0
+ #define TMFL_OS_IS_BTM                0
+ #define TMFL_OS_IS_CE                 0
+ #define TMFL_OS_IS_NT                 1
+ #define TMFL_OS_IS_PSOS               0
+ #define TMFL_OS_IS_NULLOS             0
+ #define TMFL_OS_IS_ECOS               0
+ #define TMFL_OS_IS_VXWORKS            0
+ #define TMFL_OS_IS_MTOS               0
+ #define TMFL_OS_IS_CEXEC              0
+ /* DO NOT CHANGE THIS FILE INDEPENDENTLY !!!                                   */
+ /* IT MUST BE SYNCHONISED WITH THE TMFLAGS TEMPLATE FILE ON THE                */
+ /* MOREUSE WEB SITE http://pww.rtg.sc.philips.com/cmd/html/global_files.html   */
+ /* CONTACT MOREUSE BEFORE ADDING NEW VALUES                                    */
+ /* constants                                    */
+ #define TMFL_CPU_TYPE_MASK            0xffff0000
+ #define TMFL_CPU_TYPE_X86             0x00010000
+ #define TMFL_CPU_TYPE_MIPS            0x00020000
+ #define TMFL_CPU_TYPE_TM              0x00030000
+ #define TMFL_CPU_TYPE_HP              0x00040000
+ #define TMFL_CPU_TYPE_ARM             0x00050000
+ #define TMFL_CPU_TYPE_REAL            0x00060000
+ #define TMFL_CPU_MODEL_MASK           0x0000ffff
+ #define TMFL_CPU_MODEL_I486           0x00000001
+ #define TMFL_CPU_MODEL_R3940          0x00000002
+ #define TMFL_CPU_MODEL_R4300          0x00000003
+ #define TMFL_CPU_MODEL_TM1100         0x00000004
+ #define TMFL_CPU_MODEL_TM1300         0x00000005
+ #define TMFL_CPU_MODEL_TM32           0x00000006
+ #define TMFL_CPU_MODEL_HP             0x00000007
+ #define TMFL_CPU_MODEL_R4640          0x00000008
+ #define TMFL_CPU_MODEL_ARM7           0x00000009
+ #define TMFL_CPU_MODEL_ARM920T        0x0000000a
+ #define TMFL_CPU_MODEL_ARM940T        0x0000000b
+ #define TMFL_CPU_MODEL_ARM10          0x0000000c
+ #define TMFL_CPU_MODEL_STRONGARM      0x0000000d
+ #define TMFL_CPU_MODEL_RD24120        0x0000000e
+ #define TMFL_CPU_MODEL_ARM926EJS      0x0000000f
+ #define TMFL_CPU_MODEL_ARM946         0x00000010
+ #define TMFL_CPU_MODEL_R1910          0x00000011
+ #define TMFL_CPU_MODEL_R4450          0x00000012
+ #define TMFL_CPU_MODEL_TM3260         0x00000013
+ #define TMFL_ENDIAN_BIG               1
+ #define TMFL_ENDIAN_LITTLE            0
+ #define TMFL_OS_MASK                  0xff000000
+ #define TMFL_OS_VERSION_MASK          0x00ffffff
+ #define TMFL_OS_BTM                   0x00000000
+ #define TMFL_OS_CE                    0x01000000
+ #define TMFL_OS_CE212                 0x01020102
+ #define TMFL_OS_CE300                 0x01030000
+ #define TMFL_OS_NT                    0x02000000
+ #define TMFL_OS_NT4                   0x02040000
+ #define TMFL_OS_PSOS                  0x03000000
+ #define TMFL_OS_PSOS250               0x03020500
+ #define TMFL_OS_PSOS200               0x03020000
+ #define TMFL_OS_NULLOS                0x04000000
+ #define TMFL_OS_ECOS                  0x05000000
+ #define TMFL_OS_VXWORKS               0x06000000
+ #define TMFL_OS_MTOS                  0x07000000
+ #define TMFL_OS_CEXEC                 0x08000000
+ #define TMFL_SCOPE_SP                 0
+ #define TMFL_SCOPE_MP                 1
+ #define TMFL_REL_ASSERT               0x00000002
+ #define TMFL_REL_DEBUG                0x00000001
+ #define TMFL_REL_RETAIL               0x00000000
+ #define TMFL_CPU_I486                 0x00010001
+ #define TMFL_CPU_R3940                0x00020002
+ #define TMFL_CPU_R4300                0x00020003
+ #define TMFL_CPU_TM1100               0x00030004
+ #define TMFL_CPU_TM1300               0x00030005
+ #define TMFL_CPU_TM32                 0x00030006
+ #define TMFL_CPU_HP                   0x00040007
+ #define TMFL_CPU_R4640             0x00020008
+ #define TMFL_CPU_ARM7              0x00050009
+ #define TMFL_CPU_ARM920T           0x0005000a
+ #define TMFL_CPU_ARM940T           0x0005000b
+ #define TMFL_CPU_ARM10                   0x0005000c
+ #define TMFL_CPU_STRONGARM            0x0005000d
+ #define TMFL_CPU_RD24120              0x0006000e
+ #define TMFL_CPU_ARM926EJS            0x0005000f
+ #define TMFL_CPU_ARM946               0x00050010
+ #define TMFL_CPU_R1910             0x00020011
+ #define TMFL_CPU_R4450             0x00020012
+ #define TMFL_CPU_TM3260             0x00030013
+ #define TMFL_MODE_KERNEL              1
+ #define TMFL_MODE_USER                0
+
+ #endif   /* !defined(_TMFLAGS_H_SEEN_)                                         */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmNxTypes.h
+
+
+/*==========================================================================*/
+/*     (Copyright (C) 2003 Koninklijke Philips Electronics N.V.             */
+/*     All rights reserved.                                                 */
+/*     This source code and any compilation or derivative thereof is the    */
+/*     proprietary information of Koninklijke Philips Electronics N.V.      */
+/*     and is confidential in nature.                                       */
+/*     Under no circumstances is this software to be exposed to or placed   */
+/*     under an Open Source License of any type without the expressed       */
+/*     written permission of Koninklijke Philips Electronics N.V.           */
+/*==========================================================================*/
+/*
+* Copyright (C) 2000,2001
+*               Koninklijke Philips Electronics N.V.
+*               All Rights Reserved.
+*
+* Copyright (C) 2000,2001 TriMedia Technologies, Inc.
+*               All Rights Reserved.
+*
+*############################################################
+*
+* Module name  : tmNxTypes.h  %version: 4 %
+*
+* Last Update  : %date_modified: Tue Jul  8 18:08:00 2003 %
+*
+* Description: TriMedia/MIPS global type definitions.
+*
+* Document Ref: DVP Software Coding Guidelines Specification
+* DVP/MoReUse Naming Conventions specification
+* DVP Software Versioning Specification
+* DVP Device Library Architecture Specification
+* DVP Board Support Library Architecture Specification
+* DVP Hardware API Architecture Specification
+*
+*
+*############################################################
+*/
+
+#ifndef TMNXTYPES_H
+#define TMNXTYPES_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+//#include "tmFlags.h"                    // DVP common build control flags
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    //-----------------------------------------------------------------------------
+    // Types and defines:
+    //-----------------------------------------------------------------------------
+    //
+
+    /*Under the TCS, <tmlib/tmtypes.h> may have been included by our client. In
+    order to avoid errors, we take account of this possibility, but in order to
+    support environments where the TCS is not available, we do not include the
+    file by name.*/
+
+#ifndef _TMtypes_h
+#define _TMtypes_h
+
+#define False           0
+#define True            1
+
+#ifdef TMFL_NATIVE_C_FORCED
+ #undef TMFL_DOT_NET_2_0_TYPES
+#undef NXPFE
+#endif
+
+#ifndef TMFL_DOT_NET_2_0_TYPES
+ #ifdef __cplusplus
+  #define Null            0
+ #else
+  #define Null            ((Void *) 0)
+ #endif
+#else
+ #define Null            nullptr
+#endif
+
+    //
+    //      Standard Types
+    //
+
+    typedef signed   char   CInt8;   //  8 bit   signed integer
+    typedef signed   short  CInt16;  // 16 bit   signed integer
+    typedef signed   long   CInt32;  // 32 bit   signed integer
+    typedef unsigned char   CUInt8;  //  8 bit unsigned integer
+    typedef unsigned short  CUInt16; // 16 bit unsigned integer
+    typedef unsigned long   CUInt32; // 32 bit unsigned integer
+//    typedef float           CFloat;  // 32 bit floating point
+    typedef unsigned int    CBool;   // Boolean (True/False)
+    typedef char            CChar;   // character, character array ptr
+    typedef int             CInt;    // machine-natural integer
+    typedef unsigned int    CUInt;   // machine-natural unsigned integer
+
+#ifndef TMFL_DOT_NET_2_0_TYPES
+    typedef CInt8           Int8;   //  8 bit   signed integer
+    typedef CInt16          Int16;  // 16 bit   signed integer
+    typedef CInt32          Int32;  // 32 bit   signed integer
+    typedef CUInt8          UInt8;  //  8 bit unsigned integer
+    typedef CUInt16         UInt16; // 16 bit unsigned integer
+    typedef CUInt32         UInt32; // 32 bit unsigned integer
+//    typedef CFloat          Float;  // 32 bit floating point
+    typedef CBool           Bool;   // Boolean (True/False)
+    typedef CChar           Char;   // character, character array ptr
+    typedef CInt            Int;    // machine-natural integer
+    typedef CUInt           UInt;   // machine-natural unsigned integer
+    typedef char           *String; // Null terminated 8 bit char str
+
+    //-----------------------------------------------------------------------------
+    // Legacy TM Types/Structures (Not necessarily DVP Coding Guideline compliant)
+    // NOTE: For DVP Coding Gudeline compliant code, do not use these types.
+    //
+    typedef char          *Address;        // Ready for address-arithmetic
+    typedef char const    *ConstAddress;
+    typedef unsigned char  Byte;           // Raw byte
+//    typedef float          Float32;        // Single-precision float
+//    typedef double         Float64;        // Double-precision float
+    typedef void          *Pointer;        // Pointer to anonymous object
+    typedef void const    *ConstPointer;
+    typedef char const    *ConstString;
+#else
+    using namespace System;    
+    typedef int             Int;
+    typedef SByte           Int8;
+    typedef Byte            UInt8;
+    typedef float           Float32;    
+    typedef unsigned int    Bool;
+#endif
+
+
+    typedef Int             Endian;
+#define BigEndian       0
+#define LittleEndian    1
+
+    typedef struct tmVersion
+    {
+        UInt8   majorVersion;
+        UInt8   minorVersion;
+        UInt16  buildVersion;
+    }   tmVersion_t, *ptmVersion_t;
+#endif /*ndef _TMtypes_h*/
+
+    /*Define DVP types that are not TCS types.*/
+
+#ifndef TMFL_DOT_NET_2_0_TYPES
+    typedef Int8   *pInt8;            //  8 bit   signed integer
+    typedef Int16  *pInt16;           // 16 bit   signed integer
+    typedef Int32  *pInt32;           // 32 bit   signed integer
+    typedef UInt8  *pUInt8;           //  8 bit unsigned integer
+    typedef UInt16 *pUInt16;          // 16 bit unsigned integer
+    typedef UInt32 *pUInt32;          // 32 bit unsigned integer
+    typedef void    Void, *pVoid;     // Void (typeless)
+//    typedef Float  *pFloat;           // 32 bit floating point
+//    typedef double  Double, *pDouble; // 32/64 bit floating point
+    typedef Bool   *pBool;            // Boolean (True/False)
+    typedef Char   *pChar;            // character, character array ptr
+    typedef Int    *pInt;             // machine-natural integer
+    typedef UInt   *pUInt;            // machine-natural unsigned integer
+    typedef String *pString;          // Null terminated 8 bit char str,
+#else
+    typedef Void *pVoid;     // Void (typeless)
+#endif
+    /*Assume that 64-bit integers are supported natively by C99 compilers and Visual
+    C version 6.00 and higher. More discrimination in this area may be added
+    here as necessary.*/
+#ifndef TMFL_DOT_NET_2_0_TYPES
+#if defined __STDC_VERSION__ && __STDC_VERSION__ > 199409L
+    /*This can be enabled only when all explicit references to the hi and lo
+    structure members are eliminated from client code.*/
+#define TMFL_NATIVE_INT64 1
+    typedef signed   long long int Int64,  *pInt64;  // 64-bit integer
+    typedef unsigned long long int UInt64, *pUInt64; // 64-bit bitmask
+    // #elif defined _MSC_VER && _MSC_VER >= 1200
+    // /*This can be enabled only when all explicit references to the hi and lo
+    //     structure members are eliminated from client code.*/
+    // #define TMFL_NATIVE_INT64 1
+    // typedef signed   __int64 Int64,  *pInt64;  // 64-bit integer
+    // typedef unsigned __int64 UInt64, *pUInt64; // 64-bit bitmask
+#else /*!(defined __STDC_VERSION__ && __STDC_VERSION__ > 199409L)*/
+#define TMFL_NATIVE_INT64 0
+    typedef
+    struct
+    {
+        /*Get the correct endianness (this has no impact on any other part of
+        the system, but may make memory dumps easier to understand).*/
+#if TMFL_ENDIAN == TMFL_ENDIAN_BIG
+        Int32 hi; UInt32 lo;
+#else
+        UInt32 lo; Int32 hi;
+#endif
+    }
+    Int64, *pInt64; // 64-bit integer
+    typedef
+    struct
+    {
+#if TMFL_ENDIAN == TMFL_ENDIAN_BIG
+        UInt32 hi; UInt32 lo;
+#else
+        UInt32 lo; UInt32 hi;
+#endif
+    }
+    UInt64, *pUInt64; // 64-bit bitmask
+#endif /*defined __STDC_VERSION__ && __STDC_VERSION__ > 199409L*/
+#endif /*TMFL_DOT_NET_2_0_TYPES*/
+    // Maximum length of device name in all BSP and capability structures
+#define HAL_DEVICE_NAME_LENGTH 16
+
+    typedef CUInt32 tmErrorCode_t;
+    typedef CUInt32 tmProgressCode_t;
+
+    /* timestamp definition */
+#ifndef TMFL_DOT_NET_2_0_TYPES
+    typedef UInt64 tmTimeStamp_t, *ptmTimeStamp_t;
+#endif
+    //for backwards compatibility with the older tmTimeStamp_t definition
+#define ticks   lo
+#define hiTicks hi
+
+    typedef union tmColor3                 // 3 byte color structure
+    {
+        unsigned long u32;
+#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+        struct {
+UInt32       : 8;
+            UInt32 red   : 8;
+            UInt32 green : 8;
+            UInt32 blue  : 8;
+        } rgb;
+        struct {
+UInt32   : 8;
+            UInt32 y : 8;
+            UInt32 u : 8;
+            UInt32 v : 8;
+        } yuv;
+        struct {
+UInt32   : 8;
+            UInt32 u : 8;
+            UInt32 m : 8;
+            UInt32 l : 8;
+        } uml;
+#else
+        struct {
+            UInt32 blue  : 8;
+            UInt32 green : 8;
+            UInt32 red   : 8;
+UInt32       : 8;
+        } rgb;
+        struct {
+            UInt32 v : 8;
+            UInt32 u : 8;
+            UInt32 y : 8;
+UInt32   : 8;
+        } yuv;
+        struct {
+            UInt32 l : 8;
+            UInt32 m : 8;
+            UInt32 u : 8;
+UInt32   : 8;
+        } uml;
+#endif
+    }   tmColor3_t, *ptmColor3_t;
+
+    typedef union tmColor4                 // 4 byte color structure
+    {
+        unsigned long u32;
+#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+        struct {
+            UInt32 alpha    : 8;
+            UInt32 red      : 8;
+            UInt32 green    : 8;
+            UInt32 blue     : 8;
+        } argb;
+        struct {
+            UInt32 alpha    : 8;
+            UInt32 y        : 8;
+            UInt32 u        : 8;
+            UInt32 v        : 8;
+        } ayuv;
+        struct {
+            UInt32 alpha    : 8;
+            UInt32 u        : 8;
+            UInt32 m        : 8;
+            UInt32 l        : 8;
+        } auml;
+#else
+        struct {
+            UInt32 blue     : 8;
+            UInt32 green    : 8;
+            UInt32 red      : 8;
+            UInt32 alpha    : 8;
+        } argb;
+        struct {
+            UInt32 v        : 8;
+            UInt32 u        : 8;
+            UInt32 y        : 8;
+            UInt32 alpha    : 8;
+        } ayuv;
+        struct {
+            UInt32 l        : 8;
+            UInt32 m        : 8;
+            UInt32 u        : 8;
+            UInt32 alpha    : 8;
+        } auml;
+#endif
+    }   tmColor4_t, *ptmColor4_t;
+
+    //-----------------------------------------------------------------------------
+    // Hardware device power states
+    //
+    typedef enum tmPowerState
+    {
+        tmPowerOn,                          // Device powered on      (D0 state)
+        tmPowerStandby,                     // Device power standby   (D1 state)
+        tmPowerSuspend,                     // Device power suspended (D2 state)
+        tmPowerOff                          // Device powered off     (D3 state)
+
+    }   tmPowerState_t, *ptmPowerState_t;
+
+    //-----------------------------------------------------------------------------
+    // Software Version Structure
+    //
+    typedef struct tmSWVersion
+    {
+        UInt32      compatibilityNr;        // Interface compatibility number
+        UInt32      majorVersionNr;         // Interface major version number
+        UInt32      minorVersionNr;         // Interface minor version number
+
+    }   tmSWVersion_t, *ptmSWVersion_t;
+
+    /*Under the TCS, <tm1/tmBoardDef.h> may have been included by our client. In
+    order to avoid errors, we take account of this possibility, but in order to
+    support environments where the TCS is not available, we do not include the
+    file by name.*/
+#ifndef _TMBOARDDEF_H_
+#define _TMBOARDDEF_H_
+
+    //-----------------------------------------------------------------------------
+    // HW Unit Selection
+    //
+    typedef CInt tmUnitSelect_t, *ptmUnitSelect_t;
+
+#define tmUnitNone (-1)
+#define tmUnit0    0
+#define tmUnit1    1
+#define tmUnit2    2
+#define tmUnit3    3
+#define tmUnit4    4
+
+    /*+compatibility*/
+#define unitSelect_t       tmUnitSelect_t
+#define unit0              tmUnit0
+#define unit1              tmUnit1
+#define unit2              tmUnit2
+#define unit3              tmUnit3
+#define unit4              tmUnit4
+#define DEVICE_NAME_LENGTH HAL_DEVICE_NAME_LENGTH
+    /*-compatibility*/
+
+#endif /*ndef _TMBOARDDEF_H_ */
+
+    //-----------------------------------------------------------------------------
+    // Instance handle
+    //
+    typedef Int tmInstance_t, *ptmInstance_t;
+
+#ifndef TMFL_DOT_NET_2_0_TYPES
+    // Callback function declaration
+    typedef Void (*ptmCallback_t) (UInt32 events, Void *pData, UInt32 userData);
+#define tmCallback_t ptmCallback_t /*compatibility*/
+#endif
+    //-----------------------------------------------------------------------------
+    // INLINE keyword for inline functions in all environments
+    //
+    // WinNT/WinCE: Use TMSHARED_DATA_BEGIN/TMSHARED_DATA_END for multiprocess
+    //  shared data on a single CPU.  To define data variables that are shared
+    //  across all processes for WinNT/WinCE, use the defined #pragma macros
+    //  TMSHARED_DATA_BEGIN/TMSHARED_DATA_END and initialize the data variables
+    //  as shown in the example below.  Data defined outside of the begin/end
+    //  section or not initialized will not be shared across all processes for
+    //  WinNT/WinCE; there will be a separate instance of the variable in each
+    //  process.  Use WinNT Explorer "QuickView" on the target DLL or text edit
+    //  the target DLL *.map file to verify the shared data section presence and
+    //  size (shared/static variables will not be named in the MAP file but will
+    //  be included in the shared section virtual size).
+    // NOTE: All data variables in the multiprocess section _MUST_BE_INITIALIZED_
+    //       to be shared across processes; if no explicit initialization is
+    //       done, the data variables will not be shared across processes.  This
+    //       shared data mechanism only applies to WinNT/WinCE multiprocess data
+    //       on a single CPU (pSOS shares all data across tasks by default).  Use
+    //       the TMML MP shared data region for shared data across multiple CPUs
+    //       and multiple processes.  Example (note global variable naming):
+    //
+    //  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+    //  #pragma TMSHARED_DATA_BEGIN         // Multiprocess shared data begin
+    //  #endif
+    //
+    //  static g<Multiprocess shared data variable> = <Initialization value>;
+    //         gtm<Multiprocess shared data variable> = <Initialization value>;
+    //
+    //  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+    //  #pragma TMSHARED_DATA_END           // Multiprocess shared data end
+    //  #endif
+    //
+
+#if        TMFL_OS_IS_CE || TMFL_OS_IS_NT
+#define inline  __inline
+
+    //
+    // Places shared data in named DLL data segment for WinNT/WinCE builds.
+    // NOTE: These pragma defines require DLLFLAGS += -section:.tmShare,RWS in the
+    //       nt.mak and ce.mak target OS makefiles for this mechanism to work.
+    //
+#define TMSHARED_DATA_BEGIN     data_seg(".tmShare")
+#define TMSHARED_DATA_END       data_seg()
+
+#elif      TMFL_OS_IS_PSOS && TMFL_CPU_IS_MIPS
+
+    // NOTE regarding the keyword INLINE:
+    //
+    // Inline is not an ANSI-C keyword, hence every compiler can implement inlining
+    // the way it wants to. When using the dcc compiler this might possibly lead to
+    // redeclaration warnings when linking. For example:
+    //
+    //      dld: warning: Redeclaration of tmmlGetMemHandle
+    //      dld:    Defined in root.o
+    //      dld:    and        tmmlApi.o(../../lib/pSOS-MIPS/libtmml.a)
+    //
+    // For the dcc compiler inlining is not on by default. When building a retail
+    // version ( _TMTGTREL=ret), inlining is turned on explicitly in the dvp1 pSOS
+    // makefiles by specifying -XO, which enables all standard optimizations plus
+    // some others, including inlining (see the Language User's Manual, D-CC and
+    // D-C++ Compiler Suites p46). When building a debug version ( _TMTGTREL=dbg),
+    // the optimizations are not turned on (and even if they were they would have
+    // been overruled by -g anyway).
+    //
+    // When a .h file with inline function declarations gets included in multiple
+    // source files, redeclaration warnings are issued.
+    //
+    // When building a retail version those functions are inlined, but in addition
+    // the function is also declared within the .o file, resulting in redeclaration
+    // warnings as the same function is also defined by including that same header
+    // file in other source files. Defining the functions as static inline rather
+    // than inline solves the problem, as now the additional function declaration
+    // is omitted (as now the compiler realizes that there is no point in keeping
+    // that declaration as it can only be called from within this specific file,
+    // but it isn't, because all calls are already inline).
+    //
+    // When building a debug version no inlining is done, but the functions are
+    // still defined within the .o file, again resulting in redeclaration warnings.
+    // Again, defining the functions to be static inline rather than inline solves
+    // the problem.
+
+    // Now if we would change the definition of the inline keyword for pSOS from
+    // __inline__ to static __inline__, all inline function definitions throughout
+    // the code would not issue redeclaration warnings anymore, but all static
+    // inline definitions would.
+    // If we don't change the definition of the inline keyword, all inline func-
+    // tion definitions would return redeclaration warnings.
+    //
+    // As this is a pSOS linker bug, it was decided not to change the code but
+    // rather to ignore the issued warnings.
+    //
+
+#define inline  __inline__
+
+#elif      TMFL_OS_IS_PSOS && TMFL_CPU_IS_TM
+    // TriMedia keyword is already inline
+
+#elif      TMFL_OS_IS_ECOS && TMFL_CPU_IS_MIPS
+
+#define inline  __inline__
+
+#elif      (TMFL_OS_IS_HPUNIX || TMFL_OS_IS_NULLOS)
+    //
+    // TMFL_OS_IS_HPUNIX is the HP Unix workstation target OS environment for the
+    // DVP SDE2 using the GNU gcc toolset.  It is the same as TMFL_OS_IS_NULLOS
+    // (which is inaccurately named because it is the HP Unix CPU/OS target
+    // environment).
+    //
+    /* LM; 02/07/2202; to be able to use Insure, I modify the definition of inline */
+    /* #define inline  __inline__ */
+#define inline  
+
+#elif TMFL_OS_IS_ECOS && TMFL_CPU_IS_MIPS
+
+#define inline
+
+#else // TMFL_OS_IS_???
+
+#error confusing value in TMFL_OS!
+
+#endif // TMFL_OS_IS_XXX
+
+    /*Assume that |restrict| is supported by tmcc and C99 compilers only. More
+    discrimination in this area may be added here as necessary.*/
+#if !(defined __TCS__ ||                                                       \
+    (defined __STDC_VERSION__ && __STDC_VERSION__ > 199409L))
+#define restrict /**/
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //ndef TMNXTYPES_H
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmCompId.h
+
+
+/*==========================================================================*/
+/*     (Copyright (C) 2003 Koninklijke Philips Electronics N.V.             */
+/*     All rights reserved.                                                 */
+/*     This source code and any compilation or derivative thereof is the    */
+/*     proprietary information of Koninklijke Philips Electronics N.V.      */
+/*     and is confidential in nature.                                       */
+/*     Under no circumstances is this software to be exposed to or placed   */
+/*     under an Open Source License of any type without the expressed       */
+/*     written permission of Koninklijke Philips Electronics N.V.           */
+/*==========================================================================*/
+//-----------------------------------------------------------------------------
+// MoReUse - 2001-11-12  Continuus Version 16
+//
+// Added
+//   CID_COMP_TRICK
+//   CID_COMP_TODISK
+//   CID_COMP_FROMDISK
+// 
+// Removed
+// CID_COMP_RTC  Twice the same request - duplicate removed          
+//
+// (C) Copyright 2000-2001 Koninklijke Philips Electronics N.V.,
+//     All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of Philips Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of Philips
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than Philips Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmCompId.h
+//
+// DESCRIPTION:  This header file identifies the standard component identifiers
+//               for DVP platforms.  The objective of DVP component IDs is to
+//               enable unique identification of software components at all
+//               classes, types, and layers.  In addition, standard status
+//               values are also defined to make determination of typical error
+//               cases much easier.  The component identifier bitfields are
+//               four bit aligned to ease in reading the hexadecimal value.
+//
+//               The process to create a new component ID follows the sequence
+//               of steps:
+//
+//               1) Select a component class:  The class is the most general
+//                  component classification.  If none of the classifications
+//                  match and the component can still be uniquely identified
+//                  by its type/tag/layer combination, use CID_CLASS_NONE.
+//                  For customers, the CID_CLASS_CUSTOMER value is defined.
+//                  If that value is used in the CID_CLASS_BITMASK field,
+//                  all other bits in the component ID are user defined.
+//
+//               2) Select a component type:   The component type is used to
+//                  classify how a component processes data.  Components may
+//                  have only output pins (source), only input pins (sink),
+//                  input and output pins with or without data modifications
+//                  (filter), control of data flow without input/output pins
+//                  (control), data storage/access/retrieval (database),
+//                  or component group (subsystem).  If the component does
+//                  not fit into any type classification, use CID_TYPE_NONE.
+//
+//               3) Create a component ID:     The component ID is used to
+//                  classify the specific type and/or attributes of a software
+//                  component API interface.  The currently defined list should
+//                  be scanned for a component match.  If no component match
+//                  can be found, define a new component tag that descibes the
+//                  component clearly.  Component name abbreviations/acronyms
+//                  are generally used; build a name starting from left to
+//                  right with the most general ('A' or 'AUD' for audio, 'V' or
+//                  'VID' for video, etc.) to the most specific ('AC3' or 'MP3'
+//                  as specific audio filter types) terms for the component.
+//
+//               NOTE: Component layer (CID_LAYER_XXX) and status (CID_ERR_XXX)
+//                     values are defined within the software component APIs
+//                     header files, not in this file.
+//
+// DOCUMENT REF: DVP Software Coding Guidelines specification
+//               DVP/MoReUse Naming Conventions specification
+//
+// NOTES:        The 32 bit component identifier bitfields are defined in the
+//               diagram below:
+//
+//           +-----------------------------------------  4 bit Component Class
+//          /      +-----------------------------------  4 bit Component Type
+//         /      /         +--------------------------  8 bit Component Tag
+//        /      /         /         +-----------------  4 bit Component Layer
+//       /      /         /         /            +----- 12 bit Component Status
+//      /      /         /         /            /
+//  |31  28|27  24|23        16|15  12|11               0| bit
+//  +------+------+------------+------+------------------+
+//  |Class | Type |ComponentTag|Layer |  Error/Progress  |
+//  +------+------+------------+------+------------------+
+//
+//-----------------------------------------------------------------------------
+//
+#ifndef TMCOMPID_H //-------------------
+#define TMCOMPID_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// TM_OK is the 32 bit global status value used by all DVP software components
+//  to indicate successful function/operation status.  If a non-zero value is
+//  returned as status, it should use the component ID formats defined.
+//
+#define TM_OK               0         // Global success return status
+
+
+//
+// NOTE: Component ID types are defined as unsigned 32 bit integers (UInt32).
+//
+//-----------------------------------------------------------------------------
+// Component Class definitions (bits 31:28, 4 bits)
+// NOTE: A class of 0x0 must not be defined to ensure that the overall 32 bit
+//       component ID/status combination is always non-0 (no TM_OK conflict).
+//
+#define CID_CLASS_BITSHIFT  28                          // Component class bit shift
+#define CID_CLASS_BITMASK   (0xF << CID_CLASS_BITSHIFT) // Class AND bitmsk
+#define CID_GET_CLASS(compId)   ((compId & CID_CLASS_BITMASK) >> CID_CLASS_BITSHIFT)
+//
+#define CID_CLASS_NONE      (0x1 << CID_CLASS_BITSHIFT) // No class information
+#define CID_CLASS_VIDEO     (0x2 << CID_CLASS_BITSHIFT) // Video data component
+#define CID_CLASS_AUDIO     (0x3 << CID_CLASS_BITSHIFT) // Audio data component
+#define CID_CLASS_GRAPHICS  (0x4 << CID_CLASS_BITSHIFT) // Graphics component
+#define CID_CLASS_BUS       (0x5 << CID_CLASS_BITSHIFT) // In/out/control bus
+#define CID_CLASS_INFRASTR  (0x6 << CID_CLASS_BITSHIFT) // Infrastructure comp.
+                            // Up to 0xE = Philips reserved class IDs
+#define CID_CLASS_CUSTOMER  (0xF << CID_CLASS_BITSHIFT) // Customer rsvd class
+
+
+//-----------------------------------------------------------------------------
+// Component Type definitions (bits 27:24, 4 bits)
+//
+#define CID_TYPE_BITSHIFT   24                          // Component type bit shift
+#define CID_TYPE_BITMASK    (0xF << CID_TYPE_BITSHIFT)  // Type AND bitmask
+#define CID_GET_TYPE(compId)    ((compId & CID_TYPE_BITMASK) >> CID_TYPE_BITSHIFT)
+//
+#define CID_TYPE_NONE       (0x0 << CID_TYPE_BITSHIFT)  // No data connections
+#define CID_TYPE_SOURCE     (0x1 << CID_TYPE_BITSHIFT)  // Source, output pins
+#define CID_TYPE_SINK       (0x2 << CID_TYPE_BITSHIFT)  // Sink,   input pins
+#define CID_TYPE_ENCODER    (0x3 << CID_TYPE_BITSHIFT)  // Data encoder
+#define CID_TYPE_DECODER    (0x4 << CID_TYPE_BITSHIFT)  // Data decoder
+#define CID_TYPE_MUX        (0x5 << CID_TYPE_BITSHIFT)  // Data multiplexer
+#define CID_TYPE_DEMUX      (0x6 << CID_TYPE_BITSHIFT)  // Data demultiplexer
+#define CID_TYPE_DIGITIZER  (0x7 << CID_TYPE_BITSHIFT)  // Data digitizer
+#define CID_TYPE_RENDERER   (0x8 << CID_TYPE_BITSHIFT)  // Data renderer
+#define CID_TYPE_FILTER     (0x9 << CID_TYPE_BITSHIFT)  // Data filter/processr
+#define CID_TYPE_CONTROL    (0xA << CID_TYPE_BITSHIFT)  // Data control/switch
+#define CID_TYPE_DATABASE   (0xB << CID_TYPE_BITSHIFT)  // Data store/access
+#define CID_TYPE_SUBSYSTEM  (0xC << CID_TYPE_BITSHIFT)  // MultiComp subsystem
+#define CID_TYPE_CUSTOMER   (0xF << CID_TYPE_BITSHIFT)  // Customer Defined Type
+                            // Up to 0xF = Philips reserved type IDs
+
+
+//-----------------------------------------------------------------------------
+// Component Tag definitions (bits 23:16, 8 bits)
+// NOTE: Component tags are defined in groups, dependent on the class and type.
+//
+#define CID_TAG_BITSHIFT    16                          // Component tag bit shift
+#define CID_TAG_BITMASK     (0xFF << CID_TAG_BITSHIFT)  // Comp tag AND bitmask
+//
+#define CID_TAG_NONE        (0x00 << CID_TAG_BITSHIFT)  // No tag information
+                            // Up to 0xFF = Philips reserved component tags
+#define CID_TAG_CUSTOMER    (0xE0 << CID_TAG_BITSHIFT)
+
+#define TAG(number)         ((number) << CID_TAG_BITSHIFT) // Create tag from num
+
+//-----------------------------------------------------------------------------
+// Component Layer definitions (bits 15:12, 4 bits)
+//
+#define CID_LAYER_BITSHIFT  12                           // Component layer bit shift
+#define CID_LAYER_BITMASK   (0xF << CID_LAYER_BITSHIFT)  // Layer AND bitmask
+#define CID_GET_LAYER(compId)   ((compId & CID_LAYER_BITMASK) >> CID_LAYER_BITSHIFT)
+//
+#define CID_LAYER_NONE      (0x0 << CID_LAYER_BITSHIFT)  // No layer info
+#define CID_LAYER_BTM       (0x1 << CID_LAYER_BITSHIFT)  // Boot manager layer
+#define CID_LAYER_HWAPI     (0x2 << CID_LAYER_BITSHIFT)  // Hardware API layer
+#define CID_LAYER_BSL       (0x3 << CID_LAYER_BITSHIFT)  // Board Supp. Lib lyr
+#define CID_LAYER_DEVLIB    (0x4 << CID_LAYER_BITSHIFT)  // Device Library lyr
+#define CID_LAYER_TMAL      (0x5 << CID_LAYER_BITSHIFT)  // Application layer
+#define CID_LAYER_TMOL      (0x6 << CID_LAYER_BITSHIFT)  // OSDependent layer
+#define CID_LAYER_CUSTOMER  (0xF << CID_LAYER_BITSHIFT)  // Customer Defined Layer
+                            // Up to 0xF = Philips reserved layer IDs
+
+
+
+//-----------------------------------------------------------------------------
+// Component Identifier definitions (bits 31:12, 20 bits)
+// NOTE: These DVP platform component identifiers are designed to be unique
+//       within the system.  The component identifier encompasses the class
+//       (CID_CLASS_XXX), type (CID_TYPE_XXX), tag, and layer (CID_LAYER_XXX)
+//       fields to form the unique component identifier.  This allows any
+//       error/progress status value to be identified as to its original
+//       source, whether or not the source component's header file is present.
+//       The standard error/progress status definitions should be used
+//       whenever possible to ease status interpretation.  No layer
+//       information is defined at this point; it should be OR'd into the API
+//       status values defined in the API's header file.
+//
+#if     (CID_LAYER_NONE != 0)
+#error  ERROR: DVP component identifiers require the layer type 'NONE' = 0 !
+#endif
+
+//
+// Classless Types/Components (don't fit into other class categories)
+//
+#define CTYP_NOCLASS_NOTYPE     (CID_CLASS_NONE | CID_TYPE_NONE)
+#define CTYP_NOCLASS_SOURCE     (CID_CLASS_NONE | CID_TYPE_SOURCE)
+#define CTYP_NOCLASS_SINK       (CID_CLASS_NONE | CID_TYPE_SINK)
+#define CTYP_NOCLASS_MUX        (CID_CLASS_NONE | CID_TYPE_MUX)
+#define CTYP_NOCLASS_DEMUX      (CID_CLASS_NONE | CID_TYPE_DEMUX)
+#define CTYP_NOCLASS_FILTER     (CID_CLASS_NONE | CID_TYPE_FILTER)
+#define CTYP_NOCLASS_CONTROL    (CID_CLASS_NONE | CID_TYPE_CONTROL)
+#define CTYP_NOCLASS_DATABASE   (CID_CLASS_NONE | CID_TYPE_DATABASE)
+#define CTYP_NOCLASS_SUBSYS     (CID_CLASS_NONE | CID_TYPE_SUBSYSTEM)
+//
+#define CID_COMP_CLOCK          (TAG(0x01) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DMA            (TAG(0x02) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_PIC            (TAG(0x03) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NORFLASH       (TAG(0x04) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NANDFLASH      (TAG(0x05) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_GPIO           (TAG(0x06) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_SMARTCARD      (TAG(0x07) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_UDMA           (TAG(0x08) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DSP            (TAG(0x09) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TIMER          (TAG(0x0A) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TSDMA          (TAG(0x0B) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_MMIARB         (TAG(0x0C) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_EEPROM         (TAG(0x0D) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_PARPORT        (TAG(0x0E) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VSS            (TAG(0x0F) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TSIO           (TAG(0x10) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DBG            (TAG(0x11) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TTE            (TAG(0x12) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_AVPROP         (TAG(0x13) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_BLASTER        (TAG(0x14) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_CAPTURE        (TAG(0x15) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_STP            (TAG(0x16) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_SYN            (TAG(0x17) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TTX            (TAG(0x18) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_MIU            (TAG(0x19) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_INTDRV         (TAG(0x1A) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_RESET          (TAG(0x1B) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_CONFIG         (TAG(0x1C) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VCTRL          (TAG(0x1D) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TUNER          (TAG(0x1E) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DEMOD          (TAG(0x1F) | CTYP_NOCLASS_NOTYPE)
+
+
+#define CID_COMP_FREAD          (TAG(0x01) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_CDRREAD        (TAG(0x02) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_VSB            (TAG(0x03) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_ANALOGTVTUNER  (TAG(0x04) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TPINMPEG2      (TAG(0x05) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_DREAD          (TAG(0x06) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TREAD          (TAG(0x07) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_RTC            (TAG(0x08) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TOUCHC         (TAG(0x09) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_KEYPAD         (TAG(0x0A) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_ADC            (TAG(0x0B) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_READLIST       (TAG(0x0C) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_FROMDISK       (TAG(0x0D) | CTYP_NOCLASS_SOURCE)
+
+#define CID_COMP_FWRITE         (TAG(0x01) | CTYP_NOCLASS_SINK)
+#define CID_COMP_CDWRITE        (TAG(0x02) | CTYP_NOCLASS_SINK)
+#define CID_COMP_CHARLCD        (TAG(0x03) | CTYP_NOCLASS_SINK)
+#define CID_COMP_PWM            (TAG(0x04) | CTYP_NOCLASS_SINK)
+#define CID_COMP_DAC            (TAG(0x05) | CTYP_NOCLASS_SINK)
+#define CID_COMP_TSDMAINJECTOR  (TAG(0x06) | CTYP_NOCLASS_SINK)
+#define CID_COMP_TODISK         (TAG(0x07) | CTYP_NOCLASS_SINK)
+
+#define CID_COMP_MUXMPEGPS      (TAG(0x01) | CTYP_NOCLASS_MUX)
+#define CID_COMP_MUXMPEG        (TAG(0x02) | CTYP_NOCLASS_MUX)
+
+#define CID_COMP_DEMUXMPEGTS    (TAG(0x01) | CTYP_NOCLASS_DEMUX)
+#define CID_COMP_DEMUXMPEGPS    (TAG(0x02) | CTYP_NOCLASS_DEMUX)
+
+#define CID_COMP_COPYIO         (TAG(0x01) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_COPYINPLACE    (TAG(0x02) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_UART           (TAG(0x03) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_SSI            (TAG(0x04) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_MODEMV34       (TAG(0x05) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_MODEMV42       (TAG(0x06) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_HTMLPARSER     (TAG(0x07) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_VMSP           (TAG(0x08) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_X              (TAG(0x09) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_TXTSUBTDECEBU  (TAG(0x0A) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_CPI            (TAG(0x0B) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_TRICK          (TAG(0x0C) | CTYP_NOCLASS_FILTER)
+
+#define CID_COMP_REMCTL5        (TAG(0x01) | CTYP_NOCLASS_CONTROL)
+#define CID_COMP_INFRARED       (TAG(0x02) | CTYP_NOCLASS_CONTROL)
+
+#define CID_COMP_PSIP           (TAG(0x01) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_IDE            (TAG(0x02) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_DISKSCHED      (TAG(0x03) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_AVFS           (TAG(0x04) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_MDB            (TAG(0x05) | CTYP_NOCLASS_DATABASE)
+
+#define CID_COMP_IRDMMPEG       (TAG(0x01) | CTYP_NOCLASS_SUBSYS)
+#define CID_COMP_STORSYS        (TAG(0x02) | CTYP_NOCLASS_SUBSYS)
+
+//
+// Video Class Types/Components (video types handle video/graphics data)
+//
+#define CTYP_VIDEO_SINK         (CID_CLASS_VIDEO | CID_TYPE_SINK)
+#define CTYP_VIDEO_SOURCE       (CID_CLASS_VIDEO | CID_TYPE_SOURCE)
+#define CTYP_VIDEO_ENCODER      (CID_CLASS_VIDEO | CID_TYPE_ENCODER)
+#define CTYP_VIDEO_DECODER      (CID_CLASS_VIDEO | CID_TYPE_DECODER)
+#define CTYP_VIDEO_DIGITIZER    (CID_CLASS_VIDEO | CID_TYPE_DIGITIZER)
+#define CTYP_VIDEO_RENDERER     (CID_CLASS_VIDEO | CID_TYPE_RENDERER)
+#define CTYP_VIDEO_FILTER       (CID_CLASS_VIDEO | CID_TYPE_FILTER)
+#define CTYP_VIDEO_SUBSYS       (CID_CLASS_VIDEO | CID_TYPE_SUBSYSTEM)
+//
+#define CID_COMP_LCD            (TAG(0x01) | CTYP_VIDEO_SINK)
+
+#define CID_COMP_VCAPVI         (TAG(0x01) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VIP            (TAG(0x02) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VI             (TAG(0x03) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VSLICER        (TAG(0x04) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_FBREAD         (TAG(0x05) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_QVI            (TAG(0x06) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_CAMERA         (TAG(0x07) | CTYP_VIDEO_SOURCE)
+
+#define CID_COMP_VENCM1         (TAG(0x01) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCM2         (TAG(0x02) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCMJ         (TAG(0x03) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCH263       (TAG(0x04) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCH261       (TAG(0x05) | CTYP_VIDEO_ENCODER)
+
+#define CID_COMP_VDECM1         (TAG(0x01) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECM2         (TAG(0x02) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECMPEG       (TAG(0x03) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECMJ         (TAG(0x04) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICSVCD (TAG(0x05) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECH263       (TAG(0x06) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECH261       (TAG(0x07) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDEC           (TAG(0x08) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICDVD  (TAG(0x09) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICBMPDVD  (TAG(0x0A) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICRENDDVD (TAG(0x0B) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4PP           (TAG(0x0C) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4MC           (TAG(0x0D) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4CSC          (TAG(0x0E) | CTYP_VIDEO_DECODER)
+
+#define CID_COMP_VDIG           (TAG(0x01) | CTYP_VIDEO_DIGITIZER)
+#define CID_COMP_VDIGVIRAW      (TAG(0x02) | CTYP_VIDEO_DIGITIZER)
+
+#define CID_COMP_VREND          (TAG(0x01) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_HDVO           (TAG(0x02) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDGFXVO     (TAG(0x03) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_AICP           (TAG(0x04) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDVORAW     (TAG(0x05) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VO             (TAG(0x06) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_QVO            (TAG(0x06) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDVOICP     (TAG(0x07) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VMIX           (TAG(0x08) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_GFX           (TAG(0x09) | CTYP_VIDEO_RENDERER)
+
+#define CID_COMP_MBS            (TAG(0x01) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANS         (TAG(0x02) | CTYP_VIDEO_FILTER)
+#define CID_COMP_QNM            (TAG(0x03) | CTYP_VIDEO_FILTER)
+#define CID_COMP_ICP            (TAG(0x04) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSNM       (TAG(0x05) | CTYP_VIDEO_FILTER)
+#define CID_COMP_QFD            (TAG(0x06) | CTYP_VIDEO_FILTER) // film detector
+#define CID_COMP_VRENDDVDVO     (TAG(0x07) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSCRYSTAL  (TAG(0x08) | CTYP_VIDEO_FILTER)
+
+#define CID_COMP_VSYSMT3        (TAG(0x01) | CTYP_VIDEO_SUBSYS) //obsolescent
+#define CID_COMP_VSYSSTB        (TAG(0x01) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_DVDVIDSYS      (TAG(0x02) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VDECUD         (TAG(0x03) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VIDSYS         (TAG(0x04) | CTYP_VIDEO_SUBSYS)
+//
+// Audio Class Types/Components (audio types primarily handle audio data)
+//
+#define CTYP_AUDIO_NONE         (CID_CLASS_AUDIO | CID_TYPE_NONE)
+#define CTYP_AUDIO_SINK         (CID_CLASS_AUDIO | CID_TYPE_SINK)
+#define CTYP_AUDIO_SOURCE       (CID_CLASS_AUDIO | CID_TYPE_SOURCE)
+#define CTYP_AUDIO_ENCODER      (CID_CLASS_AUDIO | CID_TYPE_ENCODER)
+#define CTYP_AUDIO_DECODER      (CID_CLASS_AUDIO | CID_TYPE_DECODER)
+#define CTYP_AUDIO_DIGITIZER    (CID_CLASS_AUDIO | CID_TYPE_DIGITIZER)
+#define CTYP_AUDIO_RENDERER     (CID_CLASS_AUDIO | CID_TYPE_RENDERER)
+#define CTYP_AUDIO_FILTER       (CID_CLASS_AUDIO | CID_TYPE_FILTER)
+#define CTYP_AUDIO_SUBSYS       (CID_CLASS_AUDIO | CID_TYPE_SUBSYSTEM)
+//
+
+#define CID_COMP_AI             (TAG(0x01) | CTYP_AUDIO_NONE)
+#define CID_COMP_AO             (TAG(0x03) | CTYP_AUDIO_NONE)
+#define CID_COMP_ADAI           (TAG(0x04) | CTYP_AUDIO_NONE)
+
+#define CID_COMP_SDAC           (TAG(0x01) | CTYP_AUDIO_SINK)
+
+#define CID_COMP_ADIGAI         (TAG(0x01) | CTYP_AUDIO_DIGITIZER)
+#define CID_COMP_ADIGSPDIF      (TAG(0x02) | CTYP_AUDIO_DIGITIZER)
+
+#define CID_COMP_ARENDAO        (TAG(0x01) | CTYP_AUDIO_RENDERER)
+#define CID_COMP_ARENDSPDIF     (TAG(0x02) | CTYP_AUDIO_RENDERER)
+
+#define CID_COMP_NOISESEQ       (TAG(0x03) | CTYP_AUDIO_SOURCE)
+
+#define CID_COMP_AENCAC3        (TAG(0x01) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCMPEG1      (TAG(0x02) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCAAC        (TAG(0x03) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCG723       (TAG(0x04) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCG728       (TAG(0x05) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCWMA        (TAG(0x06) | CTYP_AUDIO_ENCODER)
+
+#define CID_COMP_ADECPROLOGIC   (TAG(0x01) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECAC3        (TAG(0x02) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECMPEG1      (TAG(0x03) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECMP3        (TAG(0x04) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECAAC        (TAG(0x05) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECG723       (TAG(0x06) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECG728       (TAG(0x07) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECWMA        (TAG(0x08) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECTHRU       (TAG(0x09) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADEC           (TAG(0x0A) | CTYP_AUDIO_DECODER)
+
+#define CID_COMP_ASPLIB         (TAG(0x01) | CTYP_AUDIO_FILTER)
+#define CID_COMP_IIR            (TAG(0x02) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ2         (TAG(0x03) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ5         (TAG(0x04) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPBASSREDIR   (TAG(0x05) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPLAT2        (TAG(0x06) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPPLUGIN      (TAG(0x07) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXDTV        (TAG(0x08) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXSIMPLE     (TAG(0x09) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXSTB        (TAG(0x0A) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ          (TAG(0x0B) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ATESTSIG       (TAG(0x0C) | CTYP_AUDIO_FILTER)
+
+#define CID_COMP_AUDSUBSYS      (TAG(0x01) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_AUDSYSSTB      (TAG(0x02) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_AUDSYSDVD      (TAG(0x03) | CTYP_AUDIO_SUBSYS)
+
+//
+// Graphics Class Types/Components
+//
+#define CTYP_GRAPHICS_RENDERER  (CID_CLASS_GRAPHICS | CID_TYPE_SINK)
+//
+#define CID_COMP_WM             (TAG(0x01) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_WIDGET         (TAG(0x02) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_OM             (TAG(0x03) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_HTMLRENDER     (TAG(0x04) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_VRENDEIA708    (TAG(0x05) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_VRENDEIA608    (TAG(0x06) | CTYP_GRAPHICS_RENDERER)
+//
+#define CTYP_GRAPHICS_DRAW      (CID_CLASS_GRAPHICS | CID_TYPE_NONE)
+//
+#define CID_COMP_DRAW           (TAG(0x10) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_UT        (TAG(0x11) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_DE        (TAG(0x12) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_REF       (TAG(0x13) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMH       (TAG(0x14) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMT       (TAG(0x15) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMTH      (TAG(0x16) | CTYP_GRAPHICS_DRAW)
+//
+#define CID_COMP_3D             (TAG(0x30) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_JAWT           (TAG(0x31) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_JINPUT         (TAG(0x32) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_LWM            (TAG(0x33) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_2D             (TAG(0x34) | CTYP_GRAPHICS_DRAW)
+
+
+//
+// Bus Class Types/Components (busses connect hardware components together)
+//
+#define CTYP_BUS_NOTYPE         (CID_CLASS_BUS | CID_TYPE_NONE)
+//
+#define CID_COMP_XIO            (TAG(0x01) | CTYP_BUS_NOTYPE)
+#define CID_COMP_IIC            (TAG(0x02) | CTYP_BUS_NOTYPE)
+#define CID_COMP_PCI            (TAG(0x03) | CTYP_BUS_NOTYPE)
+#define CID_COMP_P1394          (TAG(0x04) | CTYP_BUS_NOTYPE)
+#define CID_COMP_ENET           (TAG(0x05) | CTYP_BUS_NOTYPE)
+#define CID_COMP_ATA            (TAG(0x06) | CTYP_BUS_NOTYPE)
+#define CID_COMP_CAN            (TAG(0x07) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UCGDMA         (TAG(0x08) | CTYP_BUS_NOTYPE)
+#define CID_COMP_I2S            (TAG(0x09) | CTYP_BUS_NOTYPE)
+#define CID_COMP_SPI            (TAG(0x0A) | CTYP_BUS_NOTYPE)
+#define CID_COMP_PCM            (TAG(0x0B) | CTYP_BUS_NOTYPE)
+#define CID_COMP_L3             (TAG(0x0C) | CTYP_BUS_NOTYPE)
+
+//
+// Infrastructure Class Types/Components
+#define CTYP_INFRASTR_NOTYPE    (CID_CLASS_INFRASTR | CID_TYPE_NONE)
+//
+#define CID_COMP_OSAL           (TAG(0x01) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_MML            (TAG(0x02) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_TSSA_DEFAULTS  (TAG(0x03) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_RPC            (TAG(0x04) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_THI            (TAG(0x05) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_REGISTRY       (TAG(0x06) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_TMMAN          (TAG(0x07) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_LDT            (TAG(0x08) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_CPUCONN        (TAG(0x09) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_COMMQUE        (TAG(0x0A) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_BSLMGR         (TAG(0x0B) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_CR             (TAG(0x0C) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_NODE           (TAG(0x0D) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_COM            (TAG(0x0E) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_UTIL           (TAG(0x0F) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_SGLIST         (TAG(0x10) | CTYP_INFRASTR_NOTYPE)
+
+//-----------------------------------------------------------------------------
+// Component Standard Error/Progress Status definitions (bits 11:0, 12 bits)
+// NOTE: These status codes are OR'd with the component identifier to create
+//       component unique 32 bit status values.  The component status values
+//       should be defined in the header files where the APIs are defined.
+//
+#define CID_ERR_BITMASK                 0xFFF // Component error AND bitmask
+#define CID_ERR_BITSHIFT                0     // Component error bit shift
+#define CID_GET_ERROR(compId)   ((compId & CID_ERR_BITMASK) >> CID_ERR_BITSHIFT)
+//
+#define TM_ERR_COMPATIBILITY            0x001 // SW Interface compatibility
+#define TM_ERR_MAJOR_VERSION            0x002 // SW Major Version error
+#define TM_ERR_COMP_VERSION             0x003 // SW component version error
+#define TM_ERR_BAD_MODULE_ID            0x004 // SW - HW module ID error
+#define TM_ERR_BAD_UNIT_NUMBER          0x005 // Invalid device unit number
+#define TM_ERR_BAD_INSTANCE             0x006 // Bad input instance value
+#define TM_ERR_BAD_HANDLE               0x007 // Bad input handle
+#define TM_ERR_BAD_INDEX                0x008 // Bad input index
+#define TM_ERR_BAD_PARAMETER            0x009 // Invalid input parameter
+#define TM_ERR_NO_INSTANCES             0x00A // No instances available
+#define TM_ERR_NO_COMPONENT             0x00B // Component is not present
+#define TM_ERR_NO_RESOURCES             0x00C // Resource is not available
+#define TM_ERR_INSTANCE_IN_USE          0x00D // Instance is already in use
+#define TM_ERR_RESOURCE_OWNED           0x00E // Resource is already in use
+#define TM_ERR_RESOURCE_NOT_OWNED       0x00F // Caller does not own resource
+#define TM_ERR_INCONSISTENT_PARAMS      0x010 // Inconsistent input params
+#define TM_ERR_NOT_INITIALIZED          0x011 // Component is not initialized
+#define TM_ERR_NOT_ENABLED              0x012 // Component is not enabled
+#define TM_ERR_NOT_SUPPORTED            0x013 // Function is not supported
+#define TM_ERR_INIT_FAILED              0x014 // Initialization failed
+#define TM_ERR_BUSY                     0x015 // Component is busy
+#define TM_ERR_NOT_BUSY                 0x016 // Component is not busy
+#define TM_ERR_READ                     0x017 // Read error
+#define TM_ERR_WRITE                    0x018 // Write error
+#define TM_ERR_ERASE                    0x019 // Erase error
+#define TM_ERR_LOCK                     0x01A // Lock error
+#define TM_ERR_UNLOCK                   0x01B // Unlock error
+#define TM_ERR_OUT_OF_MEMORY            0x01C // Memory allocation failed
+#define TM_ERR_BAD_VIRT_ADDRESS         0x01D // Bad virtual address
+#define TM_ERR_BAD_PHYS_ADDRESS         0x01E // Bad physical address
+#define TM_ERR_TIMEOUT                  0x01F // Timeout error
+#define TM_ERR_OVERFLOW                 0x020 // Data overflow/overrun error
+#define TM_ERR_FULL                     0x021 // Queue (etc.) is full
+#define TM_ERR_EMPTY                    0x022 // Queue (etc.) is empty
+#define TM_ERR_NOT_STARTED              0x023 // Component stream not started
+#define TM_ERR_ALREADY_STARTED          0x024 // Comp. stream already started
+#define TM_ERR_NOT_STOPPED              0x025 // Component stream not stopped
+#define TM_ERR_ALREADY_STOPPED          0x026 // Comp. stream already stopped
+#define TM_ERR_ALREADY_SETUP            0x027 // Component already setup
+#define TM_ERR_NULL_PARAMETER           0x028 // Null input parameter
+#define TM_ERR_NULL_DATAINFUNC          0x029 // Null data input function
+#define TM_ERR_NULL_DATAOUTFUNC         0x02A // Null data output function
+#define TM_ERR_NULL_CONTROLFUNC         0x02B // Null control function
+#define TM_ERR_NULL_COMPLETIONFUNC      0x02C // Null completion function
+#define TM_ERR_NULL_PROGRESSFUNC        0x02D // Null progress function
+#define TM_ERR_NULL_ERRORFUNC           0x02E // Null error handler function
+#define TM_ERR_NULL_MEMALLOCFUNC        0x02F // Null memory alloc function
+#define TM_ERR_NULL_MEMFREEFUNC         0x030 // Null memory free  function
+#define TM_ERR_NULL_CONFIGFUNC          0x031 // Null configuration function
+#define TM_ERR_NULL_PARENT              0x032 // Null parent data
+#define TM_ERR_NULL_IODESC              0x033 // Null in/out descriptor
+#define TM_ERR_NULL_CTRLDESC            0x034 // Null control descriptor
+#define TM_ERR_UNSUPPORTED_DATACLASS    0x035 // Unsupported data class
+#define TM_ERR_UNSUPPORTED_DATATYPE     0x036 // Unsupported data type
+#define TM_ERR_UNSUPPORTED_DATASUBTYPE  0x037 // Unsupported data subtype
+#define TM_ERR_FORMAT                   0x038 // Invalid/unsupported format
+#define TM_ERR_INPUT_DESC_FLAGS         0x039 // Bad input  descriptor flags
+#define TM_ERR_OUTPUT_DESC_FLAGS        0x03A // Bad output descriptor flags
+#define TM_ERR_CAP_REQUIRED             0x03B // Capabilities required ???
+#define TM_ERR_BAD_TMALFUNC_TABLE       0x03C // Bad TMAL function table
+#define TM_ERR_INVALID_CHANNEL_ID       0x03D // Invalid channel identifier
+#define TM_ERR_INVALID_COMMAND          0x03E // Invalid command/request
+#define TM_ERR_STREAM_MODE_CONFUSION    0x03F // Stream mode config conflict
+#define TM_ERR_UNDERRUN                 0x040 // Data underflow/underrun
+#define TM_ERR_EMPTY_PACKET_RECVD       0x041 // Empty data packet received
+#define TM_ERR_OTHER_DATAINOUT_ERR      0x042 // Other data input/output err
+#define TM_ERR_STOP_REQUESTED           0x043 // Stop in progress
+#define TM_ERR_PIN_NOT_STARTED          0x044 // Pin not started
+#define TM_ERR_PIN_ALREADY_STARTED      0x045 // Pin already started
+#define TM_ERR_PIN_NOT_STOPPED          0x046 // Pin not stopped
+#define TM_ERR_PIN_ALREADY_STOPPED      0x047 // Pin already stopped
+#define TM_ERR_STOP_PIN_REQUESTED       0x048 // Stop of a single pin is in progress (obsolescent)
+#define TM_ERR_PAUSE_PIN_REQUESTED      0x048 // Stop of a single pin is in progress
+#define TM_ERR_ASSERTION                0x049 // Assertion failure
+#define TM_ERR_HIGHWAY_BANDWIDTH        0x04A // Highway bandwidth bus error
+#define TM_ERR_HW_RESET_FAILED          0x04B // Hardware reset failed
+#define TM_ERR_PIN_PAUSED               0x04C // Pin Paused
+
+// Add new standard error/progress status codes here
+
+#define TM_ERR_COMP_UNIQUE_START        0x800 // 0x800-0xDFF: Component unique
+
+#define TM_ERR_CUSTOMER_START           0xC00  
+
+// DVP Standard assert error code start offset
+// NOTE: This define should be added to the component's base error value and
+//       standard error code(s) to define assert error codes.  For example:
+// #define TMBSL_ERR_MGR_ASSERT_BAD_PARAM 
+//          (TMBSL_ERR_MGR_BASE + TM_ERR_ASSERT_START + TM_ERR_BAD_PARAMETER)
+//
+#define TM_ERR_ASSERT_START             0xE00 // 0xE00-0xEFF: Assert failures
+#define TM_ERR_ASSERT_LAST              0xEFF // Last assert error range value
+#define CID_IS_ASSERT_ERROR(compId)     \
+    ((CID_GET_ERROR(compId) >= TM_ERR_ASSERT_START) && \
+     (CID_GET_ERROR(compId) <= TM_ERR_ASSERT_LAST))
+
+// DVP Standard fatal error code start offset
+// NOTE: This define should be added to the component's base error value and
+//       standard error code(s) to define fatal error codes.  For example:
+// #define TMML_ERR_FATAL_OUT_OF_MEMORY  
+//          (TMML_ERR_BASE + TM_ERR_FATAL_START + TM_ERR_OUT_OF_MEMORY)
+//
+#define TM_ERR_FATAL_START              0xF00 // 0xF00-0xFFF: Fatal failures
+#define TM_ERR_FATAL_LAST               0xFFF // Last fatal error range value
+#define CID_IS_FATAL_ERROR(compId)      \
+    ((CID_GET_ERROR(compId) >= TM_ERR_FATAL_START) && \
+     (CID_GET_ERROR(compId) <= TM_ERR_FATAL_LAST))
+
+
+//-----------------------------------------------------------------------------
+// DVP hardware module IDs
+//
+#define VMPG_100_MOD_ID         0x00000100
+#define C1394_101_MOD_ID        0x00000101
+#define FPBC_102_MOD_ID         0x00000102
+#define JTAG_103_MOD_ID         0x00000103
+#define EJTAG_104_MOD_ID        0x00000104
+#define IIC_105_MOD_ID          0x00000105
+#define SMCARD_106_MOD_ID       0x00000106
+#define UART_107_MOD_ID         0x00000107
+/* #define CLOCKS_108_MOD_ID       0x00000108 */
+#define USB_109_MOD_ID          0x00000109
+#define BOOT_10A_MOD_ID         0x0000010A
+#define MPBC_10B_MOD_ID         0x0000010B
+#define SSI_10C_MOD_ID          0x0000010C
+#define AI_10D_MOD_ID           0x0000010D
+#define VMSP_10E_MOD_ID         0x0000010E
+#define GPIO_10F_MOD_ID         0x0000010F
+#define SPDI_110_MOD_ID         0x00000110
+#define AICP_111_MOD_ID         0x00000111
+#define TPBC_112_MOD_ID         0x00000112
+#define PCI_113_MOD_ID          0x00000113
+#define MMI_114_MOD_ID          0x00000114
+#define ORCA3_115_MOD_ID        0x00000115
+#define DBG_116_MOD_ID          0x00000116
+#define DE_117_MOD_ID           0x00000117
+#define AICP_118_MOD_ID         0x00000118
+#define MBS_119_MOD_ID          0x00000119
+#define VIP_11A_MOD_ID          0x0000011A
+#define PIMI_11B_MOD_ID         0x0000011B
+#define PIB_11C_MOD_ID          0x0000011C
+#define PIC_11D_MOD_ID          0x0000011D
+#define TMDBG_11F_MOD_ID        0x0000011F
+#define AO_120_MOD_ID           0x00000120
+#define SPDO_121_MOD_ID         0x00000121
+#define FPIMI_122_MOD_ID        0x00000122
+#define RESET_123_MOD_ID        0x00000123
+#define NULL_124_MOD_ID         0x00000124
+#define TSDMA_125_MOD_ID        0x00000125
+#define GLBREG_126_MOD_ID       0x00000126
+#define TMDBG_127_MOD_ID        0x00000127
+#define GLBREG_128_MOD_ID       0x00000128
+#define DMA_130_MOD_ID          0x00000130
+#define IR_131_MOD_ID           0x00000131
+#define GFX2D_131_MOD_ID        0x00000132 // TODO: Remove after code corrected
+#define GFX2D_132_MOD_ID        0x00000132
+#define P1284_133_MOD_ID        0x00000133
+#define QNM_134_MOD_ID          0x00000134
+#define OSD_136_MOD_ID            0x00000136
+#define MIX_137_MOD_ID            0x00000137
+#define DENC_138_MOD_ID            0x00000138
+#define SYN_13A_MOD_ID            0x0000013A
+#define CLOCKS_13E_MOD_ID       0x0000013E
+#define CONFIG_13F_MOD_ID       0x0000013F
+#define MIU_A04C_MOD_ID            0x0000A04C
+#define DISP_A04D_MOD_ID        0x0000A04D
+#define VCTRL_A04E_MOD_ID       0x0000A04E
+
+
+#define PR3930_2B10_MOD_ID      0x00002B10
+#define PR3940_2B11_MOD_ID      0x00002B11
+
+#define TM3218_2B80_MOD_ID      0x00002B80
+#define TM64_2b81_MOD_ID        0x00002B81
+
+#define QNM_A017_MOD_ID         0x0000A017
+
+// There is no HW module ID for TS IO ROUTER.  We assign
+// a SW module ID to this module, because it is needed by Clock 
+// device and HWAPI libraries. Use 010Eh for lower word 
+// (for lack of better reason ! because IO Router is closely
+// associated with VMSP module)
+
+#define IORT_1010E_MOD_ID       0x0001010E
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMCOMPID_H //-----------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmFrontEnd.h
+
+
+/**
+  Copyright (C) 2007 NXP B.V., All Rights Reserved.
+  This source code and any compilation or derivative thereof is the proprietary
+  information of NXP B.V. and is confidential in nature. Under no circumstances
+  is this software to be  exposed to or placed under an Open Source License of
+  any type without the expressed written permission of NXP B.V.
+ *
+ * \file          tmFrontEnd.h
+ *                %version: CFR_STB#0.4.1.7 %
+ *
+ * \date          %date_modified%
+ *
+ * \brief         Describe briefly the purpose of this file.
+ *
+ * REFERENCE DOCUMENTS :
+ *
+ * Detailed description may be added here.
+ *
+ * \section info Change Information
+ *
+ * \verbatim
+   Date          Modified by CRPRNr  TASKNr  Maintenance description
+   -------------|-----------|-------|-------|-----------------------------------
+    26-Mar-2008 | B.GUILLOT | 13122 | 23456 | Creation
+   -------------|-----------|-------|-------|-----------------------------------
+   \endverbatim
+ *
+*/
+
+
+#ifndef TMFRONTEND_H
+#define TMFRONTEND_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITION                              */
+/*============================================================================*/
+#define TMFRONTEND_DVBT2MAXPLPNB 250
+
+/* standard*/
+typedef enum _tmFrontEndStandard_t {
+    tmFrontEndStandardDVBT,
+    tmFrontEndStandardDVBS,
+    tmFrontEndStandardDVBC,
+    tmFrontEndStandardDSS,
+    tmFrontEndStandardBSD,
+    tmFrontEndStandardDVBH,
+    tmFrontEndStandardAnalogDVBT,
+    tmFrontEndStandardDVBS2,
+    tmFrontEndStandardDVBT2,
+    tmFrontEndStandardMax
+} tmFrontEndStandard_t, *ptmFrontEndStandard_t;
+
+/* spectral inversion*/
+typedef enum _tmFrontEndSpecInv_t {
+    tmFrontEndSpecInvAuto = 0,
+    tmFrontEndSpecInvOff,
+    tmFrontEndSpecInvOn,
+    tmFrontEndSpecInvMax
+} tmFrontEndSpecInv_t, *ptmFrontEndSpecInv_t;
+
+/* modulation*/
+typedef enum _tmFrontEndModulation_t {
+    tmFrontEndModulationAuto = 0,
+    tmFrontEndModulationBpsk,
+    tmFrontEndModulationQpsk,
+    tmFrontEndModulationQam4,
+    tmFrontEndModulationPsk8,
+    tmFrontEndModulationQam16,
+    tmFrontEndModulationQam32,
+    tmFrontEndModulationQam64,
+    tmFrontEndModulationQam128,
+    tmFrontEndModulationQam256,
+    tmFrontEndModulationQam512,
+    tmFrontEndModulationQam1024,
+    tmFrontEndModulation8VSB,
+    tmFrontEndModulation16VSB,
+    tmFrontEndModulationQam,
+    tmFrontEndModulationMax
+} tmFrontEndModulation_t, *ptmFrontEndModulation_t;
+
+/* viterbi rate*/
+typedef enum _tmFrontEndCodeRate_t {
+    tmFrontEndCodeRateAuto = 0,
+    tmFrontEndCodeRate_1_4,
+    tmFrontEndCodeRate_1_3,
+    tmFrontEndCodeRate_2_5,
+    tmFrontEndCodeRate_1_2,
+    tmFrontEndCodeRate_3_5,
+    tmFrontEndCodeRate_2_3,
+    tmFrontEndCodeRate_3_4,
+    tmFrontEndCodeRate_4_5,
+    tmFrontEndCodeRate_5_6,
+    tmFrontEndCodeRate_6_7,
+    tmFrontEndCodeRate_7_8,
+    tmFrontEndCodeRate_8_9,
+    tmFrontEndCodeRate_9_10,
+    tmFrontEndCodeRate_NotRelevant,
+    tmFrontEndCodeRateMax
+} tmFrontEndCodeRate_t, *ptmFrontEndCodeRate_t;
+
+/* frequency offset*/
+typedef enum _tmFrontEndRfOffset_t {
+    tmFrontEndRfOffsetAuto = 0,
+    tmFrontEndRfOffsetNull,
+    tmFrontEndRfOffsetPlus125,
+    tmFrontEndRfOffsetMinus125,
+    tmFrontEndRfOffsetPlus166,
+    tmFrontEndRfOffsetMinus166,
+    tmFrontEndRfOffsetPlus333,
+    tmFrontEndRfOffsetMinus333,
+    tmFrontEndRfOffsetPlus500,
+    tmFrontEndRfOffsetMinus500,
+    tmFrontEndRfOffsetMax
+} tmFrontEndRfOffset_t, *ptmFrontEndRfOffset_t;
+
+/* frequency offset*/
+typedef enum _tmFrontEndRfOffsetMode_t {
+    tmFrontEndRfOffsetModeAuto,
+    tmFrontEndRfOffsetModeManual,
+    tmFrontEndRfOffsetModeMax
+} tmFrontEndRfOffsetMode_t, *ptmFrontEndRfOffsetMode_t;
+
+/* guard interval*/
+typedef enum _tmFrontEndGI_t {
+    tmFrontEndGIAuto = 0,
+    tmFrontEndGI_1_32,
+    tmFrontEndGI_1_16,
+    tmFrontEndGI_1_8,
+    tmFrontEndGI_1_4,
+    tmFrontEndGI_1_128,
+    tmFrontEndGI_19_128,
+    tmFrontEndGI_19_256,
+    tmFrontEndGIMax
+} tmFrontEndGI_t, *ptmFrontEndGI_t;
+
+/* fast Fourrier transform size*/
+typedef enum _tmFrontEndFft_t {
+    tmFrontEndFftAuto = 0,
+    tmFrontEndFft2K,
+    tmFrontEndFft8K,
+    tmFrontEndFft4K,
+    tmFrontEndFft16K,
+    tmFrontEndFft32K,
+    tmFrontEndFftMax
+} tmFrontEndFft_t, *ptmFrontEndFft_t;
+
+/* hierarchy*/
+typedef enum _tmFrontEndHier_t {
+    tmFrontEndHierAuto = 0,
+    tmFrontEndHierNo,
+    tmFrontEndHierAlpha1,
+    tmFrontEndHierAlpha2,
+    tmFrontEndHierAlpha4,
+    tmFrontEndHierMax
+} tmFrontEndHier_t, *ptmFrontEndHier_t;
+
+/* priority*/
+typedef enum _tmFrontEndPrior_t {
+    tmFrontEndPriorAuto = 0,
+    tmFrontEndPriorHigh,
+    tmFrontEndPriorLow,
+    tmFrontEndPriorMax
+} tmFrontEndPrior_t, *ptmFrontEndPrior_t;
+
+/* roll off */
+typedef enum _tmFrontEndRollOff_t {
+    tmFrontEndRollOffAuto = 0,
+    tmFrontEndRollOff_0_15,
+    tmFrontEndRollOff_0_20,
+    tmFrontEndRollOff_0_25,
+    tmFrontEndRollOff_0_35,
+    tmFrontEndRollOffMax
+} tmFrontEndRollOff_t, *ptmFrontEndRollOff_t;
+
+/* LNB polarity */
+typedef enum _tmFrontEndLNBPolarity_t {
+    tmFrontEndLNBPolarityAuto = 0,
+    tmFrontEndLNBPolarityHigh,
+    tmFrontEndLNBPolarityLow,
+    tmFrontEndLNBPolarityMax
+} tmFrontEndLNBPolarity_t, *ptmFrontEndLNBPolarity_t;
+
+/* continuous tone */
+typedef enum _tmFrontEndContinuousTone_t {
+    tmFrontEndContinuousToneAuto = 0,
+    tmFrontEndContinuousToneOff,
+    tmFrontEndContinuousTone22KHz,
+    tmFrontEndContinuousToneMax
+} tmFrontEndContinuousTone_t, *ptmFrontEndContinuousTone_t;
+
+typedef enum _tmFrontEndChannelType_t
+{
+    tmFrontEndChannelTypeNone    = 0x00,  /* No detection         */
+    tmFrontEndChannelTypeDigital = 0x01,  /* Digital channel      */
+    tmFrontEndChannelTypeAnalog  = 0x02,  /* Analog channel       */
+    tmFrontEndChannelTypeUnknown = 0x20   /* unknown channel type */
+} tmFrontEndChannelType_t;
+
+typedef enum _tmFrontEndChannelConfidence_t
+{
+    tmFrontEndConfidenceNotAvailable,
+    tmFrontEndConfidenceNull,
+    tmFrontEndConfidenceLow,
+    tmFrontEndConfidenceMedium,
+    tmFrontEndConfidenceHigh
+} tmFrontEndConfidence_t;
+
+typedef enum _tmFrontEndDVBT2PLPType_t
+{
+    tmFrontEndDVBT2PLPTypeAuto,
+    tmFrontEndDVBT2PLPTypeCommon,
+    tmFrontEndDVBT2PLPType1,
+    tmFrontEndDVBT2PLPType2,
+    tmFrontEndDVBT2PLPTypeMax
+} tmFrontEndDVBT2PLPType_t;
+
+typedef enum _tmFrontEndDVBT2PLPPayloadType_t
+{
+    tmFrontEndDVBT2PLPPayloadTypeAuto,
+    tmFrontEndDVBT2PLPPayloadTypeGFPS,
+    tmFrontEndDVBT2PLPPayloadTypeGCS,
+    tmFrontEndDVBT2PLPPayloadTypeGSE,
+    tmFrontEndDVBT2PLPPayloadTypeTS,
+    tmFrontEndDVBT2PLPPayloadTypeMax
+} tmFrontEndDVBT2PLPPayloadType_t;
+
+typedef enum _tmFrontEndRotationState_t
+{
+    tmFrontEndRotationStateAuto,
+    tmFrontEndRotationStateOn,
+    tmFrontEndRotationStateOff,
+    tmFrontEndRotationStateMax
+} tmFrontEndRotationState;
+
+typedef enum _tmFrontEndDVBT2FECType_t
+{
+    tmFrontEndDVBT2FECTypeAuto,
+    tmFrontEndDVBT2FECType16K,
+    tmFrontEndDVBT2FECType64K,
+    tmFrontEndDVBT2FECTypeMax
+} tmFrontEndDVBT2FECType_t;
+
+typedef enum _tmFrontEndDVBT2InputType_t
+{
+    tmFrontEndDVBT2InputTypeAuto,
+    tmFrontEndDVBT2InputTypeSISO,
+    tmFrontEndDVBT2InputTypeMISO,
+    tmFrontEndDVBT2InputTypeMax
+} tmFrontEndDVBT2InputType_t;
+
+typedef enum _tmFrontEndFECMode_t
+{
+    tmFrontEndFECModeUnknown = 0,
+    tmFrontEndFECModeAnnexA,
+    tmFrontEndFECModeAnnexB,
+    tmFrontEndFECModeAnnexC,
+    tmFrontEndFECModeMax
+} tmFrontEndFECMode_t;
+
+typedef struct _tmFrontEndFracNb8_t
+{
+    Int8 lInteger;
+    UInt8 uDivider;
+}tmFrontEndFracNb8_t;
+
+typedef struct _tmFrontEndFracNb16_t
+{
+    Int16 lInteger;
+    UInt16 uDivider;
+}tmFrontEndFracNb16_t;
+
+typedef struct _tmFrontEndFracNb32_t
+{
+    Int32 lInteger;
+    UInt32 uDivider;
+}tmFrontEndFracNb32_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMFRONTEND_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmUnitParams.h
+
+
+/**
+  Copyright (C) 2007 NXP B.V., All Rights Reserved.
+  This source code and any compilation or derivative thereof is the proprietary
+  information of NXP B.V. and is confidential in nature. Under no circumstances
+  is this software to be  exposed to or placed under an Open Source License of
+  any type without the expressed written permission of NXP B.V.
+ *
+ * \file          tmUnitParams.h
+ *                %version: 2 %
+ *
+ * \date          %date_modified%
+ *
+ * \brief         Describe briefly the purpose of this file.
+ *
+ * REFERENCE DOCUMENTS :
+ *
+ * Detailed description may be added here.
+ *
+ * \section info Change Information
+ *
+ * \verbatim
+   Date          Modified by CRPRNr  TASKNr  Maintenance description
+   -------------|-----------|-------|-------|-----------------------------------
+    26-Mar-2008 | B.GUILLOT | 13122 | 23456 | Creation
+   -------------|-----------|-------|-------|-----------------------------------
+   \endverbatim
+ *
+*/
+
+
+#ifndef TMUNITPARAMS_H
+#define TMUNITPARAMS_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITION                              */
+/*============================================================================*/
+
+
+/******************************************************************************/
+/** \brief "These macros map to tmUnitSelect_t variables parts"
+*
+******************************************************************************/
+
+#define UNIT_VALID(_tUnIt)                      (((_tUnIt)&0x80000000)==0)
+
+#define UNIT_PATH_INDEX_MASK                    (0x0000001F)
+#define UNIT_PATH_INDEX_POS                     (0)
+
+#define UNIT_PATH_TYPE_MASK                     (0x000003E0)
+#define UNIT_PATH_TYPE_POS                      (5)
+
+#define UNIT_PATH_CONFIG_MASK                   (0x0003FC00)
+#define UNIT_PATH_CONFIG_POS                    (10)
+
+#define UNIT_SYSTEM_INDEX_MASK                  (0x007C0000)
+#define UNIT_SYSTEM_INDEX_POS                   (18)
+
+#define UNIT_SYSTEM_CONFIG_MASK                 (0x7F800000)
+#define UNIT_SYSTEM_CONFIG_POS                  (23)
+
+
+
+
+#define UNIT_PATH_INDEX_GET(_tUnIt)             ((_tUnIt)&UNIT_PATH_INDEX_MASK)
+#define UNIT_PATH_INDEX_VAL(_val)               (((_val)<<UNIT_PATH_INDEX_POS)&UNIT_PATH_INDEX_MASK)
+#define UNIT_PATH_INDEX_SET(_tUnIt, _val)       ( ((_tUnIt)&~UNIT_PATH_INDEX_MASK) | UNIT_PATH_INDEX_VAL(_val) )
+#define UNIT_PATH_INDEX_VAL_GET(_val)           (UNIT_PATH_INDEX_VAL(UNIT_PATH_INDEX_GET(_val)))
+
+#define UNIT_PATH_TYPE_GET(_tUnIt)              (((_tUnIt)&UNIT_PATH_TYPE_MASK) >> UNIT_PATH_TYPE_POS)
+#define UNIT_PATH_TYPE_VAL(_val)                (((_val)<<UNIT_PATH_TYPE_POS)&UNIT_PATH_TYPE_MASK)
+#define UNIT_PATH_TYPE_SET(_tUnIt, _val)        ( ((_tUnIt)&~UNIT_PATH_TYPE_MASK) | UNIT_PATH_TYPE_VAL(_val) )
+#define UNIT_PATH_TYPE_VAL_GET(_val)            (UNIT_PATH_TYPE_VAL(UNIT_PATH_TYPE_GET(_val)))
+
+
+#define UNIT_PATH_CONFIG_GET(_tUnIt)            (((_tUnIt)&UNIT_PATH_CONFIG_MASK) >> UNIT_PATH_CONFIG_POS)
+#define UNIT_PATH_CONFIG_VAL(_val)              (((_val)<<UNIT_PATH_CONFIG_POS)&UNIT_PATH_CONFIG_MASK)
+#define UNIT_PATH_CONFIG_SET(_tUnIt, _val)      ( ((_tUnIt)&~UNIT_PATH_CONFIG_MASK) | UNIT_PATH_CONFIG_VAL(_val) )
+#define UNIT_PATH_CONFIG_VAL_GET(_val)          (UNIT_PATH_CONFIG_VAL(UNIT_PATH_CONFIG_GET(_val)))
+
+#define UNIT_SYSTEM_INDEX_GET(_tUnIt)           (((_tUnIt)&UNIT_SYSTEM_INDEX_MASK) >> UNIT_SYSTEM_INDEX_POS)
+#define UNIT_SYSTEM_INDEX_VAL(_val)             (((_val)<<UNIT_SYSTEM_INDEX_POS)&UNIT_SYSTEM_INDEX_MASK)
+#define UNIT_SYSTEM_INDEX_SET(_tUnIt, _val)     ( ((_tUnIt)&~UNIT_SYSTEM_INDEX_MASK) | UNIT_SYSTEM_INDEX_VAL(_val) )
+#define UNIT_SYSTEM_INDEX_VAL_GET(_val)         (UNIT_SYSTEM_INDEX_VAL(UNIT_SYSTEM_INDEX_GET(_val)))
+
+#define UNIT_SYSTEM_CONFIG_GET(_tUnIt)          (((_tUnIt)&UNIT_SYSTEM_CONFIG_MASK) >> UNIT_SYSTEM_CONFIG_POS)
+#define UNIT_SYSTEM_CONFIG_VAL(_val)            (((_val)<<UNIT_SYSTEM_CONFIG_POS)&UNIT_SYSTEM_CONFIG_MASK)
+#define UNIT_SYSTEM_CONFIG_SET(_tUnIt, _val)    ( ((_tUnIt)&~UNIT_SYSTEM_CONFIG_MASK) | UNIT_SYSTEM_CONFIG_POS(_val) )
+#define UNIT_SYSTEM_CONFIG_VAL_GET(_val)        (UNIT_SYSTEM_CONFIG_VAL(UNIT_SYSTEM_CONFIG_GET(_val)))
+
+
+#define GET_WHOLE_SYSTEM_TUNIT(_tUnIt)          (UNIT_SYSTEM_CONFIG_VAL_GET(_tUnIt)|UNIT_SYSTEM_INDEX_VAL_GET(_tUnIt))
+
+#define GET_SYSTEM_TUNIT(_tUnIt)                (UNIT_SYSTEM_CONFIG_VAL_GET(_tUnIt)|UNIT_SYSTEM_INDEX_VAL_GET(_tUnIt)|UNIT_PATH_INDEX_VAL_GET(_tUnIt))
+
+#define GET_INDEX_TUNIT(_tUnIt)                 (UNIT_SYSTEM_INDEX_VAL_GET(_tUnIt)|UNIT_PATH_INDEX_VAL_GET(_tUnIt))
+
+#define GET_INDEX_TYPE_TUNIT(_tUnIt)            (UNIT_SYSTEM_INDEX_VAL_GET(_tUnIt)|UNIT_PATH_INDEX_VAL_GET(_tUnIt)|UNIT_PATH_TYPE_VAL_GET(_tUnIt))
+
+#define XFER_DISABLED_FLAG                      (UNIT_PATH_CONFIG_VAL(0x80))
+#define GET_XFER_DISABLED_FLAG_TUNIT(_tUnIt)    (((_tUnIt)&XFER_DISABLED_FLAG)!=0)
+
+
+/*============================================================================*/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMUNITPARAMS_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\inc\tmbslFrontEndTypes.h
+
+
+/**
+  Copyright (C) 2007 NXP B.V., All Rights Reserved.
+  This source code and any compilation or derivative thereof is the proprietary
+  information of NXP B.V. and is confidential in nature. Under no circumstances
+  is this software to be  exposed to or placed under an Open Source License of
+  any type without the expressed written permission of NXP B.V.
+ *
+ * \file          tmbslFrontEndTypes.h
+ *                %version: CFR_STB#1.10 %
+ *
+ * \date          %date_modified%
+ *
+ * \brief         Describe briefly the purpose of this file.
+ *
+ * REFERENCE DOCUMENTS :
+ *
+ * Detailed description may be added here.
+ *
+ * \section info Change Information
+ *
+ * \verbatim
+   Date          Modified by CRPRNr  TASKNr  Maintenance description
+   -------------|-----------|-------|-------|-----------------------------------
+    27-Mar-2008 | B.GUILLOT | 13122 | 23472 | Integrate with tmbslDvbtIp.
+   -------------|-----------|-------|-------|-----------------------------------
+   \endverbatim
+ *
+*/
+
+
+#ifndef TMBSLFRONTENDTYPES_H
+#define TMBSLFRONTENDTYPES_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/*============================================================================*/
+/*                       MACRO DEFINITION                                     */
+/*============================================================================*/
+
+
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITION                              */
+/*============================================================================*/
+
+    
+/* Status of the carrier phase lock loop */
+typedef enum _tmbslFrontEndState_t
+{
+    /** status Unknown */
+    tmbslFrontEndStateUnknown = 0,
+    /** Channel locked*/
+    tmbslFrontEndStateLocked,
+    /** Channel not locked */
+    tmbslFrontEndStateNotLocked,
+    /** Channel lock in process */
+    tmbslFrontEndStateSearching,
+    tmbslFrontEndStateMax
+} tmbslFrontEndState_t, *ptmbslFrontEndState_t;
+
+
+/* Gpio config */
+typedef enum _tmbslFrontEndGpioConfig_t
+{
+    tmbslFrontEndGpioConfUnknown = 0,
+    tmbslFrontEndGpioConfInput,
+    tmbslFrontEndGpioConfOutputPushPull,
+    tmbslFrontEndGpioConfOutputOpenDrain,
+    tmbslFrontEndGpioConfTriState,
+    tmbslFrontEndGpioConfMax
+} tmbslFrontEndGpioConfig_t, *ptmbslFrontEndGpioConfig_t;
+
+/* Gpio polarity */
+typedef enum _tmbslFrontEndGpioPolarity_t
+{
+    tmbslFrontEndGpioPolUnknown = 0,
+    tmbslFrontEndGpioPolNotInverted,
+    tmbslFrontEndGpioPolInverted,
+    tmbslFrontEndGpioPolMax
+} tmbslFrontEndGpioPolarity_t, *ptmbslFrontEndGpioPolarity_t;
+
+/* IT Selection */
+typedef enum _tmbslFrontEndITSel_t
+{
+    tmbslFrontEndITSelUnknown = 0,
+    tmbslFrontEndITSelFELGoesUp,
+    tmbslFrontEndITSelFELGoesDown,
+    tmbslFrontEndITSelDVBSynchroFlag,
+    tmbslFrontEndITSelVBERRefreshed,
+    tmbslFrontEndITSelBERRefreshed,
+    tmbslFrontEndITSelUncor,
+    tmbslFrontEndGpioITSelMax
+} tmbslFrontEndITSel_t, *ptmbslFrontEndITSel_t;
+
+/* I2C switch */
+typedef enum _tmbslFrontEndI2CSwitchState_t
+{
+    tmbslFrontEndI2CSwitchStateUnknown = 0,
+    tmbslFrontEndI2CSwitchStateOpen,
+    tmbslFrontEndI2CSwitchStateClosed,
+    tmbslFrontEndI2CSwitchStateReset,
+    tmbslFrontEndI2CSwitchStateMax
+} tmbslFrontEndI2CSwitchState_t, *ptmbslFrontEndI2CSwitchState_t;
+
+/* DVBT2 PLP */
+typedef struct _tmbslFrontEndDVBT2PLP_t
+{
+    UInt32 uId;
+    UInt32 uGroupId;
+    tmFrontEndDVBT2PLPType_t eType;
+    tmFrontEndDVBT2PLPPayloadType_t ePayloadType;
+    tmFrontEndCodeRate_t eCodeRate;
+    tmFrontEndModulation_t eModulation;
+    tmFrontEndRotationState eRotation;
+    tmFrontEndDVBT2FECType_t eFECType;
+} tmbslFrontEndDVBT2PLP_t;
+
+typedef enum _tmbslFrontEndTVStandard_t
+{
+    tmbslFrontEndTVStandardNone,
+    tmbslFrontEndTVStandardMN,
+    tmbslFrontEndTVStandardBG,
+    tmbslFrontEndTVStandardI,
+    tmbslFrontEndTVStandardDKL,
+    tmbslFrontEndTVStandardLp,
+    tmbslFrontEndTVStandardMax
+} tmbslFrontEndTVStandard_t;
+ 
+
+/******************************************************************************/
+/** \brief "Function pointers to hardware access services"
+ *
+ ******************************************************************************/
+typedef struct _tmbslFrontEndIoFunc_t
+{
+    /** Read hardware function */
+    tmErrorCode_t   (*Read)(tmUnitSelect_t tUnit, UInt32 AddrSize, UInt8* pAddr, UInt32 ReadLen, UInt8* pData);
+    /** Write hardware register, 8bit aligned function */
+    tmErrorCode_t   (*Write)(tmUnitSelect_t tUnit, UInt32 AddrSize, UInt8* pAddr, UInt32 WriteLen, UInt8* pData);
+} tmbslFrontEndIoFunc_t, *ptmbslFrontEndIoFunc_t;
+
+
+/******************************************************************************/
+/** \brief "Function pointers to Time services"
+ *
+ ******************************************************************************/
+typedef struct _tmbslFrontEndTimeFunc_t
+{
+    /** Return current time value in ms */
+    tmErrorCode_t   (*Get)(UInt32 *ptms); 
+    /**  Wait t ms without blocking scheduler; warning this function 
+     don't schedule others frontend instance */
+    tmErrorCode_t   (*Wait)(tmUnitSelect_t tUnit, UInt32 tms);
+} tmbslFrontEndTimeFunc_t, *ptmbslFrontEndTimeFunc_t;
+   
+
+/******************************************************************************/
+/** \brief "Function pointers to Debug services "
+ *
+ ******************************************************************************/
+typedef struct _tmbslFrontEndDebugFunc_t
+{
+    /** Print a debug message */
+    tmErrorCode_t   (*Print)(UInt32 level, const char* format, ...);
+} tmbslFrontEndDebugFunc_t, *ptmbslFrontEndDebugFunc_t;
+
+/* Mutex types */
+typedef void *ptmbslFrontEndMutexHandle;
+#define TMBSL_FRONTEND_MUTEX_TIMEOUT_INFINITE		(0xFFFFFFFF)
+
+/******************************************************************************/
+/** \brief "Function pointers to Mutex services "
+ *
+ ******************************************************************************/
+typedef struct _tmbslFrontEndMutexFunc_t
+{
+    /* Initialize a mutex object */
+    tmErrorCode_t   (*Init)(ptmbslFrontEndMutexHandle *ppMutexHandle);
+    /* Deinitialize a mutex object */
+    tmErrorCode_t   (*DeInit)(ptmbslFrontEndMutexHandle pMutexHandle);
+    /* Acquire a mutex object */
+    tmErrorCode_t   (*Acquire)(ptmbslFrontEndMutexHandle pMutexHandle, UInt32 timeOut);
+    /* Release a mutex object */
+    tmErrorCode_t   (*Release)(ptmbslFrontEndMutexHandle pMutexHandle);
+} tmbslFrontEndMutexFunc_t, *ptmbslFrontEndMutexFunc_t;
+
+/******************************************************************************/
+/** \brief "This structure contain all the bsl driver external dependencies"
+ *
+ *  \sa    "all bsl 'init' functions"
+ *
+ ******************************************************************************/
+typedef struct _tmbslFrontEndDependency_t
+{
+    /** Hardware access to FrontEnd */
+    tmbslFrontEndIoFunc_t       sIo;
+    /** Time services (wait, getTime, ...) */
+    tmbslFrontEndTimeFunc_t     sTime;
+    /** Debug services (Print, Store, ...) */
+    tmbslFrontEndDebugFunc_t    sDebug;
+    /** Mutex services */
+    tmbslFrontEndMutexFunc_t		sMutex;
+    /** Device Parameters data size */
+    UInt32                      dwAdditionalDataSize;
+    /** Device Parameters data pointer */
+    void*                       pAdditionalData;
+} tmbslFrontEndDependency_t, *ptmbslFrontEndDependency_t;
+
+/*============================================================================*/
+
+typedef struct tmSWSettingsVersion
+{
+    UInt32      customerNr;         /* SW Settings customer number */
+    UInt32      projectNr;          /* SW Settings project number */
+    UInt32      majorVersionNr;     /* SW Settings major version number */
+    UInt32      minorVersionNr;     /* SW Settings minor version number */
+
+}   tmSWSettingsVersion_t, *ptmSWSettingsVersion_t;
+
+/******************************************************************************/
+/** \brief "These macros map to trace functions "
+* P_DBGPRINTEx macro should be defined in each component
+******************************************************************************/
+
+#define DEBUGLVL_BLAB    3
+#define DEBUGLVL_VERBOSE 2
+#define DEBUGLVL_TERSE   1
+#define DEBUGLVL_ERROR   0
+
+#ifdef TMBSLFRONTEND_DEBUG_TRACE
+/*
+#define tmDBGPRINTEx(_level, _format, ...)                                                              \
+{                                                                                                       \
+    if(P_DBGPRINTVALID)                                                                                 \
+    {                                                                                                   \
+        if(_level == DEBUGLVL_ERROR)                                                                    \
+        {                                                                                               \
+            P_DBGPRINTEx(_level, "Error: In Function %s (Line %d):\n==> ", __FUNCTION__, __LINE__ );    \
+        }                                                                                               \
+        P_DBGPRINTEx(_level, _format, __VA_ARGS__);                                                     \
+    }                                                                                                   \
+}
+*/
+#else
+//#define tmDBGPRINTEx(_level, _format, ...)
+#endif
+
+#define tmASSERTExTR(_retVar, _expr, _strings)                                                      
+/*
+{                                                                                                   
+    if((_retVar) != (_expr))                                                                        
+    {                                                                                               
+        tmDBGPRINTEx _strings ;                                                                     
+        return _retVar;                                                                             
+    }                                                                                               
+}
+*/
+
+#define tmASSERTExT(_retVar, _expr, _strings)                                                       
+/*{                                                                                                   \
+    if((_retVar) != (_expr))                                                                        \
+    {                                                                                               \
+        tmDBGPRINTEx _strings ;                                                                     \
+    }                                                                                               \
+}
+*/
+/*============================================================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMBSLFRONTENDTYPES_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmbslTDA182I2\inc\tmbslTDA18272.h
+
+
+/**
+Copyright (C) 2008 NXP B.V., All Rights Reserved.
+This source code and any compilation or derivative thereof is the proprietary
+information of NXP B.V. and is confidential in nature. Under no circumstances
+is this software to be  exposed to or placed under an Open Source License of
+any type without the expressed written permission of NXP B.V.
+*
+* \file          tmbslTDA18272.h
+*                %version: 21 %
+*
+* \date          %date_modified%
+*
+* \brief         Describe briefly the purpose of this file.
+*
+* REFERENCE DOCUMENTS :
+*
+* Detailed description may be added here.
+*
+* \section info Change Information
+*
+* \verbatim
+Date          Modified by CRPRNr  TASKNr  Maintenance description
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+\endverbatim
+*
+*/
+
+#ifndef _TMBSL_TDA18272_H
+#define _TMBSL_TDA18272_H
+
+/*------------------------------------------------------------------------------*/
+/* Standard include files:                                                      */
+/*------------------------------------------------------------------------------*/
+
+/*------------------------------------------------------------------------------*/
+/* Project include files:                                                       */
+/*------------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*------------------------------------------------------------------------------*/
+    /* Types and defines:                                                           */
+    /*------------------------------------------------------------------------------*/
+
+    /* SW Error codes */
+#define TDA182I2_ERR_BASE               (CID_COMP_TUNER | CID_LAYER_BSL)
+#define TDA182I2_ERR_COMP               (CID_COMP_TUNER | CID_LAYER_BSL | TM_ERR_COMP_UNIQUE_START)
+
+#define TDA182I2_ERR_BAD_UNIT_NUMBER    (TDA182I2_ERR_BASE + TM_ERR_BAD_UNIT_NUMBER)
+#define TDA182I2_ERR_NOT_INITIALIZED    (TDA182I2_ERR_BASE + TM_ERR_NOT_INITIALIZED)
+#define TDA182I2_ERR_INIT_FAILED        (TDA182I2_ERR_BASE + TM_ERR_INIT_FAILED)
+#define TDA182I2_ERR_BAD_PARAMETER      (TDA182I2_ERR_BASE + TM_ERR_BAD_PARAMETER)
+#define TDA182I2_ERR_NOT_SUPPORTED      (TDA182I2_ERR_BASE + TM_ERR_NOT_SUPPORTED)
+#define TDA182I2_ERR_HW_FAILED          (TDA182I2_ERR_COMP + 0x0001)
+#define TDA182I2_ERR_NOT_READY          (TDA182I2_ERR_COMP + 0x0002)
+#define TDA182I2_ERR_BAD_VERSION        (TDA182I2_ERR_COMP + 0x0003)
+
+
+    typedef enum _tmTDA182I2PowerState_t {
+        tmTDA182I2_PowerNormalMode = 0,                                 /* Device normal mode */
+        tmTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndSynthe,         /* Device standby mode with LNA and Xtal Output and Synthe */
+        tmTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn,                  /* Device standby mode with LNA and Xtal Output */
+        tmTDA182I2_PowerStandbyWithXtalOn,                              /* Device standby mode with Xtal Output */
+        tmTDA182I2_PowerStandby,                                        /* Device standby mode */
+        tmTDA182I2_PowerMax
+    } tmTDA182I2PowerState_t, *ptmTDA182I2PowerState_t;
+
+    typedef enum _tmTDA182I2StandardMode_t {
+        tmTDA182I2_DVBT_6MHz = 0,                       /* Digital TV DVB-T 6MHz */
+        tmTDA182I2_DVBT_7MHz,                           /* Digital TV DVB-T 7MHz */
+        tmTDA182I2_DVBT_8MHz,                           /* Digital TV DVB-T 8MHz */
+        tmTDA182I2_QAM_6MHz,                            /* Digital TV QAM 6MHz */
+        tmTDA182I2_QAM_8MHz,                            /* Digital TV QAM 8MHz */
+        tmTDA182I2_ISDBT_6MHz,                          /* Digital TV ISDBT 6MHz */
+        tmTDA182I2_ATSC_6MHz,                           /* Digital TV ATSC 6MHz */
+        tmTDA182I2_DMBT_8MHz,                           /* Digital TV DMB-T 8MHz */
+        tmTDA182I2_ANLG_MN,                             /* Analog TV M/N */
+        tmTDA182I2_ANLG_B,                              /* Analog TV B */
+        tmTDA182I2_ANLG_GH,                             /* Analog TV G/H */
+        tmTDA182I2_ANLG_I,                              /* Analog TV I */
+        tmTDA182I2_ANLG_DK,                             /* Analog TV D/K */
+        tmTDA182I2_ANLG_L,                              /* Analog TV L */
+        tmTDA182I2_ANLG_LL,                             /* Analog TV L' */
+        tmTDA182I2_FM_Radio,                            /* Analog FM Radio */
+        tmTDA182I2_Scanning,                            /* analog  preset blind Scanning */
+        tmTDA182I2_ScanXpress,                          /* ScanXpress */
+        tmTDA182I2_StandardMode_Max
+    } tmTDA182I2StandardMode_t, *ptmTDA182I2StandardMode_t;
+
+    typedef enum _tmTDA182I2LPF_t {
+        tmTDA182I2_LPF_6MHz = 0,                        /* 6MHz LPFc */
+        tmTDA182I2_LPF_7MHz,                            /* 7MHz LPFc */
+        tmTDA182I2_LPF_8MHz,                            /* 8MHz LPFc */
+        tmTDA182I2_LPF_9MHz,                            /* 9MHz LPFc */
+        tmTDA182I2_LPF_1_5MHz,                          /* 1.5MHz LPFc */
+        tmTDA182I2_LPF_Max
+    } tmTDA182I2LPF_t, *ptmTDA182I2LPF_t;
+
+    typedef enum _tmTDA182I2LPFOffset_t {
+        tmTDA182I2_LPFOffset_0pc = 0,                   /* LPFc 0% */
+        tmTDA182I2_LPFOffset_min_4pc,                   /* LPFc -4% */
+        tmTDA182I2_LPFOffset_min_8pc,                   /* LPFc -8% */
+        tmTDA182I2_LPFOffset_min_12pc,                  /* LPFc -12% */
+        tmTDA182I2_LPFOffset_Max
+    } tmTDA182I2LPFOffset_t, *ptmTDA182I2LPFOffset_t;
+
+    typedef enum _tmTDA182I2IF_AGC_Gain_t {
+        tmTDA182I2_IF_AGC_Gain_2Vpp_0_30dB = 0,         /* 2Vpp       0 - 30dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_1_25Vpp_min_4_26dB,      /* 1.25Vpp   -4 - 26dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,         /* 1Vpp      -6 - 24dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_0_8Vpp_min_8_22dB,       /* 0.8Vpp    -8 - 22dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_0_85Vpp_min_7_5_22_5dB,  /* 0.85Vpp   -7.5 - 22.5dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,       /* 0.7Vpp    -9 - 21dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_0_6Vpp_min_10_3_19_7dB,  /* 0.6Vpp    -10.3 - 19.7dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_0_5Vpp_min_12_18dB,      /* 0.5Vpp    -12 - 18dB IF AGC Gain */
+        tmTDA182I2_IF_AGC_Gain_Max
+    } tmTDA182I2IF_AGC_Gain_t, *ptmTDA182I2IF_AGC_Gain_t;
+
+    typedef enum _tmTDA182I2IF_Notch_t {
+        tmTDA182I2_IF_Notch_Disabled = 0,               /* IF Notch Enabled */
+        tmTDA182I2_IF_Notch_Enabled,                    /* IF Notch Disabled */
+        tmTDA182I2_IF_Notch_Max
+    } tmTDA182I2IF_Notch_t, *ptmTDA182I2IF_Notch_t;
+
+    typedef enum _tmTDA182I2IF_HPF_t {
+        tmTDA182I2_IF_HPF_Disabled = 0,                 /* IF HPF 0.4MHz */
+        tmTDA182I2_IF_HPF_0_4MHz,                       /* IF HPF 0.4MHz */
+        tmTDA182I2_IF_HPF_0_85MHz,                      /* IF HPF 0.85MHz */
+        tmTDA182I2_IF_HPF_1MHz,                         /* IF HPF 1MHz */
+        tmTDA182I2_IF_HPF_1_5MHz,                       /* IF HPF 1.5MHz */
+        tmTDA182I2_IF_HPF_Max
+    } tmTDA182I2IF_HPF_t, *ptmTDA182I2IF_HPF_t;
+
+    typedef enum _tmTDA182I2DC_Notch_t {
+        tmTDA182I2_DC_Notch_Disabled = 0,               /* IF Notch Enabled */
+        tmTDA182I2_DC_Notch_Enabled,                    /* IF Notch Disabled */
+        tmTDA182I2_DC_Notch_Max
+    } tmTDA182I2DC_Notch_t, *ptmTDA182I2DC_Notch_t;
+
+    typedef enum _tmTDA182I2AGC1_LNA_TOP_t {
+        tmTDA182I2_AGC1_LNA_TOP_d95_u89dBuV = 0,            /* AGC1 LNA TOP down 95 up 89 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d95_u93dBuV_do_not_use,     /* AGC1 LNA TOP down 95 up 93 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d95_u94dBuV_do_not_use,     /* AGC1 LNA TOP down 95 up 94 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d95_u95dBuV_do_not_use,     /* AGC1 LNA TOP down 95 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d99_u89dBuV,                /* AGC1 LNA TOP down 99 up 89 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d99_u93dBuV,                /* AGC1 LNA TOP down 95 up 93 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d99_u94dBuV,                /* AGC1 LNA TOP down 99 up 94 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d99_u95dBuV,                /* AGC1 LNA TOP down 99 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d99_u9SdBuV,                /* AGC1 LNA TOP down 99 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d100_u93dBuV,               /* AGC1 LNA TOP down 100 up 93 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d100_u94dBuV,               /* AGC1 LNA TOP down 100 up 94 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d100_u95dBuV,               /* AGC1 LNA TOP down 100 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d100_u9SdBuV,               /* AGC1 LNA TOP down 100 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d101_u93dBuV,               /* AGC1 LNA TOP down 101 up 93 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d101_u94dBuV,               /* AGC1 LNA TOP down 101 up 94 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d101_u95dBuV,               /* AGC1 LNA TOP down 101 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_d101_u9SdBuV,               /* AGC1 LNA TOP down 101 up 95 dBuV */
+        tmTDA182I2_AGC1_LNA_TOP_Max
+    } tmTDA182I2AGC1_LNA_TOP_t, *ptmTDA182I2AGC1_LNA_TOP_t;
+
+    typedef enum _tmTDA182I2AGC2_RF_Attenuator_TOP_t {
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d89_u81dBuV = 0, /* AGC2 RF Attenuator TOP down 89 up 81 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d91_u83dBuV,     /* AGC2 RF Attenuator TOP down 91 up 83 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d93_u85dBuV,     /* AGC2 RF Attenuator TOP down 93 up 85 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d95_u87dBuV,     /* AGC2 RF Attenuator TOP down 95 up 87 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d88_u88dBuV,     /* AGC2 RF Attenuator TOP down 88 up 81 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d89_u82dBuV,     /* AGC2 RF Attenuator TOP down 89 up 82 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u83dBuV,     /* AGC2 RF Attenuator TOP down 90 up 83 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d91_u84dBuV,     /* AGC2 RF Attenuator TOP down 91 up 84 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d92_u85dBuV,     /* AGC2 RF Attenuator TOP down 92 up 85 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d93_u86dBuV,     /* AGC2 RF Attenuator TOP down 93 up 86 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d94_u87dBuV,     /* AGC2 RF Attenuator TOP down 94 up 87 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d95_u88dBuV,     /* AGC2 RF Attenuator TOP down 95 up 88 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d87_u81dBuV,     /* AGC2 RF Attenuator TOP down 87 up 81 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d88_u82dBuV,     /* AGC2 RF Attenuator TOP down 88 up 82 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d89_u83dBuV,     /* AGC2 RF Attenuator TOP down 89 up 83 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d90_u84dBuV,     /* AGC2 RF Attenuator TOP down 90 up 84 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d91_u85dBuV,     /* AGC2 RF Attenuator TOP down 91 up 85 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d92_u86dBuV,     /* AGC2 RF Attenuator TOP down 92 up 86 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d93_u87dBuV,     /* AGC2 RF Attenuator TOP down 93 up 87 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d94_u88dBuV,     /* AGC2 RF Attenuator TOP down 94 up 88 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_d95_u89dBuV,     /* AGC2 RF Attenuator TOP down 95 up 89 dBuV */
+        tmTDA182I2_AGC2_RF_Attenuator_TOP_Max
+    } tmTDA182I2AGC2_RF_Attenuator_TOP_t, *ptmTDA182I2AGC2_RF_Attenuator_TOP_t;
+    
+    typedef enum _tmTDA182I2AGC3_RF_AGC_TOP_t {
+        tmTDA182I2_AGC3_RF_AGC_TOP_94dBuV = 0, /* AGC3 RF AGC TOP 94 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_96dBuV,     /* AGC3 RF AGC TOP 96 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_98dBuV,     /* AGC3 RF AGC TOP 98 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_100dBuV,    /* AGC3 RF AGC TOP 100 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_102dBuV,    /* AGC3 RF AGC TOP 102 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_104dBuV,    /* AGC3 RF AGC TOP 104 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_106dBuV,    /* AGC3 RF AGC TOP 106 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_107dBuV,    /* AGC3 RF AGC TOP 107 dBuV */
+        tmTDA182I2_AGC3_RF_AGC_TOP_Max
+    } tmTDA182I2AGC3_RF_AGC_TOP_t, *ptmTDA182I2AGC3_RF_AGC_TOP_t;
+
+#define tmTDA182I2_AGC3_RF_AGC_TOP_FREQ_LIM 291000000
+
+    typedef enum _tmTDA182I2AGC4_IR_Mixer_TOP_t {
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u99dBuV = 0,     /* AGC4 IR_Mixer TOP down 105 up 99 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u100dBuV,        /* AGC4 IR_Mixer TOP down 105 up 100 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d105_u101dBuV,        /* AGC4 IR_Mixer TOP down 105 up 101 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d107_u101dBuV,        /* AGC4 IR_Mixer TOP down 107 up 101 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d107_u102dBuV,        /* AGC4 IR_Mixer TOP down 107 up 102 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d107_u103dBuV,        /* AGC4 IR_Mixer TOP down 107 up 103 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d108_u103dBuV,        /* AGC4 IR_Mixer TOP down 108 up 103 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d109_u103dBuV,        /* AGC4 IR_Mixer TOP down 109 up 103 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d109_u104dBuV,        /* AGC4 IR_Mixer TOP down 109 up 104 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d109_u105dBuV,        /* AGC4 IR_Mixer TOP down 109 up 105 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u104dBuV,        /* AGC4 IR_Mixer TOP down 110 up 104 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u105dBuV,        /* AGC4 IR_Mixer TOP down 110 up 105 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d110_u106dBuV,        /* AGC4 IR_Mixer TOP down 110 up 106 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d112_u106dBuV,        /* AGC4 IR_Mixer TOP down 112 up 106 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d112_u107dBuV,        /* AGC4 IR_Mixer TOP down 112 up 107 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_d112_u108dBuV,        /* AGC4 IR_Mixer TOP down 112 up 108 dBuV */
+        tmTDA182I2_AGC4_IR_Mixer_TOP_Max
+    } tmTDA182I2AGC4_IR_Mixer_TOP_t, *ptmTDA182I2AGC4_IR_Mixer_TOP_t;
+
+    typedef enum _tmTDA182I2AGC5_IF_AGC_TOP_t {
+        tmTDA182I2_AGC5_IF_AGC_TOP_d105_u99dBuV = 0,        /* AGC5 IF AGC TOP down 105 up 99 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d105_u100dBuV,           /* AGC5 IF AGC TOP down 105 up 100 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d105_u101dBuV,           /* AGC5 IF AGC TOP down 105 up 101 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d107_u101dBuV,           /* AGC5 IF AGC TOP down 107 up 101 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d107_u102dBuV,           /* AGC5 IF AGC TOP down 107 up 102 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d107_u103dBuV,           /* AGC5 IF AGC TOP down 107 up 103 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d108_u103dBuV,           /* AGC5 IF AGC TOP down 108 up 103 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d109_u103dBuV,           /* AGC5 IF AGC TOP down 109 up 103 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d109_u104dBuV,           /* AGC5 IF AGC TOP down 109 up 104 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d109_u105dBuV,           /* AGC5 IF AGC TOP down 109 up 105 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d110_u104dBuV,           /* AGC5 IF AGC TOP down 108 up 104 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d110_u105dBuV,           /* AGC5 IF AGC TOP down 108 up 105 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d110_u106dBuV,           /* AGC5 IF AGC TOP down 108 up 106 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d112_u106dBuV,           /* AGC5 IF AGC TOP down 108 up 106 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d112_u107dBuV,           /* AGC5 IF AGC TOP down 108 up 107 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_d112_u108dBuV,           /* AGC5 IF AGC TOP down 108 up 108 dBuV */
+        tmTDA182I2_AGC5_IF_AGC_TOP_Max
+    } tmTDA182I2AGC5_IF_AGC_TOP_t, *ptmTDA182I2AGC5_IF_AGC_TOP_t;
+
+    typedef enum _tmTDA182I2AGC5_Detector_HPF_t {
+        tmTDA182I2_AGC5_Detector_HPF_Disabled = 0,          /* AGC5_Detector_HPF Enabled */
+        tmTDA182I2_AGC5_Detector_HPF_Enabled,               /* IF Notch Disabled */
+        tmTDA182I2_AGC5_Detector_HPF_Max
+    } tmTDA182I2AGC5_Detector_HPF_t, *ptmTDA182I2AGC5_Detector_HPFh_t;
+
+    typedef enum _tmTDA182I2AGC3_Adapt_t {
+        tmTDA182I2_AGC3_Adapt_Enabled = 0,                  /* AGC3_Adapt Enabled */
+        tmTDA182I2_AGC3_Adapt_Disabled,                     /* AGC3_Adapt Disabled */
+        tmTDA182I2_AGC3_Adapt_Max
+    } tmTDA182I2AGC3_Adapt_t, *ptmTDA182I2AGC3_Adapt_t;
+
+    typedef enum _tmTDA182I2AGC3_Adapt_TOP_t {
+        tmTDA182I2_AGC3_Adapt_TOP_0_Step = 0,              /* same level as AGC3 TOP  */
+        tmTDA182I2_AGC3_Adapt_TOP_1_Step,                  /* 1 level below AGC3 TOP  */
+        tmTDA182I2_AGC3_Adapt_TOP_2_Step,                  /* 2 level below AGC3 TOP  */
+        tmTDA182I2_AGC3_Adapt_TOP_3_Step,                  /* 3 level below AGC3 TOP  */
+    } tmTDA182I2AGC3_Adapt_TOP_t, *ptmTDA182I2AGC3_Adapt_TOP_t;
+
+    typedef enum _tmTDA182I2AGC5_Atten_3dB_t {
+        tmTDA182I2_AGC5_Atten_3dB_Disabled = 0,             /* AGC5_Atten_3dB Disabled */
+        tmTDA182I2_AGC5_Atten_3dB_Enabled,                  /* AGC5_Atten_3dB Enabled */
+        tmTDA182I2_AGC5_Atten_3dB_Max
+    } tmTDA182I2AGC5_Atten_3dB_t, *ptmTDA182I2AGC5_Atten_3dB_t;
+
+    typedef enum _tmTDA182I2H3H5_VHF_Filter6_t {
+        tmTDA182I2_H3H5_VHF_Filter6_Disabled = 0,           /* H3H5_VHF_Filter6 Disabled */
+        tmTDA182I2_H3H5_VHF_Filter6_Enabled,                /* H3H5_VHF_Filter6 Enabled */
+        tmTDA182I2_H3H5_VHF_Filter6_Max
+    } tmTDA182I2H3H5_VHF_Filter6_t, *ptmTDA182I2H3H5_VHF_Filter6_t;
+
+    typedef enum _tmTDA182I2_LPF_Gain_t {
+        tmTDA182I2_LPF_Gain_Unknown = 0,                    /* LPF_Gain Unknown */
+        tmTDA182I2_LPF_Gain_Frozen,                         /* LPF_Gain Frozen */
+        tmTDA182I2_LPF_Gain_Free                            /* LPF_Gain Free */
+    } tmTDA182I2_LPF_Gain_t, *ptmTDA182I2_LPF_Gain_t;
+
+    typedef struct _tmTDA182I2StdCoefficients
+    {
+        UInt32                              IF;
+        Int32                               CF_Offset;
+        tmTDA182I2LPF_t                     LPF;
+        tmTDA182I2LPFOffset_t               LPF_Offset;
+        tmTDA182I2IF_AGC_Gain_t             IF_Gain;
+        tmTDA182I2IF_Notch_t                IF_Notch;
+        tmTDA182I2IF_HPF_t                  IF_HPF;
+        tmTDA182I2DC_Notch_t                DC_Notch;
+        tmTDA182I2AGC1_LNA_TOP_t            AGC1_LNA_TOP;
+        tmTDA182I2AGC2_RF_Attenuator_TOP_t  AGC2_RF_Attenuator_TOP;
+        tmTDA182I2AGC3_RF_AGC_TOP_t         AGC3_RF_AGC_TOP_Low_band;
+        tmTDA182I2AGC3_RF_AGC_TOP_t         AGC3_RF_AGC_TOP_High_band;
+        tmTDA182I2AGC4_IR_Mixer_TOP_t       AGC4_IR_Mixer_TOP;
+        tmTDA182I2AGC5_IF_AGC_TOP_t         AGC5_IF_AGC_TOP;
+        tmTDA182I2AGC5_Detector_HPF_t       AGC5_Detector_HPF;
+        tmTDA182I2AGC3_Adapt_t              AGC3_Adapt;
+        tmTDA182I2AGC3_Adapt_TOP_t          AGC3_Adapt_TOP;
+        tmTDA182I2AGC5_Atten_3dB_t          AGC5_Atten_3dB;
+        UInt8                               GSK;
+        tmTDA182I2H3H5_VHF_Filter6_t        H3H5_VHF_Filter6;
+        tmTDA182I2_LPF_Gain_t               LPF_Gain;
+		Bool								AGC1_Freeze;
+		Bool								LTO_STO_immune;
+    } tmTDA182I2StdCoefficients, *ptmTDA182I2StdCoefficients;
+
+    typedef enum _tmTDA182I2RFFilterRobustness_t {
+        tmTDA182I2RFFilterRobustness_Low = 0,
+        tmTDA182I2RFFilterRobustness_High,
+        tmTDA182I2RFFilterRobustness_Error,
+        tmTDA182I2RFFilterRobustness_Max
+    } tmTDA182I2RFFilterRobustness_t, *ptmTDA182I2RFFilterRobustness_t;
+/*
+    typedef struct _tmTDA182I2RFFilterRating {
+        double                               VHFLow_0_Margin;
+        double                               VHFLow_1_Margin;
+        double                               VHFHigh_0_Margin;
+        double                               VHFHigh_1_Margin;
+        double                               UHFLow_0_Margin;
+        double                               UHFLow_1_Margin;
+        double                               UHFHigh_0_Margin;
+        double                               UHFHigh_1_Margin;    
+        tmTDA182I2RFFilterRobustness_t      VHFLow_0_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      VHFLow_1_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      VHFHigh_0_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      VHFHigh_1_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      UHFLow_0_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      UHFLow_1_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      UHFHigh_0_RFFilterRobustness;
+        tmTDA182I2RFFilterRobustness_t      UHFHigh_1_RFFilterRobustness;
+    } tmTDA182I2RFFilterRating, *ptmTDA182I2RFFilterRating;
+*/
+    tmErrorCode_t
+        tmbslTDA182I2Init(
+        tmUnitSelect_t              tUnit,      /*  I: Unit number */
+        tmbslFrontEndDependency_t*  psSrvFunc,   /*  I: setup parameters */
+        TUNER_MODULE                *pTuner	    // Added by Realtek
+        );
+    tmErrorCode_t 
+        tmbslTDA182I2DeInit (
+        tmUnitSelect_t  tUnit   /*  I: Unit number */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetSWVersion (
+        ptmSWVersion_t  pSWVersion  /*  I: Receives SW Version */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2CheckHWVersion (
+        tmUnitSelect_t tUnit    /* I: Unit number */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2SetPowerState (
+        tmUnitSelect_t          tUnit,      /*  I: Unit number */
+        tmTDA182I2PowerState_t  powerState  /*  I: Power state of this device */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetPowerState (
+        tmUnitSelect_t            tUnit,        /*  I: Unit number */
+        tmTDA182I2PowerState_t    *pPowerState  /*  O: Power state of this device */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2SetStandardMode (
+        tmUnitSelect_t              tUnit,          /*  I: Unit number */
+        tmTDA182I2StandardMode_t    StandardMode    /*  I: Standard mode of this device */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetStandardMode (
+        tmUnitSelect_t              tUnit,          /*  I: Unit number */
+        tmTDA182I2StandardMode_t    *pStandardMode  /*  O: Standard mode of this device */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2SetRf(
+        tmUnitSelect_t  tUnit,  /*  I: Unit number */
+        UInt32          uRF,    /*  I: RF frequency in hertz */
+        tmTDA182I2IF_AGC_Gain_t   IF_Gain     // Added by realtek
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetRf(
+        tmUnitSelect_t  tUnit,  /*  I: Unit number */
+        UInt32*         pRF     /*  O: RF frequency in hertz */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2Reset(
+        tmUnitSelect_t tUnit    /* I: Unit number */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetIF(
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt32*         puIF    /* O: IF Frequency in hertz */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetCF_Offset(
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32*         puOffset    /* O: Center frequency offset in hertz */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetLockStatus(
+        tmUnitSelect_t          tUnit,      /* I: Unit number */
+        tmbslFrontEndState_t*   pLockStatus /* O: PLL Lock status */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetPowerLevel(
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32*         pPowerLevel /* O: Power Level in dBV */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2SetIRQWait(
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        Bool            bWait   /* I: Determine if we need to wait IRQ in driver functions */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetIRQWait(
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        Bool*           pbWait  /* O: Determine if we need to wait IRQ in driver functions */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetIRQ(
+        tmUnitSelect_t  tUnit  /* I: Unit number */,
+        Bool*           pbIRQ  /* O: IRQ triggered */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2WaitIRQ(
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          timeOut,    /* I: timeOut for IRQ wait */
+        UInt32          waitStep,   /* I: wait step */
+        UInt8           irqStatus   /* I: IRQs to wait */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2GetXtalCal_End(
+        tmUnitSelect_t  tUnit           /* I: Unit number */,
+        Bool*           pbXtalCal_End   /* O: XtalCal_End triggered */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2WaitXtalCal_End(
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          timeOut,    /* I: timeOut for IRQ wait */
+        UInt32          waitStep    /* I: wait step */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2SoftReset(
+        tmUnitSelect_t  tUnit   /* I: Unit number */
+        );
+/*
+    tmErrorCode_t
+        tmbslTDA182I2CheckRFFilterRobustness
+        (
+        tmUnitSelect_t                         tUnit,      // I: Unit number
+        ptmTDA182I2RFFilterRating              rating      // O: RF Filter rating
+        );
+*/
+    tmErrorCode_t
+        tmbslTDA182I2Write (
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          uIndex,     /* I: Start index to write */
+        UInt32          WriteLen,   /* I: Number of bytes to write */
+        UInt8*          pData       /* I: Data to write */
+        );
+    tmErrorCode_t
+        tmbslTDA182I2Read (
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          uIndex,     /* I: Start index to read */
+        UInt32          ReadLen,    /* I: Number of bytes to read */
+        UInt8*          pData       /* I: Data to read */
+        );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TMBSL_TDA18272_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmbslTDA182I2\inc\tmbslTDA182I2local.h
+
+
+/**
+Copyright (C) 2008 NXP B.V., All Rights Reserved.
+This source code and any compilation or derivative thereof is the proprietary
+information of NXP B.V. and is confidential in nature. Under no circumstances
+is this software to be  exposed to or placed under an Open Source License of
+any type without the expressed written permission of NXP B.V.
+*
+* \file          tmbslTDA182I2local.h
+*                %version: 9 %
+*
+* \date          %date_modified%
+*
+* \brief         Describe briefly the purpose of this file.
+*
+* REFERENCE DOCUMENTS :
+*
+* Detailed description may be added here.
+*
+* \section info Change Information
+*
+* \verbatim
+Date          Modified by CRPRNr  TASKNr  Maintenance description
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+\endverbatim
+*
+*/
+
+#ifndef _TMBSL_TDA182I2LOCAL_H 
+#define _TMBSL_TDA182I2LOCAL_H
+
+/*------------------------------------------------------------------------------*/
+/* Standard include files:                                                      */
+/*------------------------------------------------------------------------------*/
+
+/*------------------------------------------------------------------------------*/
+/* Project include files:                                                       */
+/*------------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*------------------------------------------------------------------------------*/
+/* Types and defines:                                                           */
+/*------------------------------------------------------------------------------*/
+
+#define TDA182I2_MUTEX_TIMEOUT  TMBSL_FRONTEND_MUTEX_TIMEOUT_INFINITE
+
+#ifdef TMBSL_TDA18272
+ #define TMBSL_TDA182I2_COMPONENT_NAME_STR "TDA18272"
+#else /* TMBSL_TDA18272 */
+ #define TMBSL_TDA182I2_COMPONENT_NAME_STR "TDA18212"
+#endif /* TMBSL_TDA18272 */
+
+#define _SYSTEMFUNC (pObj->SystemFunc)
+#define POBJ_SRVFUNC_SIO pObj->sRWFunc
+#define POBJ_SRVFUNC_STIME pObj->sTime
+#define P_DBGPRINTEx pObj->sDebug.Print
+#define P_DBGPRINTVALID ((pObj != Null) && (pObj->sDebug.Print != Null))
+
+
+/*-------------*/
+/* ERROR CODES */
+/*-------------*/
+
+#define TDA182I2_MAX_UNITS                          2
+
+    typedef struct _tmTDA182I2Object_t
+    {
+        tmUnitSelect_t              tUnit;
+        tmUnitSelect_t              tUnitW;
+        ptmbslFrontEndMutexHandle   pMutex;
+        Bool                        init;
+        tmbslFrontEndIoFunc_t       sRWFunc;
+        tmbslFrontEndTimeFunc_t     sTime;
+        tmbslFrontEndDebugFunc_t    sDebug;
+        tmbslFrontEndMutexFunc_t    sMutex;
+        tmTDA182I2PowerState_t      curPowerState;
+        tmTDA182I2PowerState_t      minPowerState;
+        UInt32                      uRF;
+        tmTDA182I2StandardMode_t    StandardMode;
+        Bool                        Master;
+        UInt8                       LT_Enable;
+        UInt8                       PSM_AGC1;
+        UInt8                       AGC1_6_15dB;
+        tmTDA182I2StdCoefficients   Std_Array[tmTDA182I2_StandardMode_Max];
+
+        // Added by Realtek.
+		TUNER_MODULE                *pTuner;
+
+    } tmTDA182I2Object_t, *ptmTDA182I2Object_t, **pptmTDA182I2Object_t;
+
+
+static tmErrorCode_t TDA182I2Init(tmUnitSelect_t tUnit);
+static tmErrorCode_t TDA182I2Wait(ptmTDA182I2Object_t pObj, UInt32 Time);
+static tmErrorCode_t TDA182I2WaitXtalCal_End( ptmTDA182I2Object_t pObj, UInt32 timeOut, UInt32 waitStep);
+
+extern tmErrorCode_t TDA182I2MutexAcquire(ptmTDA182I2Object_t   pObj, UInt32 timeOut);
+extern tmErrorCode_t TDA182I2MutexRelease(ptmTDA182I2Object_t   pObj);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TMBSL_TDA182I2LOCAL_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmbslTDA182I2\inc\tmbslTDA182I2Instance.h
+
+
+//-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2001 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmbslTDA182I2Instance.h
+//
+// DESCRIPTION:  define the static Objects
+//
+// DOCUMENT REF: DVP Software Coding Guidelines v1.14
+//               DVP Board Support Library Architecture Specification v0.5
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+//
+#ifndef _TMBSLTDA182I2_INSTANCE_H //-----------------
+#define _TMBSLTDA182I2_INSTANCE_H
+
+tmErrorCode_t TDA182I2AllocInstance (tmUnitSelect_t tUnit, pptmTDA182I2Object_t ppDrvObject);
+tmErrorCode_t TDA182I2DeAllocInstance (tmUnitSelect_t tUnit);
+tmErrorCode_t TDA182I2GetInstance (tmUnitSelect_t tUnit, pptmTDA182I2Object_t ppDrvObject);
+
+
+#endif // _TMBSLTDA182I2_INSTANCE_H //---------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\inc\tmddTDA182I2.h
+
+
+/**
+Copyright (C) 2008 NXP B.V., All Rights Reserved.
+This source code and any compilation or derivative thereof is the proprietary
+information of NXP B.V. and is confidential in nature. Under no circumstances
+is this software to be  exposed to or placed under an Open Source License of
+any type without the expressed written permission of NXP B.V.
+*
+* \file          tmddTDA182I2.h
+*                %version: 11 %
+*
+* \date          %date_modified%
+*
+* \brief         Describe briefly the purpose of this file.
+*
+* REFERENCE DOCUMENTS :
+*
+* Detailed description may be added here.
+*
+* \section info Change Information
+*
+* \verbatim
+Date          Modified by CRPRNr  TASKNr  Maintenance description
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+|            |           |       |
+-------------|-----------|-------|-------|-----------------------------------
+\endverbatim
+*
+*/
+#ifndef _TMDD_TDA182I2_H //-----------------
+#define _TMDD_TDA182I2_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    //-----------------------------------------------------------------------------
+    // Types and defines:
+    //-----------------------------------------------------------------------------
+    //
+
+    /* SW Error codes */
+#define ddTDA182I2_ERR_BASE               (CID_COMP_TUNER | CID_LAYER_BSL)
+#define ddTDA182I2_ERR_COMP               (CID_COMP_TUNER | CID_LAYER_BSL | TM_ERR_COMP_UNIQUE_START)
+
+#define ddTDA182I2_ERR_BAD_UNIT_NUMBER    (ddTDA182I2_ERR_BASE + TM_ERR_BAD_UNIT_NUMBER)
+#define ddTDA182I2_ERR_NOT_INITIALIZED    (ddTDA182I2_ERR_BASE + TM_ERR_NOT_INITIALIZED)
+#define ddTDA182I2_ERR_INIT_FAILED        (ddTDA182I2_ERR_BASE + TM_ERR_INIT_FAILED)
+#define ddTDA182I2_ERR_BAD_PARAMETER      (ddTDA182I2_ERR_BASE + TM_ERR_BAD_PARAMETER)
+#define ddTDA182I2_ERR_NOT_SUPPORTED      (ddTDA182I2_ERR_BASE + TM_ERR_NOT_SUPPORTED)
+#define ddTDA182I2_ERR_HW_FAILED          (ddTDA182I2_ERR_COMP + 0x0001)
+#define ddTDA182I2_ERR_NOT_READY          (ddTDA182I2_ERR_COMP + 0x0002)
+#define ddTDA182I2_ERR_BAD_VERSION        (ddTDA182I2_ERR_COMP + 0x0003)
+
+
+    typedef enum _tmddTDA182I2PowerState_t {
+        tmddTDA182I2_PowerNormalMode,                                               /* Device normal mode */
+        tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndWithSyntheOn,             /* Device standby mode with LNA and Xtal Output and Synthe on*/
+        tmddTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn,                            /* Device standby mode with LNA and Xtal Output */
+        tmddTDA182I2_PowerStandbyWithXtalOn,                                        /* Device standby mode with Xtal Output */
+        tmddTDA182I2_PowerStandby,                                                  /* Device standby mode */
+        tmddTDA182I2_PowerMax
+    } tmddTDA182I2PowerState_t, *ptmddTDA182I2PowerState_t;
+
+    typedef enum _tmddTDA182I2_LPF_Gain_t {
+        tmddTDA182I2_LPF_Gain_Unknown = 0,                                          /* LPF_Gain Unknown */
+        tmddTDA182I2_LPF_Gain_Frozen,                                               /* LPF_Gain Frozen */
+        tmddTDA182I2_LPF_Gain_Free                                                  /* LPF_Gain Free */
+    } tmddTDA182I2_LPF_Gain_t, *ptmddTDA182I2_LPF_Gain_t;
+
+    tmErrorCode_t
+    tmddTDA182I2Init
+    (
+    tmUnitSelect_t    tUnit,    //  I: Unit number
+    tmbslFrontEndDependency_t*  psSrvFunc   /*  I: setup parameters */
+    );
+    tmErrorCode_t 
+    tmddTDA182I2DeInit
+    (
+    tmUnitSelect_t    tUnit     //  I: Unit number
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetSWVersion
+    (
+    ptmSWVersion_t    pSWVersion        //  I: Receives SW Version 
+    );
+    tmErrorCode_t
+    tmddTDA182I2Reset
+    (
+    tmUnitSelect_t  tUnit     //  I: Unit number
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetLPF_Gain_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uMode   /* I: Unknown/Free/Frozen */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetLPF_Gain_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           *puMode /* O: Unknown/Free/Frozen */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Write
+    (
+    tmUnitSelect_t      tUnit,      //  I: Unit number
+    UInt32              uIndex,         //  I: Start index to write
+    UInt32              uNbBytes,       //  I: Number of bytes to write
+    UInt8*             puBytes         //  I: Pointer on an array of bytes
+    );
+    tmErrorCode_t
+    tmddTDA182I2Read
+    (
+    tmUnitSelect_t      tUnit,      //  I: Unit number
+    UInt32              uIndex,         //  I: Start index to read
+    UInt32              uNbBytes,       //  I: Number of bytes to read
+    UInt8*             puBytes         //  I: Pointer on an array of bytes
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPOR
+    (
+    tmUnitSelect_t    tUnit,    //  I: Unit number
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetLO_Lock
+    (
+    tmUnitSelect_t    tUnit,    //  I: Unit number
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMS
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIdentity
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt16*        puValue      //  I: Address of the variable to output item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMinorRevision
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMajorRevision
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetTM_D
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetTM_ON
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetTM_ON
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPowerState
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    tmddTDA182I2PowerState_t  powerState    //  I: Power state of this device
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPowerState
+    (
+    tmUnitSelect_t        tUnit,    //  I: Unit number
+    ptmddTDA182I2PowerState_t    pPowerState  //  O: Power state of this device
+    );
+
+    tmErrorCode_t
+    tmddTDA182I2GetPower_Level
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIRQ_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIRQ_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXtalCal_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXtalCal_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RSSI_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RSSI_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_LOCalc_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_LOCalc_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RFCAL_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RFCAL_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_IRCAL_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_IRCAL_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RCCal_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RCCal_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIRQ_Clear
+    (
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt8           irqStatus   /* I: IRQs to clear */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXtalCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXtalCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RSSI_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RSSI_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_LOCalc_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_LOCalc_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RFCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RFCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_IRCAL_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_IRCAL_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RCCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RCCal_Clear
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIRQ_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIRQ_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXtalCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXtalCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RSSI_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RSSI_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_LOCalc_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_LOCalc_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RFCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RFCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_IRCAL_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_IRCAL_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_RCCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RCCal_Set
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIRQ_status
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_XtalCal_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RSSI_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_LOCalc_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RFCal_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_IRCAL_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_RCCal_End
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetLT_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetLT_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC1_6_15dB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_6_15dB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC1_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC2_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC2_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGCs_Up_Step_assym
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGCs_Up_Step_assym
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGCs_Up_Step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGCs_Up_Step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPulse_Shaper_Disable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPulse_Shaper_Disable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGCK_Step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGCK_Step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGCK_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGCK_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPD_RFAGC_Adapt
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPD_RFAGC_Adapt
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFAGC_Adapt_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFAGC_Adapt_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFAGC_Low_BW
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFAGC_Low_BW
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Atten_3dB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Atten_3dB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFAGC_Top
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFAGC_Top
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Mixer_Top
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Mixer_Top
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGCs_Do_Step_assym
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGCs_Do_Step_assym
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC5_Ana
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_Ana
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC5_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIF_Level
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIF_Level
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIF_HP_Fc
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIF_HP_Fc
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIF_ATSC_Notch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIF_ATSC_Notch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetLP_FC_Offset
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetLP_FC_Offset
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetLP_FC
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetLP_FC
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetI2C_Clock_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetI2C_Clock_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetDigital_Clock_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDigital_Clock_Mode
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXtalOsc_AnaReg_En
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXtalOsc_AnaReg_En
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXTout
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXTout
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIF_Freq
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32          uValue      //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIF_Freq
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*        puValue      //  I: Address of the variable to output item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Freq
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32          uValue      //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Freq
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt32*        puValue      //  I: Address of the variable to output item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_Meas
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_Meas
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_CAL_AV
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_CAL_AV
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_CAL
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_CAL
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_CAL_Loop
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_CAL_Loop
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Cal_Image
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Cal_Image
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_CAL_Wanted
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_CAL_Wanted
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRC_Cal
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRC_Cal
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetCalc_PLL
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetCalc_PLL
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetXtalCal_Launch
+    (
+    tmUnitSelect_t      tUnit    //  I: Unit number
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetXtalCal_Launch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetMSM_Launch
+    (
+    tmUnitSelect_t      tUnit    //  I: Unit number
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetMSM_Launch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSM_AGC1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSM_AGC1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSM_StoB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSM_StoB
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSMRFpoly
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSMRFpoly
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSM_Mixer
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSM_Mixer
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSM_Ifpoly
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSM_Ifpoly
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPSM_Lodriver
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPSM_Lodriver
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetDCC_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDCC_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetDCC_Slow
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDCC_Slow
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetDCC_psm
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDCC_psm
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetFmax_Lo
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetFmax_Lo
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Loop
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Loop
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Target
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Target
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_GStep
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_GStep
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Corr_Boost
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Corr_Boost
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_FreqLow_Sel
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_FreqLow_Sel
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_mode_ram_store
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_mode_ram_store
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_FreqLow
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_FreqLow
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_FreqMid
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_FreqMid
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetCoarse_IR_FreqHigh
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetCoarse_IR_FreqHigh
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_FreqHigh
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_FreqHigh
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+
+    tmErrorCode_t
+    tmddTDA182I2SetPD_Vsync_Mgt
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPD_Vsync_Mgt
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPD_Ovld
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPD_Ovld
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetPD_Udld
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetPD_Udld
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC_Ovld_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC_Ovld_TOP
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC_Ovld_Timer
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC_Ovld_Timer
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Mixer_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Mixer_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIR_Mixer_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIR_Mixer_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetHi_Pass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetHi_Pass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIF_Notch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIF_Notch
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC1_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC1_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetForce_AGC1_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetForce_AGC1_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC1_Gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_Gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC5_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC5_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetForce_AGC5_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetForce_AGC5_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC5_Gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_Gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq0
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq0
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq3
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq3
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq6
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq6
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq7
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq7
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq8
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq8
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq9
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq9
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq10
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq10
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Freq11
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Freq11
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset0
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset0
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset3
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset3
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue   //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset6
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset6
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset7
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset7
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset8
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset8
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset9
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset9
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset10
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset10
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Offset11
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Offset11
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_SW_Algo_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_SW_Algo_Enable
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Filter_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Filter_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC2_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC2_loop_off
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetForce_AGC2_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetForce_AGC2_gain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Filter_Gv
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Filter_Gv
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Filter_Band
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Filter_Band
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_Filter_Cap
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_Filter_Cap
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetAGC2_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC2_Do_step
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetGain_Taper
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetGain_Taper
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_BPF
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_BPF
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRF_BPF_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRF_BPF_Bypass
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetN_CP_Current
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetN_CP_Current
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetUp_AGC5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDo_AGC5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetUp_AGC4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDo_AGC4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetUp_AGC2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDo_AGC2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetUp_AGC1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDo_AGC1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC2_Gain_Read
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC1_Gain_Read
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetTOP_AGC3_Read
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC5_Gain_Read
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetAGC4_Gain_Read
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_AV
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_AV
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_Cap_Reset_En
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_Cap_Reset_En
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_Cap_Val
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_Cap_Val
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_Ck_Speed
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_Ck_Speed
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRSSI_Dicho_not
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRSSI_Dicho_not
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_Phi2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_Phi2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetDDS_Polarity
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    UInt8           uValue  //  I: Item value
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetDDS_Polarity
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetRFCAL_DeltaGain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetRFCAL_DeltaGain
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIRQ_Polarity
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8           uValue  /* I: Item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIRQ_Polarity
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_0
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_1
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_2
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_3
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_4
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_5
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_6
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_7
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_8
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_9
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_10
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2Getrfcal_log_11
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+        UInt8*          puValue /* I: Address of the variable to output item value */
+    );
+    tmErrorCode_t
+    tmddTDA182I2LaunchRF_CAL
+    (
+        tmUnitSelect_t  tUnit       /* I: Unit number */
+    );
+    tmErrorCode_t
+    tmddTDA182I2WaitIRQ
+    (
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          timeOut,    /* I: timeout */
+        UInt32          waitStep,   /* I: wait step */
+        UInt8           irqStatus   /* I: IRQs to wait */
+    );
+    tmErrorCode_t
+    tmddTDA182I2WaitXtalCal_End
+    (
+        tmUnitSelect_t  tUnit,      /* I: Unit number */
+        UInt32          timeOut,    /* I: timeout */
+        UInt32          waitStep    /* I: wait step */
+    );
+    tmErrorCode_t
+    tmddTDA182I2SetIRQWait
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool            bWait       /* I: Determine if we need to wait IRQ in driver functions */
+    );
+    tmErrorCode_t
+    tmddTDA182I2GetIRQWait
+    (
+        tmUnitSelect_t  tUnit,  /* I: Unit number */
+    Bool*           pbWait      /* O: Determine if we need to wait IRQ in driver functions */
+    );
+    tmErrorCode_t
+    tmddTDA182I2AGC1_Adapt
+    (
+        tmUnitSelect_t  tUnit   /* I: Unit number */
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _TMDD_TDA182I2_H //---------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\inc\tmddTDA182I2local.h
+
+
+//-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2007 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmddTDA182I2local.h
+//
+// DESCRIPTION:  define the Object for the TDA182I2
+//
+// DOCUMENT REF: DVP Software Coding Guidelines v1.14
+//               DVP Board Support Library Architecture Specification v0.5
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+//
+#ifndef _TMDD_TDA182I2LOCAL_H //-----------------
+#define _TMDD_TDA182I2LOCAL_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+
+//#include "tmddTDA182I2.h"
+
+/*------------------------------------------------------------------------------*/
+/* Project include files:                                                       */
+/*------------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    //-----------------------------------------------------------------------------
+    // Types and defines:
+    //-----------------------------------------------------------------------------
+    //
+
+#define ddTDA182I2_MUTEX_TIMEOUT       TMBSL_FRONTEND_MUTEX_TIMEOUT_INFINITE
+
+#define _SYSTEMFUNC (pObj->SystemFunc)
+
+#define POBJ_SRVFUNC_SIO pObj->sRWFunc
+#define POBJ_SRVFUNC_STIME pObj->sTime
+#define P_DBGPRINTEx pObj->sDebug.Print
+#define P_DBGPRINTVALID ((pObj != Null) && (pObj->sDebug.Print != Null))
+
+#define TDA182I2_DD_COMP_NUM    2 // Major protocol change - Specification change required
+#define TDA182I2_DD_MAJOR_VER   4 // Minor protocol change - Specification change required
+#define TDA182I2_DD_MINOR_VER   7 // Software update - No protocol change - No specification change required
+
+#define TDA182I2_POWER_LEVEL_MIN  40
+#define TDA182I2_POWER_LEVEL_MAX  110
+
+#define TDA182I2_MAX_UNITS                  2
+#define TDA182I2_I2C_MAP_NB_BYTES           68
+
+#define TDA182I2_DEVICE_ID_MASTER  1
+#define TDA182I2_DEVICE_ID_SLAVE   0
+
+
+    typedef struct _TDA182I2_I2C_Map_t
+    {
+        union
+        {
+            UInt8 ID_byte_1;
+            struct       
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 MS:1;
+                UInt8 Ident_1:7;
+#else
+                UInt8 Ident_1:7;
+                UInt8 MS:1;
+#endif
+            }bF;
+        }uBx00;
+
+        union
+        {
+            UInt8 ID_byte_2;
+            struct
+            {
+                UInt8 Ident_2:8;
+            }bF;
+        }uBx01;
+
+        union
+        {
+            UInt8 ID_byte_3;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 Major_rev:4;
+				UInt8 Minor_rev:4;
+#else
+                UInt8 Minor_rev:4;
+                UInt8 Major_rev:4;
+#endif                
+            }bF;
+        }uBx02;
+
+        union
+        {
+            UInt8 Thermo_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:1;
+				UInt8 TM_D:7;
+#else
+                UInt8 TM_D:7;
+                UInt8 UNUSED_I0_D0:1;
+#endif                
+            }bF;
+        }uBx03;
+
+        union
+        {
+            UInt8 Thermo_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:7;
+				UInt8 TM_ON:1;
+#else
+                UInt8 TM_ON:1;
+                UInt8 UNUSED_I0_D0:7;
+#endif                
+            }bF;
+        }uBx04;
+
+        union
+        {
+            UInt8 Power_state_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:6;
+                UInt8 POR:1;
+				UInt8 LO_Lock:1;
+#else
+                UInt8 LO_Lock:1;
+                UInt8 POR:1;
+                UInt8 UNUSED_I0_D0:6;
+#endif                
+            }bF;
+        }uBx05;
+
+        union
+        {
+            UInt8 Power_state_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:4;
+                UInt8 SM:1;
+                UInt8 SM_Synthe:1;
+                UInt8 SM_LT:1;
+				UInt8 SM_XT:1;
+#else
+                UInt8 SM_XT:1;
+                UInt8 SM_LT:1;
+                UInt8 SM_Synthe:1;
+                UInt8 SM:1;
+                UInt8 UNUSED_I0_D0:4;
+#endif                
+            }bF;
+        }uBx06;
+
+        union
+        {
+            UInt8 Input_Power_Level_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:1;
+				UInt8 Power_Level:7;
+#else
+                UInt8 Power_Level:7;
+                UInt8 UNUSED_I0_D0:1;
+#endif                
+            }bF;
+        }uBx07;
+
+        union
+        {
+            UInt8 IRQ_status;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IRQ_status:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 MSM_XtalCal_End:1;
+                UInt8 MSM_RSSI_End:1;
+                UInt8 MSM_LOCalc_End:1;
+                UInt8 MSM_RFCal_End:1;
+                UInt8 MSM_IRCAL_End:1;
+				UInt8 MSM_RCCal_End:1;				    
+#else
+                UInt8 MSM_RCCal_End:1;
+                UInt8 MSM_IRCAL_End:1;
+                UInt8 MSM_RFCal_End:1;
+                UInt8 MSM_LOCalc_End:1;
+                UInt8 MSM_RSSI_End:1;
+                UInt8 MSM_XtalCal_End:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 IRQ_status:1;
+#endif                
+            }bF;
+        }uBx08;
+
+        union
+        {
+            UInt8 IRQ_enable;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IRQ_Enable:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 XtalCal_Enable:1;
+                UInt8 MSM_RSSI_Enable:1;
+                UInt8 MSM_LOCalc_Enable:1;
+                UInt8 MSM_RFCAL_Enable:1;
+                UInt8 MSM_IRCAL_Enable:1;
+				UInt8 MSM_RCCal_Enable:1;
+#else
+                UInt8 MSM_RCCal_Enable:1;
+                UInt8 MSM_IRCAL_Enable:1;
+                UInt8 MSM_RFCAL_Enable:1;
+                UInt8 MSM_LOCalc_Enable:1;
+                UInt8 MSM_RSSI_Enable:1;
+                UInt8 XtalCal_Enable:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 IRQ_Enable:1;
+#endif                
+            }bF;
+        }uBx09;
+
+        union
+        {
+            UInt8 IRQ_clear;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IRQ_Clear:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 XtalCal_Clear:1;
+                UInt8 MSM_RSSI_Clear:1;
+                UInt8 MSM_LOCalc_Clear:1;
+                UInt8 MSM_RFCal_Clear:1;
+                UInt8 MSM_IRCAL_Clear:1;
+				UInt8 MSM_RCCal_Clear:1;
+#else
+                UInt8 MSM_RCCal_Clear:1;
+                UInt8 MSM_IRCAL_Clear:1;
+                UInt8 MSM_RFCal_Clear:1;
+                UInt8 MSM_LOCalc_Clear:1;
+                UInt8 MSM_RSSI_Clear:1;
+                UInt8 XtalCal_Clear:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 IRQ_Clear:1;
+#endif                
+            }bF;
+        }uBx0A;
+
+        union
+        {
+            UInt8 IRQ_set;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IRQ_Set:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 XtalCal_Set:1;
+                UInt8 MSM_RSSI_Set:1;
+                UInt8 MSM_LOCalc_Set:1;
+                UInt8 MSM_RFCal_Set:1;
+                UInt8 MSM_IRCAL_Set:1;
+				UInt8 MSM_RCCal_Set:1;
+#else
+                UInt8 MSM_RCCal_Set:1;
+                UInt8 MSM_IRCAL_Set:1;
+                UInt8 MSM_RFCal_Set:1;
+                UInt8 MSM_LOCalc_Set:1;
+                UInt8 MSM_RSSI_Set:1;
+                UInt8 XtalCal_Set:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 IRQ_Set:1;
+#endif                
+            }bF;
+        }uBx0B;
+
+        union
+        {
+            UInt8 AGC1_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 LT_Enable:1;
+                UInt8 AGC1_6_15dB:1;
+                UInt8 UNUSED_I0_D0:2;
+				UInt8 AGC1_TOP:4;
+#else
+                UInt8 AGC1_TOP:4;
+                UInt8 UNUSED_I0_D0:2;
+                UInt8 AGC1_6_15dB:1;
+                UInt8 LT_Enable:1;
+#endif                
+            }bF;
+        }uBx0C;
+
+        union
+        {
+            UInt8 AGC2_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:3;
+				UInt8 AGC2_TOP:5;
+#else
+                UInt8 AGC2_TOP:5;
+                UInt8 UNUSED_I0_D0:3;
+#endif                
+            }bF;
+        }uBx0D;
+
+        union
+        {
+            UInt8 AGCK_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 AGCs_Up_Step_assym:2;
+                UInt8 AGCs_Up_Step:1;
+                UInt8 Pulse_Shaper_Disable:1;
+                UInt8 AGCK_Step:2;
+				UInt8 AGCK_Mode:2;
+#else
+                UInt8 AGCK_Mode:2;
+                UInt8 AGCK_Step:2;
+                UInt8 Pulse_Shaper_Disable:1;
+                UInt8 AGCs_Up_Step:1;
+                UInt8 AGCs_Up_Step_assym:2;
+#endif                
+            }bF;
+        }uBx0E;
+
+        union
+        {
+            UInt8 RF_AGC_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 PD_RFAGC_Adapt:1;
+                UInt8 RFAGC_Adapt_TOP:2;
+                UInt8 RFAGC_Low_BW:1;
+                UInt8 RF_Atten_3dB:1;
+				UInt8 RFAGC_Top:3;
+#else
+                UInt8 RFAGC_Top:3;
+                UInt8 RF_Atten_3dB:1;
+                UInt8 RFAGC_Low_BW:1;
+                UInt8 RFAGC_Adapt_TOP:2;
+                UInt8 PD_RFAGC_Adapt:1;
+#endif                
+            }bF;
+        }uBx0F;
+
+        union
+        {
+            UInt8 IR_Mixer_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:4;
+				UInt8 IR_Mixer_Top:4;
+#else
+                UInt8 IR_Mixer_Top:4;
+                UInt8 UNUSED_I0_D0:4;
+#endif                
+            }bF;
+        }uBx10;
+
+        union
+        {
+            UInt8 AGC5_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 AGCs_Do_Step_assym:2;
+                UInt8 AGC5_Ana:1;
+				UInt8 AGC5_TOP:4;
+#else
+                UInt8 AGC5_TOP:4;
+                UInt8 AGC5_Ana:1;
+                UInt8 AGCs_Do_Step_assym:2;
+                UInt8 UNUSED_I0_D0:1;
+#endif                
+            }bF;
+        }uBx11;
+
+        union
+        {
+            UInt8 IF_AGC_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:5;
+				UInt8 IF_level:3;
+#else
+                UInt8 IF_level:3;
+                UInt8 UNUSED_I0_D0:5;
+#endif                
+            }bF;
+        }uBx12;
+
+        union
+        {
+            UInt8 IF_Byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IF_HP_Fc:2;
+                UInt8 IF_ATSC_Notch:1;
+                UInt8 LP_FC_Offset:2;
+				UInt8 LP_Fc:3;
+#else
+                UInt8 LP_Fc:3;
+                UInt8 LP_FC_Offset:2;
+                UInt8 IF_ATSC_Notch:1;
+                UInt8 IF_HP_Fc:2;
+#endif                
+            }bF;
+        }uBx13;
+
+        union
+        {
+            UInt8 Reference_Byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 I2C_Clock_Mode:1;
+                UInt8 Digital_Clock_Mode:1;
+                UInt8 UNUSED_I1_D0:1;
+                UInt8 XtalOsc_AnaReg_En:1;
+                UInt8 UNUSED_I0_D0:2;
+				UInt8 XTout:2;
+#else
+                UInt8 XTout:2;
+                UInt8 UNUSED_I0_D0:2;
+                UInt8 XtalOsc_AnaReg_En:1;
+                UInt8 UNUSED_I1_D0:1;
+                UInt8 Digital_Clock_Mode:1;
+                UInt8 I2C_Clock_Mode:1;
+#endif
+            }bF;
+        }uBx14;
+
+        union
+        {
+            UInt8 IF_Frequency_byte;
+            struct
+            {
+                UInt8 IF_Freq:8;
+            }bF;
+        }uBx15;
+
+        union
+        {
+            UInt8 RF_Frequency_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:4;
+				UInt8 RF_Freq_1:4;
+#else
+                UInt8 RF_Freq_1:4;
+                UInt8 UNUSED_I0_D0:4;
+#endif
+            }bF;
+        }uBx16;
+
+        union
+        {
+            UInt8 RF_Frequency_byte_2;
+            struct
+            {
+                UInt8 RF_Freq_2:8;
+            }bF;
+        }uBx17;
+
+
+        union
+        {
+            UInt8 RF_Frequency_byte_3;
+            struct
+            {
+                UInt8 RF_Freq_3:8;
+            }bF;
+        }uBx18;
+
+        union
+        {
+            UInt8 MSM_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RSSI_Meas:1;
+                UInt8 RF_CAL_AV:1;
+                UInt8 RF_CAL:1;
+                UInt8 IR_CAL_Loop:1;
+                UInt8 IR_Cal_Image:1;
+                UInt8 IR_CAL_Wanted:1;
+                UInt8 RC_Cal:1;
+				UInt8 Calc_PLL:1;
+#else
+                UInt8 Calc_PLL:1;
+                UInt8 RC_Cal:1;
+                UInt8 IR_CAL_Wanted:1;
+                UInt8 IR_Cal_Image:1;
+                UInt8 IR_CAL_Loop:1;
+                UInt8 RF_CAL:1;
+                UInt8 RF_CAL_AV:1;
+                UInt8 RSSI_Meas:1;
+#endif
+            }bF;
+        }uBx19;
+
+        union
+        {
+            UInt8 MSM_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:6;
+                UInt8 XtalCal_Launch:1;
+				UInt8 MSM_Launch:1;
+#else
+                UInt8 MSM_Launch:1;
+                UInt8 XtalCal_Launch:1;
+                UInt8 UNUSED_I0_D0:6;
+#endif
+            }bF;
+        }uBx1A;
+
+        union
+        {
+            UInt8 PowerSavingMode;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 PSM_AGC1:2;
+                UInt8 PSM_StoB:1;
+                UInt8 PSMRFpoly:1;
+                UInt8 PSM_Mixer:1;
+                UInt8 PSM_Ifpoly:1;
+				UInt8 PSM_Lodriver:2;
+#else
+                UInt8 PSM_Lodriver:2;
+                UInt8 PSM_Ifpoly:1;
+                UInt8 PSM_Mixer:1;
+                UInt8 PSMRFpoly:1;
+                UInt8 PSM_StoB:1;
+                UInt8 PSM_AGC1:2;
+#endif
+            }bF;
+        }uBx1B;
+
+        union
+        {
+            UInt8 DCC_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 DCC_Bypass:1;
+                UInt8 DCC_Slow:1;
+                UInt8 DCC_psm:1;
+                UInt8 UNUSED_I0_D0:5;
+#else
+                UInt8 UNUSED_I0_D0:5;
+                UInt8 DCC_psm:1;
+                UInt8 DCC_Slow:1;
+                UInt8 DCC_Bypass:1;
+#endif
+            }bF;
+        }uBx1C;
+
+        union
+        {
+            UInt8 FLO_max_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:2;
+                UInt8 Fmax_Lo:6;
+#else
+                UInt8 Fmax_Lo:6;
+                UInt8 UNUSED_I0_D0:2;
+#endif
+            }bF;
+        }uBx1D;
+
+        union
+        {
+            UInt8 IR_Cal_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IR_Loop:2;  
+                UInt8 IR_Target:3;
+                UInt8 IR_GStep:3;
+#else
+                UInt8 IR_GStep:3;
+                UInt8 IR_Target:3;
+                UInt8 IR_Loop:2;  
+#endif
+            }bF;
+        }uBx1E;
+
+        union
+        {
+            UInt8 IR_Cal_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IR_Corr_Boost:1;
+                UInt8 IR_FreqLow_Sel:1;
+                UInt8 IR_mode_ram_store:1;
+                UInt8 IR_FreqLow:5;
+#else
+                UInt8 IR_FreqLow:5;
+                UInt8 IR_mode_ram_store:1;
+                UInt8 IR_FreqLow_Sel:1;
+                UInt8 IR_Corr_Boost:1;
+#endif
+            }bF;
+        }uBx1F;
+
+        union
+        {
+            UInt8 IR_Cal_byte_3;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:3;
+                UInt8 IR_FreqMid:5;
+#else
+                UInt8 IR_FreqMid:5;
+                UInt8 UNUSED_I0_D0:3;
+#endif
+            }bF;
+        }uBx20;
+
+        union
+        {
+            UInt8 IR_Cal_byte_4;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:2;
+                UInt8 Coarse_IR_FreqHigh:1;
+                UInt8 IR_FreqHigh:5;
+#else
+                UInt8 IR_FreqHigh:5;
+                UInt8 Coarse_IR_FreqHigh:1;
+                UInt8 UNUSED_I0_D0:2;
+#endif
+            }bF;
+        }uBx21;
+
+        union
+        {
+            UInt8 Vsync_Mgt_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 PD_Vsync_Mgt:1;
+                UInt8 PD_Ovld:1;
+                UInt8 PD_Udld:1;
+                UInt8 AGC_Ovld_TOP:3;
+                UInt8 AGC_Ovld_Timer:2;
+#else
+                UInt8 AGC_Ovld_Timer:2;
+                UInt8 AGC_Ovld_TOP:3;
+                UInt8 PD_Udld:1;
+                UInt8 PD_Ovld:1;
+                UInt8 PD_Vsync_Mgt:1;
+#endif
+            }bF;
+        }uBx22;
+
+        union
+        {
+            UInt8 IR_Mixer_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 IR_Mixer_loop_off:1;
+                UInt8 IR_Mixer_Do_step:2;
+                UInt8 UNUSED_I0_D0:3;
+                UInt8 Hi_Pass:1;
+                UInt8 IF_Notch:1;
+#else
+                UInt8 IF_Notch:1;
+                UInt8 Hi_Pass:1;
+                UInt8 UNUSED_I0_D0:3;
+                UInt8 IR_Mixer_Do_step:2;
+                UInt8 IR_Mixer_loop_off:1;
+#endif
+            }bF;
+        }uBx23;
+
+        union
+        {
+            UInt8 AGC1_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 AGC1_loop_off:1;
+                UInt8 AGC1_Do_step:2;
+                UInt8 Force_AGC1_gain:1;
+                UInt8 AGC1_Gain:4;
+#else
+                UInt8 AGC1_Gain:4;
+                UInt8 Force_AGC1_gain:1;
+                UInt8 AGC1_Do_step:2;
+                UInt8 AGC1_loop_off:1;
+#endif
+            }bF;
+        }uBx24;
+
+        union
+        {
+            UInt8 AGC5_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 AGC5_loop_off:1;
+                UInt8 AGC5_Do_step:2;
+                UInt8 UNUSED_I1_D0:1;
+                UInt8 Force_AGC5_gain:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 AGC5_Gain:2;
+#else
+                UInt8 AGC5_Gain:2;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 Force_AGC5_gain:1;
+                UInt8 UNUSED_I1_D0:1;
+                UInt8 AGC5_Do_step:2;
+                UInt8 AGC5_loop_off:1;
+#endif
+            }bF;
+        }uBx25;
+
+        union
+        {
+            UInt8 RF_Cal_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog0:2;
+                UInt8 RFCAL_Freq0:2;
+                UInt8 RFCAL_Offset_Cprog1:2;
+                UInt8 RFCAL_Freq1:2;
+#else
+                UInt8 RFCAL_Freq1:2;
+                UInt8 RFCAL_Offset_Cprog1:2;
+                UInt8 RFCAL_Freq0:2;
+                UInt8 RFCAL_Offset_Cprog0:2;
+#endif
+            }bF;
+        }uBx26;
+
+        union
+        {
+            UInt8 RF_Cal_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog2:2;
+                UInt8 RFCAL_Freq2:2;
+                UInt8 RFCAL_Offset_Cprog3:2;
+                UInt8 RFCAL_Freq3:2;
+#else
+                UInt8 RFCAL_Freq3:2;
+                UInt8 RFCAL_Offset_Cprog3:2;
+                UInt8 RFCAL_Freq2:2;
+                UInt8 RFCAL_Offset_Cprog2:2;
+#endif
+            }bF;
+        }uBx27;
+
+        union
+        {
+            UInt8 RF_Cal_byte_3;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog4:2;
+                UInt8 RFCAL_Freq4:2;
+                UInt8 RFCAL_Offset_Cprog5:2;
+                UInt8 RFCAL_Freq5:2;
+#else
+                UInt8 RFCAL_Freq5:2;
+                UInt8 RFCAL_Offset_Cprog5:2;
+                UInt8 RFCAL_Freq4:2;
+                UInt8 RFCAL_Offset_Cprog4:2;
+#endif
+            }bF;
+        }uBx28;
+
+        union
+        {
+            UInt8 RF_Cal_byte_4;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog6:2;
+                UInt8 RFCAL_Freq6:2;
+                UInt8 RFCAL_Offset_Cprog7:2;
+                UInt8 RFCAL_Freq7:2;
+#else
+                UInt8 RFCAL_Freq7:2;
+                UInt8 RFCAL_Offset_Cprog7:2;
+                UInt8 RFCAL_Freq6:2;
+                UInt8 RFCAL_Offset_Cprog6:2;
+#endif
+            }bF;
+        }uBx29;
+
+        union
+        {
+            UInt8 RF_Cal_byte_5;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog8:2;
+                UInt8 RFCAL_Freq8:2;
+                UInt8 RFCAL_Offset_Cprog9:2;
+                UInt8 RFCAL_Freq9:2;
+#else
+                UInt8 RFCAL_Freq9:2;
+                UInt8 RFCAL_Offset_Cprog9:2;
+                UInt8 RFCAL_Freq8:2;
+                UInt8 RFCAL_Offset_Cprog8:2;
+#endif
+            }bF;
+        }uBx2A;
+
+        union
+        {
+            UInt8 RF_Cal_byte_6;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Offset_Cprog10:2;
+                UInt8 RFCAL_Freq10:2;
+                UInt8 RFCAL_Offset_Cprog11:2;
+                UInt8 RFCAL_Freq11:2;
+#else
+                UInt8 RFCAL_Freq11:2;
+                UInt8 RFCAL_Offset_Cprog11:2;
+                UInt8 RFCAL_Freq10:2;
+                UInt8 RFCAL_Offset_Cprog10:2;
+#endif
+            }bF;
+        }uBx2B;
+
+        union
+        {
+            UInt8 RF_Filters_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RF_Filter_Bypass:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 AGC2_loop_off:1;
+                UInt8 Force_AGC2_gain:1;
+                UInt8 RF_Filter_Gv:2;
+                UInt8 RF_Filter_Band:2;
+#else
+                
+                UInt8 RF_Filter_Band:2;
+                UInt8 RF_Filter_Gv:2;
+                UInt8 Force_AGC2_gain:1;
+                UInt8 AGC2_loop_off:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 RF_Filter_Bypass:1;
+#endif
+            }bF;
+        }uBx2C;
+
+        union
+        {
+            UInt8 RF_Filters_byte_2;
+            struct
+            {
+                UInt8 RF_Filter_Cap:8;
+            }bF;
+        }uBx2D;
+
+        union
+        {
+            UInt8 RF_Filters_byte_3;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 AGC2_Do_step:2;
+                UInt8 Gain_Taper:6;
+#else
+                UInt8 Gain_Taper:6;
+                UInt8 AGC2_Do_step:2;
+#endif
+            }bF;
+        }uBx2E;
+
+        union
+        {
+            UInt8 RF_Band_Pass_Filter_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RF_BPF_Bypass:1;
+                UInt8 UNUSED_I0_D0:4;
+                UInt8 RF_BPF:3;
+#else
+                UInt8 RF_BPF:3;
+                UInt8 UNUSED_I0_D0:4;
+                UInt8 RF_BPF_Bypass:1;
+#endif
+            }bF;
+        }uBx2F;
+
+        union
+        {
+            UInt8 CP_Current_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 N_CP_Current:7;
+#else
+                UInt8 N_CP_Current:7;
+                UInt8 UNUSED_I0_D0:1;
+#endif
+            }bF;
+        }uBx30;
+
+        union
+        {
+            UInt8 AGCs_DetOut_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 Up_AGC5:1;
+                UInt8 Do_AGC5:1;
+                UInt8 Up_AGC4:1;
+                UInt8 Do_AGC4:1;
+                UInt8 Up_AGC2:1;
+                UInt8 Do_AGC2:1;
+                UInt8 Up_AGC1:1;
+                UInt8 Do_AGC1:1;
+#else
+                UInt8 Do_AGC1:1;
+                UInt8 Up_AGC1:1;
+                UInt8 Do_AGC2:1;
+                UInt8 Up_AGC2:1;
+                UInt8 Do_AGC4:1;
+                UInt8 Up_AGC4:1;
+                UInt8 Do_AGC5:1;
+                UInt8 Up_AGC5:1;
+#endif
+            }bF;
+        }uBx31;
+
+        union
+        {
+            UInt8 RFAGCs_Gain_byte_1;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:2;
+                UInt8 AGC2_Gain_Read:2;
+                UInt8 AGC1_Gain_Read:4;
+#else
+                UInt8 AGC1_Gain_Read:4;
+                UInt8 AGC2_Gain_Read:2;
+                UInt8 UNUSED_I0_D0:2;
+#endif
+            }bF;
+        }uBx32;
+
+        union
+        {
+            UInt8 RFAGCs_Gain_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:5;
+                UInt8 TOP_AGC3_Read:3;
+#else
+                UInt8 TOP_AGC3_Read:3;
+                UInt8 UNUSED_I0_D0:5;
+#endif
+            }bF;
+        }uBx33;
+
+        union
+        {
+            UInt8 IFAGCs_Gain_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I0_D0:3;
+                UInt8 AGC5_Gain_Read:2;
+                UInt8 AGC4_Gain_Read:3;
+#else
+                UInt8 AGC4_Gain_Read:3;
+                UInt8 AGC5_Gain_Read:2;
+                UInt8 UNUSED_I0_D0:3;
+#endif
+            }bF;
+        }uBx34;
+
+        union
+        {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+#else
+#endif
+            UInt8 RSSI_byte_1;
+            UInt8 RSSI;
+        }uBx35;
+
+        union
+        {
+            UInt8 RSSI_byte_2;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 UNUSED_I1_D0:2;
+                UInt8 RSSI_AV:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 RSSI_Cap_Reset_En:1;
+                UInt8 RSSI_Cap_Val:1;
+                UInt8 RSSI_Ck_Speed:1;
+                UInt8 RSSI_Dicho_not:1;
+#else
+                UInt8 RSSI_Dicho_not:1;
+                UInt8 RSSI_Ck_Speed:1;
+                UInt8 RSSI_Cap_Val:1;
+                UInt8 RSSI_Cap_Reset_En:1;
+                UInt8 UNUSED_I0_D0:1;
+                UInt8 RSSI_AV:1;
+                UInt8 UNUSED_I1_D0:2;
+#endif
+            }bF;
+        }uBx36;
+
+        union
+        {
+            UInt8 Misc_byte;
+            struct
+            {
+#ifdef _TARGET_PLATFORM_MSB_FIRST
+                UInt8 RFCAL_Phi2:2;
+                UInt8 DDS_Polarity:1;
+                UInt8 RFCAL_DeltaGain:4;
+                UInt8 IRQ_Polarity:1;
+#else
+                UInt8 IRQ_Polarity:1;
+                UInt8 RFCAL_DeltaGain:4;
+                UInt8 DDS_Polarity:1;
+                UInt8 RFCAL_Phi2:2;
+#endif
+            }bF;
+        }uBx37;
+
+        union
+        {
+            UInt8 rfcal_log_0;
+            struct       
+            {
+                UInt8 rfcal_log_0:8;
+            }bF;
+        }uBx38;
+
+        union
+        {
+            UInt8 rfcal_log_1;
+            struct       
+            {
+                UInt8 rfcal_log_1:8;
+            }bF;
+        }uBx39;
+
+        union
+        {
+            UInt8 rfcal_log_2;
+            struct       
+            {
+                UInt8 rfcal_log_2:8;
+            }bF;
+        }uBx3A;
+
+        union
+        {
+            UInt8 rfcal_log_3;
+            struct       
+            {
+                UInt8 rfcal_log_3:8;
+            }bF;
+        }uBx3B;
+
+        union
+        {
+            UInt8 rfcal_log_4;
+            struct       
+            {
+                UInt8 rfcal_log_4:8;
+            }bF;
+        }uBx3C;
+
+        union
+        {
+            UInt8 rfcal_log_5;
+            struct       
+            {
+                UInt8 rfcal_log_5:8;
+            }bF;
+        }uBx3D;
+
+        union
+        {
+            UInt8 rfcal_log_6;
+            struct       
+            {
+                UInt8 rfcal_log_6:8;
+            }bF;
+        }uBx3E;
+
+        union
+        {
+            UInt8 rfcal_log_7;
+            struct       
+            {
+                UInt8 rfcal_log_7:8;
+            }bF;
+        }uBx3F;
+
+        union
+        {
+            UInt8 rfcal_log_8;
+            struct       
+            {
+                UInt8 rfcal_log_8:8;
+            }bF;
+        }uBx40;
+
+        union
+        {
+            UInt8 rfcal_log_9;
+            struct       
+            {
+                UInt8 rfcal_log_9:8;
+            }bF;
+        }uBx41;
+
+        union
+        {
+            UInt8 rfcal_log_10;
+            struct       
+            {
+                UInt8 rfcal_log_10:8;
+            }bF;
+        }uBx42;
+
+        union
+        {
+            UInt8 rfcal_log_11;
+            struct       
+            {
+                UInt8 rfcal_log_11:8;
+            }bF;
+        }uBx43;
+
+    } TDA182I2_I2C_Map_t, *pTDA182I2_I2C_Map_t;
+
+    typedef struct _tmTDA182I2_RFCalProg_t {
+        UInt8   Cal_number;
+        Int8    DeltaCprog;
+        Int8    CprogOffset;
+    } tmTDA182I2_RFCalProg_t, *ptmTDA182I2_RFCalProg_t;
+
+    typedef struct _tmTDA182I2_RFCalCoeffs_t {
+        UInt8   Sub_band;
+        UInt8   Cal_number;
+        Int32   RF_A1;
+        Int32   RF_B1;
+    } tmTDA182I2_RFCalCoeffs_t, *ptmTDA182I2_RFCalCoeffs_t;
+
+#define TDA182I2_RFCAL_PROG_ROW (12)
+#define TDA182I2_RFCAL_COEFFS_ROW (8)
+
+    typedef struct _tmddTDA182I2Object_t {
+        tmUnitSelect_t              tUnit;
+        tmUnitSelect_t              tUnitW;
+        ptmbslFrontEndMutexHandle   pMutex;
+        Bool                        init;
+        tmbslFrontEndIoFunc_t       sRWFunc;
+        tmbslFrontEndTimeFunc_t     sTime;
+        tmbslFrontEndDebugFunc_t    sDebug;
+        tmbslFrontEndMutexFunc_t    sMutex;
+        tmddTDA182I2PowerState_t    curPowerState;
+        Bool                        bIRQWait;
+        TDA182I2_I2C_Map_t          I2CMap;
+    } tmddTDA182I2Object_t, *ptmddTDA182I2Object_t, **pptmddTDA182I2Object_t;
+
+
+    extern tmErrorCode_t ddTDA182I2GetIRQ_status(ptmddTDA182I2Object_t pObj, UInt8* puValue);
+    extern tmErrorCode_t ddTDA182I2GetMSM_XtalCal_End(ptmddTDA182I2Object_t pObj, UInt8* puValue);
+
+    extern tmErrorCode_t ddTDA182I2WaitIRQ(ptmddTDA182I2Object_t pObj, UInt32 timeOut, UInt32 waitStep, UInt8 irqStatus);
+    extern tmErrorCode_t ddTDA182I2WaitXtalCal_End(ptmddTDA182I2Object_t pObj, UInt32 timeOut, UInt32 waitStep);
+
+    extern tmErrorCode_t ddTDA182I2Write(ptmddTDA182I2Object_t pObj, UInt8 uSubAddress, UInt8 uNbData);
+    extern tmErrorCode_t ddTDA182I2Read(ptmddTDA182I2Object_t pObj, UInt8 uSubAddress, UInt8 uNbData);
+    extern tmErrorCode_t ddTDA182I2Wait(ptmddTDA182I2Object_t pObj, UInt32 Time);
+
+    extern tmErrorCode_t ddTDA182I2MutexAcquire(ptmddTDA182I2Object_t   pObj, UInt32 timeOut);
+    extern tmErrorCode_t ddTDA182I2MutexRelease(ptmddTDA182I2Object_t   pObj);
+	extern tmErrorCode_t tmddTDA182I2AGC1_Adapt(tmUnitSelect_t tUnit);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _TMDD_TDA182I2LOCAL_H //---------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// NXP source code - .\tmddTDA182I2\inc\tmddTDA182I2Instance.h
+
+
+/*-----------------------------------------------------------------------------
+// $Header: 
+// (C) Copyright 2001 NXP Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of NXP Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of NXP
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than NXP Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmddTDA182I2Instance.h
+//
+// DESCRIPTION:  define the static Objects
+//
+// DOCUMENT REF: DVP Software Coding Guidelines v1.14
+//               DVP Board Support Library Architecture Specification v0.5
+//
+// NOTES:        
+//-----------------------------------------------------------------------------
+*/
+#ifndef _TMDDTDA182I2_INSTANCE_H //-----------------
+#define _TMDDTDA182I2_INSTANCE_H
+
+tmErrorCode_t ddTDA182I2AllocInstance (tmUnitSelect_t tUnit, pptmddTDA182I2Object_t ppDrvObject);
+tmErrorCode_t ddTDA182I2DeAllocInstance (tmUnitSelect_t tUnit);
+tmErrorCode_t ddTDA182I2GetInstance (tmUnitSelect_t tUnit, pptmddTDA182I2Object_t ppDrvObject);
+
+
+#endif // _TMDDTDA182I2_INSTANCE_H //---------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is TDA18272 tuner API source code
+
+
+
+
+
+// Definitions
+
+// Unit number
+enum TDA18272_UNIT_NUM
+{
+	TDA18272_UNIT_0,	// For master tuner or single tuner only.
+	TDA18272_UNIT_1,	// For slave tuner only.
+};
+
+
+// IF output Vp-p mode
+enum TDA18272_IF_OUTPUT_VPP_MODE
+{
+	TDA18272_IF_OUTPUT_VPP_2V    = tmTDA182I2_IF_AGC_Gain_2Vpp_0_30dB,
+	TDA18272_IF_OUTPUT_VPP_1P25V = tmTDA182I2_IF_AGC_Gain_1_25Vpp_min_4_26dB,
+	TDA18272_IF_OUTPUT_VPP_1V    = tmTDA182I2_IF_AGC_Gain_1Vpp_min_6_24dB,
+	TDA18272_IF_OUTPUT_VPP_0P8V  = tmTDA182I2_IF_AGC_Gain_0_8Vpp_min_8_22dB,
+	TDA18272_IF_OUTPUT_VPP_0P85V = tmTDA182I2_IF_AGC_Gain_0_85Vpp_min_7_5_22_5dB,
+	TDA18272_IF_OUTPUT_VPP_0P7V  = tmTDA182I2_IF_AGC_Gain_0_7Vpp_min_9_21dB,
+	TDA18272_IF_OUTPUT_VPP_0P6V  = tmTDA182I2_IF_AGC_Gain_0_6Vpp_min_10_3_19_7dB,
+	TDA18272_IF_OUTPUT_VPP_0P5V  = tmTDA182I2_IF_AGC_Gain_0_5Vpp_min_12_18dB,
+	TDA18272_IF_OUTPUT_VPP_MAX   = tmTDA182I2_IF_AGC_Gain_Max,
+};
+
+
+// Standard bandwidth mode
+enum TDA18272_STANDARD_BANDWIDTH_MODE
+{
+	TDA18272_STANDARD_BANDWIDTH_DVBT_6MHZ  = tmTDA182I2_DVBT_6MHz,
+	TDA18272_STANDARD_BANDWIDTH_DVBT_7MHZ  = tmTDA182I2_DVBT_7MHz,
+	TDA18272_STANDARD_BANDWIDTH_DVBT_8MHZ  = tmTDA182I2_DVBT_8MHz,
+	TDA18272_STANDARD_BANDWIDTH_QAM_6MHZ   = tmTDA182I2_QAM_6MHz,
+	TDA18272_STANDARD_BANDWIDTH_QAM_8MHZ   = tmTDA182I2_QAM_8MHz,
+	TDA18272_STANDARD_BANDWIDTH_ISDBT_6MHZ = tmTDA182I2_ISDBT_6MHz,
+	TDA18272_STANDARD_BANDWIDTH_ATSC_6MHZ  = tmTDA182I2_ATSC_6MHz,
+	TDA18272_STANDARD_BANDWIDTH_DMBT_8MHZ  = tmTDA182I2_DMBT_8MHz,
+};
+
+
+// Power mode
+enum TDA18272_POWER_MODE
+{
+	TDA18272_POWER_NORMAL                             = tmTDA182I2_PowerNormalMode,
+	TDA18272_POWER_STANDBY_WITH_XTALOUT_LNA_SYNTHE_ON = tmTDA182I2_PowerStandbyWithLNAOnAndWithXtalOnAndSynthe,
+	TDA18272_POWER_STANDBY_WITH_XTALOUT_LNA_ON        = tmTDA182I2_PowerStandbyWithLNAOnAndWithXtalOn,
+	TDA18272_POWER_STANDBY_WITH_XTALOUT_ON            = tmTDA182I2_PowerStandbyWithXtalOn,
+	TDA18272_POWER_STANDBY                            = tmTDA182I2_PowerStandby,
+};
+
+
+
+
+
+// Builder
+void
+BuildTda18272Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr,
+	unsigned long CrystalFreqHz,
+	int UnitNo,
+	int IfOutputVppMode
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+tda18272_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+tda18272_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+tda18272_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+tda18272_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+tda18272_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+tda18272_SetStandardBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int StandardBandwidthMode
+	);
+
+int
+tda18272_GetStandardBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pStandardBandwidthMode
+	);
+
+int
+tda18272_SetPowerMode(
+	TUNER_MODULE *pTuner,
+	int PowerMode
+	);
+
+int
+tda18272_GetPowerMode(
+	TUNER_MODULE *pTuner,
+	int *pPowerMode
+	);
+
+int
+tda18272_GetIfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pIfFreqHz
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is implemented for TDA18272 source code.
+
+
+// Functions
+tmErrorCode_t
+tda18272_Read(
+	tmUnitSelect_t tUnit,
+	UInt32 AddrSize,
+	UInt8* pAddr,
+	UInt32 ReadLen,
+	UInt8* pData
+	);
+
+tmErrorCode_t
+tda18272_Write(
+	tmUnitSelect_t tUnit,
+	UInt32 AddrSize,
+	UInt8* pAddr,
+	UInt32 WriteLen,
+	UInt8* pData
+	);
+
+tmErrorCode_t
+tda18272_Wait(
+	tmUnitSelect_t tUnit,
+	UInt32 tms
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/usb/rtl2832u/tuner_tua9001.c b/drivers/media/usb/rtl2832u/tuner_tua9001.c
new file mode 100644
index 00000000..404ea959
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_tua9001.c
@@ -0,0 +1,1245 @@
+/**
+
+@file
+
+@brief   TUA9001 tuner module definition
+
+One can manipulate TUA9001 tuner through TUA9001 module.
+TUA9001 module is derived from tuner module.
+
+*/
+
+
+#include "tuner_tua9001.h"
+
+
+
+
+
+/**
+
+@brief   TUA9001 tuner module builder
+
+Use BuildTua9001Module() to build TUA9001 module, set all module function pointers with the corresponding functions,
+and initialize module private variables.
+
+
+@param [in]   ppTuner                      Pointer to TUA9001 tuner module pointer
+@param [in]   pTunerModuleMemory           Pointer to an allocated tuner module memory
+@param [in]   pBaseInterfaceModuleMemory   Pointer to an allocated base interface module memory
+@param [in]   pI2cBridgeModuleMemory       Pointer to an allocated I2C bridge module memory
+@param [in]   DeviceAddr                   TUA9001 I2C device address
+
+
+@note
+	-# One should call BuildTua9001Module() to build TUA9001 module before using it.
+
+*/
+void
+BuildTua9001Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr
+	)
+{
+	TUNER_MODULE *pTuner;
+	TUA9001_EXTRA_MODULE *pExtra;
+
+
+
+	// Set tuner module pointer.
+	*ppTuner = pTunerModuleMemory;
+
+	// Get tuner module.
+	pTuner = *ppTuner;
+
+	// Set base interface module pointer and I2C bridge module pointer.
+	pTuner->pBaseInterface = pBaseInterfaceModuleMemory;
+	pTuner->pI2cBridge = pI2cBridgeModuleMemory;
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+
+
+	// Set tuner type.
+	pTuner->TunerType = TUNER_TYPE_TUA9001;
+
+	// Set tuner I2C device address.
+	pTuner->DeviceAddr = DeviceAddr;
+
+
+	// Initialize tuner parameter setting status.
+	pTuner->IsRfFreqHzSet = NO;
+
+	// Initialize tuner module variables.
+	// Note: Need to give both RF frequency and bandwidth for TUA9001 tuning function,
+	//       so we have to give a default RF frequncy.
+	pTuner->RfFreqHz = TUA9001_RF_FREQ_HZ_DEFAULT;
+
+
+	// Set tuner module manipulating function pointers.
+	pTuner->GetTunerType  = tua9001_GetTunerType;
+	pTuner->GetDeviceAddr = tua9001_GetDeviceAddr;
+
+	pTuner->Initialize    = tua9001_Initialize;
+	pTuner->SetRfFreqHz   = tua9001_SetRfFreqHz;
+	pTuner->GetRfFreqHz   = tua9001_GetRfFreqHz;
+
+
+	// Initialize tuner extra module variables.
+	// Note: Need to give both RF frequency and bandwidth for TUA9001 tuning function,
+	//       so we have to give a default bandwidth.
+	pExtra->BandwidthMode = TUA9001_BANDWIDTH_MODE_DEFAULT;
+	pExtra->IsBandwidthModeSet = NO;
+
+	// Set tuner extra module function pointers.
+	pExtra->SetBandwidthMode       = tua9001_SetBandwidthMode;
+	pExtra->GetBandwidthMode       = tua9001_GetBandwidthMode;
+	pExtra->GetRegBytesWithRegAddr = tua9001_GetRegBytesWithRegAddr;
+	pExtra->SetSysRegByte          = tua9001_SetSysRegByte;
+	pExtra->GetSysRegByte          = tua9001_GetSysRegByte;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_TUNER_TYPE
+
+*/
+void
+tua9001_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	)
+{
+	// Get tuner type from tuner module.
+	*pTunerType = pTuner->TunerType;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_DEVICE_ADDR
+
+*/
+void
+tua9001_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	)
+{
+	// Get tuner I2C device address from tuner module.
+	*pDeviceAddr = pTuner->DeviceAddr;
+
+
+	return;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_INITIALIZE
+
+*/
+int
+tua9001_Initialize(
+	TUNER_MODULE *pTuner
+	)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+	// Initialize TUA9001 tuner.
+	if(initializeTua9001(pTuner) != TUA9001_TUNER_OK)
+		goto error_status_initialize_tuner;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_initialize_tuner:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_SET_RF_FREQ_HZ
+
+*/
+int
+tua9001_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+
+	long RfFreqKhz;
+	int BandwidthMode;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+	// Get bandwidth mode.
+	BandwidthMode = pExtra->BandwidthMode;
+
+	// Calculate RF frequency in KHz.
+	// Note: RfFreqKhz = round(RfFreqHz / 1000)
+	RfFreqKhz = (long)((RfFreqHz + 500) / 1000);
+
+	// Set TUA9001 RF frequency and bandwidth.
+	if(tuneTua9001(pTuner, RfFreqKhz, BandwidthMode) != TUA9001_TUNER_OK)
+		goto error_status_set_tuner_rf_frequency;
+
+
+	// Set tuner RF frequency parameter.
+	pTuner->RfFreqHz      = (unsigned long)(RfFreqKhz * 1000);
+	pTuner->IsRfFreqHzSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@see   TUNER_FP_GET_RF_FREQ_HZ
+
+*/
+int
+tua9001_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	)
+{
+	// Get tuner RF frequency in Hz from tuner module.
+	if(pTuner->IsRfFreqHzSet != YES)
+		goto error_status_get_tuner_rf_frequency;
+
+	*pRfFreqHz = pTuner->RfFreqHz;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_rf_frequency:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set TUA9001 tuner bandwidth mode.
+
+*/
+int
+tua9001_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+
+	long RfFreqKhz;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+	// Get RF frequncy in KHz.
+	// Note: Doesn't need to take round() of RfFreqHz, because its value unit is 1000 Hz.
+	RfFreqKhz = (long)(pTuner->RfFreqHz / 1000);
+
+	// Set TUA9001 RF frequency and bandwidth.
+	if(tuneTua9001(pTuner, RfFreqKhz, BandwidthMode) != TUA9001_TUNER_OK)
+		goto error_status_set_tuner_bandwidth;
+
+
+	// Set tuner bandwidth parameter.
+	pExtra->BandwidthMode      = BandwidthMode;
+	pExtra->IsBandwidthModeSet = YES;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get TUA9001 tuner bandwidth mode.
+
+*/
+int
+tua9001_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+
+	// Get tuner bandwidth in Hz from tuner module.
+	if(pExtra->IsBandwidthModeSet != YES)
+		goto error_status_get_tuner_bandwidth;
+
+	*pBandwidthMode = pExtra->BandwidthMode;
+
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_bandwidth:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get register bytes with address.
+
+*/
+int
+tua9001_GetRegBytesWithRegAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char DeviceAddr,
+	unsigned char RegAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	)
+{
+	// Get tuner register byte.
+	//if(rtl2832usb_ReadWithRegAddr(DeviceAddr, RegAddr, pReadingBytes, ByteNum) != FUNCTION_SUCCESS)
+	//	goto error_status_get_tuner_registers_with_address;
+
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char TunerDeviceAddr;
+
+	struct dvb_usb_device	*d;	
+
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+	pBaseInterface = pTuner->pBaseInterface;	
+
+	// Get tuner device address.
+	pTuner->GetDeviceAddr(pTuner,&TunerDeviceAddr); 
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);	
+
+	if( read_rtl2832_tuner_register( d, TunerDeviceAddr, RegAddr, pReadingBytes, ByteNum ) )
+		goto error_status_get_tuner_registers_with_address;
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_tuner_registers_with_address:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Set system register byte.
+
+*/
+int
+tua9001_SetSysRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char WritingByte
+	)
+{
+	// Set demod system register byte.
+//	if(RTK_SYS_Byte_Write(RegAddr, LEN_1_BYTE, &WritingByte) != TRUE)
+//		goto error_status_set_system_registers;
+
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	struct dvb_usb_device	*d;	
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+	pBaseInterface = pTuner->pBaseInterface;	
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);	
+
+	if ( write_usb_sys_char_bytes( d, RTD2832U_SYS, RegAddr, &WritingByte, LEN_1_BYTE) ) 
+		goto error_status_set_system_registers;
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_set_system_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+/**
+
+@brief   Get system register byte.
+
+*/
+int
+tua9001_GetSysRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char *pReadingByte
+	)
+{
+	// Get demod system register byte.
+//	if(RTK_SYS_Byte_Read(RegAddr, LEN_1_BYTE, pReadingByte) != TRUE)
+//		goto error_status_get_system_registers;
+
+	I2C_BRIDGE_MODULE *pI2cBridge;
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	struct dvb_usb_device	*d;	
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;
+	pBaseInterface = pTuner->pBaseInterface;	
+
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);	
+
+	if ( read_usb_sys_char_bytes(d, RTD2832U_SYS, RegAddr, pReadingByte, LEN_1_BYTE) )
+		goto error_status_get_system_registers;
+
+	return FUNCTION_SUCCESS;
+
+
+error_status_get_system_registers:
+	return FUNCTION_ERROR;
+}
+
+
+
+
+
+// TUA9001 custom-implement functions
+
+
+int tua9001setRESETN (TUNER_MODULE *pTuner, unsigned int i_state)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+	unsigned char Byte;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+	// Get GPO value.
+
+	if(pExtra->GetSysRegByte(pTuner, GPO_ADDR, &Byte) != FUNCTION_SUCCESS)
+		goto error_status_get_system_registers;
+
+	// Note: Hardware PCB has inverter in this pin, should give inverted value on GPIO3.
+	if (i_state == TUA9001_H_LEVEL)
+	{
+		/* set tuner RESETN pin to "H"  */
+		// Note: The GPIO3 output value should be '0'.
+		Byte &= ~BIT_3_MASK;
+	}
+	else
+	{
+		/* set tuner RESETN pin to "L"  */
+		// Note: The GPIO3 output value should be '1'.
+		Byte |= BIT_3_MASK;
+	}
+
+	// Set GPO value.
+	if(pExtra->SetSysRegByte(pTuner, GPO_ADDR, Byte) != FUNCTION_SUCCESS)
+		goto error_status_set_system_registers;
+
+
+	return TUA9001_TUNER_OK;
+
+
+error_status_set_system_registers:
+error_status_get_system_registers:
+	return TUA9001_TUNER_ERR;
+}
+
+
+
+int tua9001setRXEN (TUNER_MODULE *pTuner, unsigned int i_state)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+	unsigned char Byte;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+	// Get GPO value.
+	if(pExtra->GetSysRegByte(pTuner, GPO_ADDR, &Byte) != FUNCTION_SUCCESS)
+		goto error_status_get_system_registers;
+
+	if (i_state == TUA9001_H_LEVEL)
+	{
+		/* set tuner RXEN pin to "H"  */
+		// Note: The GPIO1 output value should be '1'.
+		Byte |= BIT_1_MASK;
+	}
+	else
+	{
+		/* set tuner RXEN pin to "L"  */
+		// Note: The GPIO1 output value should be '0'.
+		Byte &= ~BIT_1_MASK;
+	}
+
+	// Set GPO value.
+	if(pExtra->SetSysRegByte(pTuner, GPO_ADDR, Byte) != FUNCTION_SUCCESS)
+		goto error_status_set_system_registers;
+
+
+	return TUA9001_TUNER_OK;
+
+
+error_status_set_system_registers:
+error_status_get_system_registers:
+	return TUA9001_TUNER_ERR;
+}
+
+
+
+int tua9001setCEN (TUNER_MODULE *pTuner, unsigned int i_state)
+{
+	// Do nothing.
+	// Note: Hardware PCB always gives 'H' to tuner CEN pin.
+	return TUA9001_TUNER_OK;
+}
+
+
+
+int tua9001waitloop (TUNER_MODULE *pTuner, unsigned int i_looptime)
+{
+	BASE_INTERFACE_MODULE *pBaseInterface;
+	unsigned long WaitTimeMs;
+
+
+	// Get base interface.
+	pBaseInterface = pTuner->pBaseInterface;
+
+	/* wait time = i_looptime * 1 uS */
+	// Note: 1. The unit of WaitMs() function is ms.
+	//       2. WaitTimeMs = ceil(i_looptime / 1000)
+	WaitTimeMs = i_looptime / 1000;
+
+	if((i_looptime % 1000) > 0)
+		WaitTimeMs += 1;
+
+	pBaseInterface->WaitMs(pBaseInterface, WaitTimeMs);
+
+
+	return TUA9001_TUNER_OK;
+}
+
+
+
+int tua9001i2cBusWrite (TUNER_MODULE *pTuner, unsigned char deviceAddress, unsigned char registerAddress, char *data,
+				 unsigned int length)
+{
+
+#if 0
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char ByteNum;
+	unsigned char WritingBytes[I2C_BUFFER_LEN];
+	unsigned int i;
+
+
+	// Get base interface.
+	pBaseInterface = pTuner->pBaseInterface;
+
+
+	/* I2C write data format */
+	/* STA  device_address  ACK  register_address  ACK   H_Byte-Data ACK   L_Byte-Data  !ACK  STO */
+
+	/* STA = start condition, ACK = Acknowledge, STO = stop condition                             */   
+	/* *data  = pointer to data source   */
+	/* length = number of bytes to write */
+
+	// Determine byte number.
+	ByteNum = length + LEN_1_BYTE;
+
+	// Determine writing bytes.
+	WritingBytes[0] = registerAddress;
+
+	for(i = 0; i < length; i++)
+		WritingBytes[LEN_1_BYTE + i] = data[i];
+
+
+	// Send I2C writing command.
+	if(pBaseInterface->I2cWrite(pBaseInterface, deviceAddress, WritingBytes, ByteNum) != FUNCTION_SUCCESS)
+		goto error_status_set_tuner_registers;
+
+
+	return TUA9001_TUNER_OK;
+
+
+error_status_set_tuner_registers:
+	return TUA9001_TUNER_ERR;
+#endif
+	BASE_INTERFACE_MODULE *pBaseInterface;
+
+	unsigned char ByteNum;
+	unsigned char WritingBytes[I2C_BUFFER_LEN];
+	unsigned int i=0;
+
+	I2C_BRIDGE_MODULE *pI2cBridge;
+
+	struct dvb_usb_device	*d;
+
+	// Get base interface.
+	pBaseInterface = pTuner->pBaseInterface;
+
+	// Get I2C bridge.
+	pI2cBridge = pTuner->pI2cBridge;	
+
+	// Get tuner device address.
+	pBaseInterface->GetUserDefinedDataPointer(pBaseInterface, (void **)&d);	
+
+	// Determine byte number.
+	ByteNum = length;
+
+	// Determine writing bytes.
+	//WritingBytes[0] = registerAddress;
+
+	for(i = 0; i < length; i++)
+		WritingBytes[i] = data[i];
+
+	// Send I2C writing command.
+	if( write_rtl2832_tuner_register( d, deviceAddress, registerAddress, WritingBytes, ByteNum ) )
+		goto error_status_set_tuner_registers;
+
+
+	return TUA9001_TUNER_OK;
+
+
+error_status_set_tuner_registers:
+	return TUA9001_TUNER_ERR;
+
+}
+
+
+
+int tua9001i2cBusRead (TUNER_MODULE *pTuner, unsigned char deviceAddress, unsigned char registerAddress, char *data,
+				unsigned int length)
+{
+	TUA9001_EXTRA_MODULE *pExtra;
+
+
+	// Get tuner extra module.
+	pExtra = &(pTuner->Extra.Tua9001);
+
+
+	/* I2C read data format */
+	/* STA  device_address  ACK  register_address  ACK  STA H_Byte-Data ACK  device_address_read  ACK  H_Byte-Data ACK L_Byte-Data  ACKH  STO */
+
+	/* STA = start condition, ACK = Acknowledge (generated by TUA9001), ACKH = Acknowledge (generated by Host), STO = stop condition                             */   
+	/* *data  = pointer to data destination   */
+	/* length = number of bytes to read       */
+
+	// Get tuner register bytes with address.
+	// Note: We must use re-start I2C reading format for TUA9001 tuner register reading.
+	if(pExtra->GetRegBytesWithRegAddr(pTuner, deviceAddress, registerAddress, data, length) != FUNCTION_SUCCESS)
+		goto error_status_get_tuner_registers;
+
+
+	return TUA9001_TUNER_OK;
+
+
+error_status_get_tuner_registers:
+	return TUA9001_TUNER_ERR;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is source code provided by Infineon.
+
+
+
+
+
+// Infineon source code - driver_tua9001.c
+
+
+/* ============================================================================
+** Copyright (C) 1997-2007 Infineon AG All rights reserved.
+** ============================================================================
+**
+** ============================================================================
+** Revision Information :
+**    File name: driver_tua9001.c
+**    Version:  V 1.01
+**    Date: 
+**
+** ============================================================================
+** History: 
+** 
+** Date         Author  Comment
+** ----------------------------------------------------------------------------
+**
+** 2007.11.06   Walter Pichler    created.
+** 2008.04.08   Walter Pichler    adaption to TUA 9001E
+**
+** ============================================================================
+*/
+
+/*============================================================================
+Includes
+============================================================================*/
+
+//#include "driver_tua9001.h"
+//#include "driver_tua9001_NeededFunctions.h"   /* Note: This function have to be provided by the user */
+
+/*============================================================================
+Local compiler keeys         ( usage depends on the application )
+============================================================================*/
+
+#define CRYSTAL_26_0_MHZ
+//#define CRYSTAL_19_2_MHZ
+//#define CRYSTAL_20_48_MHZ
+
+//#define AGC_BY_IIC
+//#define AGC_BY_AGC_BUS
+#define AGC_BY_EXT_PIN
+
+
+/*============================================================================
+Named Constants Definitions    ( usage depends on the application )
+============================================================================*/
+
+#define TUNERs_TUA9001_DEVADDR    0xC0
+
+/* Note: The correct device address depends hardware settings. See Datasheet
+      and User Manual for details. */
+
+/*============================================================================
+Local Named Constants Definitions
+============================================================================*/
+#define		OPERATIONAL_MODE     	0x03 
+#define		CHANNEL_BANDWITH    	0x04
+#define		SW_CONTR_TIME_SLICING	0x05
+#define		BASEBAND_GAIN_CONTROL	0x06
+#define		MANUAL_BASEBAND_GAIN	0x0b
+#define		REFERENCE_FREQUENCY 	0x1d
+#define		CHANNEL_WORD        	0x1f
+#define		CHANNEL_OFFSET	    	0x20
+#define		CHANNEL_FILTER_TRIMMING	0x2f
+#define		OUTPUT_BUFFER	    	0x32
+#define		RF_AGC_CONFIG_A	    	0x36
+#define		RF_AGC_CONFIG_B	    	0x37
+#define		UHF_LNA_SELECT	    	0x39
+#define		LEVEL_DETECTOR	    	0x3a
+#define		MIXER_CURRENT	    	0x3b
+#define		PORT_CONTROL		    0x3e
+#define		CRYSTAL_TRIMMING    	0x41
+#define		CHANNEL_FILTER_STATUS	0x60
+#define		SIG_STRENGHT_INDICATION	0x62
+#define		PLL_LOCK	        	0x69
+#define		RECEIVER_STATE	    	0x70
+#define		RF_INPUT	        	0x71
+#define		BASEBAND_GAIN	    	0x72
+#define		CHIP_IDENT_CODE	    	0x7e
+#define		CHIP_REVISION	    	0x7f
+
+#define TUNERs_TUA9001_BW_8         0xcf
+#define TUNERs_TUA9001_BW_7         0x10
+#define TUNERs_TUA9001_BW_6         0x20
+#define TUNERs_TUA9001_BW_5         0x30
+
+
+
+
+/*============================================================================
+ Types definition
+============================================================================*/
+
+
+
+
+/*============================================================================
+ Public Functions
+============================================================================*/
+
+
+/**
+ * tuner initialisation
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+ 
+int initializeTua9001 (TUNER_MODULE *pTuner)
+{
+//  unsigned int counter;
+  char i2cseq[2];
+//  tua9001tunerReceiverState_t tunerState;
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+  /* Note: CEN may also be hard wired in the application*/
+  if(tua9001setCEN    (pTuner, TUA9001_H_LEVEL) != TUA9001_TUNER_OK) goto error_status;    /* asserting Chip enable      */
+
+  if(tua9001setRESETN (pTuner, TUA9001_L_LEVEL) != TUA9001_TUNER_OK) goto error_status;    /* asserting RESET            */
+  
+  if(tua9001setRXEN   (pTuner, TUA9001_L_LEVEL) != TUA9001_TUNER_OK) goto error_status;    /* RXEN to low >> IDLE STATE  */
+  
+  /* Note: 20ms assumes that all external power supplies are settled. If not, add more time here */
+  tua9001waitloop (pTuner, 20);          /* wait for 20 uS     */
+  
+  if(tua9001setRESETN (pTuner, TUA9001_H_LEVEL) != TUA9001_TUNER_OK) goto error_status;    /* de-asserting RESET */
+
+  /* This is to wait for the Crystal Oscillator to settle .. wait until IDLE mode is reached */  
+//  counter = 6;
+//  do
+//    {
+//    counter --;
+//    tua9001waitloop (pTuner, 1000);      /* wait for 1 mS      */
+//    if(getReceiverStateTua9001 (pTuner, &tunerState) != TUA9001_TUNER_OK) goto error_status;
+//    }while ((tunerState != TUA9001_IDLE) && (counter));  
+
+//  if (tunerState != TUA9001_IDLE)
+//      return TUA9001_TUNER_ERR;   /* error >> break initialization   */
+
+  // Replace the above check loop with 6 ms delay.
+  // Because maybe there are undefined cases in getReceiverStateTua9001(), we have to avoid using the function.
+  tua9001waitloop (pTuner, 6000);         /* wait for 6 mS      */
+
+  /**** Overwrite default register value ****/ 
+  i2cseq[0] = 0x65;    /* Waiting time before PLL cal. start */
+  i2cseq[1] = 0x12;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x1e, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0xB8;    /* VCO Varactor bias fine tuning */
+  i2cseq[1] = 0x88;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x25, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x54;    /* LNA switching Threshold for UHF1/2 */
+  i2cseq[1] = 0x60;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x39, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x00;    
+  i2cseq[1] = 0xC0;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x3b, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0xF0;    /* LO- Path Set LDO output voltage */
+  i2cseq[1] = 0x00;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x3a, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  
+  i2cseq[0] = 0x00;    /* Set EXTAGC interval */
+  i2cseq[1] = 0x00;               
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x08, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  
+  i2cseq[0] = 0x00;    /* Set max. capacitive load */
+  i2cseq[1] = 0x30;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x32, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+
+  /**** Set Crystal Reference Frequency an Trim value ****/
+
+#if defined(CRYSTAL_26_0_MHZ)       //  Frequency 26 MHz 
+  i2cseq[0] = 0x01;
+  i2cseq[1] = 0xB0;    
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x1d, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x70;              // NDK 3225 series 26 MHz XTAL 
+  i2cseq[1] = 0x3a;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x41, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  i2cseq[0] = 0x1C;
+  i2cseq[1] = 0x78;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x40, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+#elif defined(CRYSTAL_19_2_MHZ)   //  Frequency 19.2 MHz 
+  i2cseq[0] = 0x01;
+  i2cseq[1] = 0xA0;    
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x1d, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  // Note: Insert optimised register values for 0x40 / 0x41 for used crystal 
+  // contact application support for further information 
+#elif defined(CRYSTAL_20_48_MHZ)  //   Frequency 20,48 MHz 
+  i2cseq[0] = 0x01;
+  i2cseq[1] = 0xA8;    
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x1d, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  // Note: Insert optimised register values for 0x40 / 0x41 for used crystal 
+  // contact application support for further information 
+#endif
+
+
+
+ /**** Set desired Analog Baseband AGC mode ****/ 
+#if defined (AGC_BY_IIC)
+  i2cseq[0] = 0x00;                /* Bypass AGC controller >>  IIC based AGC */
+  i2cseq[1] = 0x40;                     
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x06, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+#elif defined(AGC_BY_AGC_BUS)      
+  i2cseq[0] = 0x00;                /* Digital AGC bus */               
+  i2cseq[1] = 0x00;                /* 0,5 dB steps    */                    
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x06, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+#elif defined(AGC_BY_EXT_PIN)      
+  i2cseq[0] = 0x40;                /* Ext. AGC pin     */               
+  i2cseq[1] = 0x00;                                    
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x06, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+#endif 
+
+ 
+  /**** set desired RF AGC parameter *****/
+  i2cseq[0] = 0x1c;      /* Set Wideband Detector Current (100 uA) */
+  i2cseq[1] = 0x00;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x2c, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+ 
+  i2cseq[0] = 0xC0;      /* Set RF AGC Threshold (-32.5dBm) */
+  i2cseq[1] = 0x13;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x36, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x6f;      /* RF AGC Parameter */
+  i2cseq[1] = 0x18;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x37, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x00;      /* aditional VCO settings  */
+  i2cseq[1] = 0x08;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x27, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x00;      /* aditional PLL settings  */
+  i2cseq[1] = 0x01;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x2a, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  i2cseq[0] = 0x0a;      /* VCM correction         */
+  i2cseq[1] = 0x40;   
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x34, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+
+
+
+/**
+ * tuner tune
+ * @param i_freq   tuning frequency
+ * @param i_bandwidth  channel  bandwidth
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int tuneTua9001 (TUNER_MODULE *pTuner, long i_freq, tua9001tunerDriverBW_t i_bandwidth)
+{
+  char i2cseq[2];
+  unsigned int divider_factor;
+  unsigned int ch_offset;
+//  unsigned int counter;
+  unsigned int lo_path_settings;
+//  tua9001tunerReceiverState_t tunerState;
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+
+ 
+  /* de-assert RXEN >> IDLE STATE */
+  if(tua9001setRXEN   (pTuner, TUA9001_L_LEVEL) != TUA9001_TUNER_OK) goto error_status;          
+ 
+
+  /* calculate divider factor */
+  if (i_freq < 1000000)    /*  divider factor and channel offset for UHF/VHF III */
+   {
+   ch_offset = 0x1C20;     /* channel offset 150 MHz */
+   divider_factor   =  (unsigned int) (((i_freq - 150000) * 48) / 1000);
+   lo_path_settings = 0xb6de;
+  }
+
+  else                     /* calculate divider factor for L-Band Frequencies */
+   {
+   ch_offset = 0x5460;     /* channel offset 450 MHz */
+   divider_factor   =  (unsigned int) (((i_freq - 450000) * 48) / 1000);
+   lo_path_settings = 0xbede;
+   }
+
+
+  // Set LO Path
+  i2cseq[0] = lo_path_settings >> 8;
+  i2cseq[1] = lo_path_settings & 0xff;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x2b, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+
+  // Set channel offset
+  i2cseq [0] =  ch_offset >> 8;
+  i2cseq [1] =  ch_offset & 0xff;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x20, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+  
+  // Set Frequency
+  i2cseq [0] =  divider_factor >> 8;
+  i2cseq [1] =  divider_factor & 0xff;
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x1f, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+   
+  // Set bandwidth
+  if(tua9001i2cBusRead (pTuner, DeviceAddr,  0x04, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;         /* get current register value */
+  i2cseq [0] &= TUNERs_TUA9001_BW_8;
+ 
+  switch (i_bandwidth)
+    {
+    case TUA9001_TUNER_BANDWIDTH_8MHZ:
+         // Do nothing.
+         break; 
+    case TUA9001_TUNER_BANDWIDTH_7MHZ: i2cseq [0] |= TUNERs_TUA9001_BW_7;
+         break; 
+    case TUA9001_TUNER_BANDWIDTH_6MHZ: i2cseq [0] |= TUNERs_TUA9001_BW_6;
+         break; 
+    case TUA9001_TUNER_BANDWIDTH_5MHZ: i2cseq [0] |= TUNERs_TUA9001_BW_5;
+         break; 
+	default:
+         goto error_status;
+         break;
+    }
+
+  if(tua9001i2cBusWrite (pTuner, DeviceAddr, 0x04, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;
+ 
+  /* assert RXEN >> RX STATE */
+  if(tua9001setRXEN   (pTuner, TUA9001_H_LEVEL) != TUA9001_TUNER_OK) goto error_status;
+
+  /* This is to wait for the RX state to settle .. wait until RX mode is reached */  
+//  counter = 3;
+//  do
+//    {
+//    counter --;
+//    tua9001waitloop (pTuner, 1000);         /* wait for 1 mS      */
+//    if(getReceiverStateTua9001 (pTuner, &tunerState) != TUA9001_TUNER_OK) goto error_status;
+//    }while ((tunerState != TUA9001_RX) && (counter));  
+
+//  if (tunerState != TUA9001_RX)
+//    {
+//    if(tua9001setRXEN  (pTuner, TUA9001_L_LEVEL) != TUA9001_TUNER_OK) goto error_status;      /* d-assert RXEN >> IDLE STATE */
+//    return   TUA9001_TUNER_ERR;      /* error >> tuning fail        */
+//    }
+
+  // Replace the above check loop with 3 ms delay.
+  // Because maybe there are undefined cases in getReceiverStateTua9001(), we have to avoid using the function.
+  tua9001waitloop (pTuner, 3000);         /* wait for 3 mS      */
+
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+
+
+/**
+ * Get pll locked state
+ * @param o_pll  pll locked state
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int getPllLockedStateTua9001 (TUNER_MODULE *pTuner, tua9001tunerPllLocked_t *o_pll)
+{
+  char i2cseq[2];
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+  if(tua9001i2cBusRead (pTuner, DeviceAddr, 0x69, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;           /* get current register value */
+  
+  o_pll[0]  = (i2cseq[1] & 0x08) ? TUA9001_PLL_LOCKED : TUA9001_PLL_NOT_LOCKED;
+ 
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+
+
+/**
+ * Get tuner state
+ * @param o_tunerState tuner state
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+/*
+int getReceiverStateTua9001 (TUNER_MODULE *pTuner, tua9001tunerReceiverState_t *o_tunerState)
+{
+  char i2cseq[2];
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+  if(tua9001i2cBusRead (pTuner, DeviceAddr, 0x70, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;           // get current register value
+
+//  switch (i2cseq[1] & ~0x1f)
+  // Note: Maybe the MSB byte is i2cseq[0]
+  //       The original code looks like the MSB byte is i2cseq[1]
+  // Note: ~0x1f = 0xffffffe0, not 0xe0 --> i2cseq[0] & ~0x1f result is wrong.
+  switch (i2cseq[0] & 0xe0)
+     {
+     case 0x80: o_tunerState [0] = TUA9001_IDLE;  break;
+     case 0x40: o_tunerState [0] = TUA9001_RX;    break;
+     case 0x20: o_tunerState [0] = TUA9001_STANDBY;    break;
+	 default: goto error_status; break;
+     }
+ 
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+*/
+
+/**
+ * Get active input
+ * @param o_activeInput active input info
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+/* 
+int getActiveInputTua9001 (TUNER_MODULE *pTuner, tua9001tunerActiveInput_t *o_activeInput)
+{
+  char i2cseq[2];
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+  if(tua9001i2cBusRead (pTuner, DeviceAddr, 0x71, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;           // get current register value
+
+//  switch (i2cseq[1] & ~0x0f)
+  // Note: Maybe the MSB byte is i2cseq[0]
+  //       The original code looks like the MSB byte is i2cseq[1]
+  // Note: ~0x0f = 0xfffffff0, not 0xf0 --> i2cseq[0] & ~0x0f result is wrong.
+  switch (i2cseq[0] & 0xf0)
+     {
+     case 0x80: o_activeInput [0] = TUA9001_L_INPUT_ACTIVE;   break;
+     case 0x20: o_activeInput [0] = TUA9001_UHF_INPUT_ACTIVE; break;
+     case 0x10: o_activeInput [0] = TUA9001_VHF_INPUT_ACTIVE; break;
+	 default: goto error_status; break;
+     }
+ 
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+*/
+
+/**
+ * Get baseband gain value
+ * @param o_basebandGain  baseband gain value
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int getBasebandGainTua9001 (TUNER_MODULE *pTuner, char *o_basebandGain)
+{
+  char i2cseq[2];
+  unsigned char DeviceAddr;
+
+  // Get tuner deviece address.
+  pTuner->GetDeviceAddr(pTuner, &DeviceAddr);
+
+  if(tua9001i2cBusRead (pTuner, DeviceAddr, 0x72, i2cseq, 2) != TUA9001_TUNER_OK) goto error_status;           /* get current register value */
+//  o_basebandGain [0] = i2cseq [1];
+  // Note: Maybe the MSB byte is i2cseq[0]
+  //       The original code looks like the MSB byte is i2cseq[1]
+  o_basebandGain [0] = i2cseq [0];
+ 
+  return TUA9001_TUNER_OK;
+
+
+error_status:
+  return TUA9001_TUNER_ERR;
+}
+
+
+
diff --git a/drivers/media/usb/rtl2832u/tuner_tua9001.h b/drivers/media/usb/rtl2832u/tuner_tua9001.h
new file mode 100644
index 00000000..dbfbce6a
--- /dev/null
+++ b/drivers/media/usb/rtl2832u/tuner_tua9001.h
@@ -0,0 +1,493 @@
+#ifndef __TUNER_TUA9001_H
+#define __TUNER_TUA9001_H
+
+/**
+
+@file
+
+@brief   TUA9001 tuner module declaration
+
+One can manipulate TUA9001 tuner through TUA9001 module.
+TUA9001 module is derived from tunerd module.
+
+
+
+@par Example:
+@code
+
+// The example is the same as the tuner example in tuner_base.h except the listed lines.
+
+
+
+#include "tuner_tua9001.h"
+
+
+...
+
+
+
+int main(void)
+{
+	TUNER_MODULE         *pTuner;
+	TUA9001_EXTRA_MODULE *pTunerExtra;
+
+	TUNER_MODULE          TunerModuleMemory;
+	BASE_INTERFACE_MODULE BaseInterfaceModuleMemory;
+	I2C_BRIDGE_MODULE     I2cBridgeModuleMemory;
+
+	int BandwidthMode;
+
+
+	...
+
+
+
+	// Build TUA9001 tuner module.
+	BuildTua9001Module(
+		&pTuner,
+		&TunerModuleMemory,
+		&BaseInterfaceModuleMemory,
+		&I2cBridgeModuleMemory,
+		0xc0								// I2C device address is 0xc0 in 8-bit format.
+		);
+
+
+
+
+
+	// Get TUA9001 tuner extra module.
+	pTunerExtra = (T2266_EXTRA_MODULE *)(pTuner->pExtra);
+
+
+
+
+
+	// ==== Initialize tuner and set its parameters =====
+
+	...
+
+	// Set TUA9001 bandwidth.
+	pTunerExtra->SetBandwidthMode(pTuner, TUA9001_BANDWIDTH_6MHZ);
+
+
+
+
+
+	// ==== Get tuner information =====
+
+	...
+
+	// Get TUA9001 bandwidth.
+	pTunerExtra->GetBandwidthMode(pTuner, &BandwidthMode);
+
+
+
+
+
+	// See the example for other tuner functions in tuner_base.h
+
+
+	return 0;
+}
+
+
+@endcode
+
+*/
+
+
+#include "tuner_base.h"
+//#include "i2c_rtl2832usb.h"
+
+
+
+
+
+// The following context is source code provided by Infineon.
+
+
+
+
+
+// Infineon source code - driver_tua9001.h
+
+
+
+/* ============================================================================
+** Copyright (C) 1997-2007 Infineon AG All rights reserved.
+** ============================================================================
+**
+** ============================================================================
+** Revision Information :
+**    File name: driver_tua9001.h
+**    Version: 
+**    Date: 
+**
+** ============================================================================
+** History: 
+** 
+** Date         Author  Comment
+** ----------------------------------------------------------------------------
+**
+** 2007.11.06   Walter Pichler    created.
+** ============================================================================
+*/
+
+ 
+/*============================================================================
+ Named Constants Definitions
+============================================================================*/
+
+#define TUA9001_TUNER_OK                       0
+#define TUA9001_TUNER_ERR                      0xff
+
+#define TUA9001_H_LEVEL                        1
+#define TUA9001_L_LEVEL                        0
+
+
+/*============================================================================
+ Types definition
+============================================================================*/
+
+
+typedef enum {
+        TUA9001_TUNER_BANDWIDTH_8MHZ,
+        TUA9001_TUNER_BANDWIDTH_7MHZ,
+        TUA9001_TUNER_BANDWIDTH_6MHZ,
+        TUA9001_TUNER_BANDWIDTH_5MHZ,
+        } tua9001tunerDriverBW_t;
+
+
+typedef enum {
+        TUA9001_PLL_LOCKED,
+        TUA9001_PLL_NOT_LOCKED
+        }tua9001tunerPllLocked_t;
+
+
+typedef enum {
+        TUA9001_STANDBY,
+        TUA9001_IDLE,
+        TUA9001_RX
+        } tua9001tunerReceiverState_t;
+
+
+typedef enum {
+        TUA9001_L_INPUT_ACTIVE,
+        TUA9001_UHF_INPUT_ACTIVE,
+        TUA9001_VHF_INPUT_ACTIVE
+        } tua9001tunerActiveInput_t;
+
+ 
+
+/*============================================================================
+ Public functions
+============================================================================*/
+
+/**
+ * tuner initialisation
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+extern int initializeTua9001 (TUNER_MODULE *pTuner);
+
+
+/**
+ * tuner tune
+ * @param i_freq   tuning frequency
+ * @param i_bandwidth  channel  bandwidth
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+extern int tuneTua9001 (TUNER_MODULE *pTuner, long i_freq, tua9001tunerDriverBW_t i_bandwidth);
+
+
+/**
+ * Get tuner state
+ * @param o_tunerState tuner state
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+extern int getReceiverStateTua9001 (TUNER_MODULE *pTuner, tua9001tunerReceiverState_t *o_tunerState);
+
+/**
+ * Get active input
+ * @param o_activeInput active input info
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+extern int getActiveInputTua9001 (TUNER_MODULE *pTuner, tua9001tunerActiveInput_t *o_activeInput);
+
+
+/**
+ * Get baseband gain value
+ * @param o_basebandGain  baseband gain value
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+extern int getBasebandGainTua9001 (TUNER_MODULE *pTuner, char *o_basebandGain);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Infineon source code - driver_tua9001_NeededFunctions.h
+
+
+
+/*========================================================================================================================
+ additional needed external funtions ( have to  be provided by the user! )
+========================================================================================================================*/
+
+/**
+ * set / reset tuner reset input
+ * @param i_state   level
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int tua9001setRESETN (TUNER_MODULE *pTuner, unsigned int i_state);
+
+
+/**
+ * set / reset tuner receive enable input
+ * @param i_state   level
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int tua9001setRXEN (TUNER_MODULE *pTuner, unsigned int i_state);
+
+
+/**
+ * set / reset tuner chiop enable input
+ * @param i_state   level
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int tua9001setCEN (TUNER_MODULE *pTuner, unsigned int i_state);
+
+
+/**
+ * waitloop 
+ * @param i_looptime   * 1uS
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+int tua9001waitloop (TUNER_MODULE *pTuner, unsigned int i_looptime);
+
+
+/**
+ * i2cBusWrite 
+ * @param deviceAdress    chip address 
+ * @param registerAdress  register address 
+ * @param *data           pointer to data source
+ * @param length          number of bytes to transmit
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+ int tua9001i2cBusWrite (TUNER_MODULE *pTuner, unsigned char deviceAddress, unsigned char registerAddress, char *data,
+	 unsigned int length);
+
+
+/**
+ * i2cBusRead 
+ * @param deviceAdress    chip address 
+ * @param registerAdress  register address 
+ * @param *data           pointer to data destination
+ * @param length          number of bytes to read
+ * @retval TUA9001_TUNER_OK No error
+ * @retval TUA9001_TUNER_ERR Error
+*/
+
+ int tua9001i2cBusRead (TUNER_MODULE *pTuner, unsigned char deviceAddress, unsigned char registerAddress, char *data,
+	 unsigned int length);
+
+/*========================================================================================================================
+ end of additional needed external funtions
+========================================================================================================================*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// The following context is TUA9001 tuner API source code
+
+
+
+
+
+/**
+
+@file
+
+@brief   TUA9001 tuner module declaration
+
+One can manipulate TUA9001 tuner through TUA9001 module.
+TUA9001 module is derived from tuner module.
+
+*/
+
+
+
+
+
+// Definitions
+
+// Constant
+#define GPO_ADDR	0x1
+
+// Bandwidth modes
+enum TUA9001_BANDWIDTH_MODE
+{
+	TUA9001_BANDWIDTH_5MHZ = TUA9001_TUNER_BANDWIDTH_5MHZ,
+	TUA9001_BANDWIDTH_6MHZ = TUA9001_TUNER_BANDWIDTH_6MHZ,
+	TUA9001_BANDWIDTH_7MHZ = TUA9001_TUNER_BANDWIDTH_7MHZ,
+	TUA9001_BANDWIDTH_8MHZ = TUA9001_TUNER_BANDWIDTH_8MHZ,
+};
+
+// Default value
+#define TUA9001_RF_FREQ_HZ_DEFAULT			50000000;
+#define TUA9001_BANDWIDTH_MODE_DEFAULT		TUA9001_BANDWIDTH_5MHZ;
+
+
+
+
+
+// Builder
+void
+BuildTua9001Module(
+	TUNER_MODULE **ppTuner,
+	TUNER_MODULE *pTunerModuleMemory,
+	BASE_INTERFACE_MODULE *pBaseInterfaceModuleMemory,
+	I2C_BRIDGE_MODULE *pI2cBridgeModuleMemory,
+	unsigned char DeviceAddr
+	);
+
+
+
+
+
+// Manipulaing functions
+void
+tua9001_GetTunerType(
+	TUNER_MODULE *pTuner,
+	int *pTunerType
+	);
+
+void
+tua9001_GetDeviceAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char *pDeviceAddr
+	);
+
+int
+tua9001_Initialize(
+	TUNER_MODULE *pTuner
+	);
+
+int
+tua9001_SetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long RfFreqHz
+	);
+
+int
+tua9001_GetRfFreqHz(
+	TUNER_MODULE *pTuner,
+	unsigned long *pRfFreqHz
+	);
+
+
+
+
+
+// Extra manipulaing functions
+int
+tua9001_SetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int BandwidthMode
+	);
+
+int
+tua9001_GetBandwidthMode(
+	TUNER_MODULE *pTuner,
+	int *pBandwidthMode
+	);
+
+int
+tua9001_GetRegBytesWithRegAddr(
+	TUNER_MODULE *pTuner,
+	unsigned char DeviceAddr,
+	unsigned char RegAddr,
+	unsigned char *pReadingBytes,
+	unsigned char ByteNum
+	);
+
+int
+tua9001_SetSysRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char WritingByte
+	);
+
+int
+tua9001_GetSysRegByte(
+	TUNER_MODULE *pTuner,
+	unsigned short RegAddr,
+	unsigned char *pReadingByte
+	);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif
